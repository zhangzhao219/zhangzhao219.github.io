<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>杂谈-20260219</title>
    <link href="/2026/02/19/diary/diary20260219/"/>
    <url>/2026/02/19/diary/diary20260219/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>这已经是我在四年内第三次在今天写一篇日记了，唯一缺席的一次应该是正在忙于我们的WSDM Cup冠军方案（果然人一闲下来就喜欢胡思乱想…）</p><p>正常来说，这是我转变学生身份的第一年，理应有不少的感触，然而除了很多学生优惠已经无法继续使用之外，确实无感，可能在社会上被毒打了多年，早已经习惯了～更多的还是对于自己的一些反思。</p><p>总有人评价我“老实”，我也觉得我确实是比较老实的类型，自然也就比较受老一辈人的喜欢。然而细想，其实我并不“老实”，例如当我看见一些“规定”这种的东西，虽然我不会是那个搅局者，但我的第一想法也并不是“我要遵守规定”，而是“如果我不遵守规定会如何”“这个规定是不是有漏洞，例如xxxx这种是不是没写…”，而我的“老实”，只不过是在传统小家庭中隐藏真实自己的一个面具罢了，可惜的是面具戴久了反而把最真实的自己忽略了。同时在我的日常生活中，充满了“将就”“跟随”这样的想法，一个东西能用就行不追求更高的质量，一件事情总有人做过自己再做才会安心一点，这些都比较“稳”，但是都缺少了向未知领域探索的，年轻人的本能。如果我对当前的现状满意，也许并不是一个问题，然而残酷的是被禁锢在童年时期的枷锁中，等我意识到了却很难摆脱了。</p><p>所以今年准备立下Flag（虽然我之前很讨厌这种说法），核心的思想是去做没有做过的事情：</p><ol><li>健身并减肥（目标体重60左右）</li><li>自行挑选更换几乎全部衣物</li><li>去至少两场演唱会/音乐会/体育比赛现场（刚上大学还是很喜欢音乐会的，也好多年没有去过了）</li><li>去除北京上海杭州外的其他至少两座城市，或出国至少一次</li><li>尝试理财（股票/基金/信用卡）等</li></ol><p>当然还是要去努力追求属于我自己的爱情，不过这不是能一厢情愿的事情，至少上面立下的Flag都是我自己一个人能够做到的。可以说去做这些对于我来说是一个非常巨大的挑战，但是谁知道呢，明年今日我或许实现了这些Flag，或许没有实现，但是至少希望可以作出一些改变。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-20260119</title>
    <link href="/2026/01/19/diary/diary20260119/"/>
    <url>/2026/01/19/diary/diary20260119/</url>
    
    <content type="html"><![CDATA[<p>我只求爱情能够不要那么样复杂</p><span id="more"></span><p>单了这么久，老大不小了，也是终于开始相亲了。相当于既是亲戚介绍的（大人相互认识），又是上下届的高中同学（有一些共同好友），两层关系。</p><p>我当然觉得我对自己有清醒的认知：身高不够，颜值欠佳，表达能力差，也一直还蛮喜欢《神盾局特工》中珍玛•西蒙斯的一句话“我不擅长随机应变，但是我非常擅长提前准备”，因此我将其当作一个任务，做了非常充分的准备，对于可能发生的不同情况都有极为充足的预案，甚至闪过提前演练一下的念头。故事的发生也完全在预料之中，可以说完全没有任何脱离控制的情况发生，且我感觉对于第一次见面来说，自己也真的算是超常发挥了。最终结果其实并不意外，好人卡+1。</p><p>如果说一件事情，不管大事还是小事，如果我觉得自己做的不满意，我会复盘一下，找到我能够进行改进的关键，如果下次还有机会会去尝试我自己的解决方案。可是这个情况，虽然我觉得我已经把我自己能控制的部分做到了我自己的极限，结果仍然与预期相差非常之大。那就还剩下两个最可能的原因：第一个就是我对我自己的认知与实际上相差巨大；第二个是我觉得我在过程中掌握了主动权，但实际上主动权在别人的手里，我做的再好也并不能改变什么。我不知道哪种概率更大一些，从我自己的角度来说，我宁愿是前一种，因为前一种我能改，虽然我的身高没有办法改变，但是可以降低体重，可以改进穿搭…表达能力也可以练习，无法在全天保持高质量的对话也可以至少撑起半天的沟通交流。如果是后一种，我是不太相信的，虽然现在我在不断怀疑我一直以来的观念，但是我仍愿相信，我自己是可以改变，可以慢慢变好的，但是我真的不知道应该往哪个方向去改变了。</p><p>也不是说我很不甘心，其实线上或者线下聊天的时候就已经有这种感觉了，虽然在工作方面比较有共同话题，也很聊得来，但是她并不好奇我的日常生活，尤其线下约饭时候也没有任何主动进一步了解的信号。我只是想不通为什么会这样。有一句话说 “人们对于未知的事情才是最恐惧的”，我自己就是难受在这一点上。本是想找一个共同话题破个冰，毕竟认识一周左右，然而话题就仅限于此了，并没有希望对我产生更多了解的愿望。为什么？我不断在问自己，到底是为什么？如果以我的爱情观来说，我是不相信一见钟情的，对于所有人，不管是陌生人还是同学还是长辈，我都不会仅通过短短的交流来在内心去批判这个人，而是希望有更多的了解，再决定是否深交。但看起来至少针对于爱情来说，至少针对于我遇见的大多数人，并不是这样的。</p><p>以我自身来说，我是那种受长辈喜欢的小孩，同事评价我说“东北老小孩”简直是再恰当不过了，我很难在与其他人第一次见面的时候就与其他人产生很紧密的情感波动，也可能是由于这个原因吧，其他人第一次见到我的时候也很难产生情感波动，也因此当朋友很简单，但是很难再深交，更不用说能真正进入一段可以相伴几十年的感情。同时也感觉自己陷入了一个无限循环，了解我的人因为太了解我了从而无法产生其他的情感交集，不了解我的人因为太不了解我也无法对我产生任何的情感波动。这是我当前最大的难题，可能真的要用一生的时间来解答。</p><p>这次的经历已经彻底结束，那么以后呢？首先emo一阵子是肯定的了，本来我就是一个心思重的人，估计这次要恢复大概一两个月吧，然后呢？然后我也不知道应该做什么 or 改变什么。可以再思考一下，虽然这一次被磨灭了大半，但也还是对美好的爱情有着一些憧憬的。如果后面真的麻木了，真的对于爱情一点点的向往都没有了，可能我也就没有那么伤心难过了。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-20250413</title>
    <link href="/2025/04/13/diary/diary20250413/"/>
    <url>/2025/04/13/diary/diary20250413/</url>
    
    <content type="html"><![CDATA[<p>胜负欲与得失心</p><span id="more"></span><p>刚刚结束了学生时代的最后一场乒乓球比赛，遗憾的是仍旧没能出线。实力固然有明显差距，不过自己发挥确实也并不好。总结一下，正式打乒乓球比赛时候的感觉是和练习时候完全不同的，可以明显感觉自己的身体处在一个绷紧的状态，一局比赛中失误增多后也渐渐开始不敢去尝试冲转而求稳，就开始被对手抓到机会。</p><p>再细想，是不是有时候胜负欲太重了？我是一个做事较为谨慎的人，如果有一些事情我觉得有很大困难，那我就会不断地去准备去模拟，力争在正式展示或汇报之前做好充分的准备。这可能也是大家口中常说的“卷”吧。我一直认为我的这种行事风格是没问题的，然而我突然意识到，如果遇到一个很短期的任务，在根本没有办法进行充分准备时，我的即兴发挥能力是非常弱的。况且我的胜负欲得失心较强，每一件事情我都希望将其做好，若是最终的效果不好，那么我就会时不时对自己进行反思（就比如比赛过去几天了我现在还在写这件事情）。</p><p>所以现在我有两种改进措施，一个是让自己的胜负欲得失心稍弱一些，这样自己的心理压力会降低很多，做事也会更快乐一点；另一个则是大幅度提升我的即兴发挥的能力，使得不论遇到什么事情，不管自己能做多少准备，下限能稍微提升一些，至少能发挥出自己的正常水平。</p><p>明天是一个相对重要的日子，希望进入新阶段后，自己可以不断发现自己的问题，一点一点慢慢改正吧。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实迷途其未远，觉今是而昨非———我的秋招之路总结</title>
    <link href="/2025/02/19/diary/diary20250219/"/>
    <url>/2025/02/19/diary/diary20250219/</url>
    
    <content type="html"><![CDATA[<p>2025秋招总结（个人感受版）</p><span id="more"></span><p>秋招应该算是结束了。首先非常非常非常感谢整个秋招过程中帮助过我的师兄师姐同事和小伙伴们，希望我连珠炮式的追问没有带来特别大的不便…其次也要感谢虽然并没有什么帮助但是支持我鼓励我的父母家人和老师们，你们是我安心面试的坚实后盾。</p><p>秋招时由于目标明确，基本朝着大模型算法岗进行投递，最终的不完全统计结果显示：</p><table><thead><tr><th>说明</th><th>统计结果</th></tr></thead><tbody><tr><td>意向投递公司数量</td><td>20</td></tr><tr><td>面试公司数量</td><td>14</td></tr><tr><td>技术面数量</td><td>38</td></tr><tr><td>HR面数量</td><td>9</td></tr><tr><td>开奖数量</td><td>7</td></tr><tr><td>面试不通过比例</td><td>10.6%</td></tr><tr><td>Offer比例</td><td>71.4%</td></tr></tbody></table><p>拿到的offer（进入到谈薪阶段）如下：</p><ul><li>字节广告大模型算法</li><li>蚂蚁垂域大模型算法</li><li>腾讯代码大模型算法</li><li>美团大模型算法</li><li>阿里云安全大模型算法</li><li>百度文心一言大模型算法</li><li>科大讯飞研究院大模型算法</li><li>华为小艺大模型算法</li><li>快手商业化算法</li><li>滴滴Llab大模型算法</li></ul><p>开奖了的薪资情况是网上（Offershow）或者周围了解到的基本最高价。可能在部门里面都是SSP或者SSP+吧，职级上有一些与博士相同。人才计划勉强能摸到一丢丢，不过相比那些真正可以拿到人才计划的硕士还是差着档次。</p><p>一直想写点东西总结一下，偶然间想起陶渊明《归去来兮辞》的一句“实迷途其未远，觉今是而昨非”，用来总结我这近七年的求学求职之路真的是再好不过了。</p><h1>高考失利——“两度长安陌，空将见泪花”</h1><p>高考结束的那一段时间是我最不愿意去回忆的。</p><p>从小学到初中甚至高中，我一直认为我的父母是相对开明相对淡泊的，从不会逼着我学这个学那个，考的好了也不会特别夸奖，考的不好了也不会特别责备。记得还是初中的时候，当时老师在课上询问我们为什么要学习，我的回答是为了父母。“我的父母几乎将下班后的全部精力放在了我的身上，也不求什么回报，因此我希望可以好好学习来报答他们。”</p><p>就这样一直到了高考。七年后再回看当时的高考成绩，我也很难说为什么当时理综会考的这么差。知识？心态？细节？又或许兼而有之吧，总之考出了一个高中三年的最差成绩。几乎无人知晓我在这一段时间的心理煎熬。高考结束→哭→想复读→父母不答应→哭→出成绩→哭→想复读→父母不答应→哭→考上了中南大学→不想复读→父母不答应→哭→…还记得我父亲的一句话让我当时的价值观彻底崩塌：“你看xxxxx都能上xxxxxx学校，你才考个什么x学校”。我突然懂了，原来我的家人和别人的家人并没有什么不一样，只不过是因为我之前的成绩稍好一些罢了。我也开始对父母灌输给我的职业规划产生质疑。</p><p>我开始自己独立思考，我真正感兴趣的是什么，以后我希望去做什么，而不是像我的人生前18年一样，沿着父母充满着“爱”的建议道路一点一点走下去。</p><p>这样我来到了我的大学，第一次忤逆了父母的意愿。</p><h1>我的大学——“学非探其花，要自拔其根”</h1><p>大学生活对我的求职之路有什么影响？我觉得是明确了我要去找一份互联网企业的工作的意向。</p><p>我在第一次独自生存中探索着属于我自己的意义。</p><p>大一基本上将学校的所有活动体验了一遍：在没有任何人脉的情况下去竞选班长，在乐团吹萨克斯，在院队打乒乓球，在学校公众号做运营；去爬山去跑马拉松去看电影去读书，去不自量力地用C语言的知识参加编程比赛，再谈个恋爱。在这个过程中认识了很多很多来自天南海北的优秀的同学，也深刻体会到了东北小城市的局限性。唯一美中不足的是我的学习成绩。虽然我始终将学习摆在相对靠前的地位上，但是最终的成绩却不尽人意。尤其是我的编程水平，我的C语言的考试成绩是本科+研究生所有课程的最差成绩，一度怀疑自己对计算机的兴趣是否发自内心。同时按照专业分流后的排名来说，拿到保研名额也是基本不可能的，在学历快速贬值的时代，当时的我认为读研究生是一个必选项，但我能否在高考的阴影下再来一次考研，完全不敢细想。</p><p>大二的课程开始从类似于高中的基础课程逐步转向偏计算机应用的更为专业性的课程，我也开始逐渐寻找我的兴趣点。一方面对大一没有理解的编程知识进行新一轮的恶补；一方面加入了实验室，在研究生学长学姐的带领下体验科研生活；一方面在课内老师的指引下，对于感兴趣的方向再补充一些更为经典的书籍或课程。说来也是奇怪，虽然我感觉我花在课程内容上的时间比大一更少，但是我的年级排名一直在稳步提升，16→10→7→5，大三下学期在申请夏令营资格的时候裸分排名升到了第3名。我开始意识到了课程的局限性，如今我认为学校课程可以看成是前方某一条道路的一盏灯，老师们的几十个学时课程的目的是将这一盏灯点亮并站在灯下介绍这条道路后面大概通向什么样的风景，若是没有老师，可能我们根本不知道这里有一条路，但是如果真的想去亲身体验道路尽头的风景，就需要拿着灯独自走下去。</p><p>大三开始全力准备保研，一方面开始重温大一的基础知识，并将大一参加过但是没有取得名次的英语竞赛和编程竞赛的奖项拿回来；一方面参加一些没有太大的技术含量的竞赛，为自己的保研简历添砖加瓦；一方面也在实验室内真正承担了一部分的工作，发了软著和专利，且每一次汇报之前都要先焦虑一会想想要讲点啥…我十分感谢我的本科导师，是他帮我坚定了以后不读博士的想法。并不是说我在实验室干的不好被导师天天批评从而产生了心理阴影（甚至有一次我的汇报被导师夸奖为“近三年实验室最好的汇报”），而是我看到了至少在我认为没有任何实际应用价值的工作，产出了一篇顶会论文，甚至得到了最佳论文的提名，我意识到了这种科学研究工作一方面是我不擅长的（论文里面我写的部分基本被导师推倒自己重新写了），另一方面也是我不感兴趣的，我真正感兴趣的部分在于我的代码能不能在实际的项目中产生作用和价值，而不是只有天花乱坠的文字描述。</p><p>因此，我在保研时候的考虑选择也是比较明确的，第一是以计算机专业相关就业为导向。当时正是计算机最为火热的时候，薪资也是水涨船高，一些同学甚至放弃了保研名额去了互联网大厂。第二是不读博士，只报名学硕，一方面我已经找到了我的兴趣点，另一方面学硕也可以有其他的退路。保研过程兜兜转转，最终选择了计算所，网上能找到的普遍说法是这个实验室的就业情况非常好，这看起来是当时的最优解了。</p><p>这样我带着一个互联网大厂的期待，在对具体的就业方向一无所知的情况下开始了我的北漂生活。</p><h1>北漂读研——“明日客程还几许，沾衣况是新寒雨”</h1><p>我的北漂之旅起始于2021年11月，距今也已经近四年了。</p><p>我带着“读完研究生就能稳稳进互联网大厂拿高薪”的幻想来到了北京，结果进京的第一天我的师兄们就给我泼了一盆冷水。网上的说法不假，但是都是大家自己一点一点拼出来的，拿着毕业证和成绩单就可以在招聘面试中乱杀的情况是绝无可能的。每一个能拿好offer的师兄师姐都各有各的强项。</p><p>我最需要感谢的是Q同学，他以他丰富的本科经历和感悟给我指明了今后道路的努力方向，帮助我有了第一段的工作体验。然而我没有完全坚持下去，研一突遭互联网寒冬，似乎之前的一片蓝海在一夜之间翻红，同时也被断崖式分手，封闭在雁栖湖的时候每天在重复写着悲观的文字，在怀疑自己的人生规划，在怀疑自己的能力和水平，在想象着如果我不读研究生会如何？是不是能踩着互联网的最后一波红利？是不是就不会分手？同时降低了自己的标准，尝试了另外一份自己觉得更为感兴趣的工作，可惜的是真正体验过了才发现也并不是那么喜欢。</p><p>研二再次回到实验室，每天被实验室的就业氛围和师兄师姐同学们的熏陶包围，放弃其他想法，开始全力硬冲在当时已经“灰飞烟灭”的互联网算法岗。每天早出晚归，在各个角落不断奔波，在各种沟通之中被拷问毒打，在各种建议批评中唯唯诺诺。当时的我是极度不自信极度卑微的，每做一件事都要反复进行核对，生怕有任何的错误被别人发现受到批评指责；最常询问别人的问题是“您对我今后的学习有没有什么建议”，期待着可以得到前辈们的指导，哪怕只有草草的几句套话。</p><p>渐渐的，在无数人的提携帮助和自己的疯狂内卷之下，简历上面的项目比赛论文等充实了起来，也在一次次的交流当中慢慢捡回自己早已踩在脚下的尊严和自信。我对于今后的就业方向也开始有了自己的想法，不仅仅希望去一个更好的公司拿下至少SP的薪资，也希望去一个更为友好的更为核心的部门，且我在部门中做的事情是自己真正感兴趣的。后来有了更为大胆的想法，希望可以拿与博士毕业相匹配的职级，冲一下各家企业的人才计划，甚至拿与博士差不多的薪资水平。</p><h1>校园招聘——“纵浪大化中，不喜亦不惧”</h1><p>我的秋招面试实际上过于顺利，可能对于其他人来说并不具有特别大的参考价值（有点凡尔赛了）。总共进行了47场面试，挂了5次，一次应该是在技术面没有聊好挂掉了，一次是HR面挂掉的，剩下三次应该是被捞的岗位不太匹配或者超时未处理导致的流程结束（至少自我感觉面试过程没有问题）。秋招之前挂过三轮六次的宇宙厂反而成为了我最早拿到的口头和书面的意向。</p><p>刚开始面试的时候还是有一些紧张的，一般提前两个小时会捋一遍自己的项目经历，提前一个小时会过一遍高频算法题，提前半个小时开始调试设备，提前15分钟进面试间，提前8分钟左右上个厕所…在8月上旬的某公司一次面试过后马上收到了“已结束”的官网状态，也是秋招的第一挂。当时难过了很久，也开始怀疑自己，因为在面试的过程中感觉没有任何问题，是不是在哪里有很明显的短板但是我自己还没有意识到。实际上这个担心是完全多余的，几天之后领导特意向我解释了一下是退出人才计划的流程了，后面秋招会继续推进。后面面的多了慢慢就放松了，面试过程中还会视情况和面试官开两句玩笑，也可以很快地判断出来有没有挂的可能性。</p><p>唯一有遗憾的是在秋招开始之前是希望可以拿着自己的丰富经历和各种算法竞赛冲一下人才计划的。然而现实很残酷，除了两家企业给了博士级别的职级，一家企业给了博士职级的大饼之外，没有收获其他的超过正常硕士级别的offer了。</p><h1>Offer选择——“利害有常势，取舍无定姿”</h1><p>我的秋招面试在10月份之前就已经基本结束了，接下来就是漫长的等待，直到11月中上旬，沟通薪资和Offer选择的部分才正式开始。</p><p>记得10月左右和朋友聚会的时候，我说“去年隔壁实验室师兄开了xxx，今年要是谁能开到这个数字肯定就毫不犹豫就接了。”然而第一个电话过来就真的听见了这个数字的时候，反而不敢接了。一方面是薪资的构成过于简单，应该不是能最终给到的水平；另一方面，更为大胆的想法在我心中发芽，“既然xxx都能开到这个数字，那是不是别的公司可以开的更高？”。电话中语无伦次地同时表达了五分兴奋，三分遗憾和两分期待后，第一次谈薪就这样结束了。</p><p>兴奋过后，我也开始重新审视目前手里基本可以拿到的Offer情况。有些公司是用来保底的，有些公司是比较想去的；有些部门偏内部业务，有些部门偏toB，有些部门偏实际业务，有些部门偏研究型等等。审视过程中自己的心态慢慢从“Offer各有各的好”转变为“Offer各有各的差”，又开始幻想“谁开的高我去谁那里”，逐渐地其他公司部门也开始打电话过来打探已有的开奖信息，并尝试给出他们的薪资方案。不得不说基本上所有的薪资方案放在去年来看都是独一档的存在，但是有了比较之后，每一次沟通后我的焦虑又更多了一分。“怎么还是这个数字”“就不能有人再高一些直接杀死比赛？”经过无数次的电话沟通，拉扯来拉扯去，最终的候选Offer大概有6个。叨扰了无数师兄师姐小伙伴们之后，最终的选择剩下两个。</p><p>两个offer特点鲜明，一个是相对轻松且比较熟悉的，另一个是业务更好但也更有挑战的。了解我的人可能都会认为我毫不犹豫就会选择后一个，然而我确实犹豫了很长时间很长时间，无数个夜不能寐的夜晚在两个Offer之间不断折磨自己，最终才作出决定选择了其中的一个。</p><p>我认为选择无所谓对错，只看在当前是否合适就可以了。可能我当前认为合适的工作选择，真正工作了一段时间后会忍不住去想如果我选择了另外一个现在会怎么怎么样；可能现在看不起但是社会上更为认可（包括家里人也更为认可）的国企央企公务员等非技术型岗位，一段时间后也会去想为什么我不充分利用应届生的身份去做一份更为稳定更有社会地位的工作。</p><p>这个工作是我当前经过充分调研和深思熟虑之后的我认为的最好选择，这对我来说就足够了。</p><h1>未来可期——“人生到处知何似，应似飞鸿踏雪泥”</h1><p>回顾这近七年的时光，从高考失利的迷茫痛苦，到大学期间的自我探索与成长，再到北漂读研时在困境中挣扎奋进，直至如今秋招尘埃落定。这一路，我告别了曾经对父母规划的依赖，学会了独立思考与抉择；我在学业的起起落落中摸索前行，找到了自己热爱并愿意为之奋斗的方向；我在求职的浪潮里历经波折，收获了自信与一份满意的工作。</p><p>记得研究生期间和一些许久未见过面的同学交流，大家的普遍看法是我的性格发生了非常大的改变。从当前较火的MBTI的角度来看的话，之前的我毋庸置疑是一个ISFJ小护士，谦逊、敏感、利他主义、自我内耗。认识到了这个性格带给我的巨大困扰之后，我有意识地去进行改变，我让我自己不再去太过在意其他人的感受和对我的看法，在意细节的同时也尽量大大咧咧一点傲一些。上一次的测试结果是INTJ，但是管它是什么结果呢，我对现在的性格感到开心就满足了。现在我认为人生中最关键的是取悦当下的自己。我的未来最重要的只有开心和快乐，我要多做一些计划之外的事情，多来几场说走就走的旅行，再去看看演唱会，追追星等等等等，做一点乖宝宝不会去做的事情。至于空窗了快三年的问题就随缘吧，相信缘分到了一切都是水到渠成。</p><p>“季节流转，日升月落，星移斗转，世事如白衣苍狗。过去有多少遗憾和侥幸，有多少悲恼和欣欢，多少披星染雾的启程和多少戴月荷锄的归途，尽管它们终将消失在记忆的犄角旮旯。新的一天终将随着初生的太阳喷薄而出，我们如同站在两个世界的边缘，愧疚地送别过去，紧张地等候未来。”</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025校园招聘（2024秋季）算法岗总结</title>
    <link href="/2025/01/10/Interview/Interview-Campus-Recruitment-2024-Autumn-Summary/"/>
    <url>/2025/01/10/Interview/Interview-Campus-Recruitment-2024-Autumn-Summary/</url>
    
    <content type="html"><![CDATA[<p>2025校园招聘（2024秋季）算法岗总结</p><span id="more"></span><h1>背景</h1><p>学历背景：末流985本科+中科院强所学硕，均为计算机相关专业</p><p>论文情况：对口论文一作1B1在投A，其他非一作不对口论文若干</p><p>实习情况：对口大厂实习1日常1暑期，此外还有小公司后端开发和中厂CV算法实习经历</p><p>竞赛情况：取得名次的NLP相关竞赛5+项</p><h1>投递情况</h1><p>意向岗位：互联网算法技术岗，城市不限，若是自己投递则选择大模型岗位方向投递，也不排斥传统的NLP算法或者是搜广推相关，不太喜欢做研究，主要投递偏应用型的岗位。不太看好创业公司的前景，投递的都是有一定规模的知名企业。</p><p>结果：秋招前筛选了大概有意向的企业共20家，其中10家企业基本拿到offer，开奖了的薪资基本为网上能查到的和周围了解到的真人的最高价SSP及以上，没有人才计划；4家企业面试挂；6家企业没有面试。</p><h2 id="进入到谈薪阶段">进入到谈薪阶段</h2><p>包括字节跳动、腾讯、阿里云、蚂蚁集团、美团、快手、百度、华为、滴滴、科大讯飞</p><p>截至目前快手、华为和滴滴谈薪但是没有开奖，其他均已接/已拒</p><p>利益相关，面经已有但是看情况公开吧，有想要的可以私戳~</p><h2 id="面试挂">面试挂</h2><h3 id="京东">京东</h3><p>找了同学内推，和内推码没有太大区别</p><p>8月初测评，8月上旬笔试</p><p>9月初HR面后紧接技术一面，HR面介绍了一下部门，然后让我讲了一下性格和实习的体验。技术一面问了论文，八股考了微调方式，LoRA的相关问题，RoPE位置编码，deepspeed各种优化点，flash attention等，算法题是滑动窗口最大值</p><p>9月下旬技术二面，问了论文，感觉他没听懂，后面讲的有些吵起来了…，八股问了tokenizer是怎么工作的，算法题出了一个巨难的通配符匹配，没做出来</p><p>9月底线下HR面（太离谱了，亦庄也太远了），就问了一下实习的体验和感觉最迷茫的事情，15分钟就结束了</p><p>12月中旬看官网时候发现挂了</p><h3 id="拼多多">拼多多</h3><p>随便找了一个内推码投递了算法工程师的大方向</p><p>7月下旬个性测评，大概200道题左右，8月中旬笔试，难度很大</p><p>8月底一面，问了论文，Transformer参数量的计算，算法题是两数和的最接近值，做的不太好</p><p>9月中旬二面，问了论文和实习，DPO的基本假设，算法题是rand7如何转化为rand10，确定面试的部门是TEMU toB的部门</p><p>10月中旬三面，问了实习，算法题是m个骰子n次求正面数字之和大于等于k的概率，面试太晚了很困没有做出来</p><p>11月初HR电话面试，介绍项目和性格等，过几天后挂</p><p>没走到谈薪的原因可能主要是HR面的时候我说不太能接受11126还打卡的企业内卷文化，然后前面的笔试面试表现也都没那么好。</p><h3 id="小红书">小红书</h3><p>7月中旬找部门领导内推RedStar</p><p>7月下旬一面，问了比赛，算法题是力扣第三题</p><p>8月上旬二面，问了实习和比赛，有一点点八股，没有算法题</p><ul><li>Transformer的Bert和GPT的结构</li><li>大模型有哪些改进</li><li>不同激活函数在不同任务上的区别</li></ul><p>面试聊的都不错，结果二面完下午直接挂，部门领导反馈挂的是RedStar，后面正式秋招开了再面我</p><p>后面没再找过我了，我也没有再问过。</p><h3 id="阿里国际">阿里国际</h3><p>没有找内推</p><p>8月中旬投递，9月初笔试</p><p>第一志愿：算法工程师-自然语言处理 Lazada；第二志愿：算法工程师-LLM 阿里巴巴国际站</p><p>第一志愿9月下旬约了一二面，上午二面后下午挂</p><p>面试主要问了论文和实习，一面没有算法题，二面是最长回文子串，挂的主要原因是不匹配，部门是做推荐的，我这边的推荐经验比较少，面试时候也聊的很清楚。</p><p>第二志愿一直没有任何消息</p><h2 id="没有面试">没有面试</h2><h3 id="淘天">淘天</h3><p>没有找内推</p><p>暑期实习笔试做的不太好，秋招不给机会重新做笔试了（或者是不是发一份给邮件也可以重新做一遍笔试？）</p><p>第一志愿：用户平台&amp;阿里妈妈；第二志愿：算法技术</p><p>第二志愿挂后自动流转：淘天集团-闲鱼-闲鱼技术</p><p>时间线：八月中旬投递，9月上旬第一志愿挂，9月下旬第二志愿挂，10月上旬闲鱼约面，直接拒绝面试。</p><h3 id="通义实验室">通义实验室</h3><p>本来也不太想找研究型的岗位，随缘找了所内的师兄内推，但是师兄不太靠谱只告诉了HR，一直没有任何消息。11月中旬突然邀请我投递简历，太晚了直接拒绝。</p><h3 id="网易雷火">网易雷火</h3><p>找了一个北大做产品的特别内推（宣传说特别内推免笔试），文本大模型算法工程师岗位，确实免了笔试，不过面试也免了…直接简历就挂掉了。</p><p>时间线：7月上旬特别内推完成，9月下旬查看雷火官网发现流程已结束，且官网上已经找不到任何技术类的岗位了。</p><h3 id="达摩院">达摩院</h3><p>没有找内推</p><p>第一志愿投递了算法工程师-自然语言处理，简历评估不通过</p><p>第二志愿投递了算法工程师-大模型，完成了测评和笔试，然后简历评估不通过</p><p>时间线：8月中旬投递两个志愿，8月下旬第一志愿挂，8月底完成笔试，9月初第二志愿挂</p><h3 id="B站">B站</h3><p>官网开放岗位后找了认识的大佬内推，但是那个人不太建议投递…说没有什么卡并且我也不大可能会来，因此没有投递。</p><h3 id="智能信息">智能信息</h3><p>官网一直没有开放校园招聘的相关岗位，没有渠道投递</p><h1>感想和建议</h1><p>代表个人的一些想法，仅供参考</p><ol><li>对口经验很重要。虽然校招看经验听起来是很离谱的事情，但是没有办法，每一个岗位投递的人数都太多了，我了解到的某个还算偏小众的岗位，暑期实习有100+投递，筛选了好学校+2篇论文以上后面了30+左右，最后暑期实习收了5个。秋招投递超过500+，基本没有面（因为坑都被暑期实习生占满了）。在这种竞争下，一方面企业只能通过一些硬性条件去筛选一波再面试，如学历是否为双九、是否有论文等等。另一方面我们也要思考一下我们的核心竞争力在哪里，如何让自己的简历在海量的候选者中脱颖而出。这里不是说简历的美观和排版情况，主要是简历中能够体现出的与岗位匹配的点有多少，也就是过往的经验如何了。</li><li>论文和实习很重要。经验只能是从论文和实习当中来，学校的项目基本都是没有任何含金量的（有含金量的就肯定有论文了）。论文重要还是实习重要这个不好说，研究型的岗位肯定是看论文，应用型的岗位论文和实习含金量应该是差不多的。一切的前提是得对口，不对口的论文或者实习都是没有任何作用的（人家又不懂咋和你聊呢）。人才计划的要求可能是成果非常多的博士或者经验非常非常对口的硕士，没有论文有一大堆实习或者比赛的硕士拿到了人才计划也是有一些的。至于比赛的含金量不太好说，本人的简历亮点在于比赛很多，且比赛基本都是与大模型相关并涉及到了很多的领域方向，在面试的时候如果部门正好是做这个方向的会比较感兴趣。没有特别对口的比赛还是会优先问实习和论文。</li><li>面试重要性不高。本人感觉部门看简历的时候基本就已经给这些候选人排好序了，而且大家的时间精力都是很有限的，真的不存在什么KPI面。面试中只要简历的内容都能hold住，一场面试下来基本就是聊聊项目就结束了。算法岗也没什么八股，考八股要不就是项目中可能涉及到了一些基础知识而且面试官正好会的，要不就是实在没啥可以聊的但是时间还早（这一种情况可能就算八股都答出来了也是一样挂）</li><li>算法题不太重要。本人大大小小实习+秋招面了五六十场，感觉上没有任何一场面试是因为算法题没有做出来而挂掉的。面试的表现（包括简历和岗位的匹配程度）与算法题的难度是基本正相关的。如果面试表现的好，即使算法题没做出来也可以换一个更简单的做；面试表现不好，算法题就算秒杀了也会出一个更难的或面试后也会挂掉。大家都是做技术的，都知道Leetcode那些东西平常也用不上，算法题基本就是走个过场。准备算法题的时候Leetcode HOT 100完全够用了，90%以上的算法题都是从这里来的。</li><li>网上有一种说法“暑期实习转正都是白菜价”。这个说法我认为是有偏的。因为暑期实习一般就是按照秋招的HC来招的，站在部门的角度想，如果这个人在我们这里干的很好我为什么要把他放走换另一个不熟悉的再赌一把呢？大多数的人实习的时候应该是没有达到面试时候的预期的，所以可能部门感觉秋招重新招一个损失也不大，因此就开了白菜价劝退了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLM强化学习</title>
    <link href="/2024/06/01/LLM-RL/"/>
    <url>/2024/06/01/LLM-RL/</url>
    
    <content type="html"><![CDATA[<p>LLM强化学习相关学习资料</p><span id="more"></span><h1>相关链接</h1><p>图解大模型RLHF系列之：人人都能看懂的PPO原理与源码解读：<a href="https://zhuanlan.zhihu.com/p/677607581">https://zhuanlan.zhihu.com/p/677607581</a></p><p>原理解析：<a href="https://blog.csdn.net/v_JULY_v/article/details/134242910">https://blog.csdn.net/v_JULY_v/article/details/134242910</a></p><p>KL散度详解：<a href="https://blog.csdn.net/Rocky6688/article/details/103470437">https://blog.csdn.net/Rocky6688/article/details/103470437</a></p><p>简要版本解析：<a href="https://blog.csdn.net/u014386899/article/details/136633074">https://blog.csdn.net/u014386899/article/details/136633074</a></p><p>代码解读：<a href="https://zhuanlan.zhihu.com/p/696044978">https://zhuanlan.zhihu.com/p/696044978</a></p><h1>强化学习</h1><h2 id="基本概念">基本概念</h2><p>状态迁移函数：  <img src="https://math.now.sh?inline=s%5E%7B%5Cprime%7D%3Df%28s%2C%20a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li><img src="https://math.now.sh?inline=s" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：输入状态</li><li><img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：行动</li><li><img src="https://math.now.sh?inline=s%5E%7B%5Cprime%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：下一个状态</li></ul><p>状态迁移概率：<img src="https://math.now.sh?inline=p%20%28s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，在 <img src="https://math.now.sh?inline=s%2C%20a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的条件下迁移到<img src="https://math.now.sh?inline=s%5E%7B%5Cprime%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的概率。</p><p>奖励函数：<img src="https://math.now.sh?inline=r%28s%2C%20a%2C%20s%5E%7B%5Cprime%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 当前状态迁移到下一个状态 (用<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>) 得到的奖励，或简略写为<img src="https://math.now.sh?inline=r%28s%5E%7B%5Cprime%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>策略：</p><ul><li>确定性策略：<img src="https://math.now.sh?inline=a%3D%5Cmu%28s%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>随机性策略：<img src="https://math.now.sh?inline=%5Cpi%28a%20%5Cmid%20s%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，在状态<img src="https://math.now.sh?inline=s" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>下采取行动<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的概率。</li></ul><p>智能代理根据策略<img src="https://math.now.sh?inline=%5Cpi%28a%20%5Cmid%20s%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>采取行动。首先根据它的行动和状态迁移概率<img src="https://math.now.sh?inline=p%20%28s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>迁移到下一个状态。然后,它根据奖励函数<img src="https://math.now.sh?inline=r%28s%2C%20a%2C%20s%5E%7B%5Cprime%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>获得奖励。</p><p>收益:  <img src="https://math.now.sh?inline=G_%7Bt%7D%3DR_%7Bt%7D%2B%5Cgamma%20R_%7Bt%2B1%7D%2B%5Cgamma%5E%7B2%7D%20R_%7Bt%2B2%7D%2B%5Cdots" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li><img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：折现率（引入折现率主要是为了防止连续性任务的收益变得无穷大）</li></ul><p>状态价值函数：<img src="https://math.now.sh?inline=v_%7B%5Cpi%7D%28s%29%3D%5Cmathbb%7BE%7D%5BG_%7Bt%7D%5Cmid%20S_%7Bt%7D%3Ds%2C%20%5Cpi%5D%20%5Crightarrow%20v_%7B%5Cpi%7D(s)%3D%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BG_%7Bt%7D%5Cmid%20S_%7Bt%7D%3Ds%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li>条件概率：<img src="https://math.now.sh?inline=P%28x%2C%20y%29%3DP(x)%20P(y%20%5Cmid%20x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=%5Cmathbb%7BE%7D%5Br%28x%2C%20y%29%5D%3D%5Csum_%7Bx%7D%20%5Csum_%7By%7D%20p(x%2C%20y)%20r(x%2C%20y)%3D%5Csum_%7Bx%7D%20%5Csum_%7By%7D%20P(x)%20p(y%20%5Cmid%20x)%20r(x%2C%20y)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>至少存在一个最优策略<img src="https://math.now.sh?inline=v_%7B%5Cpi%5E*%7D%28s%29%5Cgeq%20v_%7B%5Cpi%7D(s)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，而且是确定性策略，每个状态下的行动是唯一确定的。用数学式可以表示为<img src="https://math.now.sh?inline=%5Cmu_*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li><img src="https://math.now.sh?inline=a%3D%5Cmu_*%28s%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>成立，当输入状态<img src="https://math.now.sh?inline=s" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，会输出行动<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><h2 id="贝尔曼方程">贝尔曼方程</h2><p>意义：将无限的计算转换为有限的联立方程。</p><h3 id="状态价值函数的贝尔曼方程">状态价值函数的贝尔曼方程</h3><p>表示当前状态的价值函数与下一状态的价值函数的关系</p><p>推导过程：</p><ul><li><img src="https://math.now.sh?inline=G_%7Bt%2B1%7D%3DR_%7Bt%2B1%7D%2B%5Cgamma%20R_%7Bt%2B2%7D%2B%5Cgamma%5E%7B2%7D%20R_%7Bt%2B3%7D%2B%5Cdots" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=G_%7Bt%7D%3DR_%7Bt%7D%2B%5Cgamma%20R_%7Bt%2B1%7D%2B%5Cgamma%5E%7B2%7D%20R_%7Bt%2B2%7D%2B%5Ccdots%3DR_%7Bt%7D%2B%5Cgamma%20G_%7Bt%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p><img src="https://math.now.sh?inline=v_%7B%5Cpi%7D%28s%29%3D%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BG_%7Bt%7D%20%5Cmid%20S_%7Bt%7D%3Ds%5D%3D%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BR_%7Bt%7D%2B%5Cgamma%20G_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%7D%3Ds%5D%3D%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BR_%7Bt%7D%20%5Cmid%20S_%7Bt%7D%3Ds%5D%2B%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5B%5Cgamma%20G_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%7D%3Ds%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>① <img src="https://math.now.sh?inline=%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BR_%7Bt%7D%20%5Cmid%20S_%7Bt%7D%3Ds%5D%3D%5Csum_%7Ba%7D%20%5Csum_%7Bs%5E%7B%5Cprime%7D%7D%20%5Cpi%28a%20%5Cmid%20s%29%20p(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%20r(s%2C%20a%2C%20s%5E%7B%5Cprime%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（所有项直接相乘）</p><p>② <img src="https://math.now.sh?inline=%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5B%5Cgamma%20G_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%7D%3Ds%5D%3D%5Cgamma%20%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BG_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%7D%3Ds%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（要对下一个时刻进行计算）</p><p><img src="https://math.now.sh?inline=%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BG_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%7D%3Ds%5D%3D%5Csum_%7Ba%2C%20s%5E%7B%5Cprime%7D%7D%20%5Cpi%28a%20%5Cmid%20s%29%20p(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%20%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BG_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%2B1%7D%3Ds%5E%7B%5Cprime%7D%5D%20%3D%5Csum_%7Ba%2C%20s%5E%7B%5Cprime%7D%7D%20%5Cpi(a%20%5Cmid%20s)%20p(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%20v_%7B%5Cpi%7D%5Cleft(s%5E%7B%5Cprime%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最终相加：<img src="https://math.now.sh?inline=v_%7B%5Cpi%7D%28s%29%3D%5Csum_%7Ba%2C%20s%5E%7B%5Cprime%7D%7D%20%5Cpi(a%20%5Cmid%20s)%20p(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%20%5C%7Br(s%2Ca%2Cs%5E%7B%5Cprime%7D)%2B%5Cgamma%20v_%7B%5Cpi%7D%20(s%5E%7B%5Cprime%7D)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="行动价值函数的贝尔曼方程">行动价值函数的贝尔曼方程</h3><p>行动价值函数（Q函数）：在状态价值函数的基础上加行动<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=q_%7B%5Cpi%7D%28s%2C%20a%29%3D%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BG_%7Bt%7D%20%5Cmid%20S_%7Bt%7D%3Ds%2C%20A_%7Bt%7D%3Da%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（将行动<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>增加为条件）</p><p>与状态价值函数的转换关系：<img src="https://math.now.sh?inline=v_%7B%5Cpi%7D%28s%29%3D%5Csum_%7Ba%7D%20%5Cpi(a%20%5Cmid%20s)%20q_%7B%5Cpi%7D(s%2C%20a)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>贝尔曼方程：</p><p><img src="https://math.now.sh?inline=q_%7B%5Cpi%7D%28s%2C%20a%29%3D%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BG_%7Bt%7D%20%5Cmid%20S_%7Bt%7D%3Ds%2C%20A_%7Bt%7D%3Da%5D%3D%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BR_%7Bt%7D%2B%5Cgamma%20G_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%7D%3Ds%2C%20A_%7Bt%7D%3Da%5D%3D%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BR_%7Bt%7D%5Cmid%20S_%7Bt%7D%3Ds%2C%20A_%7Bt%7D%3Da%5D%2B%5Cgamma%20%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5B%20G_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%7D%3Ds%2C%20A_%7Bt%7D%3Da%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>① <img src="https://math.now.sh?inline=%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BR_%7Bt%7D%5Cmid%20S_%7Bt%7D%3Ds%2C%20A_%7Bt%7D%3Da%5D%3D%5Csum_%7Bs%5E%7B%5Cprime%7D%7D%20P%28s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a%29%20r(s%2C%20a%2C%20s%5E%7B%5Cprime%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>② <img src="https://math.now.sh?inline=%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5B%20G_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%7D%3Ds%2C%20A_%7Bt%7D%3Da%5D%3D%5Csum_%7Bs%5E%7B%5Cprime%7D%7D%20P%28s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a%29%20%5Cmathbb%7BE%7D_%7B%5Cpi%7D%5BG_%7Bt%2B1%7D%20%5Cmid%20S_%7Bt%2B1%7D%3Ds%5E%7B%5Cprime%7D%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最终相加：</p><p><img src="https://math.now.sh?inline=q_%7B%5Cpi%7D%28s%2C%20a%29%3D%5Csum_%7Bs%5E%7B%5Cprime%7D%7D%20P(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%5C%7Br(s%2C%20a%2C%20s%5E%7B%5Cprime%7D)%2B%5Cgamma%20v_%7B%5Cpi%7D(s%5E%7B%5Cprime%7D)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>换掉$v_{\pi}(s^{\prime}) $</p><p><img src="https://math.now.sh?inline=q_%7B%5Cpi%7D%28s%2C%20a%29%3D%5Csum_%7Bs%5E%7B%5Cprime%7D%7D%20P(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%5C%7Br(s%2C%20a%2C%20s%5E%7B%5Cprime%7D)%2B%5Cgamma%20%5Csum_%7Ba%5E%7B%5Cprime%7D%7D%20%5Cpi(a%5E%7B%5Cprime%7D%20%5Cmid%20s%5E%7B%5Cprime%7D)%20q_%7B%5Cpi%7D(s%5E%7B%5Cprime%7D%2C%20a%5E%7B%5Cprime%7D)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>贝尔曼最优方程：对最优策略<img src="https://math.now.sh?inline=v_%7B%5Cstar%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>成立的贝尔曼方程。</p><p><img src="https://math.now.sh?inline=v_%7B%5Cstar%7D%28s%29%3D%5Csum_%7Ba%7D%20%5Cpi_%7B%5Cstar%7D(a%20%5Cmid%20s)%5Csum_%7Bs%5E%7B%5Cprime%7D%7D%20P(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%20%5C%7Br(s%2Ca%2Cs%5E%7B%5Cprime%7D)%2B%5Cgamma%20v_%7B%5Cstar%7D%20(s%5E%7B%5Cprime%7D)%5C%7D%3D%5Cunderset%7Ba%7D%7B%5Coperatorname%7Bmax%7D%7D%5Csum_%7Bs%5E%7B%5Cprime%7D%7D%20P(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%20%5C%7Br(s%2Ca%2Cs%5E%7B%5Cprime%7D)%2B%5Cgamma%20v_%7B%5Cstar%7D%20(s%5E%7B%5Cprime%7D)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=q_%7B%5Cstar%7D%28s%2C%20a%29%3D%5Csum_%7Bs%5E%7B%5Cprime%7D%7D%20P(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%5C%7Br(s%2C%20a%2C%20s%5E%7B%5Cprime%7D)%2B%5Cgamma%20%5Cunderset%7Ba%5E%7B%5Cprime%7D%7D%7B%5Coperatorname%7Bmax%7D%7D%20%5C%7Bq_%7B%5Cpi%7D(s%5E%7B%5Cprime%7D%2C%20a%5E%7B%5Cprime%7D)%5C%7D%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最优行动  <img src="https://math.now.sh?inline=%5Cmu_%7B%5Cstar%7D%28s%29%3D%5Cunderset%7Ba%7D%7B%5Coperatorname%7Bargmax%7D%7D%20%5C%7Bq_%7B%5Cstar%7D(s%2C%20a)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="动态规划法求解">动态规划法求解</h2><ul><li>策略评估：求给定策略<img src="https://math.now.sh?inline=%5Cpi" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的价值函数<img src="https://math.now.sh?inline=v_%7B%5Cpi%7D%28s%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=q_%7B%5Cpi%7D%28s%2C%20a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>策略控制：控制策略并转换为最优的策略。</li></ul><p>联立方程，未知数的数量可能非常多，因此采用动态规划法进行策略评估。</p><p>将贝尔曼方程转化为更新式：（迭代策略评估）</p><p><img src="https://math.now.sh?inline=V_%7Bk%2B1%7D%28s%29%3D%5Csum_%7Ba%2C%20s%5E%7B%5Cprime%7D%7D%20%5Cpi(a%20%5Cmid%20s)%20p(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%20%5C%7Br(s%2Ca%2Cs%5E%7B%5Cprime%7D)%2B%5Cgamma%20V_%7Bk%7D%20(s%5E%7B%5Cprime%7D)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（<img src="https://math.now.sh?inline=V_%7Bk%7D%28s%29%2CV_%7Bk%2B1%7D(s)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>都是推测值）（自举法）</p><p>如果状态迁移是确定性的<img src="https://math.now.sh?inline=s%5E%7B%5Cprime%7D%3Df%28s%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：</p><p><img src="https://math.now.sh?inline=V_%7Bk%2B1%7D%28s%29%3D%5Csum_%7Ba%7D%20%5Cpi(a%20%5Cmid%20s)%20%5C%7Br(s%2Ca%2Cs%5E%7B%5Cprime%7D)%2B%5Cgamma%20V_%7Bk%7D%20(s%5E%7B%5Cprime%7D)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>策略改进：</p><p><img src="https://math.now.sh?inline=%5Cmu_%7B%5Cstar%7D%28s%29%3D%5Cunderset%7Ba%7D%7B%5Coperatorname%7Bargmax%7D%7D%20%5C%7Bq_%7B%5Cstar%7D(s%2C%20a)%5C%7D%3D%5Cunderset%7Ba%7D%7B%5Coperatorname%7Bargmax%7D%7D%5C%7BP(s%5E%7B%5Cprime%7D%20%5Cmid%20s%2C%20a)%20%5C%7Br(s%2Ca%2Cs%5E%7B%5Cprime%7D)%2B%5Cgamma%20v_%7B%5Cstar%7D%20(s%5E%7B%5Cprime%7D)%5C%7D%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>价值迭代法：融合了策略评估阶段和策略改进阶段</p><h2 id="NLP中的强化学习">NLP中的强化学习</h2><p><img src="https://pic1.zhimg.com/80/v2-eb250d428d3b9a751d4ba3aeae70e290_1440w.webp" alt=""></p><ul><li><img src="https://math.now.sh?inline=A_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：模型根据上文，产生一个token</li><li><img src="https://math.now.sh?inline=R_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：即时收益，指语言模型当下产生token<img src="https://math.now.sh?inline=A_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的收益</li><li><img src="https://math.now.sh?inline=V_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：实际期望总收益（即时+未来），指对语言模型“当下产生token <img src="https://math.now.sh?inline=A_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，一直到整个response生产结束”的后期收益预估。因为当下语言模型还没产出<img src="https://math.now.sh?inline=A_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>后的token，所以我们只是对它之后一系列动作的收益做了估计，因而称为“期望总收益”。</li></ul><p><img src="https://pic3.zhimg.com/80/v2-22c2f6fce157dc4385a14f0de50d8136_1440w.webp" alt=""></p><p><strong>在RLHF-PPO阶段，一共有四个主要模型</strong> ，分别是：</p><ul><li><strong>Actor Model：演员模型</strong> ，这就是我们想要训练的目标语言模型</li><li><strong>Critic Model：评论家模型</strong> ，它的作用是预估总收益<img src="https://math.now.sh?inline=V_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><strong>Reward Model：奖励模型</strong> ，它的作用是计算即时收益<img src="https://math.now.sh?inline=R_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><strong>Reference Model：参考模型</strong> ，它的作用是在RLHF阶段给语言模型增加一些“约束”，防止语言模型训歪（朝不受控制的方向更新，效果可能越来越差）</li></ul><p><strong>Actor/Critic Model</strong>在RLHF阶段是<strong>需要训练</strong>的（图中给这两个模型加了粗边，就是表示这个含义）；而<strong>Reward/Reference Model</strong>是<strong>参数冻结</strong>的。</p><p>Critic/Reward/Reference Model共同组成了一个“奖励-loss”计算体系（我自己命名的，为了方便理解），我们综合它们的结果计算loss，用于更新Actor和Critic Model</p><h3 id="Actor-Model-演员模型">Actor Model (演员模型)</h3><p><strong>Actor就是我们想要训练的目标语言模型。我们一般用SFT阶段产出的SFT模型来对它做初始化。</strong></p><p>我们的最终目的是让Actor模型能产生符合人类喜好的response。所以我们的策略是，先喂给Actor一条prompt （这里假设batch_size = 1，所以是1条prompt），让它生成对应的response。然后，我们再将“prompt + response&quot;送入我们的“奖励-loss”计算体系中去算得最后的loss，用于更新actor。</p><h3 id="Reference-Model（参考模型）">Reference Model（参考模型）</h3><p><strong>Reference Model（以下简称Ref模型）一般也用SFT阶段得到的SFT模型做初始化，在训练过程中，它的参数是冻结的。</strong> Ref模型的主要作用是防止Actor”训歪”</p><p><strong>我们希望训练出来的Actor模型既能达到符合人类喜好的目的，又尽量让它和SFT模型不要差异太大</strong> 。因此我们使用KL散度来衡量输出分布的相似度</p><p><img src="https://pic1.zhimg.com/80/v2-c4030ebb772b2619043f46b9ab5e58e8_1440w.webp" alt="img"></p><ul><li><strong>对Actor模型</strong> ，我们喂给它一个prompt，它正常输出对应的response。那么response中每一个token肯定有它对应的log_prob结果，我们把这样的结果记为<strong>log_probs</strong></li><li><strong>对Ref模型</strong> ，我们把Actor生成的&quot;prompt + response&quot;喂给它，那么它同样能给出每个token的log_prob结果，我们记其为<strong>ref_log_probs</strong></li><li>那么这两个模型的输出分布相似度就可以用  <code>ref_log_probs - log_probs</code> 来衡量，就是KL散度的公式<ul><li>ref_log_probs越高，说明Ref模型对Actor模型输出的肯定性越大。即Ref模型也认为Actor模型较Ref模型没有训歪</li></ul></li></ul><h3 id="Critic-Model（评论家模型）">Critic Model（评论家模型）</h3><p><strong>Critic Model用于预测期望总收益，和Actor模型一样，它需要做参数更新</strong> 。</p><p><strong>在<img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时刻，我们给不出客观存在的总收益<img src="https://math.now.sh?inline=V_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，我们只能训练一个模型去预测它。</strong></p><p><strong>在RLHF中，我们不仅要训练模型生成符合人类喜好的内容的能力（Actor），也要提升模型对人类喜好量化判断的能力（Critic）</strong></p><p>deepspeed-chat采用了Reward模型作为它的初始化,可以简单理解成，Reward/Critic模型和Actor模型的架构是很相似的（毕竟输入都一样），同时，它在最后一层增加了一个Value Head层，该层是个简单的线形层，用于将原始输出结果映射成单一的<img src="https://math.now.sh?inline=V_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>值。</p><h3 id="Reward-Model（奖励模型）">Reward Model（奖励模型）</h3><p>Reward Model用于计算生成token的即时收益，它就是RW阶段所训练的奖励模型，在RLHF过程中，它的参数是冻结的。</p><p>Reward模型是站在上帝视角的。这个上帝视角有两层含义：</p><ul><li>第一点，Reward模型是经过和“估算收益”相关的训练的，因此在RLHF阶段它可以直接被当作一个能产生客观值的模型。</li><li>第二点，Reward模型代表的含义就是“即时收益”，你的token<img src="https://math.now.sh?inline=A_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>已经产生，因此即时收益自然可以立刻算出。</li></ul><p>reward是对actor模型进行了某一个action之后的直接打分；而critic则是对这个actor模型的整体预估得分。每次actor模型更新后，critic模型都要对这个新的actor模型重新打分，所以critic模型也要更新参数。critic模型对actor模型的整体预估得分，是根据reward模型的每一次实时打分来预估的。当critic模型的预估得分达到了一定的基准，就代表actor模型训练完成。</p><h2 id="RLHF-PPO的训练过程">RLHF-PPO的训练过程</h2><ul><li>第一步，我们准备一个batch的prompts</li><li>第二步，我们将这个batch的prompts喂给Actor模型，让它生成对应的responses</li><li>第三步，我们把prompt+responses喂给我们的Critic/Reward/Reference模型，让它生成用于计算actor/critic loss的数据，按照强化学习的术语，我们称这些数据为经验（experiences）。</li><li>第四步，我们根据这些经验，实际计算出actor/critic loss，然后更新Actor和Critic模型</li></ul><p><img src="https://pic4.zhimg.com/80/v2-5b0028cc73d9f2aa599b256df24bda83_1440w.webp" alt=""></p><h2 id="Loss">Loss</h2><h3 id="Actor-Loss">Actor Loss</h3><p>直观设计</p><ul><li>Actor接收到当前上文<img src="https://math.now.sh?inline=S_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，产出token <img src="https://math.now.sh?inline=A_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，概率是<img src="https://math.now.sh?inline=P%28A_t%7CS_t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>Critic model 根据<img src="https://math.now.sh?inline=S_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和 <img src="https://math.now.sh?inline=A_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，产出对总收益的预测<img src="https://math.now.sh?inline=V_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>actor loss = <img src="https://math.now.sh?inline=%5Csum%20V_tlog%20P%28A_t%7CS_t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/><ul><li>当<img src="https://math.now.sh?inline=V_t%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，意味着Critic对Actor当前采取的动作给了正向反馈，因此我们就需要在训练迭代中提高<img src="https://math.now.sh?inline=%F0%9D%91%83%28%F0%9D%90%B4_%F0%9D%91%A1%7C%F0%9D%91%86_%F0%9D%91%A1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，这样就能达到减小loss的作用。</li><li>当<img src="https://math.now.sh?inline=V_t%3C0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，意味着Critic对Actor当前采取的动作给了负向反馈，因此我们就需要在训练迭代中降低<img src="https://math.now.sh?inline=%F0%9D%91%83%28%F0%9D%90%B4_%F0%9D%91%A1%7C%F0%9D%91%86_%F0%9D%91%A1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，这样就能到达到减小loss的作用。</li></ul></li></ul><p><strong>引入优势</strong></p><p>如果Critic对<img src="https://math.now.sh?inline=%F0%9D%90%B4_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/><strong>的总收益预测为<img src="https://math.now.sh?inline=V_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，但实际执行<img src="https://math.now.sh?inline=%F0%9D%90%B4_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>后的总收益是</strong> <img src="https://math.now.sh?inline=%F0%9D%91%85_%F0%9D%91%A1%2B%20%5Cgamma%20%E2%88%97%F0%9D%91%89_%7B%F0%9D%91%A1%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> <strong>，我们就定义优势为：</strong></p><p><img src="https://math.now.sh?inline=%F0%9D%90%B4%F0%9D%91%91%F0%9D%91%A3_%F0%9D%91%A1%3D%F0%9D%91%85_%F0%9D%91%A1%2B%20%5Cgamma%20%E2%88%97%F0%9D%91%89_%7B%F0%9D%91%A1%2B1%7D%E2%88%92%F0%9D%91%89_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，替换上面的<img src="https://math.now.sh?inline=V_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>actor loss = <img src="https://math.now.sh?inline=%5Csum%20%F0%9D%90%B4%F0%9D%91%91%F0%9D%91%A3_%F0%9D%91%A1%20log%20P%28A_t%7CS_t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=R_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>本来是即时收益，但是可以调整一下：（<img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是最后一个时刻）</p><ul><li>当<img src="https://math.now.sh?inline=t%E2%89%A0T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，我们更加关心Actor是否有在Ref的约束下生产token<img src="https://math.now.sh?inline=A_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>当<img src="https://math.now.sh?inline=%F0%9D%91%A1%3D%F0%9D%91%87" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，我们不仅关心Actor是否遵从了Ref的约束，也关心真正的即时收益<img src="https://math.now.sh?inline=R_T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p><img src="https://math.now.sh?inline=R_t%3D-0.1*log%5Cfrac%7BP%28A_t%7CS_t%29%7D%7BP_%7Bref%7D(A_t%7CS_t)%7D%2Ct%E2%89%A0T%3B%20%3D-0.1*log%5Cfrac%7BP(A_t%7CS_t)%7D%7BP_%7Bref%7D(A_t%7CS_t)%7D%2BR_T%2Ct%3DT" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>为什么只有最后一个时刻的<img src="https://math.now.sh?inline=R_T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>被纳入了考量呢？这是因为在Reward模型训练阶段，就是用这个位置的的<img src="https://math.now.sh?inline=R_T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 来表示对完整的prompt + response的奖励预测（但不妨碍你理解成是执行完<img src="https://math.now.sh?inline=A_T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的即时奖励），然后用这个指标来做模型eval的（但是Reward训练阶段算loss时，还是考虑了response部分所有token输出的reward值）。所以到了RLHF的场景下，其余时刻的即时奖励，我们就用“Actor是否遵循了Ref的约束”来进行评价。</p><p><strong>改造优势</strong></p><p><img src="https://math.now.sh?inline=%F0%9D%90%B4%F0%9D%91%91%F0%9D%91%A3_%F0%9D%91%A1%3D%F0%9D%91%85_%F0%9D%91%A1%2B%20%5Cgamma%20%E2%88%97%F0%9D%91%89_%7B%F0%9D%91%A1%2B1%7D%E2%88%92%F0%9D%91%89_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%F0%9D%90%B4%F0%9D%91%91%F0%9D%91%A3_%F0%9D%91%A1%3D%28%F0%9D%91%85_%F0%9D%91%A1%2B%20%5Cgamma%20%E2%88%97%F0%9D%91%89_%7B%F0%9D%91%A1%2B1%7D%E2%88%92%F0%9D%91%89_%F0%9D%91%A1%29%2B%5Cgamma%20*%20%5Clambda%20*%20Adv_%7Bt%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>新引入的<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>也是一个常量，可将其理解为权衡因子，直觉上看它控制了在计算当前优势时对未来优势的考量。</strong></p><p>对于最后一个时刻<img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，它的未来收益<img src="https://math.now.sh?inline=%F0%9D%91%89_%7BT%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和未来优势<img src="https://math.now.sh?inline=Adv_%7BT%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>都是0，也就是<img src="https://math.now.sh?inline=%F0%9D%90%B4%F0%9D%91%91%F0%9D%91%A3_%F0%9D%91%87%3D%F0%9D%91%85_%F0%9D%91%87%E2%88%92%F0%9D%91%89_%F0%9D%91%87" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，这是可以直接算出来的。而有了<img src="https://math.now.sh?inline=%F0%9D%90%B4%F0%9D%91%91%F0%9D%91%A3_%F0%9D%91%87" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> <strong>，我们可以通过动态规划的方法，把所有时刻的优势算出来</strong></p><p><strong>重复使用</strong></p><p>太慢了，所以一个batch的经验值将被用于n次模型更新</p><p>1个batch的经验值被使用ppo_epochs次，在这ppo_epochs中，Actor是不吃任何新数据，不做任何交互的，所以我们只能让Actor“模拟”一下和环境交互的过程，吐出一些新数据出来。</p><p>还是保证新的数据和旧的差不多，还是使用KL散度</p><p>actor loss = <img src="https://math.now.sh?inline=%5Csum%20%F0%9D%90%B4%F0%9D%91%91%F0%9D%91%A3_%F0%9D%91%A1%20*%20%5Cfrac%7BP%28A_t%7CS_t%29%7D%7BP_%7Bold%7D(A_t%7CS_t)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>在Actor想通过模拟交互的方式，使用一个batch的经验值更新自己时，它需要收到真正吃到batch的那个时刻的Actor的约束，这样才能在有效利用batch，提升训练速度的基础上，保持训练的稳定。</strong></p><p>设置一个范围，差距太大就不要更新了</p><h3 id="Critic-Loss">Critic Loss</h3><ul><li><img src="https://math.now.sh?inline=V_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：Critic对<img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时刻的总收益的预估，这个总收益包含即时和未来的概念（预估收益）</li><li><img src="https://math.now.sh?inline=%F0%9D%91%85_%F0%9D%91%A1%2B%20%5Cgamma%20%E2%88%97%F0%9D%91%89_%7B%F0%9D%91%A1%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：Reward计算出的即时收益<img src="https://math.now.sh?inline=R_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，Critic预测出的<img src="https://math.now.sh?inline=%F0%9D%91%A1%2B1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>及之后时候的收益的折现，这是比<img src="https://math.now.sh?inline=%F0%9D%91%89_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>更接近<img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时刻真值总收益的一个值（实际收益）</li></ul><p>第一想法：Critic loss =$ (𝑅_𝑡+ \gamma ∗𝑉_{𝑡+1}-V_t)^2$</p><p>实际收益优化：<img src="https://math.now.sh?inline=%F0%9D%91%85_%F0%9D%91%A1%2B%20%5Cgamma%20%E2%88%97%F0%9D%91%89_%7B%F0%9D%91%A1%2B1%7D%5Crightarrow%20Adv_t%2BV_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>预估收益优化：类比于Actor，Critic模型在ppo_epochs的过程中也是不断更新的。所以这个<img src="https://math.now.sh?inline=%F0%9D%91%89_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可以理解成是<img src="https://math.now.sh?inline=%F0%9D%90%B6%F0%9D%91%9F%F0%9D%91%96%F0%9D%91%A1%F0%9D%91%96%F0%9D%91%90_%7B%F0%9D%91%9C%F0%9D%91%99%F0%9D%91%91%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，也就是真正吃了batch，参与产出经验的那个时候的Critic产出的收益预测结果。</p><p>用老<img src="https://math.now.sh?inline=%F0%9D%91%89_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>设计了了一个变动范围，然后用这个变动范围去约束新<img src="https://math.now.sh?inline=%F0%9D%91%89_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最终我们就取实际收益和预估收益的MSE做为loss就好，这里注意，计算实际收益时<img src="https://math.now.sh?inline=%F0%9D%90%B4%F0%9D%91%91%F0%9D%91%A3_%F0%9D%91%A1%2C%F0%9D%91%89_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>都是老Critic（真正吃了batch的那个）产出的结果，而预估收益是随着ppo_epochs而变动的。</p><h1>DPO</h1><p>DPO通过简单的分类目标直接优化最满足偏好的策略，而没有明确的奖励函数或RL</p><p>DPO的本质在于增加了被首选的response相对不被首选的response的对数概率，但它包含了一个动态的、每个示例的重要性权重，以防止设计的概率比让模型的能力退化。</p><p>核心假设：偏好数据遵循 Bradley-Terry 模型（<img src="https://math.now.sh?inline=P%28i%20%3E%20j%29%3D%5Cfrac%7BP_i%7D%7BP_i%2BP_j%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>）</p><p><img src="https://img2024.cnblogs.com/blog/1070495/202401/1070495-20240115092911186-835855853.png" alt="img"></p><p>DPO与PPO的区别：<a href="https://zhuanlan.zhihu.com/p/11913305485">https://zhuanlan.zhihu.com/p/11913305485</a></p><h1>变种</h1><p>IPO相当于在DPO的损失函数上添加了一个正则项，从而可以使得不使用early stopping技巧就可以使模型收敛。</p><p>KTO定义的损失函数只需要将样本标注为&quot;好(good)“或&quot;坏(bad)”，从而使得获取标注样本的成本更低。（就是不需要一对一对标注了）</p><p>CPO在训练期间不需要加载参考策略模型。通过省略内存的参考模型，CPO提高了操作效率，与DPO相比，能够以更低的成本训练更大的模型。</p><p>ORPO整合SFT和DPO，且不需要额外的参考模型</p><p>SimPO 包含两个主要组件：（1）在长度上归一化的奖励，其计算方式是使用策略模型的奖励中所有 token 的平均对数概率；（2）目标奖励差额，用以确保获胜和失败响应之间的奖励差超过这个差额。</p><p>SimPO 不需要参考模型，性能却明显优于 DPO 及其最新变体，且不会显著增加响应长度</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Python</tag>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-其他题目</title>
    <link href="/2024/04/14/Leetcode/Leetcode-others/"/>
    <url>/2024/04/14/Leetcode/Leetcode-others/</url>
    
    <content type="html"><![CDATA[<p>Leetcode-其他题目</p><span id="more"></span><h1>回溯</h1><h2 id="22-括号生成">22. 括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong>括号组合。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    vector&lt;string&gt; result;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;string&gt; temp, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> nowleft, <span class="hljs-type">int</span> nowright)</span></span>&#123;        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == n * <span class="hljs-number">2</span>)&#123;            string res = <span class="hljs-string">&quot;&quot;</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;                res += temp[i];            &#125;            result.<span class="hljs-built_in">push_back</span>(res);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (nowleft &lt; n)&#123;            temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;(&quot;</span>);            <span class="hljs-built_in">backtracking</span>(temp,n,nowleft<span class="hljs-number">+1</span>,nowright);            temp.<span class="hljs-built_in">pop_back</span>();        &#125;        <span class="hljs-keyword">if</span>(nowright &lt; n &amp;&amp; nowright &lt; nowleft)&#123;            temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;)&quot;</span>);            <span class="hljs-built_in">backtracking</span>(temp,n,nowleft,nowright<span class="hljs-number">+1</span>);            temp.<span class="hljs-built_in">pop_back</span>();        &#125;    &#125;    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        vector&lt;string&gt; temp;        <span class="hljs-built_in">backtracking</span>(temp,n,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><h2 id="31-下一个排列">31. 下一个排列</h2><p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li></ul><p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> index = n<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span>(;index&gt;=<span class="hljs-number">1</span>;index--)&#123;            <span class="hljs-keyword">if</span>(nums[index] &gt; nums[index<span class="hljs-number">-1</span>])&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(index != <span class="hljs-number">0</span>)&#123;            index -= <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[index])&#123;                    <span class="hljs-built_in">swap</span>(nums[index], nums[i]);                    <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>()+index<span class="hljs-number">+1</span>,nums.<span class="hljs-built_in">end</span>());                    <span class="hljs-keyword">return</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());        &#125;    &#125;&#125;;</code></pre></div><h2 id="79-单词搜索">79. 单词搜索</h2><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-type">bool</span> result = <span class="hljs-literal">false</span>;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n,<span class="hljs-type">int</span> now, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; &amp;visited,  string word)</span></span>&#123;        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || i &gt;= m || j &gt;= n || visited[i][j] == <span class="hljs-literal">true</span> || board[i][j] != word[now])&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(now == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;            result = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span>;        &#125;        visited[i][j] = <span class="hljs-literal">true</span>;        <span class="hljs-built_in">DFS</span>(i<span class="hljs-number">+1</span>,j,m,n,now<span class="hljs-number">+1</span>,board,visited, word);        <span class="hljs-built_in">DFS</span>(i<span class="hljs-number">-1</span>,j,m,n,now<span class="hljs-number">+1</span>,board,visited, word);        <span class="hljs-built_in">DFS</span>(i,j<span class="hljs-number">+1</span>,m,n,now<span class="hljs-number">+1</span>,board,visited, word);        <span class="hljs-built_in">DFS</span>(i,j<span class="hljs-number">-1</span>,m,n,now<span class="hljs-number">+1</span>,board,visited, word);        visited[i][j] = <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;                vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));                <span class="hljs-built_in">DFS</span>(i,j,m,n,<span class="hljs-number">0</span>,board,visited, word);                <span class="hljs-keyword">if</span>(result)&#123;                    <span class="hljs-keyword">return</span> result;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><h1>二叉树</h1><h2 id="94-二叉树的中序遍历">94. 二叉树的中序遍历</h2><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    vector&lt;<span class="hljs-type">int</span>&gt; result;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">inorder</span>(root-&gt;left);        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);        <span class="hljs-built_in">inorder</span>(root-&gt;right);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">inorder</span>(root);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><h2 id="103-二叉树的锯齿形层序遍历">103. 二叉树的锯齿形层序遍历</h2><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>锯齿形层序遍历</strong> 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> result;        &#125;        queue&lt;TreeNode*&gt; q;        q.<span class="hljs-built_in">push</span>(root);        <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">size</span>();            vector&lt;<span class="hljs-type">int</span>&gt; temp;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;                TreeNode* x = q.<span class="hljs-built_in">front</span>();                q.<span class="hljs-built_in">pop</span>();                temp.<span class="hljs-built_in">push_back</span>(x-&gt;val);                <span class="hljs-keyword">if</span>(x-&gt;left != <span class="hljs-literal">NULL</span>)&#123;                    q.<span class="hljs-built_in">push</span>(x-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(x-&gt;right != <span class="hljs-literal">NULL</span>)&#123;                    q.<span class="hljs-built_in">push</span>(x-&gt;right);                &#125;            &#125;            <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;                <span class="hljs-built_in">reverse</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>());            &#125;            result.<span class="hljs-built_in">push_back</span>(temp);            sign = <span class="hljs-number">1</span> - sign;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><h1>动态规划</h1><h2 id="64-最小路径和">64. 最小路径和</h2><p>给定一个包含非负整数的 <code>&lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt;</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong> 每次只能向下或者向右移动一步。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;            dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][j];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre></div><h1>数组</h1><h2 id="7-整数反转">7. 整数反转</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31 &lt;/sup&gt;− 1]</code> ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;        <span class="hljs-type">int</span> rev = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (rev &lt; INT_MIN / <span class="hljs-number">10</span> || rev &gt; INT_MAX / <span class="hljs-number">10</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            <span class="hljs-type">int</span> digit = x % <span class="hljs-number">10</span>;            x /= <span class="hljs-number">10</span>;            rev = rev * <span class="hljs-number">10</span> + digit;        &#125;        <span class="hljs-keyword">return</span> rev;    &#125;&#125;;</code></pre></div><h2 id="215-数组中的第K个最大元素">215. 数组中的第K个最大元素</h2><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>&lt;strong&gt;k&lt;/strong&gt;</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> k)</span></span>&#123;        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> x = nums[start];        <span class="hljs-type">int</span> left = start;        <span class="hljs-type">int</span> right = end;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] &lt;= x)&#123;                right--;            &#125;            nums[left] = nums[right];            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] &gt; x)&#123;                left++;            &#125;            nums[right] = nums[left];        &#125;        nums[left] = x;        <span class="hljs-comment">// start    left    end   </span>        <span class="hljs-comment">// k</span>        <span class="hljs-keyword">if</span>(k == left + <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k &lt; left<span class="hljs-number">+1</span>)&#123;            <span class="hljs-built_in">quicksort</span>(nums, start, left<span class="hljs-number">-1</span>,k);        &#125; <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">quicksort</span>(nums,left<span class="hljs-number">+1</span>,end,k);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k);        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre></div><h2 id="347-前K个高频元素">347. 前K个高频元素</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt;&amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, <span class="hljs-type">int</span> k)</span></span>&#123;        <span class="hljs-keyword">if</span>(start &gt;= end)&#123;            <span class="hljs-keyword">return</span>;        &#125;        pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; x = nums[start];        <span class="hljs-type">int</span> left = start;        <span class="hljs-type">int</span> right = end;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right].second &lt;= x.second)&#123;                right--;            &#125;            <span class="hljs-built_in">swap</span>(nums[left],nums[right]);            <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left].second &gt; x.second)&#123;                left++;            &#125;            <span class="hljs-built_in">swap</span>(nums[left],nums[right]);        &#125;        nums[left].first = x.first;        nums[left].second = x.second;        <span class="hljs-comment">// start  left  end;</span>        <span class="hljs-keyword">if</span>(k == left)&#123;            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k &gt; left)&#123;            <span class="hljs-built_in">quicksort</span>(nums, left<span class="hljs-number">+1</span>, end,k);        &#125; <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">quicksort</span>(nums, start, left<span class="hljs-number">-1</span>,k);        &#125;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; result;        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;            mp[nums[i]]++;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it=mp.<span class="hljs-built_in">begin</span>();it!= mp.<span class="hljs-built_in">end</span>();it++)&#123;            result.<span class="hljs-built_in">push_back</span>(&#123;it-&gt;first, it-&gt;second&#125;);        &#125;        <span class="hljs-built_in">quicksort</span>(result, <span class="hljs-number">0</span>, result.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k);        vector&lt;<span class="hljs-type">int</span>&gt; res;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;            res.<span class="hljs-built_in">push_back</span>(result[i].first);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre></div><h2 id="32-最长有效括号">32. 最长有效括号</h2><p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(s.size(),<span class="hljs-literal">false</span>)</span></span>;        stack&lt;pair&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; &gt; st;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>() || s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || (s[i] == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; st.<span class="hljs-built_in">top</span>().first == <span class="hljs-string">&#x27;)&#x27;</span>))&#123;                st.<span class="hljs-built_in">push</span>(&#123;s[i],i&#125;);                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=st.<span class="hljs-built_in">top</span>().second;j&lt;=i;j++)&#123;                visit[j] = <span class="hljs-literal">true</span>;            &#125;            st.<span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-type">int</span> maxlength = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(index &lt; visit.<span class="hljs-built_in">size</span>())&#123;            <span class="hljs-type">int</span> counttemp = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(index &lt; visit.<span class="hljs-built_in">size</span>() &amp;&amp; visit[index])&#123;                counttemp += <span class="hljs-number">1</span>;                index += <span class="hljs-number">1</span>;            &#125;            maxlength = <span class="hljs-built_in">max</span>(maxlength, counttemp);            <span class="hljs-keyword">while</span>(index &lt; visit.<span class="hljs-built_in">size</span>() &amp;&amp; !visit[index])&#123;                index += <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> maxlength;    &#125;&#125;;</code></pre></div><h2 id="2570-合并两个二维数组-求和法">2570. 合并两个二维数组 - 求和法</h2><p>给你两个 <strong>二维</strong> 整数数组 <code>nums1</code> 和 <code>nums2.</code></p><ul><li><code>nums1[i] = [id&lt;sub&gt;i&lt;/sub&gt;, val&lt;sub&gt;i&lt;/sub&gt;]</code> 表示编号为 <code>id&lt;sub&gt;i&lt;/sub&gt;</code> 的数字对应的值等于 <code>val&lt;sub&gt;i&lt;/sub&gt;</code> 。</li><li><code>nums2[i] = [id&lt;sub&gt;i&lt;/sub&gt;, val&lt;sub&gt;i&lt;/sub&gt;]</code> 表示编号为 <code>id&lt;sub&gt;i&lt;/sub&gt;</code> 的数字对应的值等于 <code>val&lt;sub&gt;i&lt;/sub&gt;</code> 。</li></ul><p>每个数组都包含 <strong>互不相同</strong> 的 id ，并按 id 以 <strong>递增</strong> 顺序排列。</p><p>请你将两个数组合并为一个按 id 以递增顺序排列的数组，并符合下述条件：</p><ul><li>只有在两个数组中至少出现过一次的 id 才能包含在结果数组内。</li><li>每个 id 在结果数组中 <strong>只能出现一次</strong> ，并且其对应的值等于两个数组中该 id 所对应的值求和。如果某个数组中不存在该 id ，则认为其对应的值等于 <code>0</code> 。</li></ul><p>返回结果数组。返回的数组需要按 id 以递增顺序排列。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];    &#125;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mergeArrays</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums1, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums2) &#123;        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(nums1[i][<span class="hljs-number">0</span>]) != mp.<span class="hljs-built_in">end</span>())&#123;                mp[nums1[i][<span class="hljs-number">0</span>]] += nums1[i][<span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span>&#123;                mp[nums1[i][<span class="hljs-number">0</span>]] = nums1[i][<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(nums2[i][<span class="hljs-number">0</span>]) != mp.<span class="hljs-built_in">end</span>())&#123;                mp[nums2[i][<span class="hljs-number">0</span>]] += nums2[i][<span class="hljs-number">1</span>];            &#125; <span class="hljs-keyword">else</span>&#123;                mp[nums2[i][<span class="hljs-number">0</span>]] = nums2[i][<span class="hljs-number">1</span>];            &#125;        &#125;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>();it++)&#123;            result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt; &#123;it-&gt;first, it-&gt;second&#125;);        &#125;        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>(), cmp);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><h2 id="33-搜索旋转排序数组">33. 搜索旋转排序数组</h2><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了  <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = n<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;                <span class="hljs-keyword">return</span> mid;            &#125;            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= nums[mid])&#123;                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid])&#123;                    right = mid - <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span>&#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;            &#125; <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[n<span class="hljs-number">-1</span>])&#123;                    left = mid + <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span>&#123;                    right = mid - <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre></div><h2 id="48-旋转图像">48. 旋转图像</h2><p>给定一个  *n * × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在** 原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要 **使用另一个矩阵来旋转图像。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; n / <span class="hljs-number">2</span>;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;(n<span class="hljs-number">+1</span>) / <span class="hljs-number">2</span>;j++)&#123;                <span class="hljs-type">int</span> temp = matrix[i][j];                matrix[i][j] = matrix[n-j<span class="hljs-number">-1</span>][i];                matrix[n-j<span class="hljs-number">-1</span>][i] = matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>];                matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>] = matrix[j][n-i<span class="hljs-number">-1</span>];                matrix[j][n-i<span class="hljs-number">-1</span>] = temp;            &#125;        &#125;    &#125;&#125;;</code></pre></div><h2 id="75-颜色分类">75. 颜色分类</h2><p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;                <span class="hljs-built_in">swap</span>(nums[i], nums[left]);                left += <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=left;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;                <span class="hljs-built_in">swap</span>(nums[i], nums[left]);                left += <span class="hljs-number">1</span>;            &#125;        &#125;    &#125;&#125;;</code></pre></div><h2 id="73-矩阵置零">73. 矩阵置零</h2><p>给定一个 <code>&lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt;</code> 的矩阵，如果一个元素为  <strong>0 ** ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法</strong>。**</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">rowvector</span><span class="hljs-params">(m,<span class="hljs-literal">false</span>)</span></span>;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">colvector</span><span class="hljs-params">(n,<span class="hljs-literal">false</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;                    rowvector[i] = <span class="hljs-literal">true</span>;                    colvector[j] = <span class="hljs-literal">true</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;                <span class="hljs-keyword">if</span>(rowvector[i] == <span class="hljs-literal">true</span> || colvector[j] == <span class="hljs-literal">true</span>)&#123;                    matrix[i][j] = <span class="hljs-number">0</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span>;    &#125;&#125;;</code></pre></div><h2 id="118-杨辉三角">118. 杨辉三角</h2><p>给定一个非负整数  <em><code>numRows</code>，</em> 生成「杨辉三角」的前 *<code>numRows</code> *行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;        vector&lt;<span class="hljs-type">int</span>&gt; temp;        temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);        result.<span class="hljs-built_in">push_back</span>(temp);        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=numRows;i++)&#123;            vector&lt;<span class="hljs-type">int</span>&gt; t;            t.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i<span class="hljs-number">-1</span>;j++)&#123;                t.<span class="hljs-built_in">push_back</span>(result[i<span class="hljs-number">-2</span>][j<span class="hljs-number">-1</span>] + result[i<span class="hljs-number">-2</span>][j]);            &#125;            t.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);            result.<span class="hljs-built_in">push_back</span>(t);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><h2 id="153-寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</h2><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：* 若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></p><ul><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = n<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[right])&#123;                right = mid;            &#125; <span class="hljs-keyword">else</span> &#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left];    &#125;&#125;;</code></pre></div><h1>链表</h1><h2 id="2-两数相加">2. 两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);        ListNode* l3 = head;        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> || l2 != <span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-type">int</span> target;            <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">NULL</span>)&#123;                target = l2-&gt;val + cur;                l2 = l2-&gt;next;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">NULL</span>)&#123;                target = l1-&gt;val + cur;                l1 = l1-&gt;next;            &#125; <span class="hljs-keyword">else</span>&#123;                target = l1-&gt;val + l2-&gt;val + cur;                l1 = l1-&gt;next;                l2 = l2-&gt;next;            &#125;            <span class="hljs-keyword">if</span> (target &gt;= <span class="hljs-number">10</span>)&#123;                cur = <span class="hljs-number">1</span>;                target -= <span class="hljs-number">10</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                cur = <span class="hljs-number">0</span>;            &#125;            l3-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(target);            l3 = l3-&gt;next;        &#125;        <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">1</span>)&#123;            l3-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> head-&gt;next;    &#125;&#125;;</code></pre></div><h2 id="21-合并两个有序链表">21. 合并两个有序链表</h2><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);        ListNode* head = dummy;        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">NULL</span> &amp;&amp; list2 != <span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;                dummy-&gt;next = list1;                dummy = dummy-&gt;next;                list1 = list1-&gt;next;            &#125; <span class="hljs-keyword">else</span>&#123;                dummy-&gt;next = list2;                dummy = dummy-&gt;next;                list2 = list2-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">if</span>(list1 != <span class="hljs-literal">NULL</span>)&#123;            dummy-&gt;next = list1;        &#125;        <span class="hljs-keyword">if</span>(list2 != <span class="hljs-literal">NULL</span>)&#123;            dummy-&gt;next = list2;        &#125;        <span class="hljs-keyword">return</span> head-&gt;next;    &#125;&#125;;</code></pre></div><h1>哈希表</h1><h1>字符串</h1><h2 id="6-Z-字形变换">6. Z 字形变换</h2><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">P</span>   <span class="hljs-selector-tag">A</span>   H   N<span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">P</span> L S <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">G</span><span class="hljs-attribute">Y</span>   <span class="hljs-selector-tag">I</span>   <span class="hljs-attribute">R</span></code></pre></div><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">convert</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> s, <span class="hljs-built_in">int</span> numRows</span>)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">convert</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> numRows)</span> </span>&#123;        <span class="hljs-keyword">if</span>(numRows == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> s;        &#125;        vector&lt;queue&lt;<span class="hljs-type">char</span>&gt; &gt; <span class="hljs-built_in">vt</span>(numRows);        <span class="hljs-type">int</span> nowindex = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> reverse = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;            vt[nowindex].<span class="hljs-built_in">push</span>(s[i]);            <span class="hljs-keyword">if</span>(nowindex == <span class="hljs-number">0</span> &amp;&amp; reverse == <span class="hljs-literal">true</span>)&#123;                reverse = <span class="hljs-literal">false</span>;                nowindex += <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nowindex == numRows<span class="hljs-number">-1</span> &amp;&amp; reverse == <span class="hljs-literal">false</span>)&#123;                reverse = <span class="hljs-literal">true</span>;                nowindex -= <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(reverse == <span class="hljs-literal">false</span>)&#123;                    nowindex += <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span>&#123;                    nowindex -= <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        string resultstring = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vt.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">while</span>(!vt[i].<span class="hljs-built_in">empty</span>())&#123;                resultstring += vt[i].<span class="hljs-built_in">front</span>();                vt[i].<span class="hljs-built_in">pop</span>();            &#125;        &#125;        <span class="hljs-keyword">return</span> resultstring;    &#125;&#125;;</code></pre></div><h2 id="8-字符串转换整数-atoi">8. 字符串转换整数 (atoi)</h2><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p><p>函数 <code>myAtoi(string s)</code> 的算法如下：</p><ol><li>读入字符串并丢弃无用的前导空格</li><li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li><li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li><li>将前面步骤读入的这些数字转换为整数（即，“123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 <code>0</code> 。必要时更改符号（从步骤 2 开始）。</li><li>如果整数数超过 32 位有符号整数范围 <code>[−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31 &lt;/sup&gt;− 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−2&lt;sup&gt;31&lt;/sup&gt;</code> 的整数应该被固定为 <code>−2&lt;sup&gt;31&lt;/sup&gt;</code> ，大于 <code>2&lt;sup&gt;31 &lt;/sup&gt;− 1</code> 的整数应该被固定为 <code>2&lt;sup&gt;31 &lt;/sup&gt;− 1</code> 。</li><li>返回整数作为最终结果。</li></ol><p><strong>注意：</strong></p><ul><li>本题中的空白字符只包括空格字符 <code>' '</code> 。</li><li>除前导空格或数字后的其余字符串外，<strong>请勿忽略</strong> 任何其他字符。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-type">bool</span> havenumsign = <span class="hljs-literal">false</span>;        <span class="hljs-type">bool</span> negativesign = <span class="hljs-literal">false</span>;        <span class="hljs-type">bool</span> fakebigsign = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; havenumsign == <span class="hljs-literal">false</span>)&#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;-&#x27;</span> &amp;&amp; havenumsign == <span class="hljs-literal">false</span>)&#123;                negativesign = <span class="hljs-literal">true</span>;                havenumsign = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;+&#x27;</span> &amp;&amp; havenumsign == <span class="hljs-literal">false</span>)&#123;                havenumsign = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;                havenumsign = <span class="hljs-literal">true</span>;                <span class="hljs-keyword">if</span>(res &gt; (INT_MAX - s[i] + <span class="hljs-string">&#x27;0&#x27;</span>) / <span class="hljs-number">10</span>)&#123;                    res = INT_MAX;                    fakebigsign = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">break</span>;                &#125;                res = res * <span class="hljs-number">10</span> - <span class="hljs-string">&#x27;0&#x27;</span> + s[i];                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span>(havenumsign == <span class="hljs-literal">true</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span> (negativesign)&#123;            <span class="hljs-keyword">if</span>(res == INT_MAX &amp;&amp; fakebigsign)&#123;                <span class="hljs-keyword">return</span> INT_MIN;            &#125;            <span class="hljs-keyword">return</span> -res;        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre></div><h2 id="12-整数转罗马数字">12. 整数转罗马数字</h2><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><div class="code-wrapper"><pre><code class="hljs mathematica">字符          数值<span class="hljs-built_in">I</span>             <span class="hljs-number">1</span><span class="hljs-variable">V</span>             <span class="hljs-number">5</span><span class="hljs-variable">X</span>             <span class="hljs-number">10</span><span class="hljs-variable">L</span>             <span class="hljs-number">50</span><span class="hljs-built_in">C</span>             <span class="hljs-number">100</span><span class="hljs-built_in">D</span>             <span class="hljs-number">500</span><span class="hljs-variable">M</span>             <span class="hljs-number">1000</span></code></pre></div><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给你一个整数，将其转为罗马数字。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">intToRoman</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><span class="hljs-function">    </span>&#123;        pair&lt;<span class="hljs-type">int</span>, string&gt; valueSymbols[] = &#123;            &#123;<span class="hljs-number">1000</span>, <span class="hljs-string">&quot;M&quot;</span>&#125;,            &#123;<span class="hljs-number">900</span>, <span class="hljs-string">&quot;CM&quot;</span>&#125;,            &#123;<span class="hljs-number">500</span>, <span class="hljs-string">&quot;D&quot;</span>&#125;,            &#123;<span class="hljs-number">400</span>, <span class="hljs-string">&quot;CD&quot;</span>&#125;,            &#123;<span class="hljs-number">100</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;,            &#123;<span class="hljs-number">90</span>, <span class="hljs-string">&quot;XC&quot;</span>&#125;,            &#123;<span class="hljs-number">50</span>, <span class="hljs-string">&quot;L&quot;</span>&#125;,            &#123;<span class="hljs-number">40</span>, <span class="hljs-string">&quot;XL&quot;</span>&#125;,            &#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;X&quot;</span>&#125;,            &#123;<span class="hljs-number">9</span>, <span class="hljs-string">&quot;IX&quot;</span>&#125;,            &#123;<span class="hljs-number">5</span>, <span class="hljs-string">&quot;V&quot;</span>&#125;,            &#123;<span class="hljs-number">4</span>, <span class="hljs-string">&quot;IV&quot;</span>&#125;,            &#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;I&quot;</span>&#125;,        &#125;;        string roman;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[value, symbol] : valueSymbols)        &#123;            <span class="hljs-keyword">while</span> (num &gt;= value)            &#123;                num -= value;                roman += symbol;            &#125;            <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)            &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> roman;    &#125;&#125;;</code></pre></div><h1>图论</h1><h2 id="207-课程表">207. 课程表</h2><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;]</code> ，表示如果要学习课程 <code>a&lt;sub&gt;i&lt;/sub&gt;</code> 则 <strong>必须</strong> 先学习课程  <code>b&lt;sub&gt;i&lt;/sub&gt;</code> ~ ~ 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">totalnum</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">matrix</span>(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prerequisites.<span class="hljs-built_in">size</span>();i++)&#123;            totalnum[prerequisites[i][<span class="hljs-number">0</span>]] += <span class="hljs-number">1</span>;            matrix[prerequisites[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(prerequisites[i][<span class="hljs-number">0</span>]);        &#125;        <span class="hljs-type">bool</span> judge = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">while</span>(judge)&#123;            judge = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++)&#123;                <span class="hljs-keyword">if</span>(totalnum[i] == <span class="hljs-number">0</span>)&#123;                    judge = <span class="hljs-literal">true</span>;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;matrix[i].<span class="hljs-built_in">size</span>();j++)&#123;                        totalnum[matrix[i][j]] -= <span class="hljs-number">1</span>;                    &#125;                    totalnum[i] = <span class="hljs-number">-1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++)&#123;            <span class="hljs-keyword">if</span>(totalnum[i] != <span class="hljs-number">-1</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre></div><h1>栈与队列</h1><h2 id="295-数据流的中位数">295. 数据流的中位数</h2><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li><li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10&lt;sup&gt;-5&lt;/sup&gt;</code> 以内的答案将被接受。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<span class="hljs-keyword">public</span>:    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; queMin;    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; queMax;    <span class="hljs-built_in">MedianFinder</span>() &#123;      &#125;      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;        <span class="hljs-keyword">if</span> (queMin.<span class="hljs-built_in">empty</span>() || num &lt;= queMin.<span class="hljs-built_in">top</span>()) &#123;            queMin.<span class="hljs-built_in">push</span>(num);            <span class="hljs-keyword">if</span> (queMax.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> &lt; queMin.<span class="hljs-built_in">size</span>()) &#123;                queMax.<span class="hljs-built_in">push</span>(queMin.<span class="hljs-built_in">top</span>());                queMin.<span class="hljs-built_in">pop</span>();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            queMax.<span class="hljs-built_in">push</span>(num);            <span class="hljs-keyword">if</span> (queMax.<span class="hljs-built_in">size</span>() &gt; queMin.<span class="hljs-built_in">size</span>()) &#123;                queMin.<span class="hljs-built_in">push</span>(queMax.<span class="hljs-built_in">top</span>());                queMax.<span class="hljs-built_in">pop</span>();            &#125;        &#125;    &#125;      <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (queMin.<span class="hljs-built_in">size</span>() &gt; queMax.<span class="hljs-built_in">size</span>()) &#123;            <span class="hljs-keyword">return</span> queMin.<span class="hljs-built_in">top</span>();        &#125;        <span class="hljs-keyword">return</span> (queMin.<span class="hljs-built_in">top</span>() + queMax.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;     &#125;&#125;;</code></pre></div><h1>双指针法</h1><h2 id="3-无重复字符的最长子串">3. 无重复字符的最长子串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;        unordered_set&lt;<span class="hljs-type">char</span>&gt; st;        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span>; right&lt;s.<span class="hljs-built_in">size</span>(); right++)&#123;            <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">find</span>(s[right]) != st.<span class="hljs-built_in">end</span>())&#123;                st.<span class="hljs-built_in">erase</span>(s[left]);                left++;            &#125;            st.<span class="hljs-built_in">insert</span>(s[right]);            result = <span class="hljs-built_in">max</span>(result, right - left + <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><h2 id="4-寻找两个正序数组的中位数">4. 寻找两个正序数组的中位数</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;        <span class="hljs-type">int</span> m = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();        <span class="hljs-type">bool</span> next;        <span class="hljs-type">int</span> sign = (m + n) / <span class="hljs-number">2</span>;         <span class="hljs-keyword">if</span>((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;            next = <span class="hljs-literal">false</span>;        &#125; <span class="hljs-keyword">else</span>&#123;            sign -= <span class="hljs-number">1</span>;            next = <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-type">int</span> res1 = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> res2 = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> globalindex = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> nums1index = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> nums2index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(globalindex &lt;= sign)&#123;            <span class="hljs-keyword">if</span>(nums1index &lt; m &amp;&amp; nums2index &lt; n)&#123;                <span class="hljs-keyword">if</span>(nums1[nums1index] &lt; nums2[nums2index])&#123;                    res1 = nums1[nums1index];                    nums1index += <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span>&#123;                    res1 = nums2[nums2index];                    nums2index += <span class="hljs-number">1</span>;                &#125;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1index &lt; m)&#123;                res1 = nums1[nums1index];                nums1index += <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                res1 = nums2[nums2index];                nums2index += <span class="hljs-number">1</span>;            &#125;            globalindex += <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(next == <span class="hljs-literal">false</span>)&#123;            <span class="hljs-keyword">return</span> res1;        &#125;        <span class="hljs-keyword">if</span>(nums1index &lt; m &amp;&amp; nums2index &lt; n)&#123;            <span class="hljs-keyword">if</span>(nums1[nums1index] &lt; nums2[nums2index])&#123;                res2 = nums1[nums1index];            &#125; <span class="hljs-keyword">else</span>&#123;                res2 = nums2[nums2index];            &#125;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1index &lt; m)&#123;            res2 = nums1[nums1index];        &#125; <span class="hljs-keyword">else</span> &#123;            res2 = nums2[nums2index];        &#125;        <span class="hljs-keyword">return</span> ((<span class="hljs-type">double</span>)res1 + (<span class="hljs-type">double</span>)res2) / <span class="hljs-number">2.0</span>;    &#125;&#125;;</code></pre></div><h2 id="5-最长回文子串">5. 最长回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;            <span class="hljs-type">int</span> left = i;            <span class="hljs-type">int</span> right = i;            <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>())&#123;                <span class="hljs-keyword">if</span>(s[left] == s[right])&#123;                    <span class="hljs-keyword">if</span>(result[<span class="hljs-number">1</span>] - result[<span class="hljs-number">0</span>] &lt; right - left)&#123;                        result[<span class="hljs-number">1</span>] = right;                        result[<span class="hljs-number">0</span>] = left;                    &#125;                    right += <span class="hljs-number">1</span>;                    left -= <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            left = i;            right = i<span class="hljs-number">+1</span>;            <span class="hljs-keyword">while</span>(left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>())&#123;                <span class="hljs-keyword">if</span>(s[left] == s[right])&#123;                    <span class="hljs-keyword">if</span>(result[<span class="hljs-number">1</span>] - result[<span class="hljs-number">0</span>] &lt; right - left)&#123;                        result[<span class="hljs-number">1</span>] = right;                        result[<span class="hljs-number">0</span>] = left;                    &#125;                    right += <span class="hljs-number">1</span>;                    left -= <span class="hljs-number">1</span>;                &#125; <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">substr</span>(result[<span class="hljs-number">0</span>], result[<span class="hljs-number">1</span>]-result[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);    &#125;&#125;;</code></pre></div><h2 id="9-回文数">9. 回文数</h2><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li></ul><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;        string s = <span class="hljs-built_in">to_string</span>(x);        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-keyword">if</span>(s[left] != s[right])&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;            left += <span class="hljs-number">1</span>;            right -= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre></div><h2 id="11-盛最多水的容器">11. 盛最多水的容器</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p><p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><p><strong>说明：</strong> 你不能倾斜容器。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;        <span class="hljs-type">int</span> maxarea = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt; right) &#123;            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;                maxarea = <span class="hljs-built_in">max</span>(maxarea, (right - left) * height[left]);                left += <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span>&#123;                maxarea = <span class="hljs-built_in">max</span>(maxarea, (right - left) * height[right]);                right -= <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> maxarea;    &#125;&#125;;</code></pre></div><h2 id="88-合并两个有序数组">88. 合并两个有序数组</h2><p>给你两个按 <strong>非递减顺序</strong> 排列的整数数组 <code>nums1</code> 和 <code>nums2</code>，另有两个整数 <code>m</code> 和 <code>n</code> ，分别表示 <code>nums1</code> 和 <code>nums2</code> 中的元素数目。</p><p>请你 <strong>合并</strong> <code>nums2</code> 到 <code>nums1</code> 中，使合并后的数组同样按 <strong>非递减顺序</strong> 排列。</p><p><strong>注意：</strong> 最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code> 的初始长度为 <code>m + n</code>，其中前 <code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code> ，应忽略。<code>nums2</code> 的长度为 <code>n</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-type">int</span> index = m + n - <span class="hljs-number">1</span>;        m -= <span class="hljs-number">1</span>;        n -= <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(index &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(m &lt; <span class="hljs-number">0</span>)&#123;                nums1[index] = nums2[n];                n--;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)&#123;                nums1[index] = nums1[m];                m--;            &#125; <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(nums1[m] &gt; nums2[n])&#123;                    nums1[index] = nums1[m];                    m--;                &#125; <span class="hljs-keyword">else</span>&#123;                    nums1[index] = nums2[n];                    n--;                &#125;            &#125;            index--;        &#125;        <span class="hljs-keyword">return</span>;    &#125;&#125;;</code></pre></div><h2 id="23-合并-K-个升序链表">23. 合并 K 个升序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;        <span class="hljs-keyword">if</span>(start &gt; end)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        &#125;        <span class="hljs-keyword">if</span>(start == end)&#123;            <span class="hljs-keyword">return</span> lists[start];        &#125;        <span class="hljs-type">int</span> mid = (end - start) / <span class="hljs-number">2</span> + start;        ListNode* first = <span class="hljs-built_in">merge</span>(lists, start, mid);        ListNode* second = <span class="hljs-built_in">merge</span>(lists, mid + <span class="hljs-number">1</span>, end);        <span class="hljs-keyword">if</span>(first == <span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> second;        &#125;        <span class="hljs-keyword">if</span>(second == <span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">return</span> first;        &#125;        ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);        ListNode* p = head;        <span class="hljs-keyword">while</span>(first != <span class="hljs-literal">NULL</span> &amp;&amp; second != <span class="hljs-literal">NULL</span>)&#123;            <span class="hljs-keyword">if</span>(first-&gt;val &lt; second-&gt;val)&#123;                p-&gt;next = first;                first = first-&gt;next;            &#125; <span class="hljs-keyword">else</span>&#123;                p-&gt;next = second;                second = second-&gt;next;            &#125;            p = p-&gt;next;        &#125;        <span class="hljs-keyword">if</span>(first != <span class="hljs-literal">NULL</span>)&#123;            p-&gt;next = first;        &#125; <span class="hljs-keyword">else</span>&#123;            p-&gt;next = second;        &#125;        <span class="hljs-keyword">return</span> head-&gt;next;    &#125;    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-20231121</title>
    <link href="/2023/11/21/diary/diary20231121/"/>
    <url>/2023/11/21/diary/diary20231121/</url>
    
    <content type="html"><![CDATA[<p>2023年11月21日，周二</p><span id="more"></span><p>又感冒了（or 发烧？）没什么区别吧，反正现在感冒必发烧。</p><p>我还记得上初中的时候，有一次去辽工大打篮球，碰见了有一段时间没有见面的小学同学。他当时问了我一句话：“你还像小时候那样总生病吗？“当时我很奇怪，因为在我的印象里面小学时候生病不算很多。这个小学同学我至今也没有再见过了，也没有联系方式，但是这一次见面我始终都会记得，可能就因为他问了我这一句话吧。</p><p>初中我已经不太记得了，但是高中确实一直在生病。几乎每一个月我都要感冒或者发烧一次。尤其是刚刚保送的一个月中，我还记得应该是周四的物理晚自习（当时物理老师给我的印象很恐怖），正好我也在生病，我就把卷子都扔给了我同桌，美美的回去休息了一个晚上，第二天就基本好的差不多了。从那之后我渐渐意识到，生病也并不是纯客观原因，其实自己的情绪、压力等主观因素才是生病的必要条件。</p><p>上了大学之后我的感冒的次数就少很多了，但是每次有一些让我非常伤心难过的事情的时候，总会发一次烧。发烧逐渐成为了我宣泄的一个出口。心情难过了，无处抱怨，用较高的体温促使自己休息一下，帮助自己放松心情缓解压力。</p><p>前一段刚刚发烧了一次，在床上躺了一天的同时出去吃了一些想吃的，完全没有看电脑。然而短暂的放松过后，自己的任务也并没有随之减轻，还是要一点一点继续推进。虽然发烧可以帮助我休息，但是实际上并没有对我的目标等起到任何的作用，短暂的麻痹过后还是要继续前行。可能我就是这样的人吧，目标很现实，丝毫不敢放松，完成一个目标后开心的同时又向着下一个目标推进，因此我现在过的并不快乐。</p><p>如果有一天，我能真正放下一切好好休息一下，才算与自己达成了和解，内心可能才能真正快乐一些？</p><p>写的稍微有点丧，心情不太好。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-20231119</title>
    <link href="/2023/11/19/diary/diary20231119/"/>
    <url>/2023/11/19/diary/diary20231119/</url>
    
    <content type="html"><![CDATA[<p>2023年11月19日，周日</p><span id="more"></span><p>今天看了一些自己博客的文章，发现对外公开的居然全都是刷题或者学习的内容，对于外人来说是不是太枯燥了一些hh。</p><p>于是挑了几篇过了很长时间的，或者已经没有隐藏的必要的文章，放出来也可以让其他人对我有更多的了解。</p><p>当然没放出来的文章还有很多，没办法很多的内容利益相关，或者写的时候直呼其名，要是公开感觉对其他人不太好，后续我会慢慢调整一下。</p><p>这些文章基本都在<a href="https://zhangzhao219.github.io/categories/">Life</a>的标签下。</p><p>文笔不好，请见谅。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stance Detection</title>
    <link href="/2023/10/07/Stance-Detection/"/>
    <url>/2023/10/07/Stance-Detection/</url>
    
    <content type="html"><![CDATA[<p>立场检测相关内容总结整理</p><span id="more"></span><h1>数据集</h1><h2 id="SemEval-2016"><a href="https://alt.qcri.org/semeval2016/task6/index.php?id=data-and-tools">SemEval 2016</a></h2><p>论文：Stance and Sentiment in Tweets</p><p>数据集可视化：<a href="http://www.saifmohammad.com/WebPages/StanceDataset.htm">http://www.saifmohammad.com/WebPages/StanceDataset.htm</a></p><h2 id="VAST"><a href="https://github.com/emilyallaway/zero-shot-stance/tree/master/data">VAST</a></h2><p>Zero-shot数据集</p><p>New data released in this submission. Short column descriptions</p><ul><li>author: username of the comment author</li><li>post: original comment, unprocessed</li><li>ori_topic: heuristically extracted topic</li><li>ori_id: id generated to link post and heuristically extracted topics</li><li>new_topic: updated topic from crowdsourced annotations</li><li>label: stance label, 0=con, 1=pro, 2=neutral</li><li>type_idx: type number, 1=HeurTopic, 2=CorrTopic, 3=ListTopic, 4=Synthetic neutral</li><li>new_id: unique id for every comment-topic-label pair</li><li>arc_id: id of the original article on NYT</li><li>text: sentence and word tokenized and lowercased text, with punctuation and stopwords removed</li><li>text_s: string version of text</li><li>topic: tokenized and lowercased version topic, with punctuation and stopwords removed</li><li>topic_str: string version of topic</li><li>seen?: indicator for zero-shot or few-shot example, 0=zero-shot, 1=few-shot</li><li>contains_topic?: indicator for whether topic is contained in the text, 0=no, 1=yes</li><li>change_lst: list of swapped words (unique to vast_test-sentswap.csv)</li><li>change_type: type of sentiment swapping</li><li>LexSim: a list of lexically similar training topics (if a zero-shot topic)</li><li>Qte: whether the example contains quotes (1=yes, 0=no)</li><li>Sarc: whether the example contains sarcasm (1=yes, 0=no)</li><li>Imp: whether the text contains the topic and the label is non-neutral (1=yes, 0=no)</li><li>mlS: whether there are other examples with the same document and different, non-neutral, stance labels (1=yes, 0=no)</li><li>mlT: whether there are other examples with the same document and different topics (1=yes, 0=no)</li></ul><h2 id="WT-WT"><a href="https://github.com/cambridge-wtwt/acl2020-wtwt-tweets/tree/master">WT-WT</a></h2><p>相关链接：<a href="https://github.com/BinLiang-NLP/TPDG">https://github.com/BinLiang-NLP/TPDG</a></p><p>51284条英文Tweet</p><p>关于公司的兼并收购的信息，第一个金融领域的数据集</p><p>四个标签：</p><ul><li>Support：两个公司会合并成一个公司</li><li>Refute：对两个公司要合并成一个的消息表示怀疑</li><li>Comment：对合并消息的评论，中立态度</li><li>Unrelated：完全不相关</li></ul><h2 id="P-stance"><a href="https://github.com/chuchun8/pstance">P-stance</a></h2><p>21574条英文Tweet</p><p>对三个target（Donald Trump（7953），Joe Biden（7296），Bernie Sanders（6325））的立场</p><p>按照8：1：1进行划分</p><h2 id="UKP">UKP</h2><h1>论文</h1><h2 id="2017">2017</h2><h3 id="A-Dataset-for-Multi-Target-Stance-Detection">A Dataset for Multi-Target Stance Detection</h3><p>时间：2017年4月</p><p>等级：EACL 2017</p><h2 id="2020">2020</h2><h3 id="Will-They-Won’t-They-A-Very-Large-Dataset-for-Stance-Detection-on-Twitter">Will-They-Won’t-They: A Very Large Dataset for Stance Detection on Twitter</h3><p>时间：2020年5月1日</p><p>等级：ACL 2020</p><p><a href="https://imgse.com/i/pPvtXj0"><img src="https://z1.ax1x.com/2023/10/08/pPvtXj0.md.png" alt="pPvtXj0.md.png"></a></p><p>思想：</p><ul><li>第一个金融领域的立场数据集，描述公司的兼并收购的信息</li><li>首先爬取关于公司、兼并等内容的Tweet</li><li>定义四个标签（support, refute, comment, unrelated），其中一个Tweet的不同的target可能会有不同的标签</li><li>找人进行标注，评估了标注的质量，并与之前的数据集进行了对比</li><li>对目前的一些模型进行了这个数据集上面的测试</li></ul><h3 id="Zero-Shot-Stance-Detection-A-Dataset-and-Model-using-Generalized-Topic-Representations">Zero-Shot Stance Detection: A Dataset and Model using Generalized Topic Representations</h3><p>时间：2020年10月7日</p><p>等级：EMNLP 2020（CCF B）</p><p>思想：提出了VAST数据集</p><ul><li>纽约时报辩论区的评论内容</li><li>选择了3365条评论，包括304个主题，找人工进行主题标注</li><li>中立的立场很少，从支持与反对两种类别中选一些可能性较低的加入到中立标签中</li></ul><p>同时提出了一个方法解决Zero-shot问题</p><p><a href="https://imgse.com/i/pPz7FzQ"><img src="https://z1.ax1x.com/2023/10/11/pPz7FzQ.md.png" alt="pPz7FzQ.md.png"></a></p><ul><li>文档和主题联合输入</li><li>对主题进行聚类，获取注意力</li></ul><p>数据集：VAST</p><h2 id="2021">2021</h2><h3 id="Target-adaptive-Graph-for-Cross-target-Stance-Detection">Target-adaptive Graph for Cross-target Stance Detection</h3><p>时间：2021年4月</p><p>等级：WWW 2021（CCF A）</p><h3 id="tWT–WT-A-Dataset-to-Assert-the-Role-of-Target-Entities-for-Detecting-Stance-of-Tweets">tWT–WT: A Dataset to Assert the Role of Target Entities for Detecting Stance of Tweets</h3><p>时间：2021年6月</p><p>等级：NAACL 2021（CCF B）</p><h3 id="Adversarial-Learning-for-Zero-Shot-Stance-Detection-on-Social-Media">Adversarial Learning for Zero-Shot Stance Detection on Social Media</h3><p>时间：2021年6月</p><p>等级：NAACL 2021（CCF B）</p><p>思想：使用对抗学习增强zero-shot的立场检测的效果</p><p><a href="https://imgse.com/i/piUUZ6J"><img src="https://z1.ax1x.com/2023/11/20/piUUZ6J.md.png" alt="piUUZ6J.md.png"></a></p><ul><li>使用BiCond编码text</li><li>将编码的向量进行正则化</li><li>对立场进行分类</li><li>对topic进行鉴别</li><li>增加对抗训练的技巧</li></ul><p>数据集：Sem-16</p><h3 id="Stance-Detection-in-COVID-19-Tweets">Stance Detection in COVID-19 Tweets</h3><p>时间：2021年8月</p><p>等级：ACL 2021（CCF A）</p><p>思想：</p><ul><li>构建了一个COVID-19数据集，包括四个target，例如关闭学校、居家、戴口罩等</li><li>用无标签的数据做预训练</li><li>对不同的监督学习方法进行了比较</li></ul><p>数据集：自行构建的COVID-19数据集</p><h3 id="Enhancing-Zero-shot-and-Few-shot-Stance-Detection-with-Commonsense-Knowledge-Graph">Enhancing Zero-shot and Few-shot Stance Detection with Commonsense Knowledge Graph</h3><p>时间：2021年8月</p><p>等级：ACL 2021 Findings （CCF A）</p><p>思想：topic在文本中是可以通过图推断出来的</p><p><a href="https://imgse.com/i/piU6EUH"><img src="https://z1.ax1x.com/2023/11/20/piU6EUH.png" alt="piU6EUH.png"></a></p><ul><li>用Bert对文本和topic进行编码</li><li>使用ConceptNet获取文本之间的关系</li><li>进行立场分类检测</li></ul><p>数据集：</p><h3 id="MeLT-Message-Level-Transformer-with-Masked-Document-Representations-as-Pre-Training-for-Stance-Detection">MeLT: Message-Level Transformer with Masked Document Representations as Pre-Training for Stance Detection</h3><p>时间：2021年09月16日</p><p>等级：EMNLP 2021 Findings</p><p><a href="https://imgse.com/i/pPj2v6S"><img src="https://z1.ax1x.com/2023/10/07/pPj2v6S.png" alt="pPj2v6S.png"></a></p><p>思想：</p><ul><li>在Twitter数据集上做预训练，将word级别的mask更改为message级别的mask，message的表示是word的表示取平均，按照时间顺序进行排列，对某个人的一些message进行随机mask（Bert的方式），让模型预测该位置的message。</li><li>后续进行分类任务的微调</li></ul><p>数据集：SemEval 2016</p><h3 id="P-Stance-A-Large-Dataset-for-Stance-Detection-in-Political-Domain">P-Stance: A Large Dataset for Stance Detection in Political Domain</h3><p>时间：2021年08月</p><p>等级：ACL 2021 Findings</p><p>思想：</p><ul><li>现有数据集局限<ul><li>明确提及的目标和可能暴露立场的表层词汇线索在数据中显式存在</li><li>社交媒体的数据太短了，模型不需要理解就可以找出立场</li></ul></li><li>通过#的标签收集三个总统候选人的Tweet，收集了2.8 million条数据<ul><li>选取10-128长度的Tweet</li><li>移除重复数据</li><li>只保留英文数据</li><li>减少到2 million，为PSTANCE-EXT数据</li><li>每个人采样10000，共30000条数据构成最终的数据集</li><li>人工标注，并去除I don’t know类别的数据</li></ul></li><li>构建一个#词典，删除文本后面的#，同时更改内部的#为中性的标记，防止暴露立场信息</li><li>微调BERTweet预测CLS进行分类任务</li><li>可以进行跨目标的立场检测、跨主题的立场检测（在2016年的数据上训练，预测2020年的立场）</li><li>采用半监督方法（UST）提升跨主题的立场检测性能（没详细介绍）</li></ul><p>数据集：SemEval-2016、Multi-Target stance datasets</p><h2 id="2022">2022</h2><h3 id="Zero-Shot-Stance-Detection-via-Contrastive-Learning">Zero-Shot Stance Detection via Contrastive Learning</h3><p>时间：2022年4月</p><p>等级：WWW 2022（CCF A）</p><p><a href="https://imgse.com/i/pPxUfET"><img src="https://z1.ax1x.com/2023/10/09/pPxUfET.md.png" alt="pPxUfET.md.png"></a></p><p>思想：</p><ul><li>将数据分为两种类型：<ul><li>target-invariant：即使目标或目标相关词被屏蔽，仍然可以识别上下文中表达的立场。</li><li>target-specific：如果目标和与目标相关的词语被屏蔽，则很难理解立场信息。</li></ul></li><li>训练一个普通的立场检测模型，训练到过拟合</li><li>用主题模型找到与target最相关的词语，然后将其MASK掉，用上面的模型进行预测。如果预测对了就是target-invariant，错了就是target-specific，加一个标签给这个数据</li><li>重新训练主模型<ul><li>target-invariant与target-specific之间作对比学习</li><li>不同的label之间做对比学习</li></ul></li><li>数据集： VAST、SEM-16、WT-WT</li></ul><h3 id="Infusing-Knowledge-from-Wikipedia-to-Enhance-Stance-Detection">Infusing Knowledge from Wikipedia to Enhance Stance Detection</h3><p>时间：2022年5月</p><p>等级：ACL 2022 Workshop（WASSA）</p><p>思想：从Wikipedia上预先查询到target的相关知识，融合到模型中进行立场检测</p><p>数据集：P-Stance、COVID-19-Stance、VAST</p><h3 id="Few-Shot-Stance-Detection-via-Target-Aware-Prompt-Distillation">Few-Shot Stance Detection via Target-Aware Prompt Distillation</h3><p>时间：2022年6月27日</p><p>等级：SIGIR 2022（CCF A）</p><p><a href="https://imgse.com/i/pPvJ5xP"><img src="https://z1.ax1x.com/2023/10/08/pPvJ5xP.md.png" alt="pPvJ5xP.md.png"></a></p><p>思想：</p><ul><li>动机：target通常是随时间变化的，对每一个target都获取充足的数据进行训练是很不现实的，立场检测方法需要获得few-shot的能力</li></ul><ol><li>多目标训练：训练一个模型，可以准确预测不同的target的label</li><li>设计三个Prompt，输入到Bert等模型的预训练任务中，让其预测label</li><li>预测的时候不映射到具体的label的词语，而是提前通过预训练模型获取label的表示向量，最终将target的向量与label的向量相乘计算损失</li><li>teacher-student model融合三个prompt的结果，迭代进行预测，对比真实标签与预测标签之间的差距。</li></ol><p>数据集：SemEval-2016、UKP</p><h3 id="JointCL-A-Joint-Contrastive-Learning-Framework-for-Zero-Shot-Stance-Detection">JointCL: A Joint Contrastive Learning Framework for Zero-Shot Stance Detection</h3><p>时间：2022年5月</p><p>等级：ACL 2022（CCF A）</p><p>思想：</p><p><a href="https://imgse.com/i/pPzo3hF"><img src="https://z1.ax1x.com/2023/10/11/pPzo3hF.md.png" alt="pPzo3hF.md.png"></a></p><p>图相关</p><ul><li>一个没有出现过的target的信息是可以通过其他已知的target表示出来的（从target-aware的视角来看）</li><li>提出了由立场对比学习与原型图网络对比学习。通过构建原形图，可以在未知target和已知target之间建立关系，从而用已学习到的信息表示未知target，从而提升对未知target的立场学习能力。</li></ul><p>数据集：VAST、SEM-16、WT-WT</p><h3 id="A-Survey-on-Stance-Detection-for-Mis-and-Disinformation-Identification">A Survey on Stance Detection for Mis- and Disinformation Identification</h3><p>时间：2022年7月</p><p>等级：NAACL 2022 Findings（CCF B）</p><p>思想：虚假新闻的立场检测，一篇综述性质的文章</p><p>数据集：没有做实验，只是汇总之前人的数据、方法与结果</p><h3 id="Enhancing-Zero-Shot-Stance-Detection-via-Targeted-Background-Knowledge">Enhancing Zero-Shot Stance Detection via Targeted Background Knowledge</h3><p>时间：2022年7月</p><p>等级：SIGIR 2022（CCF A）</p><p><a href="https://imgse.com/i/pPxUhUU"><img src="https://z1.ax1x.com/2023/10/09/pPxUhUU.png" alt="pPxUhUU.png"></a></p><p>思想：</p><ul><li>用相关信息进行增强<ul><li>根据target在网络上爬取相关信息，找最相关的top k个主题</li><li>用NLTK的工具提取关键词，找到爬取的信息中与关键词最相关的部分，作为额外知识</li></ul></li><li>其他的模型训练非常普通</li></ul><p>数据集：VAST、SEM-16、WT-WT</p><h3 id="Exploiting-Sentiment-and-Common-Sense-for-Zero-shot-Stance-Detection">Exploiting Sentiment and Common Sense for Zero-shot Stance Detection</h3><p>时间：2022年10月</p><p>等级：COLING 2022</p><p>思想：</p><p><a href="https://imgse.com/i/pPzolkT"><img src="https://z1.ax1x.com/2023/10/11/pPzolkT.md.png" alt="pPzolkT.md.png"></a></p><p>图相关</p><ol><li>使用图自动编码的模块将target的普遍信息融合进立场检测的模型</li><li>立场检测是被情感词汇影响的，使用Bert单独提取文档中的情感的词汇。</li></ol><h3 id="Generative-Data-Augmentation-with-Contrastive-Learning-for-Zero-Shot-Stance-Detection">Generative Data Augmentation with Contrastive Learning for Zero-Shot Stance Detection</h3><p>时间：2022年12月</p><p>等级：EMNLP 2022（CCF B）</p><p>思想：在看见过的target的基础之上生成没有看见过的target的数据</p><p><a href="https://imgse.com/i/piU6WM6"><img src="https://z1.ax1x.com/2023/11/20/piU6WM6.md.png" alt="piU6WM6.md.png"></a></p><ul><li>使用GAN网络进行对抗生成</li><li>添加对比学习的策略</li><li>在立场检测任务上进行微调</li></ul><p>数据集：VAST、Sem-16</p><h3 id="How-would-Stance-Detection-Techniques-Evolve-after-the-Launch-of-ChatGPT">How would Stance Detection Techniques Evolve after the Launch of ChatGPT?</h3><p>时间：2022年12月30日</p><p>等级：Arxiv</p><p>思想：</p><ul><li>加个Prompt的立场检测效果可以达到SOTA</li><li>多轮对话理论上可以增强背景知识等</li><li>没有和很多的SOTA进行比较，没啥说服力</li></ul><p>数据集：P-Stance</p><h2 id="2023">2023</h2><h3 id="Hashtag-Guided-Low-Resource-Tweet-Classification">Hashtag-Guided Low-Resource Tweet Classification</h3><p>时间：2023年2月20日</p><p>等级：WWW 2023（CCF A）</p><p>思想：</p><p><a href="https://imgse.com/i/piSBw1U"><img src="https://z1.ax1x.com/2023/10/12/piSBw1U.png" alt="piSBw1U.png"></a></p><ul><li>Hash Tag是很重要的</li><li>Tweet注意力模块：获取Tweet之间的相关性从而借鉴已有的标签</li><li>实体注意力模块：实体图获取Tweet中的实体</li><li>融合两个模块生成HashTag</li><li>通过原始的Tweet与HashTag一起输入到预训练模型中进行训练</li></ul><p>数据集：</p><h3 id="Few-shot-Learning-for-Cross-Target-Stance-Detection-by-Aggregating-Multimodal-Embeddings">Few-shot Learning for Cross-Target Stance Detection by Aggregating Multimodal Embeddings</h3><p>时间：2023年3月31日</p><p>等级：IEEE Transactions on Computational Social Systems（CCF C）</p><p>思想：</p><p><a href="https://imgse.com/i/pipi3YF"><img src="https://z1.ax1x.com/2023/10/13/pipi3YF.png" alt="pipi3YF.png"></a></p><ul><li>通过发Tweet的人之间的关系网络增强立场检测的效果</li><li>包括Follower、Like和Friend的信息</li></ul><p>数据集：P-Stance，额外找到了作者的关系信息</p><h3 id="Investigating-Chain-of-thought-with-ChatGPT-for-Stance-Detection-on-Social-Media">Investigating Chain-of-thought with ChatGPT for Stance Detection on Social Media</h3><p>时间：2023年4月6日</p><p>等级：Arxiv</p><p>思想：通过思维链的方式，给一个例子帮助ChatGPT进行分析，在多个数据集上达到了SOTA（假）效果</p><p><a href="https://imgse.com/i/pipF4D1"><img src="https://z1.ax1x.com/2023/10/13/pipF4D1.md.png" alt="pipF4D1.md.png"></a></p><p>数据集：SEM-16、VAST、P-Stance</p><h3 id="Claim-Extraction-and-Dynamic-Stance-Detection-in-COVID-19-Tweets">Claim Extraction and Dynamic Stance Detection in COVID-19 Tweets</h3><p>时间：2023年4月</p><p>等级：WWW 2023 Companion</p><p>思想：</p><ul><li>是否存在主张：作者是否在Tweet中提出了客观事实的主张？并进一步分析是否值得检查。<ul><li>微调Bert系列的模型来完成</li></ul></li><li>主张提取：识别Tweet中的哪些部分对应于事实主张，哪些部分对应于作者的评论<ul><li>使用IOB2方式进行标注，也是微调Bert进行，尝试了多种模型结构</li></ul></li><li>动态立场检测：识别作者对事实主张的立场。不过主张是上面识别出来的，因此变化很大，基本上之前都没有见过</li><li>数据集：自行收集的COVID-19的数据集</li></ul><h3 id="Can-ChatGPT-Reproduce-Human-Generated-Labels-A-Study-of-Social-Computing-Tasks">Can ChatGPT Reproduce Human-Generated Labels? A Study of Social Computing Tasks</h3><p>时间：2023年4月22日</p><p>等级：无</p><p>思想：</p><ul><li>将一些NLP任务的数据集通过ChatGPT进行标注，标注后评估效果</li><li>在立场检测的任务上面大概0.5-0.6左右</li></ul><h3 id="Examining-Temporalities-on-Stance-Detection-Towards-COVID-19-Vaccination">Examining Temporalities on Stance Detection Towards COVID-19 Vaccination</h3><p>时间：2023年5月7日</p><p>等级：ICWSM Data Challenge</p><p>思想：</p><ul><li>划分数据集是以时间顺序进行划分的，更接近于真实的情况</li><li>用单语言的Bert和多语言的Bert进行测试</li></ul><p>数据集：COVID数据集</p><h3 id="Robust-Integration-of-Contextual-Information-for-Cross-Target-Stance-Detection">Robust Integration of Contextual Information for Cross-Target Stance Detection</h3><p>（Contextual information integration for stance detection via cross-attention）</p><p>时间：2023年5月25日</p><p>等级：SEM2023（Co-located with ACL 2023）</p><p><a href="https://imgse.com/i/pPxUqDx"><img src="https://z1.ax1x.com/2023/10/09/pPxUqDx.png" alt="pPxUqDx.png"></a></p><p>思想：</p><ul><li>一个灵活的结合外部知识的方法<ul><li>一个Input+Target的Encoder和另外一个Context的Encoder，相当于Cross Attention</li><li>直接连接Context与Text，相当于Self Attention</li></ul></li><li>尝试了多种获取外部知识的方法。例如ConceptNet、CauseNet、预训练模型等</li><li>多个数据集测试效果</li></ul><h3 id="Guiding-Computational-Stance-Detection-with-Expanded-Stance-Triangle-Framework">Guiding Computational Stance Detection with Expanded Stance Triangle Framework</h3><p>时间：2023年5月31日</p><p>等级：ACL 2023</p><p>思想：</p><p><a href="https://imgse.com/i/pipkSVP"><img src="https://z1.ax1x.com/2023/10/13/pipkSVP.md.png" alt="pipkSVP.md.png"></a></p><ul><li>从语言学的角度考虑立场检测，使用很早就提出过的立场检测三角形</li><li>语言学看不太懂，效果也没有很SOTA</li><li>感觉就是方法比较新颖</li></ul><p>数据集：SEM-16、P-Stance、VAST、Tweet-COVID</p><h3 id="Knowledge-enhanced-Prompt-tuning-for-Stance-Detection">Knowledge-enhanced Prompt-tuning for Stance Detection</h3><p>时间：2023年6月</p><p>等级：2023 ACM Transactions on Asian and Low-Resource Language Information Processing（SCI 4区 CCF C）</p><p><a href="https://imgse.com/i/pPjWQbQ"><img src="https://z1.ax1x.com/2023/10/07/pPjWQbQ.md.png" alt="pPjWQbQ.md.png"></a></p><p>思想：</p><ul><li>将立场检测的任务通过Bert中MASK的方式转换成一个MLM任务</li><li>自动空间映射器：用SenticNet扩充词汇，自动选择相关的词语进行答案的映射（涉及一个树模型）</li><li>背景知识<ol><li>将target送入ConceptGraph中获得target的背景知识</li><li>使用neural topic model学习利用#符号的语义信息（涉及变分自编码器VAE）</li></ol></li><li>将上述的知识一起作为Prompt送入到预训练模型中进行微调，得到类别</li></ul><p>数据集：SEM16、VAST、P-stance、自己的数据集（ISD）</p><h3 id="Topic-Guided-Sampling-For-Data-Efficient-Multi-Domain-Stance-Detection">Topic-Guided Sampling For Data-Efficient Multi-Domain Stance Detection</h3><p>时间：2023年6月</p><p>等级：ACL 2023 Oral（CCF A）</p><p>思想：</p><p><a href="https://imgse.com/i/pPz522d"><img src="https://z1.ax1x.com/2023/10/11/pPz522d.png" alt="pPz522d.png"></a></p><ul><li>适用于跨主题（领域）的立场检测</li><li>方法<ul><li>通过主题模型进行训练数据的采样</li><li>将立场检测看成序列分类问题（d, t），加个Prompt</li><li>对比学习计算损失</li></ul></li></ul><p>数据集：16个benchmark数据集</p><h3 id="Voting-Booklet-Bias-Stance-Detection-in-Swiss-Federal-Communication">Voting Booklet Bias: Stance Detection in Swiss Federal Communication</h3><p>时间：2023年6月15日</p><p>等级：Arxiv</p><p>思想：</p><ul><li>分析的目标是面向选民的小册子中的Topic的立场是否为中立的立场</li><li>模型结构没有创新，评价了一些方法的性能</li><li>这个任务与普通的立场检测任务不同</li></ul><p>数据集：x-stance</p><h3 id="C-STANCE-A-Large-Dataset-for-Chinese-Zero-Shot-Stance-Detection">C-STANCE: A Large Dataset for Chinese Zero-Shot Stance Detection</h3><p>时间：2023年7月</p><p>等级：ACL 2023（CCF A）</p><p>思想：第一个中文的Zero-shot数据集</p><ul><li>微博的数据</li><li>人工进行标注</li><li>在多个立场检测的领域，使用多种方法进行评测</li></ul><p>数据集：C-STANCE</p><h3 id="A-New-Direction-in-Stance-Detection-Target-Stance-Extraction-in-the-Wild">A New Direction in Stance Detection: Target-Stance Extraction in the Wild</h3><p>时间：2023年7月</p><p>等级：ACL 2023（CCF A）</p><p>思想：</p><p><a href="https://imgse.com/i/piUJzO1"><img src="https://z1.ax1x.com/2023/11/20/piUJzO1.png" alt="piUJzO1.png"></a></p><ul><li>在立场检测中，target可能是隐含在text中的，大规模标注target不太现实</li><li>从文本中获取target-stance的对</li><li>Target Identification：<ul><li>训练一个分类器对target进行分类</li><li>用BART对target进行生成，然后map到已知的target上面</li></ul></li><li>Stance Detection<ul><li>建立一个分类器，并用target预测作为辅助任务</li></ul></li></ul><p>数据集：SemEval-2016、AM、COVID-19、P-Stance、自己构建的zero-shot数据集</p><h3 id="Distilling-Calibrated-Knowledge-for-Stance-Detection">Distilling Calibrated Knowledge for Stance Detection</h3><p>时间：2023年7月</p><p>等级：ACL 2023 Findings（CCF A）</p><p>思想：与知识蒸馏等相关</p><p>数据集：AM、COVID-19、P-Stance</p><h3 id="Target-Oriented-Relation-Alignment-for-Cross-Lingual-Stance-Detection">Target-Oriented Relation Alignment for Cross-Lingual Stance Detection</h3><p>时间：2023年7月</p><p>等级：ACL 2023 Findings（CCF A）</p><p>思想：将单语言的立场检测迁移到多语言上</p><p><a href="https://imgse.com/i/piUcLtJ"><img src="https://z1.ax1x.com/2023/11/20/piUcLtJ.md.png" alt="piUcLtJ.md.png"></a></p><ul><li>使用mBert获取文本的表示</li><li>构建target的关系图</li></ul><p>也是图相关的工作</p><p>数据集：X-Stance-all</p><h3 id="Exploration-of-Contrastive-Learning-Strategies-toward-more-Robust-Stance-Detection">Exploration of Contrastive Learning Strategies toward more Robust Stance Detection</h3><p>时间：2023年7月</p><p>等级：ACL 2023 Workshop（WASSA）</p><p>思想：使用对比学习增强立场检测系统的鲁棒性</p><ul><li>词表相似的句子也能通过对比学习获取语义从而发现他们之间的区别</li><li>选择anchor的策略可以有多种方法</li><li>使用拼写错误、同义重复和同义词替换三种策略来对数据集进行增强</li><li>不同的构造方法（数据集中的所有topic或者一部分的topic）进行不同的数据集下的训练，仅考虑二分类</li></ul><p>数据集：DebateForum (DF), SemEval2016 (SE) ,ARC, Perspectrum, FNC-1, KSD-Biden, KSD-Trump</p><h3 id="Zero-Shot-and-Few-Shot-Stance-Detection-on-Varied-Topics-via-Conditional-Generation">Zero-Shot and Few-Shot Stance Detection on Varied Topics via Conditional Generation</h3><p>时间：2023年7月</p><p>等级：ACL 2023（CCF A）</p><p>思想：</p><ul><li>用生成的思想做立场检测的问题，使用BART作为基础架构</li><li>使用联合训练，不仅生成标签，同时生成target</li><li>Unlikelihood Training 数据增强方法提升性能</li><li>结合Wiki的知识（其他论文的工作）</li></ul><p>数据集：VAST</p><h3 id="Ladder-of-Thought-Using-Knowledge-as-Steps-to-Elevate-Stance-Detection">Ladder-of-Thought: Using Knowledge as Steps to Elevate Stance Detection</h3><p>时间：2023年8月31日</p><p>等级：Arxiv</p><p><a href="https://imgse.com/i/pPvJTr8"><img src="https://z1.ax1x.com/2023/10/08/pPvJTr8.md.png" alt="pPvJTr8.md.png"></a></p><p>思想：</p><ul><li>CoT利用的是大模型内部的知识，但是立场检测相关的知识大模型可能没有见过</li><li>首先在Google上面搜到target的相关信息</li><li>用Text，Target和上面搜集到的信息微调一个预训练模型，让其产生更好的外部信息 Generation Finetuning</li><li>在上面的模型基础上，将text，target，和上面产生的外部信息连接在一起输入到模型中，以预测label为目标进行微调</li></ul><p>数据集：VAST</p><h3 id="Use-of-Large-Language-Models-for-Stance-Classification">Use of Large Language Models for Stance Classification</h3><p>时间：2023年9月24日</p><p>等级：ICWSM 2024 （CCF B）</p><p>思想：</p><ul><li>尝试了四种Prompt，用上下文包裹text和target，加一些few shot的例子，最后让其解释原因</li><li>尝试了几种开源的大模型</li><li>总结：大模型不太行，不如微调过的小模型，甚至不如zero-shot</li></ul><p>数据集：covid-lies、election2016、phemerumors、semeval2016、wtwt</p><h3 id="STANCE-C3-Domain-adaptive-Cross-target-Stance-Detection-via-Contrastive-Learning-and-Counterfactual-Generation">STANCE-C3: Domain-adaptive Cross-target Stance Detection via Contrastive Learning and Counterfactual Generation</h3><p>时间：2023年9月26日</p><p>等级：无</p><p>思想：</p><p><a href="https://imgse.com/i/pPzQSNn"><img src="https://z1.ax1x.com/2023/10/10/pPzQSNn.md.png" alt="pPzQSNn.md.png"></a></p><ul><li>跨领域的知识迁移</li><li>反事实数据增强</li></ul><h3 id="StanceReCL-Zero-Shot-Stance-Detection-Based-on-Relevance-and-Contrastive-Learning">StanceReCL: Zero-Shot Stance Detection Based on Relevance and Contrastive Learning</h3><p>时间：2023年10月</p><p>等级：投稿 EMNLP 2023 没中</p><p>思想：</p><p><a href="https://imgse.com/i/pPvYprT"><img src="https://z1.ax1x.com/2023/10/08/pPvYprT.md.png" alt="pPvYprT.md.png"></a></p><ul><li>提出了几个概念：stance indicator（support，against和neutral），stance pattern（由stance indicator和target组成）</li><li>两种表达：句子层面的表达（[CLS]对应的最后一层的表示）与词语层面的表达（单个token的最后一层的隐藏状态）</li><li>相关性的计算：<ul><li>上面的CLS与下面的CLS计算句子层面的相关性</li><li>上面的stance indicator与下面的sentence中的最相关的词语计算相关性</li></ul></li><li>句子层面计算对比学习的损失，然后与词语层面的损失加权重融合计算</li></ul><p>数据集：SEM-16、VAST、WT-WT</p><h3 id="Stance-Detection-with-Collaborative-Role-Infused-LLM-Based-Agents">Stance Detection with Collaborative Role-Infused LLM-Based Agents</h3><p>时间：2023年10月</p><p>等级：Arxiv</p><p>思想：多个LLM的Agent一起分析文本的各个方面，最后一正一反对立场进行推断，完全的Zero-shot</p><p><a href="https://imgse.com/i/piUkrSe"><img src="https://z1.ax1x.com/2023/11/19/piUkrSe.png" alt="piUkrSe.png"></a></p><p>数据集：Sem-16、WT-WT、VAST</p><h3 id="TATA-Stance-Detection-via-Topic-Agnostic-and-Topic-Aware-Embeddings">TATA: Stance Detection via Topic-Agnostic and Topic-Aware Embeddings</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023（CCF B）</p><p>思想：</p><p><a href="https://imgse.com/i/piUk7Os"><img src="https://z1.ax1x.com/2023/11/19/piUk7Os.png" alt="piUk7Os.png"></a></p><ul><li>topic-aware/TAW embeddings and generalized topic-agnostic/TAG stance embeddings</li><li>使用T5-Flan作为基座模型</li><li>收集了一个新的数据集，包括相关的passage对与相关的topic对，Topic-Aware/TAW Dataset<ul><li>使用T5对topic进行预测从而做预训练任务</li><li>使用MPNet LLM 识别其他数据集中相同的topic</li></ul></li><li>用TAW Dataset对VAST数据集进行扩充</li><li>Topic-Aware/TAW Embedding Layer：对整个的text-topic对进行训练</li><li>Topic-Agnostic/TAG Embedding Layer：topic看不到</li><li>后面加两个注意力层</li></ul><p>数据集：VAST</p><h3 id="Support-or-Refute-Analyzing-the-Stance-of-Evidence-to-Detect-Out-of-Context-Mis-and-Disinformation">Support or Refute: Analyzing the Stance of Evidence to Detect Out-of-Context Mis- and Disinformation</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023（CCF B）</p><p>思想：多模态的信息不匹配会造成误解</p><p><a href="https://imgse.com/i/pFuEtgA"><img src="https://s11.ax1x.com/2024/01/28/pFuEtgA.md.png" alt="pFuEtgA.md.png"></a></p><p>分别训练图片的立场检测分类器、文本的立场检测分类器，外加一些实体的知识进行识别</p><p>数据集：NewsCLIPpings</p><h3 id="Why-Should-This-Article-Be-Deleted-Transparent-Stance-Detection-in-Multilingual-Wikipedia-Editor-Discussions">Why Should This Article Be Deleted? Transparent Stance Detection in Multilingual Wikipedia Editor Discussions</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023（CCF B）</p><p>思想：在文本审核中加入立场检测从而进行自动判断其是否应该被删除</p><p><a href="https://imgse.com/i/pFlQIR1"><img src="https://s11.ax1x.com/2024/02/04/pFlQIR1.png" alt="pFlQIR1.png"></a></p><p>数据集：提出了多语言的Wiki的审核数据集</p><h3 id="ORCHID-A-Chinese-Debate-Corpus-for-Target-Independent-Stance-Detection-and-Argumentative-Dialogue-Summarization">ORCHID: A Chinese Debate Corpus for Target-Independent Stance Detection and Argumentative Dialogue Summarization</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023（CCF B）</p><p>思想：</p><ul><li>提出中文的辩论的立场检测数据集，且是与目标无关的</li><li>提出立场相关的摘要任务，可以提升摘要的效果</li></ul><p>数据集：</p><h3 id="Cross-Lingual-Cross-Target-Stance-Detection-with-Dual-Knowledge-Distillation-Framework">Cross-Lingual Cross-Target Stance Detection with Dual Knowledge Distillation Framework</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023（CCF B）</p><p>思想：</p><p><a href="https://imgse.com/i/pFlQoxx"><img src="https://s11.ax1x.com/2024/02/04/pFlQoxx.png" alt="pFlQoxx.png"></a></p><p><a href="https://imgse.com/i/pFlQ7M6"><img src="https://s11.ax1x.com/2024/02/04/pFlQ7M6.png" alt="pFlQ7M6.png"></a></p><ul><li>提出了新的跨语言cross target的立场检测任务</li><li>一个跨语言的老师，一个跨target的老师</li><li>大量的目标语言的无标签数据如何利用</li><li>使用mBert作为跨语言的teacher，翻译prompt和label构建文本对，使得两个文本对的预测结果更为接近</li><li>使用上面的跨语言的teacher作为跨target的encoder</li><li>使用GAT等将target分类，然后做与类别相关的对比学习</li><li>用无标签的目标语言数据+两个teacher的伪标签训练</li></ul><p>数据集：X-Stance、Semeval-2016、R-ita、Czech</p><h3 id="Identification-of-Multimodal-Stance-Towards-Frames-of-Communication">Identification of Multimodal Stance Towards Frames of Communication</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023（CCF B）</p><p>思想：文字和图片的多模态立场检测，主要的贡献是数据集</p><ul><li>在疫苗场景下</li><li>收集了关于疫苗或者新冠的Twitter的数据集，包括文字与图片数据</li><li>选择了一些多模态的模型作为baseline，通过OCR等方式提取图片中的文字</li><li>分一些图片与文字不吻合的情况</li></ul><p>数据集：MMVAX-STANCE</p><h3 id="From-Values-to-Opinions-Predicting-Human-Behaviors-and-Stances-Using-Value-Injected-Large-Language-Models">From Values to Opinions: Predicting Human Behaviors and Stances Using Value-Injected Large Language Models</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023（CCF B）</p><p>思想：与价值观相关，不算立场检测任务</p><ul><li>使用Argument Generation和Question Answering两种方法对LLM进行微调</li></ul><p>数据集：非立场检测</p><h3 id="Stance-Detection-on-Social-Media-with-Background-Knowledge">Stance Detection on Social Media with Background Knowledge</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023（CCF B）</p><p>思想：补充两种知识增强立场检测的效果</p><p><a href="https://imgse.com/i/pFlQbqO"><img src="https://s11.ax1x.com/2024/02/04/pFlQbqO.png" alt="pFlQbqO.png"></a></p><ul><li>Episodic knowledge：情景知识，只能从背景知识中推断出来</li><li>discourse knowledge：口语知识，代号、hashtag等</li><li>在网络上搜索最相关的top10的wiki知识</li><li>通过主题模型和关键词检索最相关的部分、使用大模型进行过滤</li><li>使用大模型对口语知识进行扩充</li><li>既微调了小模型，也在大模型上面做zero-shot看效果</li></ul><p>数据集：Sem-16、P-Stance、VAST</p><h3 id="EZ-STANCE-A-Large-Dataset-for-Zero-Shot-Stance-Detection">EZ-STANCE: A Large Dataset for Zero-Shot Stance Detection</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023 Findings</p><p>思想：提出了与VAST对标的EZ-Stance数据集</p><p>数据集：EZ-Stance</p><h3 id="Multi-label-and-Multi-target-Sampling-of-Machine-Annotation-for-Computational-Stance-Detection">Multi-label and Multi-target Sampling of Machine Annotation for Computational Stance Detection</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023 Findings</p><p>思想：思维链等zero-shot来增强直接使用大模型进行立场检测的效果</p><p><a href="https://imgse.com/i/pFlQvid"><img src="https://s11.ax1x.com/2024/02/04/pFlQvid.png" alt="pFlQvid.png"></a></p><p>数据集：</p><h3 id="Chain-of-Thought-Embeddings-for-Stance-Detection-on-Social-Media">Chain-of-Thought Embeddings for Stance Detection on Social Media</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023 Findings</p><p>思想：用大模型对立场进行预测，然后输入到Roberta中进行再次预测</p><p><a href="https://imgse.com/i/piUklJU"><img src="https://z1.ax1x.com/2023/11/19/piUklJU.md.png" alt="piUklJU.md.png"></a></p><p>数据集：Tweet-Stance、P-Stance</p><h3 id="Toxicity-Morality-and-Speech-Act-Guided-Stance-Detection">Toxicity, Morality, and Speech Act Guided Stance Detection</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023 Findings</p><p>思想：关注一些情绪倾向</p><p><a href="https://imgse.com/i/pFllSzt"><img src="https://s11.ax1x.com/2024/02/04/pFllSzt.png" alt="pFllSzt.png"></a></p><p>数据集：SemEval、P-Stance、Climate、COVID</p><h3 id="Multilingual-Coarse-Political-Stance-Classification-of-Media-The-Editorial-Line-of-a-ChatGPT-and-Bard-Newspaper">Multilingual Coarse Political Stance Classification of Media. The Editorial Line of a ChatGPT and Bard Newspaper</h3><p>时间：2023年12月</p><p>等级：EMNLP 2023 Findings</p><p>思想：使用大模型对人工编写的新闻的倾向进行判断，不算立场检测</p><p>数据集：与立场检测无关</p><h2 id="2024">2024</h2><h3 id="Cross-target-Stance-Detection-by-Exploiting-Target-Analytical-Perspectives">Cross-target Stance Detection by Exploiting Target Analytical Perspectives</h3><p>时间：2024年1月</p><p>等级：Arxiv</p><p>思想：先用GPT3.5给出可以分析的视角，然后一起送到小模型中进行立场检测，同时情感词汇使用SenticNet进行扩充。比较传统的做法</p><p>数据集：SEM16和VAST</p><h3 id="EACL-2024-气候相关立场检测竞赛">EACL 2024 气候相关立场检测竞赛</h3><p>HAMiSoN-Generative at ClimateActivism 2024: Stance Detection using generative large language models</p><ul><li>大模型+分类头做立场检测</li><li>BertTweet+CNN</li><li>扩充了数据，然后用小模型做了微调</li><li>训练多个模型，包括小模型、大模型等，然后进行集成</li></ul><h3 id="Unsupervised-Stance-Detection-for-Social-Media-Discussions-A-Generic-Baseline">Unsupervised Stance Detection for Social Media Discussions: A Generic Baseline</h3><p>采用无监督学习的方式保证立场检测的泛化性</p><p>关于图神经网络的做法</p><p>等级：EACL 2024</p><h3 id="SocialPET-Socially-Informed-Pattern-Exploiting-Training-for-Few-Shot-Stance-Detection-in-Social-Media">SocialPET: Socially Informed Pattern Exploiting Training for Few-Shot Stance Detection in Social Media</h3><p>等级：期刊</p><p>现状介绍的很详细，可以参考</p><p>也是用辩论的方式，构建多个场景然后集成一下</p><p>数据集：P-Stance</p><h3 id="Collaborative-Knowledge-Infusion-for-Low-resource-Stance-Detection">Collaborative Knowledge Infusion for Low-resource Stance Detection</h3><p>等级：Arxiv</p><p>小模型+Wiki的RAG+LoRA+一些训练技巧</p><p>数据集：VAST、P-Stance、COVID-19-Stance</p><h3 id="Stance-Detection-on-Social-Media-with-Fine-Tuned-Large-Language-Models">Stance Detection on Social Media with Fine-Tuned Large Language Models</h3><p>用大模型微调的方式探索了一下立场检测使用大模型能力的边界</p><h3 id="Zero-shot-Cross-lingual-Stance-Detection-via-Adversarial-Language-Adaptation">Zero-shot Cross-lingual Stance Detection via  Adversarial Language Adaptation</h3><p>有跨主题跨语言的相关工作</p><p>用一个多语言的Encoder，构建一个Pipeline做跨语言的立场检测</p><h3 id="EDDA-An-Encoder-Decoder-Data-Augmentation-Framework-for-Zero-Shot-Stance-Detection">EDDA: An Encoder-Decoder Data Augmentation Framework for Zero-Shot Stance Detection</h3><p>Coling 2024</p><p>先训一个完整的Transformer，然后将他的输出通过Prompt的方式进行多步推理的立场检测</p><h3 id="EcoVerse-An-Annotated-Twitter-Dataset-for-Eco-Relevance-Classification-Environmental-Impact-Analysis-and-Stance-Detection">EcoVerse: An Annotated Twitter Dataset for Eco-Relevance Classification, Environmental Impact Analysis, and Stance Detection</h3><p>关于气候的新的立场检测的数据集</p><h3 id="KPatch-Knowledge-Patch-to-Pre-trained-Language-Model-for-Zero-Shot-Stance-Detection-on-Social-Media">KPatch: Knowledge Patch to Pre-trained Language Model for Zero-Shot Stance Detection on Social Media</h3><p>先扩充Topic，然后通过查询知识库的方式提取相关信息，获取知识</p><p>获取知识后先判断知识的正确性，然后再使用大模型、LoRA的方式进行立场检测</p><h3 id="STEntConv-Predicting-Disagreement-with-Stance-Detection-and-a-Signed-Graph-Convolutional-Network">STEntConv: Predicting Disagreement with Stance Detection and a Signed Graph Convolutional Network</h3><p>不用大模型，是GCN+小模型的做法</p><h3 id="Examining-Temporalities-on-Stance-Detection-Towards-COVID-19-Vaccination-2">Examining Temporalities on Stance Detection Towards COVID-19 Vaccination</h3><p>探索了一下新冠数据集中大家的立场随着时间的变化，用一些模型跑了一下</p><h3 id="A-Challenge-Dataset-and-Effective-Models-for-Conversational-Stance-Detection">A Challenge Dataset and Effective Models for Conversational Stance Detection</h3><p>构建了一个对话的立场检测数据集，魔改了一下Attention的结构进行立场检测</p><h3 id="Investigating-the-Robustness-of-Modelling-Decisions-for-Few-Shot-Cross-Topic-Stance-Detection-A-Preregistered-Study">Investigating the Robustness of Modelling Decisions for Few-Shot Cross-Topic Stance Detection: A Preregistered Study</h3><p>探索了不同的立场检测结构对于新闻立场检测的效果</p><h3 id="Stance-Reasoner-Zero-Shot-Stance-Detection-on-Social-Media-with-Explicit-Reasoning">Stance Reasoner: Zero-Shot Stance Detection on Social Media with Explicit Reasoning</h3><p>Prompt+In Context+示例选择的方式，不微调大模型进行立场检测</p><h3 id="Target-Adaptive-Consistency-Enhanced-Prompt-Tuning-for-Multi-Domain-Stance-Detection">Target-Adaptive Consistency Enhanced Prompt-Tuning for Multi-Domain Stance Detection</h3><p>比较传统的Verbalizer的方法，不涉及大模型</p><h3 id="DEEM-Dynamic-Experienced-Expert-Modeling-for-Stance-Detection">DEEM: Dynamic Experienced Expert Modeling for Stance Detection</h3><p>使用多专家的方式，多步进行推理</p><h3 id="The-Impact-of-Stance-Object-Type-on-the-Quality-of-Stance-Detection">The Impact of Stance Object Type on the Quality of Stance Detection</h3><p>claim、frame相关，构建了一套pipeline</p><h3 id="Ad-Hoc-Compounds-for-Stance-Detection">Ad Hoc Compounds for Stance Detection</h3><p>和立场检测不是很相关</p><h3 id="Relative-Counterfactual-Contrastive-Learning-for-Mitigating-Pretrained-Stance-Bias-in-Stance-Detection">Relative Counterfactual Contrastive Learning for Mitigating Pretrained Stance Bias in Stance Detection</h3><p>更改了对比学习的构建数据的方式，算是对训练方法的改进，用的是小模型</p><h3 id="Zero-Shot-Stance-Detection-using-Contextual-Data-Generation-with-LLMs">Zero-Shot Stance Detection using Contextual Data Generation with LLMs</h3><p>用GPT-3扩充VAST数据集</p><p>增强目前已有模型的能力</p><h3 id="Let-Silence-Speak-Enhancing-Fake-News-Detection-with-Generated-Comments-from-Large-Language-Models">Let Silence Speak: Enhancing Fake News Detection with Generated Comments from Large Language Models</h3><p>还是多的角度的角色扮演，然后再对比学习什么的做一下立场检测</p><h3 id="Reinforcement-Tuning-for-Detecting-Stances-and-Debunking-Rumors-Jointly-with-Large-Language-Models">Reinforcement Tuning for Detecting Stances and Debunking Rumors Jointly with Large Language Models</h3><p>强化学习+MOE+LoRA</p><h3 id="Mitigating-Biases-of-Large-Language-Models-in-Stance-Detection-with-Calibration">Mitigating Biases of Large Language Models in Stance Detection with Calibration</h3><p>分析模型的偏见，蛮复杂的</p><h3 id="The-Power-of-LLM-Generated-Synthetic-Data-for-Stance-Detection-in-Online-Political-Discussions">The Power of LLM-Generated Synthetic Data for Stance Detection in Online Political Discussions</h3><p>（SQBC: Active Learning using LLM-Generated Synthetic Data  for Stance Detection in Online Political Discussions）</p><p>像是投ICML然后没中，投了NeurIPS</p><p>生成数据然后通过查询的方式，筛选出最有价值的没有打标签的样本</p><h3 id="CoSD-Collaborative-Stance-Detection-with-Contrastive-Heterogeneous-Topic-Graph-Learning">CoSD: Collaborative Stance Detection with  Contrastive Heterogeneous Topic Graph Learning</h3><p>通过主题模型找主题的做法</p><h3 id="Applying-the-Ego-Network-Model-to-Cross-Target-Stance-Detection">Applying the Ego Network Model to Cross-Target Stance Detection</h3><p>利用社交网络信息对立场检测的效果进行增强</p><h3 id="GunStance-Stance-Detection-for-Gun-Control-and-Gun-Regulation">GunStance: Stance Detection for Gun Control and Gun Regulation</h3><p>收集了一个枪支的数据集，然后进行立场检测</p><h3 id="Multi-modal-Stance-Detection-New-Datasets-and-Model">Multi-modal Stance Detection: New Datasets and Model</h3><p>多模态的数据集和基本的方法</p><h3 id="Tree-of-Counterfactual-Prompting-for-Zero-Shot-Stance-Detection">Tree-of-Counterfactual Prompting for Zero-Shot Stance Detection</h3><p>树形的Prompt，多步推理出立场检测的标签</p><h3 id="Transitive-Consistency-Constrained-Learning-for-Entity-to-Entity-Stance-Detection">Transitive Consistency Constrained Learning for  Entity-to-Entity Stance Detection</h3><p>实体对实体的立场检测，与普通的差异较大</p><h3 id="ZeroStance-Leveraging-ChatGPT-for-Open-Domain-Stance-Detection-via-Dataset-Generation">ZeroStance: Leveraging ChatGPT for Open-Domain Stance Detection via  Dataset Generation</h3><p>用ChatGPT构建数据的pipeline</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Stance Detection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch分布式训练</title>
    <link href="/2023/08/12/Pytorch-distributed/"/>
    <url>/2023/08/12/Pytorch-distributed/</url>
    
    <content type="html"><![CDATA[<p>Pytorch分布式训练学习整理</p><span id="more"></span><h1>参考资料</h1><p>源码解析：<a href="https://zhuanlan.zhihu.com/p/343951042">PyTorch 源码解读之 DP &amp; DDP：模型并行和分布式训练解析</a></p><p>简单小模型示例：<a href="https://blog.csdn.net/weixin_43579015/article/details/131811657">pytorch中分布式训练DDP教程（新手快速入门！）</a></p><p><a href="https://blog.csdn.net/lgzlgz3102/article/details/124418378">Pytorch - 弹性训练极简实现(附源码)</a></p><p>系列文章：<a href="https://zhuanlan.zhihu.com/p/72939003">【分布式训练】单机多卡的正确打开方式（一）：理论基础</a></p><p><a href="https://blog.csdn.net/ARPOSPF/article/details/131805949">【分布式训练】基于PyTorch进行多GPU分布式模型训练（补充）</a></p><p>较新较详细的教程：<a href="https://blog.csdn.net/orangerfun/article/details/123887725">torch分布式训练</a></p><p>博客：<a href="https://qiankunli.github.io/2021/11/27/pytorch_elastic.html#%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8-train_script">pytorch弹性分布式训练</a></p><h1>模型并行（流水线）</h1><p>把模型隔成不同的层，每一层都放到一块GPU上</p><p><strong>（1）GPU利用度不够。</strong></p><p><img src="https://pic2.zhimg.com/80/v2-8db7ffbb378266ad68cac5401664a471_1440w.webp" alt=""></p><p>如图，阴影部分所表示的时间段里，总有GPU在空转。<strong>GPU的数量越多时，空置的比例接近1</strong></p><p><strong>（2）中间结果占据大量内存</strong></p><p>在做backward计算梯度的过程中，我们需要用到每一层的中间结果z。假设我们的模型有L层，每一层的宽度为d，则对于每块GPU，不考虑其参数本身的存储，额外的空间复杂度为<img src="https://math.now.sh?inline=%F0%9D%91%82%28%F0%9D%91%81%E2%88%97%5Cfrac%7BL%7D%7BK%7D%E2%88%97%F0%9D%91%91%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 。从这个复杂度可以看出，随着模型的增大，N，L，d三者的增加可能会平滑掉K增加带来的GPU内存收益。因此，这也是需要优化的地方。</p><h1>Gpipe</h1><p>流水线并行的核心思想是： <strong>在模型并行的基础上，进一步引入数据并行的办法，即把原先的数据再划分成若干个batch，送入GPU进行训练</strong> 。未划分前的数据，叫 <strong>mini-batch</strong> 。在mini-batch上再划分的数据，叫 <strong>micro-batch</strong> 。</p><p><img src="https://pic1.zhimg.com/80/v2-accf297316558a8a0328a0defadcf00c_1440w.webp" alt=""></p><p>其中，第一个下标表示GPU编号，第二个下标表示micro-batch编号。假设我们将mini-batch划分为M个，则流水线并行下，bubble的时间复杂度为：<img src="https://math.now.sh?inline=%F0%9D%91%82%28%5Cfrac%7B%F0%9D%90%BE%E2%88%921%7D%7B%F0%9D%90%BE%2B%F0%9D%91%80%E2%88%921%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 。Gpipe通过实验证明，当<img src="https://math.now.sh?inline=%F0%9D%91%80%3E%3D4%F0%9D%90%BE" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，bubble产生的空转时间占比对最终训练时长影响是微小的，可以忽略不计。</p><p>将batch切好，并逐一送入GPU的过程，就像一个流水生产线一样（类似于CPU里的流水线），因此也被称为Pipeline Parallelism。</p><p>Gpipe采用<strong>用时间换空间的方法，几乎不存中间结果，等到backward的时候，再重新算一遍forward</strong></p><p>每块GPU上只保存来自上一块的最后一层输入z，其余的中间结果我们算完就废。等到backward的时候再由保存下来的z重新进行forward来算出。</p><p>空间复杂度为<img src="https://math.now.sh?inline=%F0%9D%91%82%28%F0%9D%91%81%2B%5Cfrac%7BN%7D%7BM%7D%E2%88%97%5Cfrac%7BL%7D%7BK%7D%E2%88%97%F0%9D%91%91%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 。</p><p>在实际应用中，流水线并行并不特别流行，主要原因是模型能否均匀切割，影响了整体计算效率，这就需要算法工程师做手调。</p><h1>数据并行</h1><p>数据并行的核心思想是： <strong>在各个GPU上都拷贝一份完整模型，各自吃一份数据，算一份梯度，最后对梯度进行累加来更新整体模型</strong> 。理念不复杂，但到了大模型场景， <strong>巨大的存储和GPU间的通讯量，</strong> 就是系统设计要考虑的重点了。在本文中，我们将递进介绍三种主流数据并行的实现方式：</p><ul><li><strong>DP（Data Parallelism）</strong> ：最早的数据并行模式，一般采用参数服务器(Parameters Server)这一编程框架。实际中多用于单机多卡</li><li><strong>DDP（Distributed Data Parallelism）</strong> ：分布式数据并行，采用Ring AllReduce的通讯方式，实际中多用于多机场景</li><li><strong>ZeRO：</strong> 零冗余优化器。由微软推出并应用于其DeepSpeed框架中。严格来讲ZeRO采用数据并行+张量并行的方式，旨在降低存储。</li></ul><h2 id="DP">DP</h2><p>一个经典数据并行的过程如下：</p><ul><li>若干块 <strong>计算GPU</strong> ，如图中GPU0~GPU2；1块 <strong>梯度收集GPU</strong> ，如图中AllReduce操作所在GPU。</li><li>在每块计算GPU上都拷贝一份完整的模型参数。</li><li>把一份数据X（例如一个batch）均匀分给不同的计算GPU。</li><li>每块计算GPU做一轮FWD和BWD后，算得一份梯度G。</li><li>每块计算GPU将自己的梯度<strong>push</strong>给梯度收集GPU，做聚合操作。这里的聚合操作一般指 <strong>梯度累加</strong> 。当然也支持用户自定义。</li><li>梯度收集GPU聚合完毕后，计算GPU从它那<strong>pull</strong>下完整的梯度结果，用于更新模型参数W。更新完毕后，计算GPU上的模型参数依然保持一致。</li><li><strong>聚合再下发梯度的操作，称为AllReduce</strong> 。</li></ul><h3 id="流程">流程</h3><p><img src="https://d2l.ai/_images/ps.svg" alt="../_images/ps.svg"></p><p>DP 基于单机多卡，所有设备都负责计算和训练网络，除此之外， device[0] (并非 GPU 真实标号而是输入参数 device_ids 首位) 还要负责整合梯度，更新参数。从图中我们可以看出，有三个主要过程：</p><ul><li>过程一（图中红色部分）：各卡分别计算损失和梯度</li><li>过程二（图中蓝色部分）：所有梯度整合到 device[0]</li><li>过程三（图中绿色部分）：device[0] 进行参数更新，其他卡拉取 device[0] 的参数进行更新</li></ul><p>所有卡都并行运算（图中红色），将梯度收集到 device[0]（图中浅蓝色）和 device[0] 分享模型参数给其他 GPU（图中绿色）三个主要过程。</p><p>更详细的流程如下图所示：</p><p><img src="https://miro.medium.com/v2/resize:fit:1000/1*FpDHkWJhkLL7KxU01Lf9Lw.png" alt=""></p><h3 id="分析">分析</h3><ul><li><strong>存储开销大</strong> 。每块GPU上都存了一份完整的模型，造成冗余。</li><li><strong>通讯开销大</strong> 。Server需要和每一个Worker进行梯度传输。当Server和Worker不在一台机器上时，Server的带宽将会成为整个系统的计算效率瓶颈。</li></ul><p>梯度异步更新：Worker并不会实际等到把聚合梯度拿回来，更新完参数W后再做计算。而是直接拿旧的W，吃新的数据，继续第11轮的计算。这样就保证在通讯的时间里，Worker也在马不停蹄做计算，提升计算通讯比。</p><p>但是模型收敛的速度不会变快，只是多用了一些数据</p><p>受通讯负载不均的影响， <strong>DP一般用于单机多卡场景</strong> 。</p><h2 id="DDP">DDP</h2><p>DDP作为一种更通用的解决方案出现了，既能多机，也能单机。<strong>DDP首先要解决的就是通讯问题：将Server上的通讯压力均衡转到各个Worker上。实现这一点后，可以进一步去Server，留Worker。</strong></p><h3 id="简介">简介</h3><p>随着大模型的出现，简单的数据并行已经无法满足需求，毕竟一个模型的大小就有可能超过显卡的显存，更不可能将其复制多份。因此需要让每一张卡仅负责模型的一部分计算，承载模型的一小部分。</p><p>使用DDP进行分布式训练有以下几个优势：</p><ol><li>加速训练：通过数据并行，DDP能够在多个设备或节点上同时处理不同批次的数据，从而加快训练速度。</li><li>内存效率：DDP在每个设备上只保存模型的局部副本和相应的梯度，而不是整个模型的副本，这样可以节省内存。</li><li>不需要额外的代码：在PyTorch中，使用DDP进行分布式训练几乎不需要修改您的原始模型和训练代码。</li></ol><h3 id="流程：Ring-All-Reduce">流程：Ring All Reduce</h3><p>Scatter Reduce过程：首先将参数分为<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>份，相邻的GPU传递不同的参数，在传递<img src="https://math.now.sh?inline=k-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次之后，可以得到每一份参数的累积（在不同的GPU上）。</p><p><img src="https://pic3.zhimg.com/v2-4590aeb5fd981b1e6f926cc68605884a_b.webp" alt="动图"></p><p>All Gather：得到每一份参数的累积之后，再做一次传递，同步到所有的GPU上。</p><p><img src="https://pic4.zhimg.com/v2-c9df34575d7d95ec87d85575d25d6f37_b.webp" alt="动图"></p><p>假设有<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个GPU， 传输总量是<img src="https://math.now.sh?inline=p" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，每一次的通信上限是<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则完成一次通信需要时间<img src="https://math.now.sh?inline=%5Cfrac%7Bp%7D%7Bb%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，那么总共需要花费时间<img src="https://math.now.sh?inline=T%3D2%28k-1%29%5Cfrac%7B%5Cfrac%7Bp%7D%7Bb%7D%7D%7Bk%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，可以看到通信成本<img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与GPU数量无关。</p><p>DP和DDP的总通讯量相同，但因负载不均的原因，DP需要耗费更多的时间搬运数据，但是DP不一定就比DDP差</p><h3 id="代码">代码</h3><h4 id="分析-2">分析</h4><p>DDP采用<strong>多进程控制</strong>多GPU，共同训练模型，一份代码会被pytorch自动分配到n个进程并在n个GPU上运行。 DDP运用Ring-Reduce通信算法在每个GPU间对梯度进行通讯，交换彼此的梯度，从而获得所有GPU的梯度。对比DP，不需要在进行模型本体的通信，因此可以加速训练。</p><p>需要注意以下几点：</p><ol><li>设置DistributedSampler来打乱数据，因为一个batch被分配到了好几个进程中，要确保不同的GPU拿到的不是同一份数据。</li><li>要告诉每个进程自己的id，即使用哪一块GPU。</li><li>如果需要做BatchNormalization，需要对数据进行同步。</li></ol><h4 id="Torchrun使用及参数详解">Torchrun使用及参数详解</h4><h5 id="核心概念">核心概念</h5><ul><li>rank：进程号，在多进程上下文中，我们通常假定rank 0是第一个进程或者主进程，其它进程分别具有1，2，3不同rank号，这样总共具有4个进程。</li><li>node：物理节点，可以是一个容器也可以是一台机器，节点内部可以有多个GPU；nnodes指物理节点数量， nproc_per_node指每个物理节点上面进程的数量</li><li>local_rank：指在一个node上进程的相对序号，local_rank在node之间相互独立</li><li>WORLD_SIZE：全局进程总个数，即在一个分布式任务中rank的数量</li><li>Group：进程组，一个分布式任务对应了一个进程组。只有用户需要创立多个进程组时才会用到group来管理，默认情况下只有一个group</li><li>backend：通信后端，可选的包括：nccl（NVIDIA推出）、gloo（Facebook推出）、mpi（OpenMPI）。一般建议GPU训练选择nccl，CPU训练选择gloo</li><li>master_addr与master_port：主节点的地址以及端口，供init_method 的tcp方式使用。 因为pytorch中网络通信建立是从机去连接主机，运行ddp只需要指定主节点的IP与端口，其它节点的IP不需要填写。</li></ul><p>如下图所示，共有3个节点(机器)，每个节点上有4个GPU，每台机器上起4个进程，每个进程占一块GPU，那么图中一共有12个rank，nproc_per_node=4，nnodes=3，每个节点都有一个对应的node_rank</p><p><img src="https://img-blog.csdnimg.cn/70c4363340b64ae382905d479cfe7931.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAb3JhbmdlcmZ1bg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>rank与GPU之间没有必然的对应关系，一个rank可以包含多个GPU；一个GPU也可以为多个rank服务（多进程共享GPU），在torch的分布式训练中习惯默认一个rank对应着一个GPU，因此local_rank可以当作GPU号</p><h5 id="简介-2">简介</h5><p>torchrun相当于原来的torch.distributed.launch，有一些额外增加的功能：</p><ul><li>通过重启优雅处理某一个worker运行过程中的错误</li><li>worker的RANK和WORLD_SIZE都是被自动分配的</li><li>Node的数量允许从最小值到最大值中间弹性伸缩</li></ul><p><code>torchrun</code>命令与 <code>python -m torch.distributed.run</code>命令完全等同，为命令行命令</p><h5 id="从旧版本迁移-use-env">从旧版本迁移 --use_env</h5><p>有一个参数 <code>--use_env</code>在目前版本的torchrun中是不存在的，因此需要做一点处理</p><ol><li>将原始指定的–local-rank参数修改为从环境变量中读取</li><li>命令行不需要再次指定 <code>--use_env</code>参数</li></ol><p>旧版本代码：</p><div class="code-wrapper"><pre><code class="hljs python">$ python -m torch.distributed.launch --use-env train_script.py<span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser()parser.add_argument(<span class="hljs-string">&quot;--local-rank&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)args = parser.parse_args()local_rank = args.local_rank</code></pre></div><p>新版本代码：</p><div class="code-wrapper"><pre><code class="hljs python">$ torchrun train_script.py<span class="hljs-keyword">import</span> oslocal_rank = <span class="hljs-built_in">int</span>(os.environ[<span class="hljs-string">&quot;LOCAL_RANK&quot;</span>])</code></pre></div><h5 id="命令行参数">命令行参数</h5><table><thead><tr><th>参数名称</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>–nnodes</td><td>节点数量，一个节点对应一个主机</td><td>1或MIN_SIZE:MAX_SIZE（弹性训练）</td></tr><tr><td>–nproc-per-node</td><td>一个节点中的进程数量，一般一个进程使用一个显卡，故也通常表述为一个节点中显卡的数量</td><td>[auto, cpu, gpu, int]</td></tr><tr><td>–rdzv-backend</td><td>rendezvous 后端</td><td>c10d etcd</td></tr><tr><td>–rdzv-endpoint</td><td>rendezvous 后端地址</td><td><code>&lt;host&gt;</code>:<code>&lt;port&gt;</code></td></tr><tr><td>–rdzv-id</td><td>用户可以指定当前rendezvous的id，所有的node都要使用这同一个id</td><td></td></tr><tr><td>–rdzv-conf</td><td>希望传入rendezvous的其他参数</td><td><code>&lt;key1&gt;</code>=<code>&lt;value1&gt;</code></td></tr><tr><td>–standalone</td><td>单节点多卡的默认配置，不需要再传入上述的rendezvous参数，默认为C10d TCP 29400（–master-addr等也会失效）</td><td>选项</td></tr><tr><td>–max-restarts</td><td>worker group重启的最大次数</td><td></td></tr><tr><td>–monitor-interval</td><td>检测worker状态的时间间隔（以秒为单位）</td><td></td></tr><tr><td>–start-method</td><td>创建子进程的方式</td><td>{spawn,fork,forkserver}</td></tr><tr><td>–role</td><td>User-defined role for the workers.</td><td></td></tr><tr><td>-m</td><td>与python -m相同，将模块当作脚本运行</td><td>选项</td></tr><tr><td>–no-python</td><td>不使用python命令而是直接执行（如果这个文件并不是一个py文件会使用这个）</td><td></td></tr><tr><td>–run-path</td><td>使用runpy.run_path执行文件</td><td></td></tr><tr><td>–log-dir</td><td>日志文件存放目录</td><td></td></tr><tr><td>–redirects</td><td>将控制台输出的日志信息重定向到日志目录中的文件</td><td>[-r 3] 将所有worker的标准输出和标准错误进行重定向，[-r 0:1,1:2] 将rank 0的标准输出重定向，将rank 1的标准错误重定向</td></tr><tr><td>–tee</td><td>除将日志输出到控制台外也输出到日志文件</td><td>日志文件流</td></tr><tr><td>–node-rank</td><td>多节点分布式训练的时候该节点的Rank</td><td></td></tr><tr><td>–master-addr</td><td>master 节点的 IP 地址，也就是 rank=0 对应的主机地址</td><td></td></tr><tr><td>–master-port</td><td>master 节点的端口号，用于通信</td><td></td></tr><tr><td>–local-addr</td><td>本地节点的IP地址</td><td></td></tr></tbody></table><p>torchrun主要是对多节点作了分布式的优化，从而可以满足容错性和弹性伸缩。如果是单节点就不需要很复杂。</p><h5 id="环境变量">环境变量</h5><table><thead><tr><th style="text-align:left">名称</th><th>含义</th><th>示例</th><th></th></tr></thead><tbody><tr><td style="text-align:left">LOCAL_RANK</td><td>GPU在单节点中的序号</td><td>0</td><td>1</td></tr><tr><td style="text-align:left">RANK</td><td>GPU在全部节点的序号</td><td>0</td><td>1</td></tr><tr><td style="text-align:left">GROUP_RANK</td><td>worker组的rank</td><td>0</td><td>0</td></tr><tr><td style="text-align:left">ROLE_RANK</td><td>相同ROLE的worker的rank</td><td>0</td><td>1</td></tr><tr><td style="text-align:left">LOCAL_WORLD_SIZE</td><td>与–nproc-per-node相同</td><td>2</td><td>2</td></tr><tr><td style="text-align:left">WORLD_SIZE</td><td>job中worker的总数</td><td>2</td><td>2</td></tr><tr><td style="text-align:left">ROLE_WORLD_SIZE</td><td>相同角色的worker的数量</td><td>1</td><td>2</td></tr><tr><td style="text-align:left">MASTER_ADDR</td><td>rank为0的worker的地址</td><td>127.0.0.1</td><td>127.0.0.1</td></tr><tr><td style="text-align:left">MASTER_PORT</td><td>rank为0的worker的端口</td><td>29500</td><td>29500</td></tr><tr><td style="text-align:left">TORCHELASTIC_RESTART_COUNT</td><td>最近重启的worker组的数量</td><td>0</td><td>0</td></tr><tr><td style="text-align:left">TORCHELASTIC_MAX_RESTARTS</td><td>配置的最大重启次数</td><td>0</td><td>0</td></tr><tr><td style="text-align:left">TORCHELASTIC_RUN_ID</td><td>与–rdzv-id相同</td><td>none</td><td>none</td></tr><tr><td style="text-align:left">PYTHON_EXEC</td><td>执行这个脚本的python的位置</td><td>没有</td><td>没有</td></tr></tbody></table><h3 id="代码示例">代码示例</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset, DataLoader<span class="hljs-keyword">from</span> torch.utils.data.distributed <span class="hljs-keyword">import</span> DistributedSampler<span class="hljs-keyword">from</span> torch.nn.parallel <span class="hljs-keyword">import</span> DistributedDataParallel<span class="hljs-keyword">from</span> torch.distributed <span class="hljs-keyword">import</span> init_process_group, destroy_process_group<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> time<span class="hljs-keyword">class</span> <span class="hljs-title class_">ToyModel</span>(nn.Module):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):        <span class="hljs-built_in">super</span>(ToyModel, <span class="hljs-variable language_">self</span>).__init__()        <span class="hljs-variable language_">self</span>.net1 = nn.Linear(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)        <span class="hljs-variable language_">self</span>.relu = nn.ReLU()        <span class="hljs-variable language_">self</span>.net2 = nn.Linear(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.net2(<span class="hljs-variable language_">self</span>.relu(<span class="hljs-variable language_">self</span>.net1(x)))<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTrainDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size</span>):        <span class="hljs-variable language_">self</span>.size = size        <span class="hljs-variable language_">self</span>.data = [(torch.rand(<span class="hljs-number">10</span>), <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.size      <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.data[index]<span class="hljs-keyword">class</span> <span class="hljs-title class_">Trainer</span>:    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"></span><span class="hljs-params">        self,</span><span class="hljs-params">        model: torch.nn.Module,</span><span class="hljs-params">        train_data: DataLoader,</span><span class="hljs-params">        optimizer: torch.optim.Optimizer,</span><span class="hljs-params">        save_every: <span class="hljs-built_in">int</span>,</span><span class="hljs-params">        snapshot_path: <span class="hljs-built_in">str</span>,</span><span class="hljs-params">    </span>) -&gt; <span class="hljs-literal">None</span>:        <span class="hljs-variable language_">self</span>.gpu_id = <span class="hljs-built_in">int</span>(os.environ[<span class="hljs-string">&quot;LOCAL_RANK&quot;</span>])        <span class="hljs-variable language_">self</span>.model = model.to(<span class="hljs-variable language_">self</span>.gpu_id)        <span class="hljs-variable language_">self</span>.train_data = train_data        <span class="hljs-variable language_">self</span>.optimizer = optimizer        <span class="hljs-variable language_">self</span>.save_every = save_every        <span class="hljs-variable language_">self</span>.epochs_run = <span class="hljs-number">0</span>        <span class="hljs-variable language_">self</span>.snapshot_path = snapshot_path        <span class="hljs-keyword">if</span> os.path.exists(snapshot_path):            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Loading snapshot&quot;</span>)            <span class="hljs-variable language_">self</span>._load_snapshot(snapshot_path)        <span class="hljs-variable language_">self</span>.model = DistributedDataParallel(<span class="hljs-variable language_">self</span>.model, device_ids=[<span class="hljs-variable language_">self</span>.gpu_id])    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_load_snapshot</span>(<span class="hljs-params">self, snapshot_path</span>):        loc = <span class="hljs-string">f&quot;cuda:<span class="hljs-subst">&#123;self.gpu_id&#125;</span>&quot;</span>        snapshot = torch.load(snapshot_path, map_location=loc)        <span class="hljs-variable language_">self</span>.model.load_state_dict(snapshot[<span class="hljs-string">&quot;MODEL_STATE&quot;</span>])        <span class="hljs-variable language_">self</span>.epochs_run = snapshot[<span class="hljs-string">&quot;EPOCHS_RUN&quot;</span>]        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Resuming training from snapshot at Epoch <span class="hljs-subst">&#123;self.epochs_run&#125;</span>&quot;</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_run_batch</span>(<span class="hljs-params">self, source, targets</span>):        <span class="hljs-variable language_">self</span>.optimizer.zero_grad()        output = <span class="hljs-variable language_">self</span>.model(source)        <span class="hljs-comment"># print(output,targets)</span>        loss = F.cross_entropy(output, targets)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU<span class="hljs-subst">&#123;self.gpu_id&#125;</span>] Loss <span class="hljs-subst">&#123;loss.item()&#125;</span>&quot;</span>)        loss.backward()        <span class="hljs-variable language_">self</span>.optimizer.step()    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_run_epoch</span>(<span class="hljs-params">self, epoch</span>):        b_sz = <span class="hljs-built_in">len</span>(<span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(<span class="hljs-variable language_">self</span>.train_data))[<span class="hljs-number">0</span>])        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU<span class="hljs-subst">&#123;self.gpu_id&#125;</span>] Epoch <span class="hljs-subst">&#123;epoch&#125;</span> | Batchsize: <span class="hljs-subst">&#123;b_sz&#125;</span> | Steps: <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(self.train_data)&#125;</span>&quot;</span>)        <span class="hljs-variable language_">self</span>.train_data.sampler.set_epoch(epoch)        <span class="hljs-keyword">for</span> source, targets <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.train_data:            source = source.to(<span class="hljs-variable language_">self</span>.gpu_id)            targets = targets.to(<span class="hljs-variable language_">self</span>.gpu_id)            <span class="hljs-variable language_">self</span>._run_batch(source, targets)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_save_snapshot</span>(<span class="hljs-params">self, epoch</span>):        snapshot = &#123;            <span class="hljs-string">&quot;MODEL_STATE&quot;</span>: <span class="hljs-variable language_">self</span>.model.module.state_dict(),            <span class="hljs-string">&quot;EPOCHS_RUN&quot;</span>: epoch,        &#125;        torch.save(snapshot, <span class="hljs-variable language_">self</span>.snapshot_path)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch&#125;</span> | Training snapshot saved at <span class="hljs-subst">&#123;self.snapshot_path&#125;</span>&quot;</span>)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, max_epochs: <span class="hljs-built_in">int</span></span>):        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>.epochs_run, max_epochs):            <span class="hljs-variable language_">self</span>._run_epoch(epoch)            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.gpu_id == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> epoch % <span class="hljs-variable language_">self</span>.save_every == <span class="hljs-number">0</span>:                <span class="hljs-variable language_">self</span>._save_snapshot(epoch)            time.sleep(<span class="hljs-number">1</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">ddp_setup</span>():    init_process_group(backend=<span class="hljs-string">&quot;nccl&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Parameters&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;LOCAL_RANK:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;LOCAL_RANK&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;RANK:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;RANK&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;GROUP_RANK:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;GROUP_RANK&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;ROLE_RANK:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;ROLE_RANK&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;LOCAL_WORLD_SIZE:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;LOCAL_WORLD_SIZE&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;WORLD_SIZE:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;WORLD_SIZE&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;ROLE_WORLD_SIZE:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;ROLE_WORLD_SIZE&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;MASTER_ADDR:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;MASTER_ADDR&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;MASTER_PORT:<span class="hljs-subst">&#123;os.environ[<span class="hljs-string">&#x27;MASTER_PORT&#x27;</span>]&#125;</span>&quot;</span>)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)    torch.cuda.set_device(<span class="hljs-built_in">int</span>(os.environ[<span class="hljs-string">&quot;LOCAL_RANK&quot;</span>]))<span class="hljs-keyword">def</span> <span class="hljs-title function_">load_train_objs</span>():    train_set = MyTrainDataset(<span class="hljs-number">2048</span>)  <span class="hljs-comment"># load your dataset</span>    model = ToyModel()    optimizer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">1e-3</span>)    <span class="hljs-keyword">return</span> train_set, model, optimizer<span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_dataloader</span>(<span class="hljs-params">dataset: Dataset, batch_size: <span class="hljs-built_in">int</span></span>):    <span class="hljs-keyword">return</span> DataLoader(        dataset,        batch_size=batch_size,        pin_memory=<span class="hljs-literal">True</span>,        shuffle=<span class="hljs-literal">False</span>,        sampler=DistributedSampler(dataset)    )<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">save_every: <span class="hljs-built_in">int</span>, total_epochs: <span class="hljs-built_in">int</span>, batch_size: <span class="hljs-built_in">int</span>, snapshot_path: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;snapshot.pt&quot;</span></span>):    ddp_setup()    dataset, model, optimizer = load_train_objs()    train_data = prepare_dataloader(dataset, batch_size)    trainer = Trainer(model, train_data, optimizer, save_every, snapshot_path)    trainer.train(total_epochs)    destroy_process_group()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    <span class="hljs-keyword">import</span> argparse    parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;simple distributed training job&#x27;</span>)    parser.add_argument(<span class="hljs-string">&#x27;--total_epochs&#x27;</span>, default=<span class="hljs-number">10</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;Total epochs to train the model&#x27;</span>)    parser.add_argument(<span class="hljs-string">&#x27;--save_every&#x27;</span>, default=<span class="hljs-number">2</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;How often to save a snapshot&#x27;</span>)    parser.add_argument(<span class="hljs-string">&#x27;--batch_size&#x27;</span>, default=<span class="hljs-number">512</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;Input batch size on each device (default: 32)&#x27;</span>)    args = parser.parse_args()      main(args.save_every, args.total_epochs, args.batch_size)</code></pre></div><p>与单卡有几点不同：</p><ol><li>初始化进程组：<code>init_process_group(backend=&quot;nccl&quot;)</code>，后端一般选择nccl</li><li>分布式数据采样器：<code>sampler=DistributedSampler(dataset)</code></li><li>封装模型：<code>self.model = DistributedDataParallel(self.model, device_ids=[self.gpu_id])</code></li><li>启动torchrun脚本进行训练</li></ol><p>训练脚本：</p><ol><li>单机多卡</li></ol><div class="code-wrapper"><pre><code class="hljs bash">torchrun \    --nnodes=1 \    --nproc_per_node=2 \--master-addr=127.0.0.1 \--master-port=29500 \main.py</code></pre></div><ol start="2"><li>多机多卡</li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NCCL_DEBUG=info<span class="hljs-built_in">export</span> NCCL_SOCKET_IFNAME=bond0<span class="hljs-built_in">export</span> NCCL_IB_DISABLE=1torchrun \    --nnodes=2 \    --nproc_per_node=2 \--master-addr=10.208.58.27 \--master-port=29602 \--node-rank=0 \main.py</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> NCCL_DEBUG=info<span class="hljs-built_in">export</span> NCCL_SOCKET_IFNAME=bond0<span class="hljs-built_in">export</span> NCCL_IB_DISABLE=1torchrun \    --nnodes=2 \    --nproc_per_node=1 \--master-addr=10.208.58.27 \--master-port=29602 \--node-rank=1 \main.py</code></pre></div><p>注意事项：</p><ol><li>多进程训练，也就是会同时运行多份代码，因此训练时候要想好GPU的序号等需要自己指定的变量</li><li>数据是按照进程数量分的，比如总共2048条，如果三个进程就每一个进程683</li></ol><p>测试环境：</p><p>master：10.208.58.27 2*V100</p><div class="code-wrapper"><pre><code class="hljs bash">ParametersLOCAL_RANK:0RANK:0GROUP_RANK:0ROLE_RANK:0LOCAL_WORLD_SIZE:2WORLD_SIZE:3ROLE_WORLD_SIZE:3MASTER_ADDR:10.208.58.27MASTER_PORT:29602ParametersLOCAL_RANK:1RANK:1GROUP_RANK:0ROLE_RANK:1LOCAL_WORLD_SIZE:2WORLD_SIZE:3ROLE_WORLD_SIZE:3MASTER_ADDR:10.208.58.27MASTER_PORT:29602</code></pre></div><p>worker：1*A100</p><div class="code-wrapper"><pre><code class="hljs bash">ParametersLOCAL_RANK:0RANK:2GROUP_RANK:1ROLE_RANK:2LOCAL_WORLD_SIZE:1WORLD_SIZE:3ROLE_WORLD_SIZE:3MASTER_ADDR:10.208.58.27MASTER_PORT:29602</code></pre></div><h2 id="ZeRO（零冗余优化）">ZeRO（零冗余优化）</h2><p>数据并行中，每个GPU上都复制了一份完整模型，当模型变大时，很容易打爆GPU的显存</p><h3 id="存储消耗">存储消耗</h3><p>存储主要分为两大块：Model States和Residual States</p><p><strong>Model States</strong>指和模型本身息息相关的，必须存储的内容，具体包括：</p><ul><li><strong>optimizer states</strong> ：Adam优化算法中的momentum和variance</li><li><strong>gradients</strong> ：模型梯度</li><li><strong>parameters</strong> ：模型参数W</li></ul><p><strong>Residual States</strong>指并非模型必须的，但在训练过程中会额外产生的内容，具体包括：</p><ul><li><strong>activation</strong> ：激活值。在流水线并行中我们曾详细介绍过。在backward过程中使用链式法则计算梯度时会用到。有了它算梯度会更快，但它不是必须存储的，因为可以通过重新做Forward来算它。</li><li><strong>temporary buffers:</strong> 临时存储。例如把梯度发送到某块GPU上做加总聚合时产生的存储。</li><li><strong>unusable fragment memory</strong> ：碎片化的存储空间。虽然总存储空间是够的，但是如果取不到连续的存储空间，相关的请求也会被fail掉。对这类空间浪费可以通过内存整理来解决。</li></ul><h3 id="精度混合训练">精度混合训练</h3><ul><li>存储一份fp32的parameter，momentum和variance（统称model states）</li><li>在forward开始之前，额外开辟一块存储空间，将fp32 parameter减半到fp16 parameter。</li><li>正常做forward和backward，在此之间产生的activation和gradients，都用fp16进行存储。</li><li>用fp16 gradients去更新fp32下的model states。</li><li>当模型收敛后，fp32的parameter就是最终的参数输出。</li></ul><h3 id="存储大小">存储大小</h3><p><img src="https://pic4.zhimg.com/80/v2-2fa670488fcc2408bd27bdcfec283d33_720w.webp" alt="img"></p><p>其中很大的momentum和variance是Adam保存的，首先就优化他们</p><h3 id="ZeRO-DP">ZeRO-DP</h3><h4 id="优化状态分割">优化状态分割</h4><p>将optimizer state分成若干份，每块GPU上各自维护一份。这样就减少了相当一部分的显存开销。</p><p><img src="https://pic2.zhimg.com/80/v2-6a314b96490b51cffc5aa4b693ea32c1_720w.webp" alt=""></p><p>得到G是与DP一样的通信，然后还要聚合W</p><p>显存和通讯量的情况如下：</p><p><img src="https://pic1.zhimg.com/80/v2-0b986b52eea0a5299dfab509a6a9323c_720w.webp" alt="img"></p><h4 id="优化状态与梯度分割">优化状态与梯度分割</h4><p>把梯度也拆开，每个GPU格子维护一块梯度。</p><p><img src="https://pic4.zhimg.com/80/v2-29290e0e77d330b6e0e4d7d3fb417a73_720w.webp" alt="img"></p><p>此时，数据并行的整体流程如下：</p><p>对梯度做一次 <strong>Reduce-Scatter</strong> ，保证每个GPU上所维持的那块梯度是聚合梯度。例如对GPU1，它负责维护G1，因此其他的GPU只需要把G1对应位置的梯度发给GPU1做加总就可。</p><p><img src="https://pic4.zhimg.com/80/v2-3dd79addc9cbe6eb3d22a49037f6e087_720w.webp" alt=""></p><p>每块GPU用自己对应的O和G去更新相应的W。更新完毕后， <strong>每块GPU维持了一块更新完毕的W</strong> 。同理，对W做一次 <strong>All-Gather</strong> ，将别的GPU算好的W同步到自己这来。单卡通讯量 Φ <strong>。</strong></p><p><img src="https://pic3.zhimg.com/80/v2-3909bd74a4ed407a71be0c146a174b86_720w.webp" alt="img"></p><h4 id="优化状态、梯度与参数分割">优化状态、梯度与参数分割</h4><p>每块GPU只维持对应的optimizer states，gradients和parameters</p><ul><li>做forward时，对W做一次 <strong>All-Gather</strong> ，取回分布在别的GPU上的W，得到一份完整的W，立刻把不是自己维护的W抛弃。</li><li>做backward时，对W做一次 <strong>All-Gather</strong> ，取回完整的W，**backward做完，立刻把不是自己维护的W抛弃。</li><li>做完backward，算得一份完整的梯度G，对G做一次 <strong>Reduce-Scatter</strong> ，从别的GPU上聚合自己维护的那部分梯度，<strong>聚合操作结束后，立刻把不是自己维护的G抛弃</strong> 。</li></ul><p><img src="https://pic2.zhimg.com/80/v2-2444902f73d6be616d72067826beb3b9_720w.webp" alt=""></p><p>到这一步， <strong>我们用1.5倍的通讯开销，换回近120倍的显存</strong> 。只要梯度计算和异步更新做的好，通讯时间大部分可以被计算时间隐藏，因此这样的额外通讯开销，也是划算的。</p><h3 id="ZeRO-VS-模型并行">ZeRO VS 模型并行</h3><p><strong>ZeRO是模型并行的形式，数据并行的实质</strong> 。</p><p>模型并行，是指在forward和backward的过程中，我只需要用自己维护的那块W来计算就行。即 <strong>同样的输入X，每块GPU上各算模型的一部分，最后通过某些方式聚合结果</strong> 。</p><p>对ZeRO来说，它做forward和backward的时候，是需要把各GPU上维护的W聚合起来的，即本质上还是用完整的W进行计算。 <strong>它是不同的输入X，完整的参数W，最终再做聚合</strong> 。</p><h3 id="ZeRO-Offload与ZeRO-Infinity">ZeRO-Offload与ZeRO-Infinity</h3><p>核心思想是： <strong>显存不够，内存来凑</strong></p><p>把要存储的大头卸载(offload)到CPU上，而把计算部分放到GPU上</p><p>ZeRO-Offload的做法是：</p><ul><li><strong>forward和backward计算量高</strong> ，因此和它们相关的部分，例如参数W（fp16），activation，就全放入GPU。</li><li><strong>update的部分计算量低</strong> ，因此和它相关的部分，全部放入CPU中。例如W(fp32)，optimizer states（fp32）和gradients(fp16)等。</li></ul><p>具体切分如下图：</p><p><img src="https://pic3.zhimg.com/80/v2-e9a588a403fe5e0b1f266faf47b6d31a_720w.webp" alt=""></p><p>ZeRO-infinity也是同理，它们在解决的事情都是：找个除GPU之外的地方，存数据。感兴趣的朋友可以深入研究，这里就不展开了。</p><h1>张量模型并行</h1><p>把模型的参数纵向切开，放到不同的GPU上进行独立计算，然后再做聚合。</p><p>假设现在W太大，导致单卡装不下。我们需要把W切开放到不同的卡上，则我们面临三个主要问题：</p><ul><li>怎么切分W。</li><li>切完W后，怎么做forward。</li><li>做完forward后，怎么做backward，进而求出梯度，更新权重。</li></ul><h2 id="按行切分权重">按行切分权重</h2><p><strong>forward</strong></p><p>我们用N来表示GPU的数量。有几块GPU，就把W按行维度切成几份。下图展示了N=2时的切割方式：</p><p><img src="https://pic3.zhimg.com/80/v2-a3219941a23cdd2ce1a3c352516e68fa_720w.webp" alt=""></p><p>W按照行维度切开后，X的维度和它不对齐了，这可怎么做矩阵乘法呢？很简单，再把X“按列切开”就行了，如下图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-c7e117053154a79a281d4e9c313f0898_720w.webp" alt=""></p><p><strong>backward</strong></p><p>做完forward，取得预测值Y，进而可计算出损失L，接下来就能做backward了。我们重画一下forward的过程，并在其中加入backward的部分，整体流程图如下：</p><p><img src="https://pic4.zhimg.com/80/v2-f23a9da7560340314fe42aff3a90709f_720w.webp" alt="img"></p><h2 id="按列切分权重">按列切分权重</h2><p><strong>forward</strong></p><p>按列切分权重后，forward计算图如下：</p><p><img src="https://pic1.zhimg.com/80/v2-b97f58d7420ec2cce8561158fe55681c_720w.webp" alt=""></p><p><strong>backward</strong></p><p><img src="https://pic4.zhimg.com/80/v2-4540e7bcea664717f17e0ad217f4fc23_720w.webp" alt="img"></p><p><a href="https://zhuanlan.zhihu.com/p/622212228">具体模型拆分方式：https://zhuanlan.zhihu.com/p/622212228</a></p><p>在实际应用中，对Transformer类的模型，采用最经典方法是张量模型并行 + 数据并行，并在数据并行中引入ZeRO做显存优化。具体的架构如下：</p><p><img src="https://pic4.zhimg.com/80/v2-0d097babc07ab0846b46c75254152703_720w.webp" alt=""></p><p>其中，node表示一台机器， <strong>一般我们在同一台机器的GPU间做张量模型并行。在不同的机器上做数据并行</strong> 。图中颜色相同的部分，为一个数据并行组。凭直觉，我们可以知道这么设计大概率和两种并行方式的通讯量有关。具体来说， <strong>它与TP和DP模式下每一层的通讯量有关，也与TP和DP的backward计算方式有关</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-20230502</title>
    <link href="/2023/05/02/diary/diary20230502/"/>
    <url>/2023/05/02/diary/diary20230502/</url>
    
    <content type="html"><![CDATA[<p>2023年5月2日，周二</p><span id="more"></span><p>干什么事情都没有动力，学习也不知道学什么，玩也不知道去哪，打球也略显尴尬，聊天也不知道找谁，刷剧也没有看下去的动力。</p><p>不管了，好久没有刷剧了，先刷一刷比较火的悬疑剧吧</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动青训营-抖音项目</title>
    <link href="/2023/03/03/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Project/"/>
    <url>/2023/03/03/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Project/</url>
    
    <content type="html"><![CDATA[<p>字节跳动青训营-抖音项目</p><span id="more"></span><h1>一、项目介绍</h1><p>“NoBugVideo”基于Gin Web框架，采用微服务架构，使用Kong集成Consul做服务发现，实现了“抖音”的基本功能，包括视频流的推送、视频投稿、用户的注册与登录，以及社交（用户之间的关注与聊天）与互动（用户对视频点赞及评论）等功能。</p><p>项目服务地址：<a href="http://124.221.120.88:8000">http://124.221.120.88:8000</a></p><p>Github地址：<a href="%5Bhttps://github.com/xu-jq/simple-DY%5D()">https://github.com/xu-jq/simple-DY</a></p><p>我们团队实现了包括<strong>基础功能</strong>在内的两大方向：<strong>互动方向</strong>与 <strong>社交方向</strong> ，根据项目考核的4个标准，自评如下：</p><table><thead><tr><th><strong>评价项</strong></th><th><strong>实现情况</strong></th></tr></thead><tbody><tr><td>功能实现</td><td>微服务与其他资源能够正常运行，完全实现文档中定义的全部接口，边界情况处理良好</td></tr><tr><td>代码质量</td><td>项目结构清晰，包划分合理，代码符合编码规范</td></tr><tr><td>服务性能</td><td>数据表设置了合理的索引，代码中尽量使用并行处理提高性能</td></tr><tr><td>安全可靠</td><td>通过GORM框架防止SQL注入，通过JWT进行用户的认证，防止越权</td></tr></tbody></table><h1>二、项目分工</h1><table><thead><tr><th><strong>团队成员</strong></th><th><strong>主要贡献</strong></th></tr></thead><tbody><tr><td><strong>@汪辉</strong></td><td>开发社交模块，搭建Kong集成Consul做服务发现</td></tr><tr><td><strong>@许珺琪</strong></td><td>开发用户互动相关模块包括点赞评论等相关接口、搭建redis服务</td></tr><tr><td><strong>@张兆</strong></td><td>开发用户模块与视频模块相关接口、搭建MySQL、RabbitMQ等服务</td></tr></tbody></table><h1>三、项目实现</h1><h3 id="3-1-技术选型与相关开发文档">3.1 技术选型与相关开发文档</h3><p>抖音上线于2016年9月26日，一开始是定位于专注于新生代的音乐创意短视频App，视频时常限制在15s内。年轻人比较爱赶新潮，乐于尝试新鲜事物，通过清晰明确定位在“潮流”“炫酷”“技术流”的方式，抖音吸引了第一批忠实粉丝。当产品功能逐渐完善后，抖音在运营方面开始发力，用户迎来大幅增长。抖音的主力用户群体年龄段上升，已经从早期的18岁到24岁，上升到了25岁到30岁用户。随着用户的快速增长，在内容层面也向着更加主流化、多元化的方向转变。</p><p>架构方面比较常见的有三种：</p><ol><li>单体应用</li></ol><p>所有的模块打包到一起部署运行，在开发小型项目上有独特优势：易于调试、部署，运维方便。缺点是容错性低，不可靠。只能通过运行更多的服务器水平扩展， 而不同的应用服务对资源的需求不同，且不可持续发展。</p><ol start="2"><li>SOA面向服务架构</li></ol><p>面向服务架构是一种设计方法，设计上通常是自上而下的，服务间松散耦合。ESB集成不同协议的服务，做消息的转化、解释、路由从而联通各个服务，解决企业通信问题，服务松耦合、可扩展。缺点是SOA更多的面向企业服务，服务拆分粒度很大，更多的是为了复用。</p><ol start="3"><li>微服务</li></ol><p>微服务是去中心化的SOA的扩展，强调服务彻底的组件化，一个组件就是一个产品，服务切分力度更小，设计上更多的是自下而上的。服务间通过轻量级的协议进行通信，并根据服务本身需要独立化部署。从产品视角出发，更多聚焦可扩展性，兼顾可维护性。</p><p>综合上述几种服务的对比，我们最终选择了微服务架构，并使用下面的技术栈：</p><ul><li>分布式中间件：Consul</li><li>网关：Kong</li><li>数据库：MySQL</li><li>orm框架：GORM</li><li>缓存：Redis</li><li>消息队列：RabbitMQ</li><li>对象存储：七牛云对象存储Kodo</li><li>Web框架：Gin</li><li>RPC 框架：GRPC</li><li>数据传输协议：protobuf</li><li>用户鉴权中间件：JWT</li><li>配置文件：viper</li></ul><h4 id="3-1-1-需求分析">3.1.1 需求分析</h4><h5 id="一、用户模块">一、用户模块</h5><p>用户模块包括用户注册、用户登录和用户信息三个部分。</p><ol><li><h6 id="用户注册接口-POST-douyin-user-register">用户注册接口 <code>POST-/douyin/user/register/</code></h6></li></ol><p>新用户注册时提供用户名，密码，昵称即可，用户名需要保证唯一。创建成功后返回用户 id 和权限token。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_register_request</span>&#123;    <span class="hljs-type">string</span> username = <span class="hljs-number">1</span>; <span class="hljs-comment">// 注册用户名，最长32个字符</span>    <span class="hljs-type">string</span> password = <span class="hljs-number">2</span>; <span class="hljs-comment">// 密码，最长32个字符</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_register_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    <span class="hljs-type">int64</span> user_id = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户id</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">4</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;</code></pre></div><ol start="2"><li><h6 id="用户登录接口-POST-douyin-user-login">用户登录接口 <code>POST-/douyin/user/login/</code></h6></li></ol><p>通过用户名和密码进行登录，登录成功后返回用户 id 和权限 token</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_login_request</span>&#123;    <span class="hljs-type">string</span> username = <span class="hljs-number">1</span>; <span class="hljs-comment">// 登录用户名</span>    <span class="hljs-type">string</span> password = <span class="hljs-number">2</span>; <span class="hljs-comment">// 登录密码</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_login_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    <span class="hljs-type">int64</span> user_id = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户id</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">4</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;</code></pre></div><ol start="3"><li><h6 id="用户信息接口-GET-douyin-user">用户信息接口 <code>GET-/douyin/user/</code></h6></li></ol><p>获取登录用户的 id、昵称，如果实现社交部分的功能，还会返回关注数和粉丝数。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_request</span>&#123;    <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    User user = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户信息</span>&#125;</code></pre></div><h5 id="二、视频模块">二、视频模块</h5><p>视频模块包括包括视频Feed流获取、视频投稿和获取用户投稿列表三个模块</p><ol><li><h6 id="视频流接口-GET-douyin-feed">视频流接口 <code>GET-/douyin/feed/</code></h6></li></ol><p>不限制登录状态，返回按投稿时间倒序的视频列表，视频数由服务端控制，单次最多30个。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_feed_request</span>&#123;    <span class="hljs-type">int64</span> latest_time = <span class="hljs-number">1</span>; <span class="hljs-comment">// 可选参数，限制返回视频的最新投稿时间戳，精确到秒，不填表示当前时间</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 可选参数，登录用户设置</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_feed_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 视频列表</span>    <span class="hljs-type">int64</span> next_time = <span class="hljs-number">4</span>; <span class="hljs-comment">// 本次返回的视频中，发布最早的时间，作为下次请求时的latest_time</span>&#125;</code></pre></div><ol start="2"><li><h6 id="发布列表接口-GET-douyin-publish-list">发布列表接口 <code>GET-/douyin/publish/list/</code></h6></li></ol><p>登录用户的视频发布列表，直接列出用户所有投稿过的视频。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_publish_list_request</span>&#123;    <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_publish_list_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户发布的视频列表</span>&#125;</code></pre></div><ol start="3"><li><h6 id="视频投稿接口-POST-douyin-publish-action">视频投稿接口 <code>POST-/douyin/publish/action/</code></h6></li></ol><p>登录用户选择视频上传。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_publish_action_request</span>&#123;    <span class="hljs-type">string</span> token = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户鉴权token</span>    <span class="hljs-type">bytes</span> data = <span class="hljs-number">2</span>; <span class="hljs-comment">// 视频数据</span>    <span class="hljs-type">string</span> title = <span class="hljs-number">3</span>; <span class="hljs-comment">// 视频标题</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_publish_action_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>&#125;</code></pre></div><h5 id="三、点赞模块">三、点赞模块</h5><ol><li><h6 id="点赞操作接口-POST-douyin-favorite-action">点赞操作接口 <code>POST-/douyin/favorite/action/</code></h6></li></ol><p>登录用户对视频进行点赞与取消点赞操作。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_action_request</span> &#123;   <span class="hljs-type">string</span> token = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户鉴权token</span>   <span class="hljs-type">int64</span> video_id = <span class="hljs-number">2</span>; <span class="hljs-comment">// 视频id</span>   <span class="hljs-type">int32</span> action_type = <span class="hljs-number">3</span>; <span class="hljs-comment">// 1-点赞，2-取消点赞</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_action_response</span> &#123;   <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>   <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>&#125;</code></pre></div><ol start="2"><li><h6 id="点赞列表接口-GET-douyin-favorite-list">点赞列表接口 <code>GET-/douyin/favorite/list/</code></h6></li></ol><p>登录用户的所有点赞视频。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_request</span> &#123;   <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>   <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_response</span> &#123;   <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>   <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>   <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户点赞视频列表</span>&#125;</code></pre></div><h5 id="四、评论模块">四、评论模块</h5><ol><li><h6 id="评论操作接口-POST-douyin-comment-action">评论操作接口 <code>POST-/douyin/comment/action/</code></h6></li></ol><p>登录用户对视频进行评论。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_comment_action_request</span> &#123;   <span class="hljs-type">string</span> token = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户鉴权token</span>   <span class="hljs-type">int64</span> video_id = <span class="hljs-number">2</span>; <span class="hljs-comment">// 视频id</span>   <span class="hljs-type">int32</span> action_type = <span class="hljs-number">3</span>; <span class="hljs-comment">// 1-发布评论，2-删除评论</span>   <span class="hljs-type">string</span> comment_text = <span class="hljs-number">4</span>; <span class="hljs-comment">// 用户填写的评论内容，在action_type=1的时候使用</span>   <span class="hljs-type">int64</span> comment_id = <span class="hljs-number">5</span>; <span class="hljs-comment">// 要删除的评论id，在action_type=2的时候使用</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_comment_action_response</span> &#123;   <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>   <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>   Comment comment = <span class="hljs-number">3</span>; <span class="hljs-comment">// 评论成功返回评论内容，不需要重新拉取整个列表</span>&#125;</code></pre></div><ol start="2"><li><h6 id="视频评论列表接口-GET-douyin-comment-list">视频评论列表接口 <code>GET-/douyin/comment/list/</code></h6></li></ol><p>查看视频的所有评论，按发布时间倒序。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_comment_list_request</span> &#123;   <span class="hljs-type">string</span> token = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户鉴权token</span>   <span class="hljs-type">int64</span> video_id = <span class="hljs-number">2</span>; <span class="hljs-comment">// 视频id</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_comment_list_response</span> &#123;   <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>   <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>   <span class="hljs-keyword">repeated</span> Comment comment_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 评论列表</span>&#125;</code></pre></div><h5 id="五、关注模块">五、关注模块</h5><ol><li><h6 id="关注操作接口-POST-douyin-relation-action">关注操作接口 <code>POST-/douyin/relation/action/</code></h6></li></ol><p>登录用户对其他用户进行关注或取消关注。实现用户之间的关注关系维护，登录用户能够关注或取关其他用户，同时自己能够看到自己关注过的所有用户列表，以及所有关注自己的用户列表。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_request</span> &#123;   <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>   <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_response</span> &#123;   <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>   <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>   <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户点赞视频列表</span>&#125;</code></pre></div><ol start="2"><li><h6 id="用户关注列表-GET-douyin-relatioin-follow-list">用户关注列表 <code>GET-/douyin/relatioin/follow/list/</code></h6></li></ol><p>登录用户关注的所有用户列表。</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_request</span> &#123;   <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>   <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_response</span> &#123;   <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>   <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>   <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户点赞视频列表</span>&#125;</code></pre></div><ol start="3"><li><h6 id="用户粉丝列表-GET-douyin-relation-follower-list">用户粉丝列表 <code>GET-/douyin/relation/follower/list/</code></h6></li></ol><p>所有关注登录用户的粉丝列表。</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_request</span> &#123;   <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>   <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_response</span> &#123;   <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>   <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>   <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户点赞视频列表</span>&#125;</code></pre></div><ol start="4"><li><h6 id="用户好友列表-GET-douyin-relation-friend-list">用户好友列表 <code>GET-/douyin/relation/friend/list/</code></h6></li></ol><p>互相关注的用户列表。</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_request</span> &#123;   <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>   <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_favorite_list_response</span> &#123;   <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>   <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>   <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户点赞视频列表</span>&#125;</code></pre></div><h5 id="六、消息模块">六、消息模块</h5><p>客户端通过定时轮询服务端接口查询消息记录</p><ol><li><h6 id="聊天记录-GET-douyin-message-chat">聊天记录 <code>GET-/douyin/message/chat/</code></h6></li></ol><p>当前登录用户和其他指定用户的聊天消息记录</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_message_chat_request</span>&#123;    <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> token=<span class="hljs-number">1</span>;<span class="hljs-comment">//用户鉴权token</span>    <span class="hljs-keyword">required</span> <span class="hljs-type">int64</span> to_user_id=<span class="hljs-number">2</span>;<span class="hljs-comment">//对方用户id</span>    <span class="hljs-keyword">required</span> <span class="hljs-type">int64</span> pre_msg_time=<span class="hljs-number">3</span>;<span class="hljs-comment">//上次最新消息的时间</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_message_chat_response</span> &#123;    <span class="hljs-keyword">required</span> int:<span class="hljs-number">32</span> status_code=<span class="hljs-number">1</span>;<span class="hljs-comment">//状态码，g-成功，其他值-失败</span>    <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> status._msg=<span class="hljs-number">2</span>;<span class="hljs-comment">//返回状态描述</span>    <span class="hljs-keyword">repeated</span> Message message_list=<span class="hljs-number">3</span>;<span class="hljs-comment">//消息列表</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">Message</span>&#123;    <span class="hljs-keyword">required</span> <span class="hljs-type">int64</span> id=<span class="hljs-number">1</span>;<span class="hljs-comment">//消息id</span>    <span class="hljs-keyword">required</span> <span class="hljs-type">int64</span> to_user_id=<span class="hljs-number">2</span>;<span class="hljs-comment">//该消息接收者的d</span>    <span class="hljs-keyword">required</span> <span class="hljs-type">int64</span> from_user_id=<span class="hljs-number">3</span>;<span class="hljs-comment">//该消息发送者的id</span>    <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> content=<span class="hljs-number">4</span>;<span class="hljs-comment">//消息内容</span>    <span class="hljs-keyword">optional</span> <span class="hljs-type">int64</span> create_time=<span class="hljs-number">5</span>;<span class="hljs-comment">//消息创建时间</span>&#125;</code></pre></div><ol start="2"><li><h6 id="消息操作-POST-douyin-message-action">消息操作 <code>POST-/douyin/message/action/</code></h6></li></ol><p>登录用户对消息的相关操作，目前只支持消息发送</p><div class="code-wrapper"><pre><code class="hljs ProtoBuf"><span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_relation_action_request</span>&#123;    <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> token=<span class="hljs-number">1</span>;<span class="hljs-comment">//用户鉴权token</span>    <span class="hljs-keyword">required</span> <span class="hljs-type">int64</span> to_user_id=<span class="hljs-number">2</span>;<span class="hljs-comment">//对方用户id</span>    <span class="hljs-keyword">required</span> <span class="hljs-type">int32</span> action_type=<span class="hljs-number">3</span>;<span class="hljs-comment">//1-发送消息</span>    <span class="hljs-keyword">required</span> <span class="hljs-type">string</span> content=<span class="hljs-number">4</span>;<span class="hljs-comment">//消息内容</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_relation_action_response</span>&#123;    <span class="hljs-keyword">required</span> <span class="hljs-type">int32</span> status._code=<span class="hljs-number">1</span>;<span class="hljs-comment">//状态码，g-成功，其他值-失败</span>    <span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> status_msg=<span class="hljs-number">2</span>;<span class="hljs-comment">//返回状态描述</span>&#125;</code></pre></div><h3 id="3-2-架构设计">3.2 架构设计</h3><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=MjJhNjc0MmNmMDc2YTM5ZTQxYTUzYTNlNWNmMzVhMjRfNDdGTDE1QXdqUnpNUDNFTVZnS242SHpibHpybk1nQ0tfVG9rZW46Ym94Y255NlhGcGsza3NUeFlOSzlPd3lUQ1BnXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><p><strong>运行流程：</strong></p><ol><li>后端服务启动，根据注册中心consul的地址（1.1.1.1:8500），将自己注册到注册中心 。</li><li>客户端访问域名，根据解析找到kong网关地址（2.2.2.2:8000）。</li><li>kong网关根据客户端传过来的服务名匹配到对应的Routes，再根据Routes找到对应的Service details 。</li><li>然后拿着Service details里面配置Host，去找consul地址（1.1.1.1:8600）。</li><li>根据名称查询consul的dns表，进而找到对应的ip+端口 。</li><li>找到对应的服务，然后通信。</li></ol><h4 id="3-2-1-用户模块">3.2.1 用户模块</h4><h5 id="1-整体架构设计">1. 整体架构设计</h5><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI5OWRmYzEyZTVhMTY0YTU0NGJjMDgzZjQ2NmUwYTlfSk1sZEVxcmtOQU00RlZiSTRwVXRmcnZyQ3VPeHZ0RnRfVG9rZW46Ym94Y25EY0pnWm9qaFBTa09xNjNJQTJoNUJmXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><h5 id="2-详细设计">2. 详细设计</h5><h6 id="2-1-用户注册">2.1. 用户注册</h6><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=YzdmZGI3MjZhYjBmNTExYjg1Nzk5OGUyNDIwODZmMGZfaFdBaUJuOFdEV2czVXpySzRCSFQ0QVNGOUpHMndOQXBfVG9rZW46Ym94Y25uaGdlbktoTmZscGFFeUhhek1ST1liXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><p>用户注册的逻辑比较简单，请求的参数中只包含用户的用户名与密码，不支持手机注册以及各种验证码操作。因此用户的唯一识别信息为用户名。如果数据库中存在相同的用户名，则认为这个用户已经存在，拒绝注册；否则则允许用户注册，并在数据库中分配给这个用户唯一的id。最后调用JWT生成Token返回响应，作为在Token生效期间的用户的唯一标识符。</p><p>用户注册流程：</p><ol><li>DY-api.UserRegister处理请求，将请求中带有的用户名和密码字段传递到服务端DY-srv.UserRegister</li><li>服务端根据用户名查询数据库，如果发现重名用户名，则直接返回错误</li><li>未发现重名用户名，则通过md5加盐（用户名）对密码进行加密，加密后插入数据库，数据库返回唯一自增ID</li><li>服务端返回成功响应给DY-api.UserRegister</li><li>DY-api.UserRegister利用响应中的ID信息，调用jwt进行Token生成，生成后构建客户端相应结构体给客户端</li></ol><h6 id="2-2-用户登录">2.2. 用户登录</h6><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=MDYyNWQyMGRiMTE4Yzg1OTFmMGMwNDIwZTNlZWU3YTJfekFJVzBQWnFIR2dnT0lqblNaNGpPeHM1aGZiS1VwcUVfVG9rZW46Ym94Y25BM0JzNllKbThIaDVnQ0F2TlZKQzRjXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><p>用户登录请求的参数中只包含用户的用户名与密码，不支持手机登录以及各种验证码操作。因此用户的唯一识别信息为用户名。如果数据库中不存在相同的用户名，则认为这个用户不存在，拒绝登录；否则则允许用户登录，并返回数据库中这个用户的唯一id。同时调用JWT生成Token返回响应，作为在Token生效期间的用户的唯一标识符。</p><p>用户登录流程：</p><ol><li>DY-api.UserLogin处理请求，将请求中带有的用户名和密码字段传递到服务端DY-srv.UserLogin</li><li>服务端根据用户名查询数据库，如果未发现相同用户名，则直接返回错误，否则返回通过用户名查询出来的用户id和密码</li><li>对用户输入的密码进行md5加盐（用户名）加密，与上一步返回的密码进行比较，如果不匹配直接返回错误</li><li>密码匹配，则服务端返回成功响应给DY-api.UserLogin</li><li>DY-api.UserLogin利用响应中的ID信息，调用jwt进行Token生成，生成后构建客户端相应结构体给客户端</li></ol><h6 id="2-3-用户信息">2.3. 用户信息</h6><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY2MzBhYjFjNzYyYzVhYmJmNTM3YzVkMjQyYjNiMmJfU0NCUkRQTUUxWFhPOFBGVWloUVFocXoyMXdXNDNoTktfVG9rZW46Ym94Y25qbkhZdUwyWXE4blRyeWNNME9ZMnBkXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><p>用户信息请求的参数包括要请求的用户的id和当前登录的用户的Token。返回的用户信息应该包括用户的名称，用户的关注人数和粉丝人数，以及用户与当前登录用户的关注关系。因此除了调用DY-api.UserInfo获取用户的基本信息之外，还需要调用DY-srv.GetFollowList与DY-srv.GetFollowerList获取用户的关注人和用户的粉丝列表。两个Count数值可以通过查看切片的大小获得，关注关系需要遍历切片进行搜索。</p><p>在对不同的服务进行调用的时候采取并行调用的方式，服务全部返回后在api层进行拼接，从而提高效率。</p><p>用户信息流程：</p><ol><li>DY-api.UserInfo处理请求，将请求中带有的id字段传递到服务端DY-srv.UserInfo、DY-srv.GetFollowList和DY-srv.GetFollowerList</li><li>并行请求三个服务，其中DY-srv.UserInfo根据id字段查询数据库，如果id有效，则返回用户姓名，否则返回错误</li><li>等待三个服务全部成功返回后，填充响应中的User的五个字段<ol><li>id与name字段通过DY-srv.UserInfo的响应直接获取</li><li>followcount通过获取DY-srv.GetFollowList返回的切片长度获取</li><li>followercount通过获取DY-srv.GetFollowerList返回的切片长度获取</li><li>通过Token获取当前的登录用户id，在DY-srv.GetFollowerList切片内部查询，如果查询到为True，否则为False</li></ol></li><li>构建响应结构体并返回给客户端</li></ol><h4 id="3-2-2-视频模块">3.2.2 视频模块</h4><h5 id="1-整体架构设计-2">1. 整体架构设计</h5><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=NmU3NjVjNzAwNmRjZDYzZGIzMTU4ZDllNTU3Y2Q5NzJfUHlydUtuQW54SVR2ZnZYVjNLckhXQzNZMW1IMFdoc3ZfVG9rZW46Ym94Y24xT0hLRElrQUdaY2l3RWxXMDF6R3ViXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt="img"></p><h5 id="2-详细设计-2">2. 详细设计</h5><h6 id="2-1-视频流">2.1. 视频流</h6><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY4NzM2YmI1YjIxMjVhODQ5MWJiY2JhYWYwN2QzZjdfeXI5TWJhenhXY1BQeG1CdFF1aDRwOWpzd2ZSNEZMblVfVG9rZW46Ym94Y25yZW1hbTVnYTJQNTZIUzJyelNPRmhjXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><p>获取视频流的请求参数包括视频的最新时间和当前用户的Token信息。如果当前用户在登录的状态下请求视频流，则通过最新时间在数据库中查询前30个视频的信息，包括视频本身的id和作者的id。获得最多30个视频的信息后，创建多个协程（视频数量个数），根据每个id获得视频的其他信息，如作者的详细信息，视频的点赞数量，作者的关注人数等等。在调用不同服务的时候也采用并行调用的方式。最后对返回的全部响应进行组织返回。</p><p>如果用户没有登录，则Token信息为空，那么返回的响应中缺少一些交互信息，如当前用户是否已经对当前视频点赞等等。</p><p>获取视频流流程：</p><ol><li><p>DY-api.Feed处理请求，准备请求服务</p></li><li><p>首先请求DY-srv.Feed服务，根据时间戳查询数据库，查询出不超过时间戳的前30个视频，查询后返回视频列表</p></li><li><p>随后并行请求视频列表中的每一个视频（即最大并发数为30）</p></li><li><p>对每一个视频，根据前一个服务响应的作者的id并行请求DY-srv.UserInfo、DY-srv.GetFollowList和DY-srv.GetFollowerList，等待全部成功返回后记录Author响应相关的5个字段</p></li><li><p>对每一个视频，根据视频id并行请求DY-srv.douyinCommentList和DY-srv.douyinLikeVideo，对于每个视频</p><ol><li>commentCount通过获取DY-srv.douyinCommentList返回的切片长度获取</li><li>favoriteCount通过获取DY-srv.douyinLikeVideo返回的切片长度获取</li><li>通过Token获取当前的登录用户id，在DY-srv.douyinLikeVideo切片内部查询，如果查询到为True，否则为False</li></ol></li><li><p>等待全部的视频返回响应后，构建响应结构体并返回给客户端</p></li></ol><h6 id="2-2-发布列表">2.2. 发布列表</h6><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjc0MjM5OGZlNjFkNDAzNGFkNTI5Y2FlYzYyYjUxMTBfTmJvZWZudHAwckk5cFJpMWNKcFczdlJ1NVJvWjFyOVdfVG9rZW46Ym94Y25lZUtQMlc0dTJQMU5tWlJaYjliOEdkXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><p>获取用户视频发布列表的请求参数包括用户的id和当前用户的Token信息。两者不一定是相同的用户，因为用户在观看视频的同时点击用户头像即可以看到这个视频作者的信息和作者的视频发布列表。</p><p>如果当前用户是查看自己的视频发布列表，则通过用户的id在数据库中查询发布的视频的信息。获得最多视频的信息后，创建多个协程（视频数量个数），根据每个id获得视频的其他信息，如视频的点赞数量，作者的关注人数等等。在调用不同服务的时候也采用并行调用的方式。最后对返回的全部响应进行组织返回。</p><p>如果Token信息为空，则当前场景是用户查看其他用户的发布视频列表。那么返回的响应中缺少一些交互信息，如当前用户是否已经对当前作者的视频点赞等等。</p><p>获取视频发布列表流程：</p><ol><li><p>DY-api.PublishList处理请求，准备请求服务</p></li><li><p>首先请求DY-srv.PublishList服务，根据id查询数据库，如果id在数据库中不存在，则直接返回错误，然后根据用户id查询发布的视频列表并返回</p></li><li><p>随后并行请求DY-srv.UserInfo、DY-srv.GetFollowList和DY-srv.GetFollowerList，等待全部成功返回后记录User响应相关的5个字段</p></li><li><p>对每一个视频，根据视频id并行请求DY-srv.douyinCommentList和DY-srv.douyinLikeVideo，对于每个视频</p><ol><li>commentCount通过获取DY-srv.douyinCommentList返回的切片长度获取</li><li>favoriteCount通过获取DY-srv.douyinLikeVideo返回的切片长度获取</li><li>通过Token获取当前的登录用户id，在DY-srv.douyinLikeVideo切片内部查询，如果查询到为True，否则为False</li></ol></li><li><p>等待全部的视频返回响应后，构建响应结构体并返回给客户端</p></li></ol><h6 id="2-3-视频投稿">2.3. 视频投稿</h6><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDdlMzEyODY4MmRiYjhmYjFiODU0Mjk4OWMwMTExYTdfOExUalZqY1hPeld1ZkhMM1E5b2twZ29rQnAzR2xoVmNfVG9rZW46Ym94Y25RR1Ztd3ZFTVFORGMzTjNtd0NjMmNoXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><p>视频投稿的请求参数中包括用户的Token，上传的视频流数据以及视频的标题。其中视频流是用户从本地上传得到的，视频的标题是用户自行输入得到的。上传视频必须是在登录的状态下，因此必须包含用户的Token信息。获得参数后，根据Token信息解析出当前用户的id，然后根据用户id判断是否存在这个用户的文件夹。如果不存在文件夹则新建用户文件夹。创建文件夹后将视频流写入这个文件夹下的视频文件，同时调用ffmpeg对视频的封面进行截取从而获得视频的首图。确认视频文件与图片文件都保存在本地后，构建返回的响应，并将上传文件的消息推送到消息队列中，此时消息队列将视频文件和图片文件异步上传到对象存储当中，上传结束后将视频信息写入数据库，在下次请求视频流的过程中就可以请求到这个视频了。</p><p>其中使用RabbitMQ进行异步处理，在服务器带宽有限的情况下，上传视频对用户来说基本无感，增加了用户的体验。且上传到对象存储后视频和图片的展示和下载速度也会更快，方便用户查看视频。</p><p>视频投稿流程：</p><ol><li>DY-api.PublishAction处理请求，将请求中的字段传递到服务端DY-srv.PublishAction</li><li>服务端从Token中获取id信息，如果无法获取id，直接返回错误</li><li>服务端根据id信息查询数据库，获取用户信息，如果id并不存在于数据库，则直接返回错误</li><li>服务端判断本地存放视频与图片文件的文件夹是否存在，如果不存在则创建文件夹</li><li>服务端将接收到的请求中的字节流写入文件，并调用ffmpeg对视频的第一帧进行截图作为封面，同样写入图片文件</li><li>服务端将文件上传信息传递给消息队列，直接返回成功响应给客户端</li><li>消息队列接收到消息后并行上传视频和图片文件，两者都上传成功后将视频信息写入数据库</li></ol><h4 id="3-2-3-点赞模块">3.2.3 点赞模块</h4><h5 id="1-整体架构设计-3">1. 整体架构设计</h5><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=ODFhZmQ0YmQ2NTZmZDEzZTA5ZjJmYWNlMTQ4YWQ5ZWFfU2ZCVEJwajA1QURYVHN4UVhJN2lyZXJCTE9mcWJrQ2VfVG9rZW46Ym94Y25Bb3NHcEhjV2twMk90dWxtYXFxMk5jXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt="img"></p><h5 id="2-详细设计-3">2. 详细设计</h5><h6 id="2-1-点赞操作">2.1 点赞操作</h6><p>点赞操作分为对未点赞的视频点赞以及对已点赞的视频取消点赞。点赞操作接口的请求参数包括，用户token；视频id；操作类型(1–点赞，2–取消点赞)。通过解析用户token可获得用户id。构建一个redis集合，将用户已经点赞的视频将其按照k-v形式存入redis。</p><p>2.1.1 对视频点赞</p><p>当请求参数操作类型的值为1时，即为点赞操作，点赞操作是要对用户未点赞的视频进行点赞，首先在redis集合中查询该用户是否对此视频点赞过，若点赞过则返回视频已点赞，若未点赞，则将该条点赞记录先插入redis再插入数据库中，最后返回成功的响应码。</p><p>2.1.2 对视频取消点赞</p><p>当请求参数操作类型的值为2时，即为取消点赞操作，取消点赞操作是要对用户点赞的视频进行取消，首先在redis集合中查询该用户是否对此视频点赞过，若未点赞过则返回视频暂未点赞，若点赞了，则将该条点赞记录先从redis中删除再从数据库中删除，最后返回成功的响应码。</p><h6 id="2-2-喜欢列表">2.2 喜欢列表</h6><p>喜欢列表接口的请求参数为用户id和用户token，先根据token验证用户身份与登录状态，若成功，则根据用户id查询用户的喜欢列表，将喜欢列表封装进响应结构体中，返回参数中还需要视频相关信息，通过调用视频服务接口，获取视频相关信息，并封装到响应结构体中，最终将响应结构体返回。</p><h4 id="3-2-4-评论模块">3.2.4 评论模块</h4><h5 id="1-整体架构设计-4">1. 整体架构设计</h5><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=OWVhZDA3Yjg5OTE1YjUwYjNhMGNmNjVlMGU3NDJkNDNfY0tWYnp0UllzcUFlaGx1ZnJuT1hsQ3pZSmlZd3pUQnhfVG9rZW46Ym94Y255bFZuTHB0WUQzNTVUOFVPWDQxTHFoXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt="img"></p><h5 id="2-详细设计-4">2. 详细设计</h5><h6 id="2-1-评论操作">2.1 评论操作</h6><p>评论操作分为发表评论和删除评论，评论操作接口的请求参数包括用户token，视频id，操作类型(1–发表评论，2–删除评论)，评论内容(发表评论时)，评论id(删除评论时)。首先根据token验证用户身份与登录状态，若成功，则解析token获取用户id。</p><p>2.1.1 发表评论</p><p>当操作类型等于1时，表示是发表评论，将对应评论内容，用户id，视频id，添加进数据库，并且将评论列表封装进响应结构体，同时调用社交服务，获取对应的用户信息，将用户信息也封装进响应结构体，最后将其返回。</p><p>2.1.2 删除评论</p><p>当操作类型等于2时，表示是删除评论，将评论id对应的数据从数据库中删除，并返回删除成功的信息。</p><h6 id="2-2-评论列表">2.2 评论列表</h6><p>评论列表接口的请求参数为视频id和用户token，先根据token验证用户身份与登录状态，若成功，则根据视频id查询视频的评论列表，将评论列表封装进响应结构体中，返回参数中还需要用户相关信息，通过调用社交服务接口，获取用户相关信息，并封装到响应结构体中，最终将响应结构体返回。</p><h4 id="3-2-5-社交模块">3.2.5 社交模块</h4><p>社交模块的整体设计如下图：</p><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=YThkZTI0YWE3OGJkNWUyN2QwYzEyMjIwZmY0YzljNzFfZktHVmZ5Q09tdkF6N2N4bGRsd3hCblhWZ3VXNGhhdVRfVG9rZW46Ym94Y24zRjZTcjVWeEpaZXl4WDdEUXptTkJlXzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><p>其中 <code>social-api</code>程序是使用Gin框架搭建的Web服务。主要接受url请求，通过路由绑定handler处理函数，添加授权中间件。<code>social-api</code>部署了多个，并将自己注册在Consule服务上，支持负载均衡，并通过服务发现调用gRPC服务。</p><p><code>social-srv</code>是业务处理代码，主要和MySQL数据库打交道。<code>social-srv</code>可以部署在多个不同服务器上，并将自己注册到Consul上来实现负载均衡，提供被其他服务发现。</p><p><strong>详细设计：</strong></p><ol><li>关注模块</li></ol><p>关注接口的请求参数为用户ID和被关注的用户ID，先根据token验证用户身份与登录状态，若成功，则向数据库插入数据，同时互相关注的用户会成为朋友，在朋友界面显示朋友列表，并展现最近的一条消息。用户也可以在信息详情页面来查看关注的用户和粉丝。</p><ol start="2"><li>消息模块</li></ol><p>通过用户ID和朋友ID可以新增一条消息。使用定时调用接口的方式来获取消息。</p><h3 id="3-3-数据库设计">3.3 数据库设计</h3><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDk5OTA0ODM2OWMzZmE3ZWU0ZTQyMTIwMTNlMzNiMzlfeHFqb3kxVENUU2pQUEpLSkw4YzA0VEE5NUpjWmd3SWJfVG9rZW46Ym94Y25wbmU2V1hWaGZJREpkenRXb3FQTEI2XzE2NzgxOTgyMjM6MTY3ODIwMTgyM19WNA" alt=""></p><h4 id="3-3-1-videos表">3.3.1 videos表</h4><p>字段如下：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>id</code></td><td>bigint</td><td>视频唯一id，自增主键</td></tr><tr><td><code>author_id</code></td><td>bigint</td><td>视频作者id</td></tr><tr><td><code>file_name</code></td><td>varchar</td><td>文件名称</td></tr><tr><td><code>publish_time</code></td><td>bigint</td><td>发布时间</td></tr><tr><td><code>title</code></td><td>varchar</td><td>视频标题</td></tr></tbody></table><p>索引设置：</p><ol><li>视频唯一id的自增主键索引</li><li>发布时间的索引，用户在数据库中查询指定时间范围的视频</li><li>作者id的索引，用于查询指定作者的视频列表</li></ol><h4 id="3-3-2-users表">3.3.2 users表</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>id</code></td><td>bigint</td><td>用户id，自增主键</td></tr><tr><td><code>name</code></td><td>varchar</td><td>用户名</td></tr><tr><td><code>password</code></td><td>varchar</td><td>用户密码</td></tr></tbody></table><p>索引设置：</p><ol><li>用户id的自增主键索引</li><li>用户名与密码的联合索引，用于在数据库中匹配用户</li></ol><h4 id="3-3-3-comments表">3.3.3 comments表</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>id</code></td><td>bigint</td><td>评论唯一id，自增主键</td></tr><tr><td><code>user_id</code></td><td>bigint</td><td>评论发布者的id</td></tr><tr><td><code>video_id</code></td><td>bigint</td><td>评论发布位置的视频id</td></tr><tr><td><code>comment_text</code></td><td>varchar</td><td>评论内容</td></tr><tr><td><code>create_time</code></td><td>datetime</td><td>评论创建时间</td></tr></tbody></table><p>索引设置：</p><ol><li>评论id的自增主键索引</li><li>视频id的索引，用于在数据库中查询某条视频对应的评论内容</li></ol><h4 id="3-3-4-follows表">3.3.4 follows表</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>id</code></td><td>bigint</td><td>关注关系id，自增主键</td></tr><tr><td><code>user_id</code></td><td>bigint</td><td>用户id</td></tr><tr><td><code>follower_id</code></td><td>bigint</td><td>关注的用户id</td></tr></tbody></table><p>索引设置：</p><ol><li>关注关系id的自增主键索引</li><li>用户id和关注的用户id的联合索引，用于在数据库中查询两个用户之间的关注关系</li><li>关注的用户id索引，用于在数据库中查询用户的关注关系</li></ol><h4 id="3-3-5-likes表">3.3.5 likes表</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>id</code></td><td>bigint</td><td>喜欢关系id，自增主键</td></tr><tr><td><code>user_id</code></td><td>bigint</td><td>点赞用户的id</td></tr><tr><td><code>video_id</code></td><td>bigint</td><td>被点赞的视频id</td></tr></tbody></table><p>索引设置：</p><ol><li>喜欢关系id的自增主键索引</li><li>用户和点赞视频的联合索引，用于在数据库中查询某个用户是否对某个视频点赞</li><li>用户id索引，用于在数据库中查询某个用户的点赞的视频的id</li><li>视频id索引，用于在数据库中查询某个视频的点赞用户的id</li></ol><h4 id="3-3-6-messages表">3.3.6 messages表</h4><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>id</code></td><td>bigint</td><td>消息唯一id，自增主键</td></tr><tr><td><code>user_id</code></td><td>bigint</td><td>发送消息的用户id</td></tr><tr><td><code>to_user_id</code></td><td>bigint</td><td>接收消息的用户id</td></tr><tr><td><code>sent_time</code></td><td>datetime</td><td>消息发送时间</td></tr><tr><td><code>content</code></td><td>varchar</td><td>消息内容</td></tr></tbody></table><p>索引设置：</p><ol><li>消息id的自增主键索引</li><li>发送用户id索引，用于查询数据库中指定的用户发送的消息</li><li>接收用户id索引，用于查询数据库中指定的用户接收的消息</li></ol><h3 id="3-4-项目代码介绍">3.4 项目代码介绍</h3><p>后端项目总体分为两个大部分：</p><ol><li>web项目（<code>simple-DY/DY-api/</code>）：使用Gin框架来获取用户请求，连接GRPC远程调用服务，最后返回数据。</li><li>service项目（<code>simple-DY/DY-srvs/</code>）：GRPC编写的微服务。</li></ol><p>项目的总体结构如下所示：</p><div class="code-wrapper"><pre><code class="hljs Bash">├── simple-DY│   ├── db.sql        // 数据库初始化文件│   ├── DY-api           // web项目│   │   ├── interact-web    // 互动模块│   │   ├── social-web      // 社交模块│   │   └── video-web       // 视频模块│   ├── DY-srvs          // service项目│   │   ├── interact-srv    // 互动模块│   │   ├── social-srv      // 社交模块│   │   └── video-srv       // 视频模块│   ├── go.mod│   ├── go.sum│   └── README.md</code></pre></div><h4 id="3-4-1-video服务（包括视频模块和用户模块）">3.4.1 video服务（包括视频模块和用户模块）</h4><ol><li>api层</li></ol><p>代码结构：</p><div class="code-wrapper"><pre><code class="hljs Bash">video-web├── api│   ├── base.go│   ├── feed.go│   ├── info.go│   ├── otherapi.go│   ├── publishaction.go│   ├── publishlist.go│   ├── userinfo.go│   ├── userlogin.go│   └── userregister.go├── config│   └── config.go├── config-debug.yaml├── config-pro.yaml├── global│   └── global.go├── initialize│   ├── config.go│   ├── logger.go│   ├── router.go│   ├── srv_conn.go│   └── validator.go├── logs│   └── video-web.log├── main.go├── middlewares│   ├── cors.go│   └── jwt.go├── models│   ├── base.go│   ├── jwt.go│   ├── other.go│   ├── request.go│   └── response.go├── proto│   ├── simpledy_grpc.pb.go│   ├── simpledy.pb.go│   └── simpledy.proto├── README.md└── utils    └── consul        └── register.go</code></pre></div><p>详细说明：</p><ul><li><code>api</code>：编写路由的Handler处理函数</li><li><code>config</code>：读取yaml文件时的接收结构体</li><li><code>*.yaml</code>：配置文件<ul><li><code>config-debug.yaml</code>：线下开发使用的配置文件</li><li><code>config-pro.yaml</code>: 线上配置文件</li></ul></li><li><code>global</code>：存放全局变量，例如config信息，连接信息等</li><li><code>initialize</code>：初始化程序代码<ul><li><code>config.go</code>：读取配置文件</li><li><code>logger.go</code>：日志配置</li><li><code>router.go</code>：gin路由</li><li><code>srv_conn.go</code>：连接微服务</li><li><code>validator.go</code>：翻译器</li></ul></li><li><code>logs</code>：日志文件</li><li><code>main.go</code>：主程序入口</li><li><code>middlewares</code>：gin的自定义中间件<ul><li><code>cors.go</code>：跨域中间件</li><li><code>jwt.go</code>：JWT中间件</li></ul></li><li><code>models</code>：用户请求参数的结构体</li><li><code>proto</code>：编写和生成proto文件</li><li><code>README.md</code>：说明文件</li><li><code>utils</code>：工具类<ul><li><code>consul</code>：调用consul api进行服务注册发现等操作</li></ul></li></ul><ol start="2"><li>srv层</li></ol><p>代码结构：</p><div class="code-wrapper"><pre><code class="hljs Bash">.├── config│   └── config.go├── config-debug.yaml├── config-pro.yaml├── global│   └── global.go├── handler│   ├── base.go│   ├── feed.go│   ├── publishaction.go│   ├── publishlist.go│   ├── userinfo.go│   ├── userlogin.go│   ├── userregister.go│   └── videoinfo.go├── initialize│   ├── config.go│   ├── db.go│   ├── handler.go│   └── logger.go├── logs│   └── video-srv.log├── main.go├── models│   ├── base.go│   └── db.go├── proto│   ├── simpledy_grpc.pb.go│   ├── simpledy.pb.go│   └── simpledy.proto├── README.md└── utils    ├── backup    │   └── backup.go    ├── consul    │   └── register.go    ├── dao    │   ├── followdao.go    │   ├── userdao.go    │   └── videodao.go    ├── ffmpeg    │   └── extractFirstFrame.go    ├── freeport    │   └── port.go    ├── jwt    │   └── token.go    ├── md5salt    │   └── md5.go    ├── oss    │   └── upload.go    └── rabbitmq        ├── base.go        ├── consumer.go        └── producer.go</code></pre></div><p>详细说明：</p><ul><li><code>config</code>：读取yaml文件时的接收结构体</li><li><code>*.yaml</code>：配置文件<ul><li><code>config-debug.yaml</code>：线下开发使用的配置文件</li><li><code>config-pro.yaml</code>: 线上配置文件</li></ul></li><li><code>global</code>：存放全局变量，例如config信息，连接信息等</li><li><code>handler</code>：主要的逻辑代码，proto的service的实现类</li><li><code>initialize</code>：初始化程序代码<ul><li><code>config.go</code>：读取配置文件</li><li><code>db.go</code>：数据库全局连接</li><li><code>handler.go</code>：监听客户端连接</li><li><code>logger.go</code>：日志配置</li></ul></li><li><code>logs</code>：日志文件</li><li><code>main.go</code>：主程序入口</li><li><code>models</code>：用户请求参数的结构体</li><li><code>proto</code>：编写和生成proto文件</li><li><code>README.md</code>：说明文件</li><li><code>utils</code>：工具类<ul><li><code>backup</code>：备份用户上传的视频和图片文件</li><li><code>consul</code>：调用consul api进行服务注册发现等操作</li><li><code>dao</code>：数据库相关操作</li><li><code>ffmpeg</code>：视频首页截图</li><li><code>freeport</code>：获取空闲网络端口</li><li><code>jwt</code>：鉴权Token的生成与解析</li><li><code>md5salt</code>：密码加密存储</li><li><code>oss</code>：七牛云对象存储相关操作</li><li><code>rabbitmq</code>：消息队列相关操作</li></ul></li></ul><h4 id="3-4-2-interact服务（包括点赞模块和评论模块）">3.4.2 interact服务（包括点赞模块和评论模块）</h4><ol><li>api层</li></ol><div class="code-wrapper"><pre><code class="hljs Bash">interact-web├── api│   ├── base.go│   ├── comment.go│   └── like.go├── config│   └── config.go├── global│   └── global.go├── initialize│   ├── config.go│   ├── logger.go│   ├── router.go│   ├── srv_conn.go│   └── validator.go├── main.go├── middlewares│   ├── cors.go│   └── jwt.go├── models│   └── request.go├── proto│   ├── simpledy_grpc.pb.go│   ├── simpledy.pb.go│   └── simpledy.proto├── router│   ├── comment.go│   └── like.go└── utils    └── register        └── consul            └── register.go</code></pre></div><ol start="2"><li>srv层</li></ol><div class="code-wrapper"><pre><code class="hljs Bash">interact-srv├── build.sh├── config│   └── config.go├── global│   └── global.go├── handler│   └── interact.go├── initalize│   ├── config.go│   ├── db.go│   ├── logger.go│   ├── rdb.go│   └── srvs_conn.go├── main.go├── model│   ├── base.go│   ├── comment.go│   ├── like.go│   └── video.go├── proto│   ├── simpledy_grpc.pb.go│   ├── simpledy.pb.go│   └── simpledy.proto└── utils    ├── addr.go    ├── jwt    │   └── token.go    ├── key    │   └── key.go    └── register        └── consul            └── register.go</code></pre></div><h4 id="3-4-3-social服务（包括关注模块和消息模块）">3.4.3 social服务（包括关注模块和消息模块）</h4><ol><li>api层</li></ol><div class="code-wrapper"><pre><code class="hljs Bash">social-web├── api│   ├── base.go│   ├── message.go│   └── relation.go├── config│   └── config.go├── config-debug.yaml├── config-pro.yaml├── forms│   ├── message.go│   └── relation.go├── global│   └── global.go├── initialize│   ├── config.go│   ├── logger.go│   ├── router.go│   ├── srv_conn.go│   └── validator.go├── main.go├── middlewares│   ├── cors.go│   └── jwt.go├── models│   └── request.go├── proto│   ├── simpledy_grpc.pb.go│   ├── simpledy.pb.go│   └── simpledy.proto├── router│   ├── message.go│   └── relation.go└── utils    ├── addr.go    └── register        └── consul            └── register.go</code></pre></div><ol start="2"><li>srv层</li></ol><div class="code-wrapper"><pre><code class="hljs Bash">social-srv├── build.sh├── config│   └── config.go├── config-debug.yaml├── config-pro.yaml├── global│   └── global.go├── handler│   └── social.go├── initialize│   ├── config.go│   ├── db.go│   └── logger.go├── main.go├── model│   └── base.go└── proto    ├── simpledy_grpc.pb.go    ├── simpledy.pb.go    └── simpledy.proto</code></pre></div><h1>四、测试结果</h1><h2 id="4-1-功能测试">4.1 功能测试</h2><p>通过Apifox的自动化测试，构建不同实际使用中可能遇到的情况，对接口进行充分测试。</p><h3 id="1-用户注册接口-douyin-user-register">1. 用户注册接口 <code>/douyin/user/register/</code></h3><p>需要对如下的用例进行测试：</p><ol><li>注册不存在的用户名-返回成功响应</li><li>注册已经存在的用户名-返回失败响应</li></ol><p>测试结果：</p><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGY5NWVkMzk1MGQ3ZTczNTIyMTdkOTI2NjQ5YTU1MTVfa01vZmhlRExwQkVZcDQxRFd5VlNiRk85cjEyZkUxb2lfVG9rZW46Ym94Y24xMkg3QmU2NExQQm1wMlZnTG0za1ViXzE2NzgxOTg3OTQ6MTY3ODIwMjM5NF9WNA" alt="img"></p><h3 id="2-用户登录接口-douyin-user-login">2. 用户登录接口 <code>/douyin/user/login/</code></h3><p>需要对如下的用例进行测试：</p><ol><li>登录已经存在的用户名且密码正确-返回成功响应</li><li>登录不存在的用户名-返回失败响应</li><li>登录已经存在的用户名，但是密码错误-返回失败响应</li></ol><p>测试结果：</p><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=MTIyNWQ5MGQ5NzlhOWZjOWYxMDQzNjI4YmNkYjNkZmZfM2tIVFlEaEhIcGxwSGxRcndpNGpTc2JqSWNVMmszVGdfVG9rZW46Ym94Y25pcThzY0JSZmJDcW5KSEpnY3NVM2NlXzE2NzgxOTg3OTQ6MTY3ODIwMjM5NF9WNA" alt="img"></p><h3 id="3-用户信息接口-douyin-user">3. 用户信息接口 <code>/douyin/user/</code></h3><p>需要对如下的用例进行测试：</p><ol><li>用户id存在且Token正确-返回成功响应</li><li>用户id存在但Token为空或不正确-返回成功响应（但是没有是否关注与是否点赞等关系信息）</li><li>用户id不存在-返回失败响应</li></ol><p>测试结果：</p><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=MGEyOGM5ODc2NmRjM2EzZmEyNjA2Y2IzMGUxMmY3OGJfeXdiMXNPWTJTS2U1ZW83SVl3SlhTblFaeTgxWlZvSktfVG9rZW46Ym94Y24zTmJuak5MNVVNWW54ZGNScGl3UEdjXzE2NzgxOTg4ODc6MTY3ODIwMjQ4N19WNA" alt="img"></p><h3 id="4-视频流接口-douyin-feed">4. 视频流接口 <code>/douyin/feed/</code></h3><p>需要对如下的用例进行测试：</p><ol><li>未登录用户请求视频流（包括Token错误的情况）-返回成功响应（但是缺少是否对视频点赞等关系信息）</li><li>登录用户请求视频流-返回完整的成功响应</li></ol><p>测试结果：</p><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmM3ZTEyYmQ0ZmE5ZTg2ZTVhYWI5YjlhZjBiODZlZjJfOG84a29PMVp0a25Ga1ZXM0xXNnBMWEhkeXI5aGVGbExfVG9rZW46Ym94Y25tY1BlWUl5NGFwanpPY2dsd093cEdkXzE2NzgxOTg4ODc6MTY3ODIwMjQ4N19WNA" alt="img"></p><h3 id="5-发布列表接口-douyin-publish-list">5. 发布列表接口 <code>/douyin/publish/list/</code></h3><p>需要对如下的用例进行测试：</p><ol><li>用户id存在且Token正确-返回成功响应</li><li>用户id存在但Token为空或不正确-返回成功响应（但是没有是否点赞等关系信息）</li><li>用户id不存在-返回失败响应</li></ol><p>测试结果：</p><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg2MzMwYzNjNmY0MGE5ZmIzY2I0OWFiYjgwNjJiYTBfTXBwN29GQmlDVWRzVGNDSHFyaTBtdzdBeUVqZFNnbThfVG9rZW46Ym94Y25zTjJEN1l6dGtmQmpnNGJWOGp2M29kXzE2NzgxOTg4ODc6MTY3ODIwMjQ4N19WNA" alt="img"></p><h3 id="6-视频投稿接口-douyin-publish-action">6. 视频投稿接口 <code>/douyin/publish/action/</code></h3><p>需要对如下的用例进行测试：</p><ol><li>正常上传视频-返回成功响应</li><li>Token为空或Token不正确-返回错误响应</li></ol><p>测试结果：</p><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=N2RlZDUwMDU0Y2FmMjFkZDgxYjU4MjU4NzY0YTkyMDRfRXRadFpVdE9xeDRmbUlqOEU5TVRteUpnWjU1Q0lGd3RfVG9rZW46Ym94Y25TVGR4QnQ0TkFuQ3ZneWZBWm1pYkxmXzE2NzgxOTg4ODc6MTY3ODIwMjQ4N19WNA" alt="img"></p><h3 id="7-社交模块">7. 社交模块</h3><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U5ZDc5NTBiNDczOWZlNTdlYmRlOTI3M2E5YzE0YThfMlV4V2ZURFU3dFdkTHNZdHZpT0VjSEZYamJxellGRkdfVG9rZW46Ym94Y252RzRrckJKUzMzZU1BdEE2QWM0YWxiXzE2NzgxOTg4ODc6MTY3ODIwMjQ4N19WNA" alt="img"></p><h3 id="8-互动模块">8. 互动模块</h3><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=YzJiMTkxNjM1NmE3ZTliZjdmMzMxMWIwMzNhOGM1N2ZfNWFFaTJUQjF0UFhkOGlacFhDMGg2R2hrYnB5VHlRRXZfVG9rZW46Ym94Y243U05qUVNtS3NWTFQ5WjJpRDRoa21QXzE2NzgxOTg4ODc6MTY3ODIwMjQ4N19WNA" alt=""></p><h2 id="4-2-性能测试">4.2 性能测试</h2><p><img src="https://aobcmgpdn3.feishu.cn/space/api/box/stream/download/asynccode/?code=YjljYTUxYzBmOTIzMjBiOTBhMzFkMDJhNzQ1ZjBhMDBfaWo5WmFZN0lxZWFhYjRKN0t1VUZiVjI1QU9ud0xlR3JfVG9rZW46Ym94Y25JRVhvZGF5bE1iQ25FWUZmcHdtU0dqXzE2NzgxOTg4ODc6MTY3ODIwMjQ4N19WNA" alt=""></p><h1>五、其他资料</h1><p><a href="https://www.apifox.cn/apidoc/shared-09d88f32-0b6c-4157-9d07-a36d32d7a75c/api-50707523">接口文档（旧版）</a></p><p><a href="https://aobcmgpdn3.feishu.cn/docx/ObOndji8SoyABTxbRqRc9TpWnoe">汇报文档</a></p><p><a href="https://bytedance.feishu.cn/docx/HfjBdjnw8oWjUFxfD2Mcwq6bn8e">课程汇总</a></p><p><a href="https://bytedance.feishu.cn/docs/doccnKrCsU5Iac6eftnFBdsXTof#">抖音项目方案说明</a></p><p><a href="https://bytedance.feishu.cn/docs/doccnM9KkBAdyDhg8qaeGlIz7S7">极简抖音App使用说明</a></p><p><a href="https://bytedance.feishu.cn/docx/TW70dNfR4oJx4KxfzkNc4Zg5n1b">青训营大项目答疑</a></p><h1>六、项目总结与反思</h1><h2 id="1-目前仍存在的问题">1. 目前仍存在的问题</h2><ul><li>在视频模块中，上传视频的大小有限制，如果超过了限制会返回网络错误，无法将视频字节流传递到服务器端。</li><li>观看视频时，一个服务器的宽带顶不住，有点卡。</li><li>获取消息的API由于是定时查询，消息会重叠。</li><li>若出现对短时间内一个视频进行大量点赞操作，写入数据库操作会太频繁，可以考虑将点赞记录进行定期写入数据库。</li></ul><h2 id="2-已识别出的优化项">2. 已识别出的优化项</h2><ul><li>视频模块中可以对用户的视频习惯进行分类，每一次获取视频流的时候对用户进行视频推荐</li><li>用户模块可以增加邮箱或手机号等验证方式，并添加密码找回的功能，增加安全性</li><li>粉丝列表、用户的聊天记录、关注列表和朋友列表可以使用Redis的List数据结构来存储，来降低MySQL的压力</li><li>用户聊天的消息推送可以使用websocket长连接来避免每次建立链接释放链接所消耗的资源。</li><li>用户聊天的消息推送可以使用MQ消息队列来实现，不查表可以减低MySQL压力和消息的实时性。</li><li>点赞功能将点赞记录存在redis中，减少数据库查询压力。</li></ul><h2 id="3-架构演进的可能性">3. 架构演进的可能性</h2><ul><li>微服务基本根据路由进行拆分，拆分不够合理，服务之间耦合的地方稍多。后续可以将微服务进行进一步拆分，真正做到将所有的功能打包成独立的单元。</li><li>可以从微服务架构演进为Serverless。Serverless是一种构建和管理基于微服务架构的完整流程，允许你在服务部署级别而不是服务器部署级别来管理你的应用部署。它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态（Stateless）、暂存（可能只存在于一次调用的过程中）计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时。Serverless真正做到了部署应用无需涉及基础设施的建设，自动构建、部署和启动服务。</li></ul><h2 id="4-项目过程中的反思与总结">4. 项目过程中的反思与总结</h2><p>在参加青训营期间，官方提供了全面的课程，涵盖了创作技巧、内容制作、问题分析等多个方面。这些课程不仅提供了实用的知识和技能，还可以让我们更好地理解抖音平台和用户需求。抖音青训营项目还提供了多种资源支持，包括专业导师、团队合作等。这些资源可以帮助我们更好地实践和落地自己的创意。</p><p>回顾整个项目的过程，我们团队做了如下总结：</p><ul><li>在代码编写的过程中，保持良好的编码规范不仅对自己以后复习代码节省时间，同事对代码的理解也会更方便。</li><li>在实践中学习新的知识和技能。</li><li>好记性不如烂笔头。伴学笔记的习惯值得我们继续保持。</li><li>在协作开发中，团队的活力来源于不断的交流。通过交流和合作，我们学到了很多新的创作思路和理念。</li></ul><h1>七、参考资料</h1><p><strong><a href="https://grpc.io/">https://grpc.io/</a></strong></p><p><strong><a href="https://www.jianshu.com/p/4e4ff6be6af9">https://www.jianshu.com/p/4e4ff6be6af9</a></strong></p><p><strong><a href="https://www.apifox.cn/apidoc/shared-09d88f32-0b6c-4157-9d07-a36d32d7a75c/api-50707523">https://www.apifox.cn/apidoc/shared-09d88f32-0b6c-4157-9d07-a36d32d7a75c/api-50707523</a></strong></p><p><strong><a href="https://juejin.cn/post/7174037539345399839">https://juejin.cn/post/7174037539345399839</a></strong></p><p><strong><a href="https://blog.csdn.net/cc18868876837/article/details/90672971">https://blog.csdn.net/cc18868876837/article/details/90672971</a></strong></p><p><strong><a href="https://www.woshipm.com/evaluating/1552722.html">https://www.woshipm.com/evaluating/1552722.html</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka简单示例</title>
    <link href="/2023/03/03/Backend/Kafka/"/>
    <url>/2023/03/03/Backend/Kafka/</url>
    
    <content type="html"><![CDATA[<p>Kafka简单示例</p><span id="more"></span><h1>Kafka</h1><h2 id="安装">安装</h2><p>首先需要安装Java</p><div class="code-wrapper"><pre><code class="hljs Go">sudo apt install openjdk<span class="hljs-number">-11</span>-jdk</code></pre></div><p>下载安装kafka</p><div class="code-wrapper"><pre><code class="hljs Bash">wget https://dlcdn.apache.org/kafka/3.4.0/kafka_2.13-3.4.0.tgztar -xzf kafka_2.13-3.4.0.tgz<span class="hljs-built_in">cd</span> kafka_2.13-3.4.0</code></pre></div><p>启动zookeeper和kafka：</p><div class="code-wrapper"><pre><code class="hljs Bash">bin/zookeeper-server-start.sh config/zookeeper.propertiesbin/kafka-server-start.sh config/server.properties</code></pre></div><h2 id="go连接Kafka使用">go连接Kafka使用</h2><h3 id="生产者">生产者</h3><p>使用给定代理地址和配置创建一个同步生产者</p><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-comment">// 使用给定代理地址和配置创建一个同步生产者</span>SyncProducer, err := sarama.NewSyncProducer(    []<span class="hljs-type">string</span>&#123;conn&#125;,    config,)</code></pre></div><p>config可以自由配置：</p><div class="code-wrapper"><pre><code class="hljs Go">config := sarama.NewConfig()<span class="hljs-comment">// 等待服务器所有副本都保存成功后的响应</span>config.Producer.RequiredAcks = sarama.WaitForAll<span class="hljs-comment">// 随机的分区类型：返回一个分区器，该分区器每次选择一个随机分区</span>config.Producer.Partitioner = sarama.NewRandomPartitioner<span class="hljs-comment">// 是否等待成功和失败后的响应</span>config.Producer.Return.Successes = <span class="hljs-literal">true</span></code></pre></div><p>构建发送的消息：</p><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-comment">// 构建发送的消息</span>msg := &amp;sarama.ProducerMessage&#123;    Topic: topic,    Key:   sarama.StringEncoder(time.Now().String()),    Value: sarama.StringEncoder(content),&#125;</code></pre></div><p>生产者发送消息：</p><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-comment">// SendMessage：该方法是生产者生产给定的消息</span><span class="hljs-comment">// 生产成功的时候返回该消息的分区和所在的偏移量</span><span class="hljs-comment">// 生产失败的时候返回error</span>partition, offset, err := SyncProducer.SendMessage(msg)</code></pre></div><h3 id="消费者">消费者</h3><p>创建一个消费者的实例</p><div class="code-wrapper"><pre><code class="hljs Go">config := sarama.NewConfig()consumer, err := sarama.NewConsumer(c.Node, config)</code></pre></div><p>查询这个 topic 有多少分区</p><div class="code-wrapper"><pre><code class="hljs Go">partitions, err := consumer.Partitions(c.Topic)</code></pre></div><p>每个分区开一个 goroutine 来消费</p><div class="code-wrapper"><pre><code class="hljs Go">wg.Add(<span class="hljs-built_in">len</span>(partitions))<span class="hljs-comment">// 然后每个分区开一个 goroutine 来消费</span><span class="hljs-keyword">for</span> _, partitionId := <span class="hljs-keyword">range</span> partitions &#123;    <span class="hljs-comment">//不开异步会导致一个消费完才会消费另外一个</span>    <span class="hljs-keyword">go</span> c.consumeByPartition(consumer, c.Topic, partitionId, &amp;wg)&#125;</code></pre></div><p>消费</p><div class="code-wrapper"><pre><code class="hljs Go">partitionConsumer, err := consumer.ConsumePartition(topic, partitionId, sarama.OffsetNewest)<span class="hljs-comment">// 然后可以通过partitionConsumer.Messages()打印得到的消息</span></code></pre></div><h3 id="主函数">主函数</h3><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    Conn := <span class="hljs-string">&quot;127.0.0.1:9092&quot;</span>    topic := <span class="hljs-string">&quot;test_log&quot;</span>    <span class="hljs-keyword">var</span> wg sync.WaitGroup    wg.Add(<span class="hljs-number">2</span>)    <span class="hljs-comment">// 消费者</span>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">defer</span> wg.Done()        <span class="hljs-comment">// 初始化consumer</span>        <span class="hljs-keyword">var</span> kafkaConsumer = consumer.KafkaConsumer&#123;            Node:  []<span class="hljs-type">string</span>&#123;Conn&#125;,            Topic: topic,        &#125;        <span class="hljs-comment">// 消费</span>        <span class="hljs-keyword">go</span> kafkaConsumer.Consume()    &#125;()    <span class="hljs-comment">// 生产者</span>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">defer</span> wg.Done()        index := <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> &#123;            <span class="hljs-comment">// 生产者发送消息</span>            _, err := producer.Send(Conn, topic, fmt.Sprintf(<span class="hljs-string">&quot;lox_%d&quot;</span>, index))            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;                log.Print(<span class="hljs-string">&quot;测试失败:&quot;</span> + err.Error())                <span class="hljs-keyword">return</span>            &#125;            index++            time.Sleep(<span class="hljs-number">1</span> * time.Second)        &#125;    &#125;()    wg.Wait()&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Prometheus简单示例</title>
    <link href="/2023/03/02/Backend/Prometheus/"/>
    <url>/2023/03/02/Backend/Prometheus/</url>
    
    <content type="html"><![CDATA[<p>Prometheus简单示例</p><span id="more"></span><h1>Prometheus</h1><p>Prometheus 是一款基于时序数据库的开源监控告警系统。Prometheus的基本原理是通过HTTP协议周期性抓取被监控组件的状态，任意组件只要提供对应的HTTP接口就可以接入监控。不需要任何SDK或者其他的集成过程。</p><h2 id="示例">示例</h2><h3 id="下载安装启动">下载安装启动</h3><div class="code-wrapper"><pre><code class="hljs Bash">wget https://github.com/prometheus/prometheus/releases/download/v2.37.6/prometheus-2.37.6.linux-amd64.tar.gztar xvfz prometheus-2.37.6.linux-amd64.tar.gz <span class="hljs-built_in">cd</span> prometheus-2.37.6.linux-amd64/./prometheus --config.file=prometheus.yml</code></pre></div><p>此时打开<a href="http://localhost:9090/%E5%8D%B3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%9B%91%E6%8E%A7%E7%95%8C%E9%9D%A2">http://localhost:9090/即可以看到监控界面</a></p><h3 id="Go客户端编写">Go客户端编写</h3><div class="code-wrapper"><pre><code class="hljs Bash">package mainimport (    <span class="hljs-string">&quot;net/http&quot;</span>    <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span>)func <span class="hljs-function"><span class="hljs-title">main</span></span>() &#123;    //提供 /metrics HTTP 端点    http.Handle(<span class="hljs-string">&quot;/metrics&quot;</span>, promhttp.Handler())    //端口号    http.ListenAndServe(<span class="hljs-string">&quot;:2112&quot;</span>, nil)&#125;</code></pre></div><p>运行后访问<a href="http://localhost:2112/metrics%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%87%87%E9%9B%86%E7%9A%84%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE">http://localhost:2112/metrics可以看到采集的指标数据</a></p><p>注册自定义应用程序指定指标：</p><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;net/http&quot;</span>    <span class="hljs-string">&quot;time&quot;</span>    <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span>    <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promauto&quot;</span>    <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">recordMetrics</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-comment">//每2秒，计数器增加1。</span>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        <span class="hljs-keyword">for</span> &#123;            opsProcessed.Inc()            time.Sleep(<span class="hljs-number">2</span> * time.Second)        &#125;    &#125;()&#125;<span class="hljs-comment">// 公开了 myapp_processed_ops_total 计数器</span><span class="hljs-keyword">var</span> (    opsProcessed = promauto.NewCounter(prometheus.CounterOpts&#123;        Name: <span class="hljs-string">&quot;myapp_processed_ops_total&quot;</span>,        Help: <span class="hljs-string">&quot;The total number of processed events&quot;</span>,    &#125;))<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    recordMetrics()    http.Handle(<span class="hljs-string">&quot;/metrics&quot;</span>, promhttp.Handler())    http.ListenAndServe(<span class="hljs-string">&quot;:2112&quot;</span>, <span class="hljs-literal">nil</span>)&#125;</code></pre></div><p>运行后访问<a href="http://localhost:2112/metrics%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%8C%87%E6%A0%87%EF%BC%8C%E6%AF%8F2%E7%A7%92%EF%BC%8C%E8%AE%A1%E6%95%B0%E5%99%A8%E5%A2%9E%E5%8A%A01">http://localhost:2112/metrics可以看到自定义的指标，每2秒，计数器增加1</a></p><h3 id="服务端看板">服务端看板</h3><p>可以修改配置文件：prometheus.yml</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-comment"># my global config</span><span class="hljs-attr">global:</span>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span>  <span class="hljs-comment"># scrape_timeout is set to the global default (10s).</span><span class="hljs-comment"># Alertmanager configuration</span><span class="hljs-attr">alerting:</span>  <span class="hljs-attr">alertmanagers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span>          <span class="hljs-comment"># - alertmanager:9093</span><span class="hljs-comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><span class="hljs-attr">rule_files:</span>  <span class="hljs-comment"># - &quot;first_rules.yml&quot;</span>  <span class="hljs-comment"># - &quot;second_rules.yml&quot;</span><span class="hljs-comment"># A scrape configuration containing exactly one endpoint to scrape:</span><span class="hljs-comment"># Here it&#x27;s Prometheus itself.</span><span class="hljs-attr">scrape_configs:</span>  <span class="hljs-comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span>    <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span>    <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span>    <span class="hljs-attr">static_configs:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:2112&quot;</span>]</code></pre></div><p>将最后的targets修改成客户端启动的端口即可</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>Prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hertz和Thrift简单示例</title>
    <link href="/2023/02/24/Backend/HertzAndThrift/"/>
    <url>/2023/02/24/Backend/HertzAndThrift/</url>
    
    <content type="html"><![CDATA[<p>Hertz和Thrift简单示例</p><span id="more"></span><h1>Hertz</h1><p>Hertz 是字节跳动服务框架团队研发的超大规模的企业级微服务 HTTP 框架，具有高易用性、易扩展、低时延等特点。</p><p>官方文档：<a href="https://www.cloudwego.io/zh/docs/hertz/">https://www.cloudwego.io/zh/docs/hertz/</a></p><p>基本使用：</p><p>定义路由：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;h := server.Default(server.WithHostPorts(<span class="hljs-string">&quot;127.0.0.1:50000&quot;</span>))h.GET(<span class="hljs-string">&quot;/ping&quot;</span>, router.Deal)h.Spin()&#125;</code></pre></div><p>路由的Handler：</p><p>其中与其他框架最大的不同点是将Context分成了两个部分：</p><p>两个上下文主要有两点区别：</p><ol><li>生命周期不同。RequestContext 的生命周期局限于一次 http 请求之内，而 context.Context 会在 RPC Client 或者日志、Tracing 等组件间传递，其生命周期可能是链路级别的；</li><li>协程安全性。RequestContext 协程不安全，不适合异步传递，但可以通过 <code>Copy()</code>方法获取一个协程安全的副本，而 context.Context 本身就是协程安全的。</li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deal</span><span class="hljs-params">(c context.Context, ctx *app.RequestContext)</span></span> &#123;ctx.JSON(consts.StatusOK, utils.H&#123;<span class="hljs-string">&quot;message&quot;</span>: res&#125;)&#125;</code></pre></div><h1>Thrift</h1><p><code>Thrift</code>是一个 <strong>轻量级</strong> 、<strong>跨语言</strong>的<strong>远程服务调用</strong>框架，最初由 <code>Facebook</code>开发，后面进入 <code>Apache</code>开源项目。它通过自身的 <code>IDL</code> <strong>中间语言</strong> , 并借助<strong>代码生成引擎</strong>生成各种主流语言的 <code>RPC</code> <strong>服务端</strong> /<strong>客户端</strong>模板代码。</p><p>官方安装：<a href="https://thrift.apache.org/docs/BuildingFromSource.html">https://thrift.apache.org/docs/BuildingFromSource.html</a></p><p>网上资料：</p><p>注意安装的thrift的版本与go的插件版本一定要相同！</p><p>安装go插件：</p><div class="code-wrapper"><pre><code class="hljs bash">go get github.com/apache/thrift/lib/go/thrift</code></pre></div><p>首先安装依赖：</p><div class="code-wrapper"><pre><code class="hljs bash">apt install libboost-dev libboost-test-dev libboost-program-options-dev libboost-filesystem-dev libboost-thread-dev libevent-dev automake libtool flex bison pkg-config g++ libssl-dev</code></pre></div><p>安装Thrift：</p><div class="code-wrapper"><pre><code class="hljs go">git clone https:<span class="hljs-comment">//github.com/apache/thrift</span>cd thrift./bootstrap.sh./configure --without-qt4 --wihout-qt5<span class="hljs-built_in">make</span><span class="hljs-built_in">make</span> install</code></pre></div><p>编译使用：</p><div class="code-wrapper"><pre><code class="hljs bash">thrift -r --gen go compute.thrift</code></pre></div><h2 id="Thrift文件定义">Thrift文件定义</h2><div class="code-wrapper"><pre><code class="hljs bash">namespace go computeservice MulRange &#123;    string BigRange(1:i64 max)&#125;</code></pre></div><h2 id="客户端">客户端</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deal</span><span class="hljs-params">(c context.Context, ctx *app.RequestContext)</span></span> &#123;transportFactory := thrift.NewTTransportFactory()protocolFactory := thrift.NewTBinaryProtocolFactoryConf(<span class="hljs-literal">nil</span>)addr := <span class="hljs-string">&quot;127.0.0.1:9999&quot;</span>cfg := &amp;thrift.TConfiguration&#123;&#125;<span class="hljs-comment">// 建立和服务器的连接socket，通过socket建立Transport</span><span class="hljs-keyword">var</span> transport thrift.TTransporttransport = thrift.NewTSocketConf(addr, cfg)transport, _ = transportFactory.GetTransport(transport)<span class="hljs-keyword">defer</span> transport.Close()<span class="hljs-comment">// 打开Transport，与服务器进行连接</span>transport.Open()iprot := protocolFactory.GetProtocol(transport)oprot := protocolFactory.GetProtocol(transport)client := compute.NewMulRangeClient(thrift.NewTStandardClient(iprot, oprot))num, _ := client.BigRange(context.Background(), <span class="hljs-number">10</span>)fmt.Println(num)ctx.JSON(consts.StatusOK, utils.H&#123;<span class="hljs-string">&quot;message&quot;</span>: num&#125;)&#125;</code></pre></div><h2 id="服务端">服务端</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 尽量一个struct对应一个service</span><span class="hljs-keyword">type</span> mulrangeThrift <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *mulrangeThrift)</span></span> BigRange(_ context.Context, max <span class="hljs-type">int64</span>) (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;result := max + <span class="hljs-number">1253</span><span class="hljs-keyword">return</span> strconv.FormatInt(result, <span class="hljs-number">10</span>), <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 创建服务器</span>serverTransport, _ := thrift.NewTServerSocket(net.JoinHostPort(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;9999&quot;</span>))<span class="hljs-comment">// 创建二进制协议</span>transportFactory := thrift.NewTTransportFactory()protocolFactory := thrift.NewTBinaryProtocolFactoryConf(<span class="hljs-literal">nil</span>)mulrangeProcessor := compute.NewMulRangeProcessor(<span class="hljs-built_in">new</span>(mulrangeThrift))<span class="hljs-comment">// 启动服务器</span>server := thrift.NewTSimpleServer4(mulrangeProcessor, serverTransport, transportFactory, protocolFactory)server.Serve()<span class="hljs-comment">// 退出时停止服务器</span><span class="hljs-keyword">defer</span> server.Stop()&#125;</code></pre></div><h2 id="Thrift深入学习">Thrift深入学习</h2><p>参考资料：<a href="https://juejin.cn/post/6844903622380093447">https://juejin.cn/post/6844903622380093447</a></p><p><code>Thrift</code>是一个 <strong>轻量级</strong> 、<strong>跨语言</strong>的<strong>远程服务调用</strong>框架，最初由 <code>Facebook</code>开发，后面进入 <code>Apache</code>开源项目。它通过自身的 <code>IDL</code> <strong>中间语言</strong> , 并借助<strong>代码生成引擎</strong>生成各种主流语言的 <code>RPC</code> <strong>服务端</strong> /<strong>客户端</strong>模板代码。</p><h3 id="Thrift的特性">Thrift的特性</h3><h4 id="一-开发速度快">(一) 开发速度快</h4><p>通过编写 <code>RPC</code>接口 <code>Thrift IDL</code>文件，利用<strong>编译生成器</strong>自动生成 <strong>服务端骨架</strong> (<code>Skeletons</code>)和 <strong>客户端桩</strong> (<code>Stubs</code>)。从而省去开发者<strong>自定义</strong>和 <strong>维护接口编解码</strong> 、 <strong>消息传输</strong> 、<strong>服务器多线程模型</strong>等基础工作。</p><ul><li>服务端：只需要按照<strong>服务骨架</strong>即 <strong>接口</strong> ，编写好具体的 <strong>业务处理程序</strong> (<code>Handler</code>)即<strong>实现类</strong>即可。</li><li>客户端：只需要拷贝 <code>IDL</code>定义好的<strong>客户端桩</strong>和 <strong>服务对象</strong> ，然后就像调用本地对象的方法一样调用远端服务。</li></ul><h4 id="二-接口维护简单">(二) 接口维护简单</h4><p>通过维护 <code>Thrift</code>格式的IDL（ <strong>接口描述语言</strong> ）文件（注意写好注释），即可作为给 <code>Client</code>使用的接口文档使用，也<strong>自动生成</strong>接口代码，始终保持代码和文档的一致性。且 <code>Thrift</code>协议可灵活支持<strong>接口</strong>的 <strong>可扩展性</strong> 。</p><h4 id="三-学习成本低">(三) 学习成本低</h4><p>因为其来自 <code>Google Protobuf</code>开发团队，所以其 <code>IDL</code>文件风格类似 <code>Google Protobuf</code>，且更加 <strong>易读易懂</strong> ；特别是 <code>RPC</code><strong>服务接口</strong>的风格就像写一个<strong>面向对象</strong>的 <code>Class</code>一样简单。</p><p>初学者只需参照：<a href="https://thrift.apache.org/">thrift.apache.org/</a>，一个多小时就可以理解 <code>Thrift IDL</code>文件的语法使用。</p><h4 id="四-多语言-跨语言支持">(四) 多语言/跨语言支持</h4><p><code>Thrift</code>支持 <code>C++</code>、 <code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>、<code>Erlang</code>、<code>Perl</code>、<code>Haskell</code>、<code>C#</code>、<code>Cocoa</code>、<code>JavaScript</code>、<code>Node.js</code>、<code>Smalltalk</code>等多种语言，即可生成上述语言的<strong>服务器端</strong>和 <strong>客户端程序</strong> 。</p><p>对于我们经常使用的 <code>Java</code>、<code>PHP</code>、<code>Python</code>、<code>C++</code>支持良好，虽然对 <code>iOS</code>环境的 <code>Objective-C</code>(<code>Cocoa</code>)支持稍逊，但也完全满足我们的使用要求。</p><h4 id="五-稳定-广泛使用">(五) 稳定/广泛使用</h4><p><code>Thrift</code>在很多开源项目中已经被验证是<strong>稳定</strong>和<strong>高效</strong>的，例如 <code>Cassandra</code>、<code>Hadoop</code>、<code>HBase</code>等；国外在 <code>Facebook</code>中有广泛使用，国内包括百度、美团小米、和饿了么等公司。</p><h3 id="数据类型">数据类型</h3><ul><li><strong>基本类型</strong><ul><li><strong>bool</strong> : 布尔值</li><li><strong>byte</strong> : 8位有符号整数</li><li><strong>i16</strong> : 16位有符号整数</li><li><strong>i32</strong> : 32位有符号整数</li><li><strong>i64</strong> : 64位有符号整数</li><li><strong>double</strong> : 64位浮点数</li><li><strong>string</strong> : UTF-8编码的字符串</li><li><strong>binary</strong> : 二进制串</li></ul></li><li><strong>结构体类型</strong><ul><li><strong>struct</strong> : 定义的结构体对象</li></ul></li><li><strong>容器类型</strong><ul><li><strong>list</strong> : 有序元素列表</li><li><strong>set</strong> : 无序无重复元素集合</li><li><strong>map</strong> : 有序的key/value集合</li></ul></li><li><strong>异常类型</strong><ul><li><strong>exception</strong> : 异常类型</li></ul></li><li><strong>服务类型</strong><ul><li><strong>service</strong> : 具体对应服务的类</li></ul></li></ul><h3 id="Thrift协议">Thrift协议</h3><p><code>Thrift</code>可以让用户选择<strong>客户端</strong>与<strong>服务端</strong>之间<strong>传输通信协议</strong>的类别，在<strong>传输协议</strong>上总体划分为 <strong>文本</strong> (<code>text</code>)和 <strong>二进制</strong> (<code>binary</code>)传输协议。为 <strong>节约带宽</strong> ， <strong>提高传输效率</strong> ，一般情况下使用<strong>二进制</strong>类型的传输协议为多数，有时还会使用基于<strong>文本类型</strong>的协议，这需要根据项目/产品中的实际需求。常用协议有以下几种：</p><ul><li>TBinaryProtocol：<strong>二进制</strong>编码格式进行数据传输</li><li>TCompactProtocol：<strong>高效率</strong>的、<strong>密集</strong>的<strong>二进制</strong>编码格式进行数据传输</li><li>TJSONProtocol： 使用 <code>JSON</code><strong>文本</strong>的数据编码协议进行数据传输</li><li>TSimpleJSONProtocol：只提供 <code>JSON</code><strong>只写</strong>的协议，适用于通过<strong>脚本语言解析</strong></li></ul><h3 id="Thrift与Protobuf的区别">Thrift与Protobuf的区别</h3><p>Thrift和Protobuf的最大不同，在于Thrift提供了完整的RPC支持，包含了Server/Client，而Protobuf只包括了stub的生成器和格式定义。</p><h3 id="Thrift示例">Thrift示例</h3><h4 id="thrift语法">thrift语法</h4><p>User.thrift</p><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-keyword">namespace</span> go Sample<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">i32</span> id;    <span class="hljs-number">2</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">string</span> name;    <span class="hljs-number">3</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">string</span> avatar;    <span class="hljs-number">4</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">string</span> address;    <span class="hljs-number">5</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">string</span> mobile;&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UserList</span> </span>&#123;    <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">list</span>&lt;User&gt; userList;    <span class="hljs-number">2</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">i32</span> page;    <span class="hljs-number">3</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">i32</span> limit;&#125;</code></pre></div><p>Service.thrift</p><div class="code-wrapper"><pre><code class="hljs Thrift">include <span class="hljs-string">&quot;User.thrift&quot;</span><span class="hljs-keyword">namespace</span> go Sample<span class="hljs-keyword">typedef</span> <span class="hljs-type">map</span>&lt;<span class="hljs-type">string</span>, <span class="hljs-type">string</span>&gt; Data<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Response</span> </span>&#123;    <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">i32</span> errCode; <span class="hljs-comment">//错误码</span>    <span class="hljs-number">2</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">string</span> errMsg; <span class="hljs-comment">//错误信息</span>    <span class="hljs-number">3</span>:<span class="hljs-keyword">required</span> Data data;&#125;<span class="hljs-comment">//定义服务</span><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Greeter</span> </span>&#123;    Response SayHello(        <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> User.User user    )    Response GetUser(        <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">i32</span> uid    )&#125;</code></pre></div><ol><li><h5 id="文件引入">文件引入</h5></li></ol><p>thrift支持引入另一个thrift文件：</p><div class="code-wrapper"><pre><code class="hljs Makefile"><span class="hljs-keyword">include</span> <span class="hljs-string">&quot;User.thrift&quot;</span></code></pre></div><p>注意：</p><p>include 引入文件的使用，字段必须带文件名前缀：</p><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> User.User user</code></pre></div><p>不能直接写 <code>User user</code>，这样会提示找不到 <code>User</code>定义。</p><p>编译时只编译引用了其他文件的thrift文件即可：</p><div class="code-wrapper"><pre><code class="hljs Bash">thrift -r --gen go Service.thrift</code></pre></div><ol start="2"><li><h5 id="定义命名空间或者包名">定义命名空间或者包名</h5></li></ol><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-keyword">namespace</span> go Sample<span class="hljs-keyword">namespace</span> php Sample</code></pre></div><p>需要支持多个语言，则需要定义多行。</p><p>命名空间或者包名是多层级，使用 <code>.</code>号隔开。例如golang对于 <code>Sample.Model</code>会生成目录 <code>Sample/Model</code>，包名是 <code>Model</code>。</p><ol start="3"><li><h5 id="Field">Field</h5></li></ol><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">i32</span> id = <span class="hljs-number">0</span>;    <span class="hljs-number">2</span>:<span class="hljs-keyword">optional</span> <span class="hljs-type">string</span> name;&#125;</code></pre></div><p>字段选项 支持 <code>required</code>、<code>optional</code>两种。</p><p>一旦一个参数设置为 <code>required</code>，未来就一定不能删除或者改为 <code>optional</code>，否则就会出现版本不兼容问题，老客户端访问新服务会出现参数错误。不确定的情况可以都使用 <code>optional</code> 。</p><ol start="4"><li><h5 id="类型定义">类型定义</h5></li><li>基本类型</li></ol><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-type">bool</span>：布尔值（<span class="hljs-literal">true</span>或<span class="hljs-literal">false</span>）<span class="hljs-type">byte</span>：<span class="hljs-number">8</span>位有符号整数<span class="hljs-type">i16</span>：<span class="hljs-number">16</span>位有符号整数<span class="hljs-type">i32</span>：<span class="hljs-number">32</span>位有符号整数<span class="hljs-type">i64</span>：<span class="hljs-number">64</span>位有符号整数<span class="hljs-type">double</span>：<span class="hljs-number">64</span>位浮点数<span class="hljs-type">string</span>：使用UTF-<span class="hljs-number">8</span>编码编码的文本字符串</code></pre></div><ol start="2"><li>容器类型</li></ol><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-type">list</span>&lt;t1&gt;：一系列t1类型的元素组成的有序列表，元素可以重复<span class="hljs-type">set</span>&lt;t1&gt;：一些t1类型的元素组成的无序集合，元素唯一不重复<span class="hljs-type">map</span>&lt;t1,t2&gt;：key/value对，key唯一</code></pre></div><ol start="3"><li>类型别名</li></ol><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-keyword">typedef</span> <span class="hljs-type">map</span>&lt;<span class="hljs-type">string</span>, <span class="hljs-type">string</span>&gt; Data</code></pre></div><ol start="4"><li>枚举类型</li></ol><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TweetType</span> </span>&#123;    TWEET,    RETWEET = <span class="hljs-number">2</span>,    DM = <span class="hljs-number">0</span>xa,    REPLY&#125;</code></pre></div><p>默认从0开始赋值，枚举值可以赋予某个常量，允许常量是十六进制整数。末尾没有逗号。</p><p>不支持枚举类嵌套，枚举常量必须是32位正整数。</p><p>对于go，会生成 <code>TweetType_</code>开头的常量。</p><ol start="5"><li>常量类型</li></ol><p>Thrift允许用户定义常量，复杂的类型和结构体可以使用JSON形式表示：</p><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-keyword">const</span> <span class="hljs-type">i32</span> INT_CONST = <span class="hljs-number">1234</span><span class="hljs-keyword">const</span> <span class="hljs-type">map</span>&lt;<span class="hljs-type">string</span>,<span class="hljs-type">string</span>&gt; MAP_CONST = &#123;<span class="hljs-string">&quot;hello&quot;</span>: <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;goodnight&quot;</span>: <span class="hljs-string">&quot;moon&quot;</span>&#125;</code></pre></div><ol start="6"><li>异常类型</li></ol><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-class"><span class="hljs-keyword">exception</span> <span class="hljs-title">BizException</span> </span>&#123;    <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">i32</span> code    <span class="hljs-number">2</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">string</span> msg&#125;</code></pre></div><ol start="7"><li>结构体</li></ol><p>结构体可以包含其他结构体，但不支持继承结构体。</p><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Response</span> </span>&#123;    <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">i32</span> errCode; <span class="hljs-comment">//错误码</span>    <span class="hljs-number">2</span>:<span class="hljs-keyword">required</span> <span class="hljs-type">string</span> errMsg; <span class="hljs-comment">//错误信息</span>    <span class="hljs-number">3</span>:<span class="hljs-keyword">required</span> Data data;&#125;</code></pre></div><ol start="8"><li>服务</li></ol><p>Thrift编译器会根据选择的目标语言为server产生服务接口代码，为client产生桩(stub)代码。</p><p>在go里是 <code>interface</code>。<code>service</code>里定义的方法必须由服务端实现。</p><div class="code-wrapper"><pre><code class="hljs Thrift"><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">Greeter</span> </span>&#123;    Response SayHello(        <span class="hljs-number">1</span>:<span class="hljs-keyword">required</span> User.User user    )&#125;</code></pre></div><p>参数是user，返回值是Response类型</p><h4 id="服务端代码">服务端代码</h4><p>服务端主要完成4个部分的工作：</p><ul><li>Create a transport</li><li>Create input/output protocols for the transport</li><li>Create a processor based on the input/output protocols</li><li>Wait for incoming connections and hand them off to the processor</li></ul><p>服务端最终要创建这样的一个server</p><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTSimpleServerFactory6</span><span class="hljs-params">(processorFactory TProcessorFactory, serverTransport TServerTransport, inputTransportFactory TTransportFactory, outputTransportFactory TTransportFactory, inputProtocolFactory TProtocolFactory, outputProtocolFactory TProtocolFactory)</span></span> *TSimpleServer &#123;    <span class="hljs-keyword">return</span> &amp;TSimpleServer&#123;        processorFactory:       processorFactory,        serverTransport:        serverTransport,        inputTransportFactory:  inputTransportFactory,        outputTransportFactory: outputTransportFactory,        inputProtocolFactory:   inputProtocolFactory,        outputProtocolFactory:  outputProtocolFactory,    &#125;&#125;</code></pre></div><p>说明：</p><ul><li>需要至少指定2个字段（processorFactory和serverTransport）</li><li>常用是指定4个字段（包括TransportFactory和ProtocolFactory），默认input与output使用的协议相同</li></ul><div class="code-wrapper"><pre><code class="hljs Go">server := thrift.NewTSimpleServer4(processor, transport, transportFactory, protocolFactory)err = server.Serve()</code></pre></div><ol><li><h5 id="processor：thrift定义服务的处理函数">processor：thrift定义服务的处理函数</h5></li></ol><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-comment">// 定义服务</span><span class="hljs-keyword">type</span> Greeter <span class="hljs-keyword">struct</span> &#123;&#125;handler := &amp;Greeter&#123;&#125;processor := Sample.NewGreeterProcessor(handler)</code></pre></div><ol start="2"><li><h5 id="serverTransport：在指定的端口上创建一个socket连接">serverTransport：在指定的端口上创建一个socket连接</h5></li></ol><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> transport thrift.TServerTransporttransport, err = thrift.NewTServerSocket(*addr)</code></pre></div><ol start="3"><li><h5 id="transportFactory">transportFactory</h5></li></ol><p>不同类型可选</p><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-comment">//buffered</span><span class="hljs-keyword">var</span> transportFactory thrift.TTransportFactory<span class="hljs-keyword">if</span> *buffered &#123;    transportFactory = thrift.NewTBufferedTransportFactory(<span class="hljs-number">8192</span>)&#125; <span class="hljs-keyword">else</span> &#123;    transportFactory = thrift.NewTTransportFactory()&#125;<span class="hljs-comment">//framed</span><span class="hljs-keyword">if</span> *framed &#123;    transportFactory = thrift.NewTFramedTransportFactory(transportFactory)&#125;</code></pre></div><ol start="4"><li><h5 id="ProtocolFactory">ProtocolFactory</h5></li></ol><p>不同类型可选</p><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> protocolFactory thrift.TProtocolFactory<span class="hljs-keyword">switch</span> *protocol &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;compact&quot;</span>:    protocolFactory = thrift.NewTCompactProtocolFactory()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;simplejson&quot;</span>:    protocolFactory = thrift.NewTSimpleJSONProtocolFactory()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;json&quot;</span>:    protocolFactory = thrift.NewTJSONProtocolFactory()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;binary&quot;</span>, <span class="hljs-string">&quot;&quot;</span>:    protocolFactory = thrift.NewTBinaryProtocolFactoryDefault()</code></pre></div><h4 id="客户端代码">客户端代码</h4><p>客户端定义好client后直接调用方法即可，如下所示：</p><div class="code-wrapper"><pre><code class="hljs Go">client := GetClient()rep, err := client.GetUser(ctx, <span class="hljs-number">100</span>)rep, err := client.SayHello(ctx, &amp;Sample.User&#123;     Name:    <span class="hljs-string">&quot;thrift&quot;</span>,     Address: <span class="hljs-string">&quot;address&quot;</span>, &#125;)</code></pre></div><ol><li><h5 id="定义client">定义client</h5></li></ol><div class="code-wrapper"><pre><code class="hljs Go">iprot := protocolFactory.GetProtocol(transport)oprot := protocolFactory.GetProtocol(transport)client := Sample.NewGreeterClient(thrift.NewTStandardClient(iprot, oprot))</code></pre></div><p>涉及到protocolFactory与transport</p><ol start="2"><li><h5 id="protocolFactory">protocolFactory</h5></li></ol><div class="code-wrapper"><pre><code class="hljs Go">protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()iprot := protocolFactory.GetProtocol(transport)oprot := protocolFactory.GetProtocol(transport)</code></pre></div><p>注意要与服务端定义的protocolFactory要一致</p><ol start="3"><li><h5 id="transport">transport</h5></li></ol><p>创建socket连接：</p><div class="code-wrapper"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> transport thrift.TTransport<span class="hljs-keyword">var</span> err <span class="hljs-type">error</span>transport, err = thrift.NewTSocket(addr)</code></pre></div><p>注意要提前进行类型定义，否则后面类型不匹配</p><p>定义transportFactory：</p><div class="code-wrapper"><pre><code class="hljs Go">transportFactory := thrift.NewTTransportFactory()transport, err = transportFactory.GetTransport(transport)transport.Open()</code></pre></div><p>注意transportFactory的类型要与服务端相同</p><h4 id="其他">其他</h4><p>可以添加key同时使用SSL进行Socket连接从而确保安全性</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>Hertz</tag>
      
      <tag>Thrift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23岁的自己，生日快乐！</title>
    <link href="/2023/02/19/diary/Happy-Birthday-2023/"/>
    <url>/2023/02/19/diary/Happy-Birthday-2023/</url>
    
    <content type="html"><![CDATA[<p>23岁的自己，生日快乐！</p><span id="more"></span><p>也许今天你很迷茫，不知道应该做一些什么事情</p><p>也许今天你很失落，努力了两周的结果是从头再来</p><p>也许今天你很懊恼，后悔自己之前的选择不够合适</p><p>也许今天你很伤心，并不会有人记得你的生日</p><p>但是今天是你的生日呀</p><p>在这个并不算很特殊的日子里，也值得你对自己说一声</p><p>张兆，生日快乐！</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CIickHouse - 你没有见过的列存储</title>
    <link href="/2023/02/14/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day18/"/>
    <url>/2023/02/14/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day18/</url>
    
    <content type="html"><![CDATA[<p>CIickHouse - 你没有见过的列存储</p><span id="more"></span><h1>ClickHouse - 你没有见过的列存储</h1><h2 id="概述">概述</h2><p>本节课程分为四个部分</p><ol><li>数据库基本概念</li><li>列式存储</li><li>ClickHouse存储设计</li><li>ClickHouse典型应用场景</li></ol><p>课前部分主要罗列课程中涉及到的概念。对于不熟悉的概念，同学们可以提前查询预习；课中部分主要罗列每一部分的关键思路，帮助同学们跟上课程的进度；课后部分是一些问题，帮助同学们在课后梳理本课程的重点。</p><h2 id="课前-（必须）">课前 （必须）</h2><h3 id="数据库基本概念">数据库基本概念</h3><ol><li>数据库</li><li>DBMS：数据库管理系统</li><li>OLTP 数据库 <strong>：</strong> OLTP（Online transactional processing）</li><li>OLAP 数据库：OLAP (Online analytical processing)</li><li>SQL (Structured Query Language)</li><li>词法分析</li><li>语法分析</li><li>AST (Abstract syntax tree)</li></ol><h3 id="列式存储">列式存储</h3><ol><li>行式存储</li><li>列式存储</li><li>数据压缩<br>a.  LZ4<br>b.  Run-length encoding<br>c.  Delta encoding</li><li>延迟物化<br>a.  物化<br>b.  Cpu cache<br>c.  内存带宽</li><li>向量化<br>a.  SIMD （single instruction multiple data）<br>b.  SSE指令集<br>c.  AVX指令集</li></ol><h3 id="ClickHouse存储设计">ClickHouse存储设计</h3><ol><li>Shard key</li><li>索引<br>a.  哈希索引<br>b.  B-Tree<br>c.  B+Tree<br>d.  LSM-Tree</li></ol><h3 id="ClickHouse典型应用场景">ClickHouse典型应用场景</h3><ol><li>Kafka</li><li>Spark</li><li>Hdfs</li><li>Bitmap</li><li>字典编码</li></ol><h2 id="课中">课中</h2><h3 id="数据库基本概念-2">数据库基本概念</h3><h4 id="数据库是什么">数据库是什么</h4><p>数据库是结构化信息或数据的有序集合，一般以电子形式存储在计算机系统中。通常由<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.oracle.com%2Fcn%2Fdatabase%2Fwhat-is-database%2F%23WhatIsDBMS" title="https://www.oracle.com/cn/database/what-is-database/#WhatIsDBMS">数据库管理系统 (DBMS)</a> 来控制。在现实中，数据、DBMS 及关联应用一起被称为数据库系统，通常简称为数据库。</p><h4 id="一个简单的例子">一个简单的例子</h4><ol><li>数据解析整理成有序集合</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a99c748ea44d77b0d020bf4e453b00~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="2"><li>数据的写入和读取，可以通过查询语言获取想要的信息</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06ebb2a9b53542039f48d606371d5c72~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="数据库的类型">数据库的类型</h4><ol><li>数据库有很多种，至于各种数据库孰优孰劣，主要取决于企业希望如何使用数据。</li><li>关系数据库：关系型数据库是把数据以表的形式进行储存，然后再各个表之间建立关系，通过这些表之间的关系来操作不同表之间的数据。</li><li>非关系数据库 <strong>：</strong> NoSQL 或非关系数据库，支持存储和操作非结构化及半结构化数据。相比于关系型数据库，NoSQL没有固定的表结构，且数据之间不存在表与表之间的关系，数据之间可以是独立的。NoSQL的关键是它们放弃了传统关系型数据库的强事务保证和关系模型，通过所谓最终一致性和非关系数据模型（例如键值对，图，文档）来提高Web应用所注重的高可用性和可扩展性。</li><li>单机数据库：在一台计算机上完成数据的存储和查询的数据库系统。</li><li>分布式数据库 <strong>：</strong> 分布式数据库由位于不同站点的两个或多个文件组成。数据库可以存储在多台计算机上，位于同一个物理位置，或分散在不同的网络上。</li><li>OLTP 数据库 <strong>：</strong> OLTP（Online transactional processing）数据库是一种高速分析数据库，专为多个用户执行大量事务而设计。</li><li>OLAP 数据库：OLAP (Online analytical processing) 数据库旨在同时分析多个数据维度，帮助团队更好地理解其数据中的复杂关系</li></ol><h4 id="OLAP数据库">OLAP数据库</h4><ol><li>大量数据的读写，PB级别的存储</li><li>多维分析，复杂的聚合函数</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/71027c9eb08c4235995a4157f890d1ed~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce86c76aa4b94069a9e0566c4e90a700~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="3"><li>离线/实时分析，对查询速度有要求</li></ol><h4 id="SQL">SQL</h4><ol><li>一种编程语言，目前几乎所有的关系数据库都使用 SQL (<strong>Structured Query Language</strong> <strong>)</strong> 编程语言来查询、操作和定义数据，进行数据访问控制。</li><li>SQL的结构</li></ol><p>查询包含一系列含有最终结果的字段, 紧跟 <code>SELECT</code>关键词。星号（“<code>*</code>”）也可以用来指定查询应当返回查询表所有字段，可选的关键词和子句包括：</p><ul><li><code>FROM</code>子句指定了选择的数据表。<code>FROM</code>子句也可以包含 <code>JOIN</code> 二层子句来为数据表的连接设置规则。</li><li><code>WHERE</code>子句后接一个比较谓词以限制返回的行。<code>WHERE</code>子句仅保留返回结果里使得比较谓词的值为True的行。</li><li><code>GROUP BY</code>子句用于将若干含有相同值的行合并。 <code>GROUP BY</code>通常与SQL聚合函数连用，或者用于清除数据重复的行。<code>GROUP BY</code>子句要用在 <code>WHERE</code>子句之后。</li><li><code>HAVING</code>子句后接一个谓词来过滤从 <code>GROUP BY</code>子句中获得的结果，由于其作用于 <code>GROUP BY</code>子句之上，所以聚合函数也可以放到其谓词中。</li><li><code>ORDER BY</code>子句指明将哪个字段用作排序关键字，以及排序顺序(升序/降序)，如果无此子句，那么返回结果的顺序不能保证有序。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/652535fe26b4462aaaec624d07ee81a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="3"><li>SQL的用途<br>a.  定义数据模型</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> default.test_insert_local(   `p_date` <span class="hljs-type">Date</span>,   `id` Int32)ENGINE <span class="hljs-operator">=</span> MergeTree<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> p_date<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> idSETTINGS index_granularity <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>复制代码</code></pre></div><p>b.  读写数据库数据</p><div class="code-wrapper"><pre><code class="hljs csharp">insert <span class="hljs-keyword">into</span> <span class="hljs-literal">default</span>.<span class="hljs-function">test_insert_local <span class="hljs-title">values</span> (<span class="hljs-params"><span class="hljs-string">&#x27;2022-01-01&#x27;</span>, <span class="hljs-number">1</span></span>)</span>;<span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">count</span>() <span class="hljs-keyword">from</span> <span class="hljs-literal">default</span>.test_insert_local</span>;复制代码</code></pre></div><ol start="4"><li>SQL的优点</li></ol><ul><li>标准化，ISO和ANSI是长期建立使用的SQL数据库标准</li><li>高度非过程化，用SQL进行数据操作，用户只需提出“做什么”，而不必指明“怎么做”，因此用户无须了解存取路径，存取路径的选择以及SQL语句的操作过程由系统自动完成。这不但大大减轻了用户负担，而且有利于提高数据独立性。</li><li>以同一种语法结构提供两种使用方式，用户可以在终端上直接输入SQL命令对数据库进行操作。作为嵌入式语言，SQL语句能够嵌入到高级语言（如C、C#、JAVA）程序中，供程序员设计程序时使用。而在两种不同的使用方式下，SQL的语法结构基本上是一致的。</li><li>语言简洁，易学易用：SQL功能极强，但由于设计巧妙，语言十分简洁，完成数据定义、数据操纵、数据控制的核心功能只用了9个动词：CREATE、ALTER、DROP、SELECT、INSERT、UPDATE、DELETE、GRANT、REVOKE。且SQL语言语法简单，接近英语口语，因此容易学习，也容易使用。</li></ul><h4 id="数据库的架构">数据库的架构</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c1f870906ca44249631505e6701208f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol><li>Client</li><li>Parser<br>词法分析，语法分析，生成AST树 (Abstract syntax tree)</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d765fa26b5c74b28a81addf4bc92712a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="3"><li>Analyzer<br>变量绑定、类型推导、语义检查、安全、权限检查、完整性检查等，为生成计划做准备</li><li>Analyzer<br>变量绑定、类型推导、语义检查、安全、权限检查、完整性检查等，为生成计划做准备</li><li>Optimizer</li></ol><ul><li>为查询生成性能最优的执行计划</li><li>进行代价评估</li><li>Executor 将执行计划翻译成可执行的物理计划</li><li>Storage engine<br>a.  管理内存数据结构【index、内存数据、缓存（Query cache、Data cache、Index cache）】<br>b.  管理磁盘数据【磁盘数据的文件格式、磁盘数据的增删查改】<br>c.  读写算子【数据写入逻辑、数据读取逻辑】</li></ul><h4 id="一个sql的执行流程">一个sql的执行流程</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dc778102a6243b88bb09f7fd638e752~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72c9663793a54274bc85f336396d3aed~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80e49afbeef141819fe7694d6b989a31~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="设计数据库存储的要点">设计数据库存储的要点</h4><ol><li>性能瓶颈在哪里：数据选择、数据读取、构造内存数据、计算</li><li>选择什么样的数据格式：是否可以并发处理、是否可以构建索引、行存，列存 或者 行列混合存储</li><li>选择什么样的索引：读写的方式：读多写少、读少写多、点查场景、分析型场景</li></ol><h3 id="列式存储-2">列式存储</h3><h4 id="什么是列存">什么是列存</h4><ol><li>行存的存储</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca237dcbd1164ed28eda5625eb28a4d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="2"><li>列存的存储</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad333d1c8e0948bcbfdc570f5df8412f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="列存的优点">列存的优点</h4><p><strong>a. 数据压缩</strong></p><ul><li>数据压缩可以使读的数据量更少，在IO密集型计算中获得大的性能优势</li><li>相同类型压缩效率更高</li><li>排序之后压缩效率更高</li><li>可以针对不同类型使用不同的压缩算法</li><li>几种常见的压缩算法</li></ul><p>【LZ4】</p><div class="code-wrapper"><pre><code class="hljs scss">输入：abcde_bcdefgh_abcdefghxxxxxxx输出：<span class="hljs-built_in">abcde_</span>(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)<span class="hljs-built_in">fgh_</span>(<span class="hljs-number">14</span>,<span class="hljs-number">5</span>)fghxxxxxxx复制代码</code></pre></div><p>(5,4) 代表向前5个byte，匹配到的内容长度有4，即&quot;bcde&quot;是一个重复</p><p>重复项越多或者越长，压缩率就会越高</p><p>【Run-length encoding】</p><div class="code-wrapper"><pre><code class="hljs">输入：WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW输出：12W1B12W3B24W1B14W复制代码</code></pre></div><blockquote><p>压缩重复的数据</p></blockquote><p>【Delta encoding】</p><div class="code-wrapper"><pre><code class="hljs csharp">输入：<span class="hljs-number">105</span>, <span class="hljs-number">135</span>, <span class="hljs-number">112</span>, <span class="hljs-number">135</span>, <span class="hljs-number">143</span>, <span class="hljs-number">147</span>输出：<span class="hljs-number">105</span>(<span class="hljs-keyword">base</span>),<span class="hljs-number">30</span>, <span class="hljs-number">-23</span>, <span class="hljs-number">23</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>复制代码</code></pre></div><p>将数据存储为连续数据之间的差异，而不是直接存储数据本身</p><p><strong>b.  数据处理</strong></p><p>【查询优化】1.可以选择特定的列做计算而不是读所有列 2.对聚合计算友好</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b0d9767c0bf454ea304ddbca992d153~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>【延迟物化】</p><ul><li>物化：将列数据转换为可以被计算或者输出的行数据或者内存数据结果的过程，物化后的数据通常可以用来做数据过滤，聚合计算，Join</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d38beaad91c54cf3af4386d79f526d44~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><ul><li>延迟物化：尽可能推迟物化操作的发生</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b0887e17c3d44feb7f020a67940565a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><ul><li>缓存友好</li><li>CPU / 内存带宽友好</li><li>可以利用到执行计划和算子的优化，例如filter</li><li>保留直接在压缩列做计算的机会</li></ul><p>【向量化】</p><ul><li>SIMD<br>single instruction multiple data，对于现代多核CPU，其都有能力用一条指令执行多条数据<br>对于代码</li></ul><div class="code-wrapper"><pre><code class="hljs css">for (size_t <span class="hljs-selector-tag">i</span> = <span class="hljs-number">0</span>; <span class="hljs-selector-tag">i</span> &lt; <span class="hljs-number">100</span>; ++<span class="hljs-selector-tag">i</span>)  c<span class="hljs-selector-attr">[i]</span> = <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[i]</span> + <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[i]</span>;复制代码</code></pre></div><p>非向量化执行</p><div class="code-wrapper"><pre><code class="hljs css">c<span class="hljs-selector-attr">[0]</span> = <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[0]</span> + <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[0]</span>; c<span class="hljs-selector-attr">[1]</span> = <span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[1]</span> + <span class="hljs-selector-tag">b</span><span class="hljs-selector-attr">[1]</span>;... ... 复制代码</code></pre></div><p>如果这时候CPU也可以并行的计算我们写的代码，那么理论上我们的处理速度就会是之前代码的100倍，幸运的是SIMD指令就是完成这样的工作的，用SIMD指令完成这样代码设计和执行就叫做向量化</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35e2b0f14c0a48799afd87ac55d48d6f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><ul><li>执行模型<br>数据需要按批读取<br>函数的调用需要明确数据类型</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4def4eb1ca0b498bb7bc18e792c29713~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>列存数据库适合设计出这样的执行模型，从而使用向量化技术</li></ul><h4 id="列存-VS-行存">列存 VS 行存</h4><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cdd14b5fe7147b8a57dc7e8be722c02~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><h3 id="ClickHouse的存储设计">ClickHouse的存储设计</h3><h4 id="ClickHouse的架构">ClickHouse的架构</h4><ol><li>架构图</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5146f2ff91cc44009f77d3d7032d6a2e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="2"><li>表定义和结构</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f1a7d82804c411cbd94c1f7ef56d8a6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="3"><li>集群架构</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3edc45c207e64b14aff68fe968c1ce7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="ClickHouse的存储架构">ClickHouse的存储架构</h4><ol><li>数据结构</li></ol><p>a.文件组织</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cae40687666d491f9ec00eac87ae3af8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>b.文件内容</p><blockquote><p>对于表</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> test.test_insert_local(    `p_date` <span class="hljs-type">Date</span>,    `id` Int32)ENGINE <span class="hljs-operator">=</span> MergeTree<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> p_date<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> idSETTINGS index_granularity <span class="hljs-operator">=</span> <span class="hljs-number">8192</span>复制代码</code></pre></div><blockquote><p>它的文件组织</p></blockquote><div class="code-wrapper"><pre><code class="hljs kotlin">├── <span class="hljs-number">20220101_1_1_0</span>│   ├── checksums.txt│   ├── columns.txt│   ├── count.txt│   ├── <span class="hljs-keyword">data</span>.bin│   ├── <span class="hljs-keyword">data</span>.mrk3│   ├── default_compression_codec.txt│   ├── minmax_p_date.idx│   ├── partition.dat│   ├── primary.idx│   └── versions.txt├── <span class="hljs-number">20220102_2_2_0</span>│   ├── checksums.txt│   ├── columns.txt│   ├── count.txt│   ├── <span class="hljs-keyword">data</span>.bin│   ├── <span class="hljs-keyword">data</span>.mrk3│   ├── default_compression_codec.txt│   ├── minmax_p_date.idx│   ├── partition.dat│   ├── primary.idx│   └── versions.txt├── detached└── format_version.txt复制代码</code></pre></div><p>c. part和partition</p><ul><li>part是物理文件夹的名字</li><li>partition是逻辑结构</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e27fbd4782743cf8557b1d2cd8dbb6b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>d. part和column</p><ul><li>每个column都是一个文件</li><li>所有的column文件都在自己的part文件夹下</li></ul><p>e. column和index</p><ul><li>一个part有一个主键索引</li><li>每个column都有列索引</li></ul><h4 id="索引设计">索引设计</h4><ol><li>主键索引</li></ol><div class="code-wrapper"><pre><code class="hljs ini">CREATE TABLE hits_UserID_URL(    `UserID` UInt32,    `URL` String,    `EventTime` DateTime)<span class="hljs-attr">ENGINE</span> = MergeTreePRIMARY KEY (UserID, URL)ORDER BY (UserID, URL, EventTime)SETTINGS <span class="hljs-attr">index_granularity</span> = <span class="hljs-number">8192</span>, index_granularity_bytes = <span class="hljs-number">0</span><span class="hljs-comment">;</span>复制代码</code></pre></div><ol start="2"><li>数据按照主键顺序一次排序<br>UserID首先做排序,然后是URL,最后是EventTime</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c34a95c8efe4c14b0238d728eb67733~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="3"><li>数据被组织成granule</li></ol><ul><li>granule是引擎做数据处理的最小数据单位，引擎读数据的时候不是按照一行一行读取的，而是最少读取一个granule</li><li>方便构建稀疏索引</li><li>方便并行计算</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1aa0b14b1995429c85a2cd1fa486e9c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="4"><li>每个granule都对应primary.idx里面的一行</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d688b3a48c1c464eb68a6ec90a0ca520~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="5"><li>默认每8192行记录主键的一行值，primary.idx需要被全部加载到内存里面</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24b20d3da955423c8b81d37b84b3718e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="6"><li>每个主键的一行数据被称为一个mark</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03a8c03bbabc4adc819650ece574eb5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="7"><li>每个列都有这样一个mark文件，mark文件存储所有granule在物理文件里面的地址，每一列都有一个mark文件</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e9c324d18fa4604b0927e85d6cdfb69~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="8"><li>mark文件里面的每一行存储两个地址</li></ol><ul><li>第一个地址称为block_offset，用于定位一个granule的压缩数据在物理文件中的位置，压缩数据会以一个block为单位解压到内存中。</li><li>第二个地址称为granule_offset，用于定位一个granule在解压之后的block中的位置。</li></ul><h4 id="索引的缺陷和优化">索引的缺陷和优化</h4><ol><li>缺陷：数据按照key的顺序做排序，因此只有第一个key的过滤效果好，后面的key过滤效果依赖第一个key的基数大小</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/308928c0d5724c15a1dd661a79e236aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="2"><li>二级索引</li></ol><ul><li>在URL列上构建二级索引</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be6e773647b147b1a16758d2bd826320~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="3"><li>构建多个主键索引</li></ol><ul><li>再建一个表(数据需要同步两份,查询需要用户判断查哪张表)</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34d5196db6ea45e18edb83dfbc28c93c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>建一个物化视图(数据自动同步到隐式表,查询需要用户判断查哪张表)</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e8d11eb319b49d593f13cefc7a23e2f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>使用Projection(数据自动同步到隐式表,查询自动路由到最优的表)</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a434f63277eb40d1a64b2ea77d997d5e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="数据合并">数据合并</h4><ul><li>一个part内的数据是有序的</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e49c1eac5f914dc4b2ae2a376e19a85f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>不同part之间的数据是无序的</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/243d0dfdcd3145babac66978b3ea4f35~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>数据合并是将多个part合并成一起的过程</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67c2f06dcb514f158e015da591396532~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>part的合并发生在一个分区内</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dee5814564b4342abee6df3b4dbd07f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>数据的可见性<br>数据合并过程中，未被合并的数据对查询可见<br>数据合并完成后，新part可见，被合并的part被标记删除</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b39e0a35dc2145b2ac695ebfc30ec476~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="数据查询">数据查询</h4><ol><li>对于查询</li></ol><div class="code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-keyword">SELECT</span>    URL,    count(URL) <span class="hljs-keyword">AS</span> Count<span class="hljs-keyword">FROM</span> hits_UserID_URL<span class="hljs-keyword">WHERE</span> UserID = <span class="hljs-number">749927693</span><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> URL<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> Count DESCLIMIT <span class="hljs-number">10</span>复制代码</code></pre></div><ol start="2"><li>通过主键找到需要读的mark</li><li>切分marks，然后并发的调度reader</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/535f009c745a4f8e9a05577bef56b10a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="4"><li>Reader 通过mark block_offset得到需要读的数据文件的偏移量</li><li>Reader 通过mark granule_offset得到解压之后数据的偏移量</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f37cfa3dba574396b2390057558cc71a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol><li>构建列式filter做数据过滤</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db5a523be0654764ac7f6dd46bd2adca~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="ClickHouse的典型使用场景">ClickHouse的典型使用场景</h3><h4 id="大宽表存储和查询">大宽表存储和查询</h4><ol><li>动态表结构</li></ol><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> <span class="hljs-title function_">test_multi_columns</span>(    <span class="hljs-string">`p_date`</span> <span class="hljs-title class_">Date</span>,    <span class="hljs-string">`id`</span> <span class="hljs-title class_">Int32</span>,    <span class="hljs-string">`map_a`</span> <span class="hljs-title class_">Map</span>(<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Int32</span>))<span class="hljs-variable constant_">ENGINE</span> = <span class="hljs-title class_">MergeTree</span><span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> p_date<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> map_a复制代码</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/948006a393ee406da6f1c3a47b3ec706~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol><li><p>map中的每个key都是一列</p></li><li><p>map中的每一列都可以单独的查询</p></li><li><p>使用方式同普通列，可以做任何计算</p></li><li><p>大宽表查询</p></li></ol><p>可以建非常多的列查询的时候引擎可以快速选择需要的列，查询的时候引擎可以快速选择需要的列</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc3f565f6d2d44f48f75ce16e3dada1d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="离线数据分析">离线数据分析</h4><ol><li>数据导入</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff7089af6bf74bc3a8cd251bb1153f74~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><blockquote><p>数据可以通过spark生成clickhouse格式的文件</p><p>导入到hdfs上由hive2ch导入工具完成数据导入</p><p>数据直接导入到各个物理节点</p></blockquote><ol start="2"><li>数据按列导入</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f6fe483136d481db157fba6acd3fcab~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>保证查询可以及时访问已有数据</p><p>可以按需加载需要的列</p><h4 id="实时数据分析">实时数据分析</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c2162a81cbb428284ae85292e853028~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol><li>数据可以被立刻查询</li><li>使用memory table减少parts数量</li></ol><ul><li>数据先缓存在内存中</li><li>到达一定阈值再写到磁盘</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/839b029f2846429db8ff7efb6f2bcca0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="复杂类型查询">复杂类型查询</h4><ol><li>bitmap索引</li></ol><ul><li>构建</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea0fcab8637f487d999070ae4f7f0a9e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>查询<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/920ba1c69ad84920b9dca82813e37e24~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></li></ul><ol start="2"><li>bitmap64类型</li></ol><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">select</span> <span class="hljs-title">countDistinct</span>(<span class="hljs-params">uid</span>)</span><span class="hljs-function"><span class="hljs-keyword">from</span> user_detial</span><span class="hljs-function"><span class="hljs-keyword">where</span> tag_id</span> = <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-function"><span class="hljs-keyword">and</span> uid <span class="hljs-title">in</span> </span><span class="hljs-function">(<span class="hljs-params"></span></span><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">select</span> uid <span class="hljs-keyword">from</span> user_detail</span></span><span class="hljs-params"><span class="hljs-function">    wherer tag_id = <span class="hljs-string">&#x27;b&#x27;</span></span></span><span class="hljs-params"><span class="hljs-function"></span>)  </span><span class="hljs-function">复制代码</span></code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43db089db47a42debba7451e6e08c499~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ol start="3"><li>lowcardinality</li></ol><ul><li>对于低基数列使用字典编码</li><li>减少数据存储和读写的IO使用</li><li>可以做运行时的压缩数据过滤</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b46c67fb4194b688690bd78da273be5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h2 id="课后">课后</h2><ol><li>列存和行存的差别是什么，使用场景有什么不同</li><li>列存的优点有哪些</li><li>列存的缺点有哪些</li><li>列存适合什么样的索引</li><li>ClickHouse的列存是什么样的存储架构</li><li>ClickHouse的索引是怎么设计的</li><li>ClickHouse的查询是怎么使用索引的</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis - 大厂程序员是怎么用的</title>
    <link href="/2023/02/13/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day17/"/>
    <url>/2023/02/13/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day17/</url>
    
    <content type="html"><![CDATA[<p>Redis - 大厂程序员是怎么用的</p><span id="more"></span><h1>Redis - 大厂程序员是怎么用的</h1><h2 id="1-概述">1.概述</h2><p>本节课程主要分为三个方面：</p><ol><li>为什么需要Redis，Redis的基本工作原理</li><li>Redis应用案例</li><li>在字节跳动，使用Redis有哪些注意事项</li></ol><h2 id="2-课前（必须）">2.课前（必须）</h2><h3 id="2-1-安装Golang开发环境">2.1 安装Golang开发环境</h3><ul><li>Golang安装，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.dev%2Fdoc%2Finstall" title="https://go.dev/doc/install">安装指引链接</a></li><li>可提前阅读课程Demo代码，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgitee.com%2Fwedone%2Fredis_course" title="https://gitee.com/wedone/redis_course">gitee链接</a></li></ul><h3 id="2-2-安装Redis">2.2 安装Redis</h3><ul><li>Windows操作系统环境，<a href="https://link.juejin.cn?target=https%3A%2F%2Fredis.io%2Fdocs%2Fgetting-started%2Finstallation%2Finstall-redis-on-windows%2F" title="https://redis.io/docs/getting-started/installation/install-redis-on-windows/">安装指引链接</a></li><li>Linux操作系统环境，<a href="https://link.juejin.cn?target=https%3A%2F%2Fredis.io%2Fdocs%2Fgetting-started%2Finstallation%2Finstall-redis-on-linux%2F" title="https://redis.io/docs/getting-started/installation/install-redis-on-linux/">安装指引链接</a></li><li>MacOS操作系环境，<a href="https://link.juejin.cn?target=https%3A%2F%2Fredis.io%2Fdocs%2Fgetting-started%2Finstallation%2Finstall-redis-on-mac-os%2F" title="https://redis.io/docs/getting-started/installation/install-redis-on-mac-os/">安装指引链接</a></li></ul><h3 id="2-3-熟悉Redis基本操作">2.3 熟悉Redis基本操作</h3><h4 id="2-3-1-熟悉以下命令的操作">2.3.1 熟悉以下命令的操作</h4><ul><li>GET/SET/DEL/INCR/SETNX</li><li>HSET/HGET/HINCRBY</li><li>LPUSH/RPOP/LRANGE</li><li>ZADD/ZRANGEBYSCORE/ZREVRANGE/ZINCRBY/ZSCORE</li></ul><h3 id="2-3-2-了解pipelining概念">2.3.2 了解pipelining概念</h3><h3 id="2-4-复习数据结构">2.4 复习数据结构</h3><ul><li>链表/FIFO</li><li>Hash Tale</li><li>Skip List</li></ul><h2 id="3-课中">3.课中</h2><h3 id="3-1-Redis基本工作原理">3.1 Redis基本工作原理</h3><ul><li>Redis实现数据持久化的原理：AOF/RDB</li><li>Redis单线程处理命令的概念</li></ul><h3 id="3-2-Redis应用案例">3.2 Redis应用案例</h3><ul><li>掘金连续签到，需要了解GET/SET，Key过期</li><li>掘金用户计数，使用到HASH</li><li>排行榜ZSET</li><li>使用SETNX实现分布式锁</li></ul><h3 id="3-3-在字节跳动，使用Redis有哪些注意事项">3.3 在字节跳动，使用Redis有哪些注意事项</h3><ul><li>大Key：Value大于10KB就是大Key，使用大Key将导致Redis系统不稳定</li><li>热Key：一个Key的QPS特别高，将导致Redis实例出现负载突增，负责均衡流量不均的情况。导致单实例故障</li><li>慢查询：大Key、热Kye的读写；一次操作过多的Key（mset/hmset/sadd/zadd）</li><li>导致缓存穿透、缓存雪崩的场景及避免方案</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL - 深入理解RDBMS</title>
    <link href="/2023/02/11/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day16/"/>
    <url>/2023/02/11/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day16/</url>
    
    <content type="html"><![CDATA[<p>MySQL - 深入理解RDBMS</p><span id="more"></span><h1>MySQL - 深入理解 RDBMS</h1><h2 id="课程概述">课程概述</h2><p>RDBMS（关系型数据库）是目前使用最为广泛的数据库之一，同时也是整个信息化时代的基石。本节课程通过生活中常见的场景向大家介绍RDBMS的作用、发展历程及其核心技术，最后以字节为例，展示了RDBMS的企业级实践。本节课程主要包含以下内容：</p><ol><li>经典案例</li><li>发展历史</li><li>关键技术</li><li>企业实践</li></ol><h2 id="课前材料">课前材料</h2><p>RDBMS有相关的数据和材料都非常多，这里主要给大家提供几篇经典论文，从经典的论文中，能够更有效的帮助大家理解RDBMS。</p><ol><li>A Relational Model of Data for Large Shared Data Banks</li></ol><p>暂时无法在飞书文档外展示此内容</p><p>这篇论文是RDBMS的奠基之作，由RDBMS之父E.F.Codd博士于1970年发表。在这篇论文中，E.F.Codd首次提出了用于管理数据的关系模型，并将数据独立于硬件来存储，用户使用一个非过程语言来访问数据。</p><ol start="2"><li>Readings in Database Systems(Fifth Edition)</li></ol><p>暂时无法在飞书文档外展示此内容</p><p>这本书被称为数据库领域的“红宝书”，由著名的图灵奖获得者，数据库领域专家，Michael Stonebraker撰写。其中介绍了数据库的基本概念，传统的RDBMS以及新的数据库架构等等，是一本非常棒的数据库领域入门文章。</p><h2 id="课程详情">课程详情</h2><h3 id="经典案例">经典案例</h3><p>通过抖音红包雨的案例，介绍 RDBMS 中 ACID 的概念：</p><ul><li>原子性( <strong>Atomicity</strong> )：事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。</li><li>一致性( <strong>Consistency</strong> )：数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</li><li>隔离性( <strong>Isolation</strong> )：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。</li><li>持久性( <strong>Durability</strong> )：在事务完成以后，该事务所对数据库所做的更改便持久的保存在数据库之中，并不会被回滚。</li></ul><h3 id="发展历史">发展历史</h3><p>数据库发展最初过程中，诞生过3种数据模型，最终关系型模型成为了应用最为广泛的数据库模型。</p><ul><li>网状模型：用有向图表示实体和实体之间的联系的数据结构模型称为网状数据模型。</li><li>层次模型：层次数据模型是用树状&lt;层次&gt;结构来组织数据的数据模型。</li><li>关系模型：使用表格表示实体和实体之间关系的数据模型称之为关系数据模型。</li></ul><table><thead><tr><th></th><th>网状模型</th><th>层次模型</th><th>关系模型</th></tr></thead><tbody><tr><td>优势</td><td>能直接描述现实世界 存取效率较高</td><td>结构简单 查询效率高 可以提供较好的完整性支持</td><td>实体及实体间的的联系都通过二维表结构表示 可以方便的表示M:N关系 数据访问路径对用户透明</td></tr><tr><td>劣势</td><td>结构复杂 用户不易使用 访问程序设计复杂</td><td>无法表示M:N的关系 插入、删除限制多 遍历子节点必须经过父节点 访问程序设计复杂</td><td>关联查询效率不够高 关系必须规范化</td></tr></tbody></table><h3 id="关键技术">关键技术</h3><h4 id="SQL-执行流程">SQL 执行流程</h4><p>在SQL执行过程中，需要经历SQL引擎、存储引擎、以及事务引擎等模块。而其中SQL引擎又分为Parser、Optimizer、Executor几个部分：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6632feb8206e4fa999b5be879d82f065~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="SQL-引擎">SQL 引擎</h4><p>SQL引擎包括了：</p><ul><li>Paser：经过词法分析、语法分析生成语法树，然后对语法树进行合法性校验。</li><li>Optimizer：根据Parser产生的语法树，根据规则或者代价产生执行计划树。</li><li>Executor：根据计划树进行执行，常见的执行方式是火山模型。</li></ul><h4 id="存储引擎">存储引擎</h4><p>存储引擎负责了数据的底层存储、管理和访问工作。各大RDBMS存储引擎的设计都有不少的差异，这里选择MySQL的InnoDB存储引擎来向大家做一个介绍：</p><ul><li>Buffer Pool：存储引擎位于内存中的重要结构，用于缓存数据，减少磁盘IO的开销。</li><li>Page：数据存储的最基本单位，一般为16KB。</li><li>B+u Tree：InnoDB中最常用的索引结构。</li></ul><h4 id="事务引擎">事务引擎</h4><p>事务引擎实现了数据库的ACID能力，这里还是以MySQL的InnoDB为例来介绍数据库内部是通过哪些技术来实现ACID：</p><ul><li>Atomicity：InnoDB中通过undo日志实现了数据库的原子性，通过Undo Log，数据库可以回滚到事务开始的状态；</li><li>Isolation：通过Undo Log实现MVCC（多版本并发控制），降低读写冲突。</li><li>Durability：通过Redo Log（一种WAL实现方式）来保证事务在提交后一定能持久化到磁盘中。</li><li>Consistency：一致性本质上是一种业务层的限制。</li></ul><h3 id="企业实践">企业实践</h3><p>字节中是国内数据规模最大的互联网公司之一，公司内部有成千上万套RDBMS系统。这一章节还是以红包雨为案例，展示了字节是如何解决大流量、流量突增、高可靠等问题的。</p><h2 id="课后大作业">课后大作业</h2><ol><li>WAL 日志到底是如何保证数据的持久化，宕机后数据不丢失的？相比于其他方案，WAL 日志都有什么优势？</li><li>除了 Undo Log 之外，是否还有其他方案可以实现 MVCC？</li><li>基于代价的优化器一般需要考虑哪些代价？</li><li>执行器的执行模型，除了本课中提到的火山模型是否还有其他模型？相比于火山模型有什么优劣势？</li><li>InnoDB 的 B+ Tree 是怎么实现的？</li><li>InnoDB 的 buffer pool 是怎么实现页面管理和淘汰的？</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>带你认识存储的本质 - 状态</title>
    <link href="/2023/02/10/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day15/"/>
    <url>/2023/02/10/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day15/</url>
    
    <content type="html"><![CDATA[<p>带你认识存储的本质 - 状态</p><span id="more"></span><h1>带你认识存储的本质 - 状态</h1><h2 id="课程概述">课程概述</h2><p>存储系统和数据库系统往往是后端服务的最后一环，提供数据存储、查询能力。本课程会先用模拟案例导入，向学员介绍存储系统、数据库系统的特点，然后解析多个主流产品，最后分享存储和数据库结合新技术演进的方向。本节课程主要包含以下内容：</p><ol><li>模拟案例</li><li>存储 &amp; 数据库简介</li><li>主流产品剖析</li><li>新技术演进</li></ol><h2 id="课前材料-（必须）">课前材料 （必须）</h2><p>跟存储 &amp; 数据库系统相关的材料很多，涵盖开源项目、博客、论文等。下面提供部分资料作为参考</p><ol><li>The Google File System</li></ol><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fstatic.googleusercontent.com%2Fmedia%2Fresearch.google.com%2Fzh-CN%2F%2Farchive%2Fgfs-sosp2003.pdf" title="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/gfs-sosp2003.pdf">static.googleusercontent.com/media/resea…</a></p><p>作为各种开源分布式文件系统的鼻祖，GFS论文里面提到的架构非常经典，值得一学。</p><ol start="2"><li>The Linux Programming Interface（第13章 FILE I/O BUFFERING）</li></ol><p>本书介绍了很多Linux内核子系统的实现，其中第13章着重讲了单机的文件IO。学习完Linux中的文件IO栈，对单机存储系统会有更深的认识。</p><h2 id="课程详情">课程详情</h2><h3 id="经典案例">经典案例</h3><p>通过一个模拟案例，描述了数据是怎么产生，在后端系统里怎么流通，最后怎么写入到存储/数据库系统。</p><h3 id="存储-数据库简介">存储 &amp; 数据库简介</h3><ul><li>存储系统概览<ul><li>存储系统特点</li><li>存储器层级结构</li><li>单机存储栈</li><li>RAID技术</li></ul></li><li>数据库系统概览<ul><li>关系型数据库特点</li><li>非关系型数据库特点</li><li>数据库 vs 经典存储</li><li>数据库使用方式</li></ul></li></ul><h3 id="主流产品剖析">主流产品剖析</h3><ul><li>单机存储产品<ul><li>单机文件系统</li><li>单机key-value存储</li></ul></li><li>分布式存储产品<ul><li>HDFS</li><li>Ceph</li></ul></li><li>单机数据库产品<ul><li>关系型数据库 —— PG、MySQL</li><li>非关系型数据库 —— ES、MongoDB、Redis</li><li>Elasticsearch使用案例</li></ul></li><li>分布式数据库产品<ul><li>问题与挑战</li><li>解决方案</li></ul></li></ul><h3 id="新技术演进">新技术演进</h3><ul><li>SPDK</li><li>人工智能</li><li>新硬件加速</li></ul><h2 id="课后思考">课后思考</h2><ol><li>写入存储系统的粒度太大，会不会导致数据原子性问题？例如一次性写100MB，如果系统突然crash，会不会只有一部分数据持久化了，另一部分丢失了？如果要解决原子性问题，一般会设计什么机制？</li><li>在从应用程序到存储介质的链路上，无论读还是写，数据可能要被拷贝好几次，这几次拷贝能不能去掉？如果我们去掉大部分拷贝操作，会有什么副作用，要怎么缓解副作用？</li><li>一个关系型数据库大概率是会被并发访问的，如果要保证并发安全，除了在行数据上加悲观锁还有其他方式吗？</li><li>在数据库领域，把数据按行存和按列存各有好处，你能从性能优先的角度设计出一种混合存储格式吗？</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC 原理与实现</title>
    <link href="/2023/02/08/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day14/"/>
    <url>/2023/02/08/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day14/</url>
    
    <content type="html"><![CDATA[<p>RPC 原理与实现</p><span id="more"></span><h1>RPC 原理与实践</h1><h2 id="概述">概述</h2><p>本节课程主要分为四个方面：</p><ol><li>RPC 相关的基本概念</li><li>RPC 框架的分层设计</li><li>衡量 RPC 框架的一些核心指标</li><li>字节内部 RPC 框架 Kitex 实践分享</li></ol><p><strong>课前部分</strong>主要罗列课程中涉及到的概念。对于不熟悉的概念，同学们可以提前查询预习；</p><p><strong>课中部分</strong>主要罗列每一部分的关键思路，帮助同学们跟上课程的进度；</p><p><strong>课后部分</strong>是一些问题，帮助同学们在课后梳理本课程的重点。</p><h2 id="课前">课前</h2><h3 id="RPC-的基本概念">RPC 的基本概念</h3><ul><li><p>RPC的概念模型：User、User-Stub、RPC-Runtime、Server-Stub、Server</p><ul><li>来自论文《<a href="https://link.juejin.cn?target=https%3A%2F%2Fweb.eecs.umich.edu%2F~mosharaf%2FReadings%2FRPC.pdf" title="https://web.eecs.umich.edu/~mosharaf/Readings/RPC.pdf">Implementing Remote Procedure Calls</a>》</li></ul></li><li><p>IDL(Interface Definition Language) 文件</p><ul><li>Thrift</li><li>Protobuf</li></ul></li><li><p>生成代码</p></li><li><p>编解码（序列化/反序列化）</p></li><li><p>通信协议</p><ul><li>应用层协议</li></ul></li><li><p>网络通信</p><ul><li>IO 网络模型<ul><li>blocking IO</li><li>unblocking IO</li><li>IO multiplexing</li><li>signal driven IO</li><li>asynchronous IO</li></ul></li><li>传输层协议<ul><li>TCP</li><li>UDP</li></ul></li></ul></li></ul><h3 id="RPC-框架分层设计">RPC 框架分层设计</h3><ul><li><p>编解码层</p><ul><li>数据格式：<ul><li>语言特定格式</li><li>文本格式</li><li>二进制编码<ul><li>TLV 编码：Thrift 使用 TLV 编码</li><li>Varint 编码：Protobuf 使用 Varint 编码</li></ul></li></ul></li><li>选项：<ul><li>兼容性</li><li>通用型</li><li>性能</li></ul></li></ul></li><li><p>传输协议层</p><ul><li>消息切分<ul><li>特殊结束符</li><li>变长协议：length+body</li></ul></li><li>协议构造<ul><li>以 Thrift 的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fapache%2Fthrift%2Fblob%2Fmaster%2Fdoc%2Fspecs%2FHeaderFormat.md" title="https://github.com/apache/thrift/blob/master/doc/specs/HeaderFormat.md">THeader</a> 协议为例讲解</li></ul></li></ul></li><li><p>网络通信层</p><ul><li>网络库</li><li>核心指标<ul><li>吞吐高</li><li>延迟低</li></ul></li></ul></li></ul><h3 id="RPC-框架的核心指标">RPC 框架的核心指标</h3><ul><li><p>稳定性</p><ul><li>保障策略<ul><li>熔断</li><li>限流</li><li>超时</li></ul></li><li>请求成功率<ul><li>负载均衡</li><li>重试</li></ul></li><li>长尾请求<ul><li>BackupRequest</li></ul></li></ul></li><li><p>易用性</p><ul><li>开箱即用</li><li>周边工具</li></ul></li><li><p>扩展性</p></li><li><p>观测性</p><ul><li>Log</li><li>Metric</li><li>Tracing</li><li>内置观测性服务</li></ul></li><li><p>高性能</p></li></ul><h3 id="字节内部-Kitex-实践分享">字节内部 Kitex 实践分享</h3><ul><li><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcloudwego%2Fkitex" title="https://github.com/cloudwego/kitex">Kitex</a> 整体架构</p></li><li><p>自研网络库 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcloudwego%2Fnetpoll" title="https://github.com/cloudwego/netpoll">Netpoll</a></p></li><li><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fspasfyqgaaid5rguinl4" title="https://www.infoq.cn/article/spasfyqgaaid5rguinl4">性能优化</a>：</p><ul><li>网络库优化</li><li>编解码优化</li></ul></li><li><p>合并部署</p></li></ul><h2 id="课中">课中</h2><h3 id="基本概念">基本概念</h3><ul><li><p>相比本地函数调用，RPC调用需要解决的问题</p><ul><li>函数映射</li><li>数据转换成字节流</li><li>网络传输</li></ul></li><li><p>一次 RPC 的完整过程</p></li><li><p>RPC 带来的问题将由 RPC 框架来解决</p><ul><li>服务宕机如何感知？</li><li>遇到网络异常应该如何应对？</li><li>请求量暴增怎么处理？</li></ul></li></ul><h3 id="RPC-框架分层设计-2">RPC 框架分层设计</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d12fff7fde5429b814f15c64fc4a261~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="编解码层">编解码层</h4><ul><li><p>数据格式</p><ul><li>语言特定格式：例如 java.io.Serializable</li><li>文本格式：例如 JSON、XML、CSV 等</li><li>二进制编码：常见有 Thrift 的 BinaryProtocol，Protobuf，实现可以有多种形式，例如 TLV 编码 和 Varint 编码</li></ul></li><li><p>选型考察点</p><ul><li>兼容性</li><li>通用型</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Falecthomas%2Fgo_serialization_benchmarks" title="https://github.com/alecthomas/go_serialization_benchmarks">性能</a><ul><li>空间开销</li><li>时间开销</li></ul></li></ul></li><li><p>生成代码和编解码层相互依赖，框架的编解码应当具备扩展任意编解码协议的能力</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ffa6428b4214c6590a3b8a6fc106390~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="协议层">协议层</h4><ul><li>以 Thrift 的 THeader 协议为例</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/228aa11d265240c3aad35736194de94f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><div class="code-wrapper"><pre><code class="hljs">-   LENGTH 字段 32bits，包括数据包剩余部分的字节大小，不包含 LENGTH 自身长度-   HEADER MAGIC 字段16bits，值为：0x1000，用于标识 协议版本信息，协议解析的时候可以快速校验-   FLAGS 字段 16bits，为预留字段，暂未使用，默认值为 0x0000-   SEQUENCE NUMBER 字段 32bits，表示数据包的 seqId，可用于多路复用，最好确保单个连接内递增-   HEADER SIZE 字段 16bits，等于头部长度字节数/4，头部长度计算从第14个字节开始计算，一直到 PAYLOAD 前（备注：header 的最大长度为 64K）-   PROTOCOL ID 字段 uint8 编码，取值有： - ProtocolIDBinary = 0 - ProtocolIDCompact = 2-   NUM TRANSFORMS 字段 uint8 编码，表示 TRANSFORM 个数-   TRANSFORM ID 字段 uint8 编码，表示压缩方式 zlib or snappy-   INFO ID 字段 uint8 编码，具体取值参考下文，用于传递一些定制的 meta 信息-   PAYLOAD 消息内容</code></pre></div><ul><li>协议解析</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae3b22f299dc4e4a8df34793263055cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="网络通信层">网络通信层</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4e3c7f3fb234b6f9f1102fca16818dd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>阻塞 IO 下，耗费一个线程去阻塞在 read(fd) 去等待用足够多的数据可读并返回。</li><li>非阻塞 IO 下，不停对所有 fds 轮询 read(fd) ，如果读取到 n &lt;= 0 则下一个循环继续轮询。</li></ul><p>第一种方式浪费线程（会占用内存和上下文切换开销），第二种方式浪费 CPU 做大量无效工作。而基于 IO 多路复用系统调用实现的 Poll 的意义在于将可读/可写状态通知和实际文件操作分开，并支持多个文件描述符通过一个系统调用监听以提升性能。</p><p>网络库的核心功能就是去同时监听大量的文件描述符的状态变化(通过操作系统调用)，并对于不同状态变更，高效，安全地进行对应的文件操作。</p><h3 id="RPC-框架核心指标">RPC 框架核心指标</h3><h4 id="稳定性">稳定性</h4><ul><li>保障策略<ul><li>熔断</li><li>限流</li><li>超时控制</li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a181793ced1e476bac5d648e8fac3717~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>从某种程度上讲超时、限流和熔断也是一种服务降级的手段 。</p><ul><li><p>请求成功率</p><ul><li>负载均衡</li><li>重试</li></ul></li><li><p>长尾请求</p><ul><li>BackupRequest</li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a8e6ff914d84384b79f6e8ad13afd75~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="易用性">易用性</h4><ul><li><p>开箱即用</p><ul><li>合理的默认参数选项、丰富的文档</li></ul></li><li><p>周边工具</p><ul><li>生成代码工具、脚手架工具</li></ul></li></ul><h4 id="扩展性">扩展性</h4><ul><li>Middleware：middleware 会被构造成一个有序调用链逐个执行，比如服务发现、路由、负载均衡、超时控制等</li><li>Option：作为初始化参数</li><li>核心层是支持扩展的：编解码、协议、网络传输层</li><li>代码生成工具也支持插件扩展</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9951e664a34042bebd3fc4d2770e6ab4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="观测性">观测性</h4><ul><li>三件套：Log、Metric 和 Tracing</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7207ac58f7564cdeb79c6e9693d38717~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>内置观测性服务，用于观察框架内部状态<ul><li>当前环境变量</li><li>配置参数</li><li>缓存信息</li><li>内置 pprof 服务用于排查问题</li></ul></li></ul><h4 id="高性能">高性能</h4><ul><li>连接池和多路复用：复用连接，减少频繁建联带来的开销</li><li>高性能编解码协议：Thrift、Protobuf、Flatbuffer 和 Cap’n Proto 等</li><li>高性能网络库：Netpoll 和 Netty 等</li></ul><h3 id="字节内部-Kitex-实践分享-2">字节内部 Kitex 实践分享</h3><ol><li><p>框架文档 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cloudwego.io%2Fzh%2Fdocs%2Fkitex%2F" title="https://www.cloudwego.io/zh/docs/kitex/">Kitex</a></p></li><li><p>自研网络库 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cloudwego.io%2Fzh%2Fdocs%2Fnetpoll%2F" title="https://www.cloudwego.io/zh/docs/netpoll/">Netpoll</a>，背景：<br>a.  原生库无法感知连接状态</p><p>b.  原生库存在 goroutine 暴涨的风险</p></li><li><p>扩展性：支持多协议，也支持灵活的自定义协议扩展</p></li><li><p>性能优化，参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fspasfyqgaaid5rguinl4" title="https://www.infoq.cn/article/spasfyqgaaid5rguinl4">字节跳动 Go RPC 框架 KiteX 性能优化实践</a><br>a. 网络优化</p><ul><li>i.  调度优化</li><li>ii.  LinkBuffer 减少内存拷贝，从而减少 GC</li><li>iii.  引入内存池和对象池</li></ul><p>b.  编解码优化</p><ul><li>i.   Codegen：预计算提前分配内存，inline，SIMD等</li><li>ii.  JIT：无生产代码，将编译过程移到了程序的加载（或首次解析）阶段，可以一次性编译生成对应的 codec 并高效执行</li></ul></li><li><p>合并部署<br>a.  微服务过微，引入的额外的传输和序列化开销越来越大</p><p>b.  将强依赖的服务统计部署，有效减少资源消耗</p></li></ol><h2 id="课后">课后</h2><ol><li>行业内各个流行的 RPC 框架的优劣对比</li><li>从第三章节 RPC 的核心指标来看，Kitex 还有哪些功能是欠缺或者需要加强的？</li><li>了解微服务的新趋势 ServiceMesh，以及 RPC 框架和 ServiceMesh 的关系</li><li>关于 RPC 框架，业界有哪些新的趋势和概念？</li><li>Netpoll 的优势在哪？相比其他高性能网络库例如 Netty 还有什么不足？</li><li>Flatbuffer 和 Cap’n Proto 等编解码协议为什么高性能？</li></ol><h2 id="参考文献">参考文献</h2><ol><li>官方文档 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cloudwego.io%2Fzh%2Fdocs%2Fkitex%2F" title="https://www.cloudwego.io/zh/docs/kitex/">Kitex</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cloudwego.io%2Fzh%2Fdocs%2Fnetpoll%2F" title="https://www.cloudwego.io/zh/docs/netpoll/">Netpoll</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fspasfyqgaaid5rguinl4" title="https://www.infoq.cn/article/spasfyqgaaid5rguinl4">字节跳动 Go RPC 框架 KiteX 性能优化实践_架构_字节跳动技术团队_InfoQ精选文章</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fasgjevrm8islszo7ixzh" title="https://www.infoq.cn/article/asgjevrm8islszo7ixzh">字节跳动微服务架构体系演进_架构_字节跳动技术团队_InfoQ精选文章</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列原理与实战</title>
    <link href="/2023/02/07/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day13/"/>
    <url>/2023/02/07/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day13/</url>
    
    <content type="html"><![CDATA[<p>消息队列原理与实战</p><span id="more"></span><h1>消息队列原理与实战</h1><h2 id="概述">概述</h2><p>本节课程主要分为五个方面：</p><ol><li>消息队列的前世今生</li><li>消息队列-Kafka</li><li>消息队列-BMQ</li><li>消息队列-RocketMQ</li><li>最佳实践</li></ol><p>课前部分主要罗列课程中涉及到的概念。对于不熟悉的概念，同学们可以提前查询预习；课中部分主要罗列每一部分的关键思路，帮助同学们跟上课程的进度；课后部分是一些问题，帮助同学们在课后梳理本课程的重点。</p><h2 id="课前">课前</h2><h3 id="消息队列的前世">消息队列的前世</h3><ul><li>消息队列应用场景</li><li>消息队列的发展历史</li></ul><h3 id="常见消息队列">常见消息队列</h3><ul><li>Kafka使用场景、架构、高级特性</li><li>Pulsar使用场景、架构、高级特性</li><li>Rocket使用场景、架构、高级特性</li></ul><h2 id="课中">课中</h2><h3 id="消息队列是什么">消息队列是什么</h3><ul><li>解耦</li><li>削峰</li><li>异步</li><li>日志处理</li></ul><h3 id="消息队列的前世今生">消息队列的前世今生</h3><h4 id="消息队列-Kafka">消息队列-Kafka</h4><p>kafka使用场景，业务日志、用户行为数据、Metrics数据</p><p>基本概念，Producer、Cluster、Consumer、Topic、Partition</p><p>数据迁移、Offset、Partition选主</p><p>一条消息从生产到消费是如何处理的，Producer端逻辑、Broker端逻辑、Consumer端逻辑</p><h4 id="消息队列-BMQ">消息队列-BMQ</h4><p>Kafka在使用中遇到问题</p><p>BMQ架构</p><p>BMQ各模块是如何工作的，Broker、Proxy、HDFS、MetaStorage</p><p>BMQ多机房容灾</p><h4 id="消息队列-RocketMQ">消息队列-RocketMQ</h4><p>RocketMQ使用场景</p><p>RocketMQ和Kafka对比</p><p>RocketMQ架构介绍，Producer、Broker、Nameserver、Consumer</p><p>一条消息从生产到消费是如何处理的，Producer端逻辑、Broker端逻辑、Consumer端逻辑</p><h4 id="消息队列在字节">消息队列在字节</h4><p>一些最佳实践的场景，包括数据展示</p><h2 id="课后">课后</h2><ol><li>消息队列的应用场景有哪些？</li><li>Kafka的哪些Feature让其可以支撑大吞吐写入的场景？</li><li>Kafka Consumer Rebalance的流程简述？</li><li>BMQ相比较Kafka有哪些优势？</li><li>RocketMQ有哪些特有的Feature？</li><li>RocketMQ事务消息处理流程简述？</li><li>你认为MQ后面应该如何发展？（开放题）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式定时任务</title>
    <link href="/2023/02/06/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day12/"/>
    <url>/2023/02/06/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day12/</url>
    
    <content type="html"><![CDATA[<p>分布式定时任务</p><span id="more"></span><h1>分布式定时任务</h1><h2 id="概述">概述</h2><p>本节课程主要分为五个方面：</p><ol><li>分布式定时任务整体架构</li><li>控制台Admin详细设计</li><li>触发器Trigger详细设计</li><li>调度器Scheduler详细设计</li><li>执行器Executor详细设计</li></ol><p>课前部分主要罗列课程中涉及到的概念。对于不熟悉的概念，同学们可以提前查询预习；课中部分主要罗列每一部分的关键思路，帮助同学们跟上课程的进度；课后部分是一些问题，帮助同学们在课后梳理本课程的重点。</p><h2 id="课前">课前</h2><h3 id="分布式定时任务发展历史">分布式定时任务发展历史</h3><ul><li>Linux命令-CronJob</li><li>单机定时任务-Timer、Ticker</li><li>单机定时任务-ScheduledExecutorService</li><li>任务调度- Quartz</li><li>分布式定时任务</li></ul><h3 id="分布式定时任务核心架构">分布式定时任务核心架构</h3><ul><li>控制台Admin</li><li>触发器Trigger</li><li>调度器Scheduler</li><li>执行器Executor</li></ul><h3 id="知识点扩充">知识点扩充</h3><ul><li>时间轮</li><li>延时消息</li><li>离线计算引擎 Hive</li><li>实时计算引擎 Flink</li></ul><h2 id="课中">课中</h2><h3 id="前言">前言</h3><ul><li><p>每年春节抖音都会有很多有意思的玩法，如果同学们是字节的后端同学，怎么设计今年春节集卡瓜分20亿的技术方案？</p></li><li><p>业务流程</p><ul><li>定时扫描抖音用户集卡状态</li><li>汇总计算用户的瓜分金额</li><li>定时开奖</li></ul></li><li><p>技术体量</p><ul><li>亿级用户规模</li><li>十亿级资金规模</li><li>百万级读写QPS</li></ul></li><li><p>方案引出</p><ul><li>自动化 + 定时执行 + 海量数据 + 高效稳定 = 分布式定时任务</li></ul></li></ul><h3 id="发展历程">发展历程</h3><ul><li><h4 id="发展历史">发展历史</h4></li><li>Linux命令-CronJob</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c391c85f1eb4e17b0728a657c3caac1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>单机定时任务-Timer、Ticker</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98b80cbc530f4826870f7491753f5595~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>单机定时任务-ScheduledExecutorService</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eca1f4b5fb864aa39af49c0fba286e96~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>任务调度- Quartz</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa15c50b15144fa29501de37f8517000~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>分布式定时任务</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26ce9817a971405c94405aba139b271f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li><h4 id="概述-2">概述</h4><ul><li>定义<ul><li>定时任务是指系统为了<strong>自动</strong>完成特定任务，<strong>实时、延时、周期</strong>性完成任务调度的过程。</li><li>分布式定时任务是把分散的、可靠性差的定时任务纳入统一的 <strong>平台</strong> ，并实现集群管理调度和<strong>分布式部署</strong>的一种定时任务的管理方式。</li></ul></li><li>特点</li><li>执行模式<ul><li>单机任务</li><li>广播任务</li><li>Map任务</li><li>MapReduce任务</li></ul></li><li>现状<ul><li>业内流行框架|            | Xxl-job    | SchedulerX | TCT  | Elastic-job | Saturn |<br>| ---------- | ---------- | ---------- | ---- | ----------- | ------ |<br>| 来源公司   | 美团点评   | 阿里巴巴   | 腾讯 | 当当网      | 唯品会 |<br>| 是否开源   | 是         | 否         | 否   | 是          | 是     |<br>| 任务编排   | 子任务依赖 | 支持       | 支持 | 不支持      | 不支持 |<br>| 任务分片   | 支持       | 支持       | 支持 | 支持        | 支持   |<br>| 高可用     | 支持       | 支持       | 支持 | 支持        | 支持   |<br>| 故障转移   | 支持       | 支持       | 支持 | 支持        | 支持   |<br>| 可视化运维 | 支持       | 支持       | 支持 | 支持        | 支持   |</li><li>美团点评Xxl-job</li><li>阿里巴巴SchedulerX</li><li>腾讯TCT</li></ul></li></ul></li><li><h4 id="关联方案">关联方案</h4><ul><li>单机定时任务</li><li>大数据处理引擎</li></ul></li></ul><h3 id="实现原理">实现原理</h3><ul><li><h4 id="整体架构">整体架构</h4><ul><li>核心架构</li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62fdceaada184704b53f995b04bfa6a1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>数据流</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a4658097cf814f76a8157e8258b25eb4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>功能架构</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05a76971927f4c34ab3cdabadc9e12e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="控制台Admin">控制台Admin</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb5d6eec9e984f5a93ff107ee905f737~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="触发器Trigger">触发器Trigger</h4><p>方案一：腾讯字节方案</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ae626a473144a8baeb96f20a388b9e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>方案二：Quartz方案——时间轮</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaa9c31252e84fac875d0a92c148dfc4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="调度器Scheduler">调度器Scheduler</h4><p>资源来源</p><ul><li>业务系统</li><li>定时任务平台</li></ul><h4 id="执行器Executor">执行器Executor</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/310f0b32aab24712b91cef18db0e33f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="业务应用">业务应用</h3><ul><li>业务应用<ul><li>所有需要定时、延时、周期性执行任务的业务场景，都可以考虑使用分布式定时任务</li></ul></li><li>知识面扩充<ul><li>分布式定时任务</li><li>单机定时任务</li><li>延时消息</li><li>离线计算引擎Hive</li><li>实时计算引擎Flink</li></ul></li></ul><h2 id="课后">课后</h2><ol><li>分布式定时任务可以帮助我们处理哪些业务场景？</li><li>春节集卡瓜分20亿的玩法，发奖金额计算、实时开奖两个阶段分别用到分布式定时任务什么执行模式？</li><li>有了分布式定时任务，单机定时任务还有适用场景么？</li><li>时间轮这种数据结构，在定时/延时场景相比其他数据结构有哪些优势？</li><li>分布式定时任务的调度中心怎么判断一台执行器的机器处于可被调度状态？</li><li>你能想到哪些业务场景，实时计算引擎优于分布式定时任务？</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑灰产监控与防御</title>
    <link href="/2023/02/04/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day11/"/>
    <url>/2023/02/04/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day11/</url>
    
    <content type="html"><![CDATA[<p>黑灰产监控与防御</p><span id="more"></span><h1>黑灰产监控与防御</h1><h2 id="1、概述">1、概述</h2><p>企业的信息安全体系是非常庞大的，任何一个环节都可能会出现安全风险。其中，黑灰产是安全人员最为关注的一个风险来源，也是历年来导致企业和用户损失最大的因素。</p><p>如果某个平台或者业务被黑灰产盯上，可能是因为这个业务存在安全隐患被黑灰产利用，也可能只是被黑灰产当做牟利的垫脚石。对黑灰产的监控和防御，就是要了解他们的意图、手段和行为模式，避免被黑灰产攻击或者利用。</p><p>本次可能会给大家简单介绍国内黑灰产的情况，挑选了几种比较经典的黑产作弊手段进行详细分析，希望能帮助大家对黑灰产这个群体有一定的了解，提升各位的安全意识，在日后的工作和生活中，多一些安全角度的思考。</p><h2 id="2、课前预习">2、课前预习</h2><p>本次课程偏科普性质，但内容不是大家在网络上可以随便看到的，课前可以阅读一些国内黑灰产的调研报告</p><p>推荐 <a href="https://link.juejin.cn?target=https%3A%2F%2Fsearch.freebuf.com%2Fsearch%2F%3Fsearch%3D%25E9%25BB%2591%25E9%2595%259C%25E8%25B0%2583%25E6%259F%25A5%23article" title="https://search.freebuf.com/search/?search=%E9%BB%91%E9%95%9C%E8%B0%83%E6%9F%A5#article">Freebuf 黑镜调查系列</a> ，其中部分内容是讲师参与调查编写，不一定权威，但内容和数据都比较真实</p><h2 id="3、思考">3、思考</h2><ul><li>身边是否有一些事情是可能与黑产有关的，如何辨别？</li><li>你当前所学习和研究的技术，是否存在一些公开的安全问题，比如漏洞或者设计缺陷？如何避免他人利用这些问题来攻击你？</li><li>如果无法避免被攻击，如何将损失降低到最小？</li></ul><h2 id="4、相关阅读">4、相关阅读</h2><h3 id="关于业务风控">关于业务风控</h3><p>《风控要略 互联网业务反欺诈之路》讲师参与编写</p><p>《互联网平台智能风控实战》</p><h3 id="关于安全攻防">关于安全攻防</h3><p>《白帽子讲web安全》</p><p>《Web安全深度剖析》</p><p>《Web安全机器学习入门》</p><p>上述几本都是入门级的书，挑一本即可</p><p>《 SQL注入攻击与防御》数据库安全进阶</p><p>《 linux服务器安全攻防》 主机安全进阶</p><h3 id="关于安全体系建设">关于安全体系建设</h3><p>《互联网企业安全高级指南》</p><p>《大型互联网企业安全架构》</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Consul与Kong联合配置理解</title>
    <link href="/2023/02/03/Backend/Consul_kong/"/>
    <url>/2023/02/03/Backend/Consul_kong/</url>
    
    <content type="html"><![CDATA[<p>Consul与Kong联合配置理解</p><span id="more"></span><h1>Consul与Kong联合配置理解</h1><h2 id="Consul介绍（实习-百度-Go后端开发-2023-02-09）">Consul介绍（实习-百度-Go后端开发-2023.02.09）</h2><p>Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。与其他分布式服务注册与发现的方案，Consul的方案更“一站式”，内置了服务注册与发现框 架、分布一致性协议实现、健康检查、Key/Value存储、多数据中心方案，不再需要依赖其他工具（比如ZooKeeper等）。使用起来也较 为简单。Consul使用Go语言编写，因此具有天然可移植性(支持Linux、windows和Mac OS X)；安装包仅包含一个可执行文件，方便部署，与Docker等轻量级容器可无缝配合 。</p><p>consul主要由server和client两种组件组成。</p><p>server负责核心数据的存储和处理请求，server可以部署多个实例(通常推荐3-5个)，server只有一个leader实例，就是主节点，主节点是通过选举产生的，主节点负责数据的写入处理，同时将数据同步至其他server节点</p><p>client负责跟server通信，处理转发服务注册、服务发现请求到server节点，client还负责服务的健康检查，client节点可以部署多个实例，甚至每个微服务节点都部署一个client实例。</p><p>以开发模式启动consul，同时具备server和client的功能，不需要单独部署server和client</p><p>consul健康检查机制制运行在consul client中，会定期的根据服务健康检查配置，去检测服务是否正常，如果服务异常，就将服务的实例标记为不用， 如果恢复了，就标记为可用。</p><ul><li>基于http请求：定时以GET请求方式，请求指定url，http请求返回状态码200表示正常，其他状态代表异常。</li><li>基于tcp请求：基于tcp请求方式，就是定时向指定的地址，建立tcp链接，连接成功就代表服务正常，否则就代表异常。</li><li>基于grpc请求：如果微服务是基于grpc协议，可以使用grpc协议监测服务是否正常。</li><li>基于命令：consul支持定期执行一个命令或脚本，来检测服务是否正常，consul通过监测命令退出状态判断服务是否正常，命令退出状态0代表正常，其他代表异常。</li><li>基于TTL（<strong>服务主动向consul报告自己的健康状况</strong>）：一个健康的APP可以周期性的将状态put到HTTP端</li></ul><h2 id="Kong介绍">Kong介绍</h2><p>Kong是一款基于OpenResty（Nginx + Lua模块）编写的高可用、易扩展的，由Mashape公司开源的API Gateway项目。Kong是基于NGINX和Apache Cassandra或PostgreSQL构建的，能提供易于使用的RESTful API来操作和配置API管理系统，所以它可以水平扩展多个Kong服务器，通过前置的负载均衡配置把请求均匀地分发到各个Server，来应对大批量的网络请求。</p><p>Konga是可以管理Kong的图形界面，带来的一个最大的便利就是可以很好地通过UI观察到现在kong的所有的配置，并且可以对于管理kong节点情况进行查看、监控和预警。</p><h2 id="传统架构">传统架构</h2><p>微服务架构是由多个服务端和多个api端组成，客户端发起请求，需要单独的api进行接收和路由转发，然后通过与不同的服务端建立连接从而获得服务。</p><p>这个过程中需要在程序中记忆大量的端口，且一旦有节点失效，整个服务都将不可用。</p><h2 id="Consul-Kong架构">Consul+Kong架构</h2><p><a href="https://imgse.com/i/pSsIlXF"><img src="https://s1.ax1x.com/2023/02/03/pSsIlXF.png" alt="pSsIlXF.png"></a></p><p>Kong</p><ul><li>将不同api的ip和端口配置到Kong中（如果与Consul结合，直接配置consul_api服务名称.service.consul即可）</li><li>在Kong中设置路由匹配规则</li><li>客户端的请求首先发送给Kong，由Kong进行路由规则的匹配，随后转发到不同的api上</li><li>客户端在请求的时候的ip地址和端口号使用任意一台api的ip地址和端口号即可，所有日志都会发送到该台服务器上，实际请求的日志会转发到其他的api上</li></ul><p>Consul</p><ul><li>一个服务下面可以启动多个实例，收到请求会平均发送给每一个实例</li><li>服务发现：请求服务时只需得知服务名称、consul的ip与端口号即可，无需知道服务具体细节</li><li>健康检查：服务注册后consul每间隔一段时间发送响应给服务的实例，确认在线情况</li><li>服务注册：服务向consul报告自己的ip和端口号</li></ul><h3 id="Consul代码示例">Consul代码示例</h3><p><strong>api端</strong></p><p>服务注册：</p><div class="code-wrapper"><pre><code class="hljs go">registerClient := consul.NewRegistryClient(global.GlobalConfig.Consul.Address, global.GlobalConfig.Consul.Port)err = registerClient.Register(global.GlobalConfig.MainServer.Address, global.GlobalConfig.MainServer.Port, <span class="hljs-string">&quot;video-api&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;api&quot;</span>, <span class="hljs-string">&quot;video&quot;</span>&#125;)</code></pre></div><p>健康检查（注意是HTTP类型的）：</p><div class="code-wrapper"><pre><code class="hljs go">check := &amp;api.AgentServiceCheck&#123;HTTP:                           <span class="hljs-string">&quot;http://&quot;</span> + address + <span class="hljs-string">&quot;:&quot;</span> + port + <span class="hljs-string">&quot;/health&quot;</span>,Timeout:                        <span class="hljs-string">&quot;5s&quot;</span>,Interval:                       <span class="hljs-string">&quot;5s&quot;</span>,DeregisterCriticalServiceAfter: <span class="hljs-string">&quot;10s&quot;</span>,&#125;</code></pre></div><p>连接服务端：</p><div class="code-wrapper"><pre><code class="hljs go">conn, err = grpc.Dial(<span class="hljs-string">&quot;consul://&quot;</span>+global.GlobalConfig.Consul.Address+<span class="hljs-string">&quot;:&quot;</span>+global.GlobalConfig.Consul.Port+<span class="hljs-string">&quot;/&quot;</span>+name+<span class="hljs-string">&quot;?wait=14s&quot;</span>,grpc.WithTransportCredentials(insecure.NewCredentials(),),grpc.WithDefaultCallOptions(grpc.MaxCallRecvMsgSize(<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*size),grpc.MaxCallSendMsgSize(<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*size),),grpc.WithDefaultServiceConfig(<span class="hljs-string">`&#123;&quot;loadBalancingPolicy&quot;: &quot;round_robin&quot;&#125;`</span>),)</code></pre></div><p><strong>服务端</strong></p><p>注意监听的时候要监听内网地址</p><div class="code-wrapper"><pre><code class="hljs go">lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, global.GlobalConfig.Address.In+<span class="hljs-string">&quot;:&quot;</span>+port)</code></pre></div><p>服务注册：</p><div class="code-wrapper"><pre><code class="hljs go">register_client := consul.NewRegistryClient(global.GlobalConfig.Consul.Address, global.GlobalConfig.Consul.Port)register_client.Register(global.GlobalConfig.Address.Out, port, name, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;srv&quot;</span>, <span class="hljs-string">&quot;video&quot;</span>&#125;)</code></pre></div><p>健康检查（注意是GRPC类型的）：</p><div class="code-wrapper"><pre><code class="hljs go">grpc_health_v1.RegisterHealthServer(s, health.NewServer())</code></pre></div><div class="code-wrapper"><pre><code class="hljs go">check := &amp;api.AgentServiceCheck&#123;GRPC:                           address + <span class="hljs-string">&quot;:&quot;</span> + port,Timeout:                        <span class="hljs-string">&quot;5s&quot;</span>,Interval:                       <span class="hljs-string">&quot;5s&quot;</span>,DeregisterCriticalServiceAfter: <span class="hljs-string">&quot;10s&quot;</span>,&#125;</code></pre></div><p>连接api端：</p><div class="code-wrapper"><pre><code class="hljs go">s := grpc.NewServer()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>Consul</tag>
      
      <tag>Kong</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【实践课】手把手教你做系统设计</title>
    <link href="/2023/02/03/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day10/"/>
    <url>/2023/02/03/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day10/</url>
    
    <content type="html"><![CDATA[<p>【实践课】手把手教你做系统设计</p><span id="more"></span><h1>【实践课】手把手教你做系统设计</h1><p>手把手教你做系统设计之秒杀系统</p><h2 id="概述">概述</h2><p>本节课程主要分为四个方面：</p><ol><li>系统设计方法论</li><li>电商秒杀业务介绍</li><li>课程实践</li><li>课程总结</li></ol><p>课前部分主要罗列课程中涉及到的中间件和相关背景知识。对于使用到的中间件，同学们需要体验了解概念，安装并正确使用。课中部分会详细讲解系统设计的方法论和秒杀系统实践，帮助同学们入门系统设计。课后部分会做一些总结，梳理核心思想和重点。</p><h2 id="课前-（必须）">课前 （必须）</h2><h3 id="了解基本的电商概念和流程">了解基本的电商概念和流程</h3><ul><li>电商平台业务</li><li>秒杀业务特点</li></ul><h3 id="MySQL">MySQL</h3><ul><li>安装MySQL，推荐使用MySQL8及以上版本</li><li>熟悉ddl，dml等基础语法</li><li>了解sql优化</li></ul><h3 id="Redis">Redis</h3><ul><li>安装Redis，推荐最新版本</li><li>了解Redis的基本数据类型和使用场景</li><li>熟悉常用命令</li><li>了解Lua脚本的使用</li><li>了解Redis分布式锁</li></ul><h3 id="RocketMQ">RocketMQ</h3><ul><li>安装RocketMQ，推荐最新版本</li><li>了解RocketMQ的基础概念和架构</li><li>了解MQ的使用场景</li><li>了解生产者如何保证消息的可靠性发送</li><li>了解消费者如何保证幂等</li><li>了解消费者pull和push模式的区别</li></ul><h3 id="OpenResty">OpenResty</h3><ul><li>安装OpenResty，推荐最新版本</li><li>了解Nginx的基础概念和使用</li><li>了解Lua脚本的语法</li></ul><h3 id="Linux">Linux</h3><ul><li>熟悉常用命令</li><li>熟悉进程和线程</li><li>了解Linux调优</li></ul><h3 id="Java">Java</h3><ul><li>按照JDK，推荐JDK11</li><li>熟悉Java基础语法和lambda表达式</li><li>熟悉idea的使用</li><li>了解并发编程</li><li>了解springboot框架的使用</li><li>了解maven的使用</li></ul><h3 id="Jmeter">Jmeter</h3><ul><li>安装Jmeter</li><li>了解使用Jmeter压测</li></ul><h2 id="课中">课中</h2><h3 id="引言">引言</h3><ul><li>为什么要做系统设计<ul><li>个人？</li><li>工作？</li></ul></li><li>系统设计的概念是什么</li><li>如何做系统设计<ul><li>4S分析法</li></ul></li><li>如何分析系统瓶颈和优化<ul><li>火焰图分析</li><li>链路分析</li><li>全链路压测</li></ul></li><li>如何验证系统的可用性和稳定性<ul><li>链路梳理</li><li>可观测性</li><li>全链路测试</li><li>稳定性控制</li><li>容灾演练</li></ul></li></ul><h3 id="电商和秒杀">电商和秒杀</h3><h4 id="基本概念">基本概念</h4><ul><li>Spu</li><li>Sku</li><li>秒杀业务的特点</li></ul><h4 id="秒杀的挑战">秒杀的挑战</h4><ul><li>资源有限性</li><li>反欺诈</li><li>高性能</li><li>防止超卖</li><li>流量管控</li><li>扩展性</li><li>鲁棒性</li></ul><h3 id="设计秒杀系统">设计秒杀系统</h3><h4 id="4S分析">4S分析</h4><ul><li>场景</li><li>存储</li><li>功能</li><li>扩展</li></ul><h4 id="系统架构图">系统架构图</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daca3b8bfc8f441bb6f525afa184eaa6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="实践">实践</h3><h4 id="秒杀流程">秒杀流程</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/24e4bde7cdc54beeae2832596dc2f7a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="总结">总结</h3><p><strong>高性能系统的通用设计思想</strong></p><h2 id="课后">课后</h2><ul><li>秒杀课程的总结</li><li>秒杀系统的扩展</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微服务框架 - 不变的基建</title>
    <link href="/2023/02/02/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day09/"/>
    <url>/2023/02/02/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day09/</url>
    
    <content type="html"><![CDATA[<p>微服务框架 - 不变的基建</p><span id="more"></span><h1>微服务框架 - 不变的基建</h1><h2 id="概述">概述</h2><p>本课程内容主要分为以下4个方面：</p><ul><li><p>微服务架构介绍</p><ul><li>微服务架构的背景由来、架构概览、基本要素</li></ul></li><li><p>微服务架构原理及特征</p><ul><li>微服务架构的基本组件、工作原理、流量特征</li></ul></li><li><p>核心服务治理功能</p><ul><li>核心的服务治理功能，包括流量治理、服务均衡、稳定性治理</li></ul></li><li><p>字节跳动服务治理实践</p><ul><li>字节跳动在微服务架构稳定性治理中，对请求重试策略的探索及实践</li></ul></li></ul><p>为了帮助大家更好地预习及理解本节课程，该学员手册列出了课前、课中、及课后这三个阶段所涉及到的专业内容大纲，其中课前部分供同学们提前预习参考，课中部分给出了课程大纲，帮助同学们整理思路，课后部分列出一些扩展性的问题让同学们进一步延伸思考。</p><h2 id="课前">课前</h2><h3 id="微服务架构介绍">微服务架构介绍</h3><ul><li><p>系统架构的演进历史</p><ul><li>单体架构</li><li>垂直应用架构</li><li>分布式架构</li><li>SOA架构</li><li>微服务架构</li></ul></li><li><p>微服务架构的三大要素</p><ul><li>服务治理</li><li>可观测性</li><li>安全</li></ul></li></ul><h3 id="微服务架构原理及特征">微服务架构原理及特征</h3><ul><li><p>微服务架构中的基本概念及组件</p><ul><li>服务、实例…</li></ul></li><li><p>服务间通信</p><ul><li>RPC、HTTP</li></ul></li><li><p>服务注册及服务发现</p></li></ul><h3 id="核心服务治理功能">核心服务治理功能</h3><ul><li><p>服务发布</p><ul><li>蓝绿部署</li><li>灰度发布（金丝雀发布）</li></ul></li><li><p>流量治理</p></li><li><p>负载均衡</p><ul><li>Round Robin</li><li>Ring Hash</li><li>Random</li></ul></li><li><p>稳定性治理</p><ul><li>限流</li><li>熔断</li><li>过载保护</li><li>降级</li></ul></li></ul><h3 id="字节跳动服务治理实践">字节跳动服务治理实践</h3><ul><li>请求重试的意义</li><li>请求重试的难点</li></ul><h2 id="课中">课中</h2><h3 id="微服务架构介绍-2">微服务架构介绍</h3><h4 id="系统架构的演进历史">系统架构的演进历史</h4><ul><li><p>单体架构</p><ul><li>All in one process</li></ul></li><li><p>垂直应用架构</p><ul><li>按照业务线垂直划分</li></ul></li><li><p>分布式架构</p><ul><li>抽出与业务无关的公共模块</li></ul></li><li><p>SOA架构</p><ul><li>面向服务</li></ul></li><li><p>微服务架构</p><ul><li>彻底的服务化</li></ul></li></ul><h4 id="微服务架构概览">微服务架构概览</h4><ul><li>网关</li><li>服务配置和治理</li><li>链路追踪和监控</li></ul><h4 id="微服务架构的三大要素">微服务架构的三大要素</h4><ul><li><p>服务治理（本课程内容）</p><ul><li>服务注册</li><li>服务发现</li><li>负载均衡</li><li>扩缩容</li><li>流量治理</li><li>稳定性治理</li></ul></li><li><p>可观测性</p><ul><li>日志采集</li><li>日志分析</li><li>监控打点</li><li>监控大盘</li><li>异常报警</li><li>链路追踪</li></ul></li><li><p>安全</p><ul><li>身份验证</li><li>认证授权</li><li>访问令牌</li><li>审计</li><li>传输加密</li><li>黑产攻击</li></ul></li></ul><h3 id="微服务架构原理及特征-2">微服务架构原理及特征</h3><h4 id="微服务架构中的基本概念及组件">微服务架构中的基本概念及组件</h4><ul><li><p>服务</p><ul><li>一组具有相同逻辑的运行实体</li></ul></li><li><p>实例</p><ul><li>一个服务中的每个运行实体</li></ul></li><li><p>实例与进程的关系</p><ul><li>没有必然对应关系，一般一对一或者一对多</li></ul></li><li><p>常见的实例承载形式</p><ul><li>进程、VM、k8s pod…</li></ul></li></ul><h4 id="服务间通信">服务间通信</h4><ul><li>微服务之间通过网络进行通信</li><li>常见的通信协议包括 HTTP、RPC</li></ul><h4 id="服务注册及服务发现">服务注册及服务发现</h4><ul><li><p>基本问题</p><ul><li>服务间调用中，如何指定下游服务实例的地址？</li></ul></li><li><p>简单方案</p><ul><li>直接指定 ip:port？<ul><li>没有任何动态能力</li><li>有多个实例下游实例怎么办？</li></ul></li><li>使用 DNS？<ul><li>本地 DNS 存在缓存，导致延迟</li><li>DNS 没有负载均衡</li><li>不支持服务探活检查</li><li>DNS 不能指定端口</li></ul></li></ul></li><li><p>服务注册发现</p><ul><li>新增一个统一的服务注册中心，用于存储服务名到服务实例之间的映射关系</li><li>旧服务实例下线前，从服务注册中心删除该实例，下线流量</li><li>新服务实例上线后，在服务注册中心注册该实例，上线流量</li></ul></li><li><p>微服务流量特征</p><ul><li>统一网关入口</li><li>外网通信多数采用 HTTP，内网通信多数采用 RPC（Thrift, gRPC）</li></ul></li></ul><h3 id="核心服务治理功能-2">核心服务治理功能</h3><h4 id="服务发布">服务发布</h4><ul><li><p>何为服务发布</p><ul><li>让一个服务升级运行新的代码的过程</li></ul></li><li><p>服务发布难点</p><ul><li>服务不可用</li><li>服务抖动</li><li>服务回滚</li></ul></li><li><p>蓝绿部署</p><ul><li>将服务分成两个部分，分别先后发布</li><li>简单、稳定</li><li>但需要两倍资源</li></ul></li><li><p>灰度发布（金丝雀发布）</p><ul><li>先发布少部分实例，接着逐步增加发布比例</li><li>不需要增加资源</li><li>回滚难度大，基础设施要求高</li></ul></li></ul><h4 id="流量治理">流量治理</h4><ul><li><p>流量控制</p><ul><li>在微服务架构中，可以从各个维度对端到端的流量在链路上进行精确控制</li></ul></li><li><p>控制维度</p><ul><li>地区维度</li><li>集群维度</li><li>实例维度</li><li>请求维度</li></ul></li></ul><h4 id="负载均衡">负载均衡</h4><ul><li>Round Robin</li><li>Random</li><li>Ring Hash</li><li>Least Request</li></ul><h4 id="稳定性治理">稳定性治理</h4><ul><li><p>限流</p><ul><li>限制服务处理的最大 QPS，拒绝过多请求</li></ul></li><li><p>熔断</p><ul><li>中断请求路径，增加冷却时间从而让故障实例尝试恢复</li></ul></li><li><p>过载保护</p><ul><li>在负载高的实例中，主动拒绝一部分请求，防止实例被打挂</li></ul></li><li><p>降级</p><ul><li>服务处理能力不足时，拒绝低级别的请求，只响应线上高优请求</li></ul></li></ul><h3 id="字节跳动服务治理实践-2">字节跳动服务治理实践</h3><ul><li><p>请求重试的意义</p><ul><li>本地函数调用<ul><li>通常没有重试意义</li></ul></li><li>远程函数调用<ul><li>网络抖动、下游负载高、下游机器宕机…</li><li>重试是有意义的，可以避免偶发性的错误，提高 SLA</li></ul></li><li>重试的意义<ul><li>降低错误率</li><li>降低长尾延时</li><li>容忍暂时性错误</li><li>避开下游故障实例</li></ul></li></ul></li><li><p>请求重试的难点</p><ul><li>幂等性<ul><li>POST 请求可以重试吗？</li></ul></li><li>重试风暴<ul><li>随着调用链路的增加，重试次数呈指数级上升</li></ul></li><li>超时设置<ul><li>假设调用时间一共1s，经过多少时间开始重试？</li></ul></li></ul></li><li><p>重试策略</p><ul><li>限制重试比例<ul><li>设定一个重试比例阈值（例如 1%），重试次数占所有请求比例不超过该阈值</li></ul></li><li>防止链路重试<ul><li>返回特殊的 status code，表示“请求失败，但别重试”</li></ul></li><li>Hedged Requests<ul><li>对于可能超时（或延时高）的请求，重新向另一个下游实例发送一个相同的请求，并等待先到达的响应</li></ul></li></ul></li><li><p>重试效果验证</p><ul><li>字节跳动重试组件能够极大限制重试发生的链路放大效应</li></ul></li></ul><h2 id="课后">课后</h2><ol><li>结合 CAP 等原理，思考微服务架构有哪些缺陷？</li><li>微服务是否拆分得越“微”越好？为什么？</li><li>Service Mesh 这一架构是为了解决微服务架构的什么问题？</li><li>有没有可能有这样一种架构，从开发上线运维体验上是微服务，但实际运行又类似单体服务？</li></ol><h2 id="参考文献">参考文献</h2><ol><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fswlh%2Fa-design-analysis-of-cloud-based-microservices-architecture-at-netflix-98836b2da45f" title="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fswlh%2Fa-design-analysis-of-cloud-based-microservices-architecture-at-netflix-98836b2da45f">A Design Analysis of Cloud-based Microservices Architecture at Netflix</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Flink.juejin.cn%3Ftarget%3Dhttps%253A%252F%252Fwww.infoq.cn%252Farticle%252Fasgjevrm8islszo7ixzh" title="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2Fasgjevrm8islszo7ixzh">字节跳动微服务架构体系演进</a></li><li><a href="https://juejin.cn/post/6960282794081812511" title="https://juejin.cn/post/6960282794081812511">微服务架构的一知半解</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式理论 - 现代架构基石</title>
    <link href="/2023/01/31/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day08/"/>
    <url>/2023/01/31/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day08/</url>
    
    <content type="html"><![CDATA[<p>分布式理论 - 现代架构基石</p><span id="more"></span><h1>分布式理论 - 现代架构基石</h1><h2 id="概述">概述</h2><p>本节课程主要分为6个方面：</p><ol><li>概述</li><li>系统模型</li><li>理论基础</li><li>分布式事务</li><li>共识协议</li><li>分布式实践</li></ol><p>课前部分主要罗列课程中涉及到的概念。对于不熟悉的概念，同学们可以提前查询预习；课中部分主要罗列每一部分的关键思路，帮助同学们跟上课程的进度；课后部分是一些问题，帮助同学们在课后梳理本课程的重点。</p><h2 id="课前-（必须）">课前 （必须）</h2><h3 id="概述-2">概述</h3><ul><li>什么是分布式？</li><li>Why-How-What</li><li>常见的分布式系统</li></ul><h3 id="系统模型">系统模型</h3><ul><li>故障模型</li><li>拜占庭将军问题</li><li>共识和一致性</li><li>时间和事件顺序</li></ul><h3 id="理论基础">理论基础</h3><ul><li>CAP理论</li><li>ACID理论</li><li>BASE理论</li></ul><h3 id="分布式事务">分布式事务</h3><ul><li>两阶段提交</li><li>三阶段提交</li><li>MVCC</li></ul><h3 id="共识协议">共识协议</h3><ul><li>Quorum NWR模型</li><li>RAFT协议</li><li>Paxos协议</li></ul><h3 id="分布式实践">分布式实践</h3><ul><li>MapReduce</li><li>分布式KV</li></ul><h2 id="课中">课中</h2><h3 id="概述-3">概述</h3><ul><li>什么是分布式？<ul><li>分布式系统定义：跨多个节点的计算机程序的集合</li><li>使用分布式系统的五大优势：去中心化、低成本、弹性、资源共享、可靠性高</li><li>分布式系统的挑战：故障、网络、环境、安全</li></ul></li><li>Why-How-What<ul><li>使用者视角：大规模计算存储的述求</li><li>学习者视角：后端开发必备技能</li></ul></li><li>常见的分布式系统<ul><li>分布式存储：GFS、Ceph、HDFS、Zookeeper</li><li>分布式数据库：Spanner、TiDB、HBase、MangoDB</li><li>分布式计算：Hadoop、YARN、Spark</li></ul></li></ul><h3 id="系统模型-2">系统模型</h3><h4 id="故障模型">故障模型</h4><ul><li>六种故障模型，从处理的难易程度分类<ul><li>Byzantine failure：节点可以任意篡改发送给其他节点的数据，是最难处理的故障</li><li>Authentication detectable byzantine failure (ADB)：节点可以篡改数据，但不能伪造其他节点的数据</li><li>Performance failure：节点未在特定时间段内收到数据，即时间太早或太晚</li><li>Omission failure：节点收到数据的时间无限晚，即收不到数据</li><li>Crash failure：节点停止响应，持续性的故障</li><li>Fail-stop failure：错误可检测，是最容易处理的故障</li></ul></li><li>故障模型举例，按照模型分类<ul><li>磁盘、主板、交换机、网络分区、cpu、内存、线缆、电源等故障详细说明</li></ul></li></ul><h4 id="拜占庭将军问题">拜占庭将军问题</h4><ul><li>两将军问题<ul><li>定义：<ul><li>两支军队的将军只能派信使穿越敌方领土互相通信，以此约定进攻时间。该问题希望求解如何在两名将军派出的任何信使都可能被俘虏的情况下，就进攻时间达成共识</li></ul></li><li>结论：<ul><li>两将军问题是被证实无解的电脑通信问题，两支军队理论上永远无法达成共识</li></ul></li><li>TCP是两将军问题的一个工程解</li></ul></li><li>三将军问题：<ul><li>两个“忠将”A和B，一个“叛徒”C，互相传递消息，消息可能丢失，也可能被篡改，当有一个将军是“叛徒”（即出现拜占庭故障）时，整个系统无法达成一致。</li><li>由于“叛徒”C的存在，将军A和将军B获得不同的信息。这样将军A获得2票进攻1票撤退的信息，将军B获得1票进攻2票撤退的信息，产生了不一致</li></ul></li><li>四将军问题：<ul><li>将军D作为消息分发中枢，约定如果没收到消息则执行撤退</li><li>步骤：<ul><li>如果D为“叛徒”，ABC无论收到任何消息，总能达成一致</li><li>D为“忠将”，ABC有2人将D的消息进行正确的传递，同样能保证最终决策符合大多数。</li></ul></li><li>进而能够证明，当有3m+1个将军，m个“叛徒”时，可以进行m轮协商，最终达成一致</li></ul></li></ul><h4 id="共识和一致性">共识和一致性</h4><ul><li>不同客户端A和B看到客户端C写入，因为时机的不同，产生数据读取的偏差。引导出最终一致性的详细说明</li><li>要保证所有客户端看到相同的值，需要多节点进行“协商”，达成共识，来保证线性一致性</li><li>一致性和可用性是对矛盾</li></ul><h4 id="时间和事件顺序">时间和事件顺序</h4><ul><li>1978年Leslie Lamport发表《<em>Time, Clocks, and the Ordering of Events in a Distributed System》</em><ul><li>定义了计算机系统中的时间和事件顺序，引入<em>happened before</em>和并发的定义，可以以此对分布式系统中的事件进行推导</li><li>根据上述推导，创造了Lamport逻辑时钟的概念，这个概念在分布式理论中具有革命性的意义，帮助我们在一系列分布式事件当中梳理出逻辑的先后关系。利用逻辑时钟，我们可以对整个系统中的事件进行全序排序</li></ul></li></ul><h3 id="理论基础-2">理论基础</h3><h4 id="CAP理论">CAP理论</h4><ul><li>CAP的定义，分别代表一致性、可用性、分区容错性。三者无法同时达到</li><li>CAP诞生了三类系统：<ul><li>CA系统：传统数据库的代表</li><li>AP系统：放弃强一致性，保证高可用，不少nosql存储系统采用</li><li>CP系统：放弃可用性，保证数据一致性</li></ul></li><li>举例说明两个分布式进程之间同步数据，当出现故障的时候，如何选择不同的CAP系统，以及带来的影响<ul><li>CP系统：故障发生时，为了避免读到不一致的数据，可能拒绝访问</li><li>AP系统：故障发生时，为了保证可用性，允许不同进程读到不同的数据</li></ul></li><li>针对故障场景，可以通过故障转移的方式，做一个相对较优的解决方式：<ul><li>允许一个进程作为Master，其他进程作为Backup，当故障时将请求转移给Backup进行处理</li></ul></li></ul><h4 id="ACID理论">ACID理论</h4><ul><li>ACID理论是针对CA系统而言的，通常在数据库中具有广泛意义</li><li>事务是数据库系统中非常重要的概念，它是数据库管理系统执行过程中的一个逻辑单元，它能够保证一个事务中的所有操作要么全部执行，要么全都不执行</li><li>数据库事务拥有四个特性ACID：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4004eafb82244f7aa65aad9b8469e899~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="BASE理论">BASE理论</h4><ul><li>BASE理论是针对AP系统而言的，其来源于对大型互联网分布式实践的总结<ul><li>Basically Available(基本可用)：假设系统，出现了不可预知的故障，但还是能用</li><li>Soft state（软状态）：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性</li><li>Eventually consistent（最终一致性）：数据最终一定能够达到一致的状态</li></ul></li></ul><h3 id="分布式事务-2">分布式事务</h3><h4 id="二阶段提交">二阶段提交</h4><ul><li>定义：<ul><li>二阶段提交（Two-phase Commit）：为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种演算法。</li></ul></li><li>三个假设：<ul><li>协调者和参与者进行通信</li><li>预写式日志被保持在可靠的存储设备上</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复</li></ul></li><li>正常流程：Prepare阶段和Commit阶段</li><li>异常流程：Prepare阶段失败 -&gt; 回滚；协调者宕机 -&gt; 重新启用新的协调者；双故障重启 -&gt; 数据库管理员介入</li><li>两阶段提交需解决的问题：<ul><li>性能问题：需要多次网络通信，资源需要等待并锁定</li><li>新协调者：如何确定状态选出新协调者</li><li>Commit阶段网络分区带来的数据不一致：非所有节点都收到Commit请求</li></ul></li><li>两个思考：<ul><li>日志被保存在「可靠」的存储设备上。如何保证这一点？</li><li>参与者Commit了，但Ack信息协调者没收到。怎么办？</li></ul></li></ul><h4 id="三阶段提交">三阶段提交</h4><ul><li>针对两阶段提交的补充，将两阶段提交中的Prepare阶段，拆成两部分：CanCommit和PreCommit机制</li><li>CanCommit阶段：询问是否可以执行；PreCommit阶段：重新确认是否可以执行</li><li>DoCommit阶段：向所有人提交事务</li></ul><h4 id="MVCC">MVCC</h4><ul><li>MVCC：多版本并发控制的方法。维持一个数据的多个版本使读写操作没有冲突。所以既不会阻塞写，也不阻塞读。提高并发性能的同时也解决了脏读的问题。</li><li>悲观锁和乐观锁<ul><li>悲观锁：操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据</li><li>乐观锁：不会上锁，只是在执行更新时判断别人是否修改数据，只有冲突时才放弃操作</li></ul></li><li>版本的选取：使用物理时钟或逻辑时钟<ul><li>物理时钟：提供TrueTime API，有Master节点维持一个绝对时间，保证各个服务器之间时钟误差控制在ϵ内，通常ϵ&lt;7ms。</li><li>逻辑时钟：中心化授时的方式–时间戳预言机（TSO），好处是无需硬件的支持</li></ul></li></ul><h3 id="共识协议-2">共识协议</h3><h4 id="Quorum-NWR模型">Quorum NWR模型</h4><ul><li>三要素：<ul><li>N：在分布式存储系统中，有多少份备份数据</li><li>W：代表一次成功的更新操作要求至少有w份数据写入成功</li><li>R： 代表一次成功的读数据操作要求至少有R份数据成功读取</li><li>为了保证强一致性，需要保证 W+R&gt;N</li></ul></li><li>Quorum NWR模型将CAP的选择交给用户，是一种简化版的一致性模型</li><li>引起的并发更新问题<ul><li>如果允许数据被覆盖，则并发更新容易引起一致性问题</li></ul></li></ul><h4 id="RAFT协议">RAFT协议</h4><ul><li>概述<ul><li>Raft协议是一种分布式一致性算法（共识算法），即使出现部分节点故障，网络延时等情况，也不影响各节点，进而提高系统的整体可用性。Raft是使用较为广泛的分布式协议。</li></ul></li><li>三种角色<ul><li>Leader - 领导者：Leader 负责处理所有的客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后，通知Follower提交日志</li><li>Follower - 跟随者：接受并持久化Leader同步的日志，在Leader告知日志可以提交后，提交日志</li><li>Candidate - 备选者：Leader选举过程中的临时角色。向其他节点发送请求投票信息</li></ul></li><li>四种定义：<ul><li>Log（日志）：节点之间同步的信息，以只追加写的方式进行同步，解决了数据被覆盖的问题</li><li>Term（任期号）：单调递增，每个Term内最多只有一个Leader</li><li>Committed：日志被复制到多数派节点，即可认为已经被提交</li><li>Applied：日志被应用到本地状态机：执行了log中命令，修改了内存状态</li></ul></li><li>状态转移：</li><li>Leader选举过程：<ul><li>初始全部为Follower</li><li>Current Term + 1</li><li>选举自己</li><li>向其它参与者发起RequestVote请求，retry直到<ul><li>收到多数派请求，成为Leader，并发送心跳</li><li>收到其它Leader的请求，转为Follower，更新自己的Term</li><li>收到部分，但未达到多数派，选举超时，随机timeout开始下一轮</li></ul></li></ul></li><li>Log Replication过程：<ul><li>新Leader产生，Leader和Follower不同步，Leader强制覆盖Followers的不同步的日志</li></ul></li><li>切主：当Leader出现问题时，就需要进行重新选举<ul><li>Leader发现失去Follower的响应，失去Leader身份</li><li>两个Follower之间一段时间未收到心跳，重新进行选举，选出新的Leader，此时发生了切主</li><li>Leader自杀重启，以Follower的身份加入进来</li></ul></li><li>Stale读：<ul><li>发生Leader切换，old leader收到了读请求。如果直接响应，可能会有Stale Read</li></ul></li></ul><h3 id="Paxos协议">Paxos协议</h3><ul><li>Paxos算法与RAFT算法区别：<ul><li>Multi-Paxos 可以并发修改日志，而Raft写日志操作必须是连续的</li><li>Multi-Paxos 可以随机选主，不必最新最全的节点当选Leader</li></ul></li><li>优劣势<ul><li>优势：写入并发性能高，所有节点都能写</li><li>劣势：没有一个节点有完整的最新的数据，恢复流程复杂，需要同步历史记录</li></ul></li></ul><h3 id="分布式实践-2">分布式实践</h3><h4 id="MapReduce">MapReduce</h4><ul><li>设计一个简易的MapReduce系统，思考如何应对故障？</li></ul><h4 id="分布式KV">分布式KV</h4><ul><li>设计一个简易的分布式键值系统，要求具备弹性的能力和达成线性一致</li></ul><h2 id="课后">课后</h2><ol><li>分布式系统有哪些优势和挑战？</li><li>两将军问题为什么理论上永远达不成共识？</li><li>为什么TCP采用三次握手？而不是两次和四次？</li><li>为什么在4将军问题中，增加1轮协商就可以对抗拜占庭故障？</li><li>什么是最终一致性？什么是线性一致性？</li><li>CAP理论中，请举例说明可用性和一致性的矛盾？</li><li>数据库里的一致性和分布式系统中的一致性有什么区别？</li><li>两阶段提交中，什么场景需要数据库管理员介入？</li><li>三阶段提交缓和两阶段提交的哪两个问题？</li><li>什么场景适合乐观锁？什么场景适合悲观锁？</li><li>在共识协议中，为什么说允许数据被覆盖会带来数据一致性问题？</li><li>RAFT协议中，Leader写成功日志Log20但未同步给Followers后宕机，Follower重新选举后产生一条新日志Log20，这时Leader重启，整个系统发现两种不一样的Log20的记录，请问如何区分并拒掉前面的Log20？</li><li>RAFT协议中，Stale读是如何产生的？该如何解决Stale读的问题？</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>架构初探 - 谁动了我的蛋糕</title>
    <link href="/2023/01/30/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day07/"/>
    <url>/2023/01/30/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day07/</url>
    
    <content type="html"><![CDATA[<p>架构初探 - 谁动了我的蛋糕</p><span id="more"></span><h1>架构初探 - 谁动了我的蛋糕</h1><h2 id="使用指南">使用指南</h2><p>为了帮助同学们更好地理解本课程，我为大家准备了本学员手册。它包含以下几大模块内容：</p><ul><li>课程目标，本课程主要框架的简单介绍，便于同学们抓住课程的框架结构，把握听课节奏；</li><li>课前，本课程的重要前置知识点，便于同学们在听课过程中快速理解、跟紧思路；</li><li>课中，本课程各章节涉及的关键概念和知识点，帮助同学们加深核心内容的理解和认识；</li><li>课后，本课程的内容提炼，便于同学们总结课程要点，争取达到举一反三的效果。</li></ul><h2 id="课程目标">课程目标</h2><p>本课程的包含以下四个方面：</p><ul><li>什么是架构<ul><li>围绕架构的定义和演进两部分内容展开</li></ul></li><li>企业级后端架构剖析<ul><li>详细介绍企业级后端架构的形态</li></ul></li><li>企业级后端架构的挑战<ul><li>企业级架构都面临着哪些挑战，如何解决</li></ul></li><li>后端架构实战<ul><li>结合前三部分的知识点，以第三部分中的一个挑战为例，讲解如何做架构设计</li></ul></li></ul><h2 id="课前">课前</h2><h3 id="什么是架构">什么是架构</h3><p>常见软件架构：</p><ul><li>单机</li><li>单体</li><li>垂直应用</li><li>SOA (Service Oriented Architecture)</li><li>微服务 (Microservice)</li></ul><p>一些小问题：</p><ul><li>如何给架构下定义？</li><li>架构的重要性？</li><li>架构演进的初衷？</li><li>架构演进的思路？</li></ul><h3 id="企业级后端架构剖析">企业级后端架构剖析</h3><ul><li>云计算<ul><li>基础<ul><li>虚拟化</li><li>编排</li></ul></li><li>架构<ul><li>IaaS</li><li>SaaS</li><li>PaaS</li><li>FaaS</li></ul></li></ul></li><li>云原生<ul><li>弹性资源<ul><li>计算资源</li><li>存储资源</li></ul></li><li>微服务架构<ul><li>通信协议</li><li>中间件</li></ul></li><li>DevOps<ul><li>软件生命周期</li></ul></li><li>服务网格</li></ul></li></ul><h3 id="企业级后端架构的挑战">企业级后端架构的挑战</h3><ul><li>离线任务</li><li>在线任务</li><li>IO 密集型</li><li>CPU 密集型</li><li>服务治理</li><li>IPC (Inter-Process Communication)</li><li>RPC (Remote Procedure Call)</li></ul><h3 id="后端架构实战">后端架构实战</h3><ul><li>负载均衡 Load Balancing</li><li>服务发现 Service Discovery</li><li>服务注册 Service Registry</li><li>宿主机 Host</li><li>容器 Container</li><li>时序数据 Time Series</li><li>一致性哈希 Consistent Hash</li></ul><h2 id="课前思考题">课前思考题</h2><ol><li>软件架构演进至今都有哪些形态？它们分别解决了什么问题？仍然存在什么问题？</li><li>云计算有哪些基础技术？云计算服务的形态又有哪些？</li><li>云原生是什么？它跟云计算的关系是？</li><li>云原生的代表技术有哪些？</li><li>企业级后端架构面临的挑战有哪些？</li></ol><h2 id="课中">课中</h2><h3 id="什么是架构-2">什么是架构</h3><h4 id="架构定义">架构定义</h4><p><strong>Q：如何给架构下定义？</strong></p><p>A：架构，又称软件架构：</p><ul><li>是有关软件整体结构与组件的抽象描述</li><li>用于指导软件系统各个方面的设计</li></ul><p><strong>Q：架构的重要性？</strong></p><p>A：那盖房子来做举例子。</p><p>我们都知道，地基对于一栋楼房的主要性，架构对于一个软件的重要性也是类似的：</p><ul><li>架构没设计好，软件容易崩，用户体验上不去。最终要么重构，要么放弃</li><li>架构设计好了，软件的稳定性上去了，用户体验高了，口碑一点点就打造出来了</li><li>良好的架构基础，也为软件的未来发展提供了更多的可能。为用户赋能，实现自身价值</li></ul><h4 id="单机架构">单机架构</h4><p>All in one，所有的东西都在一个进程里，部署在一个机器上。</p><p>优点：</p><ul><li>简单</li></ul><p>缺点：</p><ul><li>运维需要停服，用户体验较差</li><li>承载能力有限。<strong>了解下 c10k 问题</strong></li></ul><h4 id="单体架构">单体架构</h4><p>在单机架构的基础上，将进程部署到多个机器上。</p><p>优点：</p><ul><li>具备水平扩容能力</li><li>运维不需要停服</li></ul><p>缺点：</p><ul><li>后端进程职责太多，越来越臃肿</li><li>爆炸半径较大，进程中一个很小的模块出现问题，都可能导致整个进程崩溃</li></ul><h4 id="垂直应用架构">垂直应用架构</h4><p>在单机架构基础上，将进程按照某种依据切分开。比如，A 软件和 B 软件的后端原先采用单机架构部署，那就是一个进程部署在多个机器上；如果用垂直应用架构，可以将 A 和 B 的后端拆分为 A、B 两个进程，然后再按照单体模式的思路，部署在多个机器上。</p><p>优点：</p><ul><li>一定程度上减少了后端进程职责</li><li>一定程度上缩小爆炸半径</li></ul><p>缺点：</p><ul><li>没有根本解决单体架构的问题</li></ul><h4 id="SOA-面向服务架构">SOA (面向服务架构)</h4><p>SOA 架构中，服务为一等公民，将进程按照不同的功能单元进行抽象，拆分为『服务』。有了服务之后，SOA 还为服务之间的通信定义了标准，保证各个服务之间通讯体验的一致性。</p><p>优点：</p><ul><li>各服务的职责更清晰</li><li>运维粒度减小到服务，爆炸半径可控</li></ul><p>缺点：</p><ul><li>ESB (企业服务总线) 往往需要一整套解决方案</li></ul><h4 id="微服务">微服务</h4><p>在 SOA 架构中，ESB 起到了至关重要的作用。但从架构拓扑来看，它更像是一个集中式的模块。有一个 SOA 分布式演进的分支，最终的形态便是微服务。</p><p>优点：</p><ul><li>兼具 SOA 解决的问题</li><li>服务间的通信更敏捷、灵活</li></ul><p>缺点：</p><ul><li>运维成本</li></ul><h4 id="小结">小结</h4><ul><li>架构演进的初衷：满足软件迭代诉求，提高迭代效率</li><li>架构演进的思路：垂直切分——分布式，水平切分——分层/模块化</li></ul><h3 id="企业级后端架构剖析-2">企业级后端架构剖析</h3><h4 id="云计算">云计算</h4><p>云计算基础：</p><ul><li>虚拟化技术<ul><li>硬件层面（VM 虚拟机）- KVM/Xen/VMware</li><li>操作系统层面（Container 容器）- LCX/Docker/Kata Container</li><li>网络层面 - Linux Bridge/Open v Switch</li></ul></li><li>编排方案<ul><li>VM - OpenStack/VMWare Workstation</li><li>Container - Kubernetes/Docker Swarm</li></ul></li></ul><p>云计算架构：</p><ul><li>云服务<ul><li>IaaS - 云基础设施，对底层硬件资源池的抽象</li><li>PaaS - 基于资源池抽象，对上层提供的弹性资源平台</li><li>SaaS - 基于弹性资源平台构建的云服务</li><li>FaaS - 更轻量级的函数服务。好比 LeetCode 等 OJ，刷题时只需要实现函数，不需要关注输入输出流</li></ul></li><li>云部署模式（拓展）<ul><li>私有云 - 企业自用</li><li>公有云 - AWS/Azure/Google Cloud/Huawei</li><li>混合云</li></ul></li></ul><h4 id="云原生">云原生</h4><p>云原生，实际是云原生（计算）的简称，它是云计算发展到现在的一种形态。</p><p>云原生技术为组织（公司）在公有云、自由云、混合云等新型的动态环境中，构建和运行可弹性拓展的应用提供了可能。 它的代表技术：</p><ul><li>弹性资源</li><li>微服务架构</li><li>DevOps</li><li>服务网格</li></ul><h5 id="弹性资源">弹性资源</h5><p>基于虚拟化技术，提供的可以快速扩缩容的能力。可以分为弹性计算资源和弹性存储资源两个方面。</p><p>弹性计算资源：</p><ul><li>计算资源调度<ul><li>在线计算 - 互联网后端服务</li><li>离线计算 - 大数据分析。Map-Reduce/Spark/Flinnk</li></ul></li><li>消息队列<ul><li>在线队列 - 削峰、解耦</li><li>离线队列 - 结合数据分析的一整套方案，如 ELK</li></ul></li></ul><p>弹性存储资源：</p><ul><li>经典存储<ul><li>对象存储 - 视频、图片等。结合 CDN 等技术，可以为应用提供丰富的多媒体能力</li><li>大数据存储 - 应用日志、用户数据等。结合数据挖掘、机器学习等技术，提高应用的体验</li></ul></li><li>关系型数据库</li><li>元数据<ul><li>服务发现</li></ul></li><li>NoSQL<ul><li>KV 存储 - Redis</li><li>文档存储 - Mongo</li></ul></li></ul><p>在云原生的大背景下，不论是计算资源还是存储资源，他们都像是服务一样供用户使用。</p><h5 id="微服务架构">微服务架构</h5><p>微服务架构下，服务之间的通讯标准是基于协议而不是 ESB 的。</p><ul><li>HTTP - H1/H2</li><li>RPC - Apache Thrift/gRPC</li></ul><p>如何在 HTTP 和 RPC 之间选择？</p><ul><li>性能 - RPC 协议往往具备较好的压缩率，性能较高。如 Thrift, Protocol Buffers</li><li>服务治理 - RPC 中间件往往集成了丰富的服务治理能力。如 熔断、降级、超时等</li><li>可解释性 - HTTP 通信的协议往往首选 JSON，可解释性、可调试性更好</li></ul><h5 id="服务网格">服务网格</h5><p>什么是服务网格？</p><ul><li>微服务之间通讯的中间层</li><li>一个高性能的 4 层网络代理</li><li>将流量层面的逻辑与业务进程解耦</li></ul><p>没有什么是加一层代理解决不了的问题，服务网格相比较于 RPC/HTTP 框架：</p><ul><li>实现了异构系统治理体验的统一化</li><li>服务网格的数据平面代理与业务进程采取进程间通信的模式，使得流量相关的逻辑（包含治理）与业务进程解耦，生命周期也更容易管理</li></ul><h3 id="企业级后端架构的挑战-2">企业级后端架构的挑战</h3><h4 id="挑战">挑战</h4><p>基础设施层面：</p><p>Q：我们总说，云是弹性的，也就是说，在用户的角度，云提供的资源是无限的。然而，云背后的物理资源是有限的。在企业级后端架构里，云如何解决近乎无限的弹性资源和有限的物理资源之间的矛盾？</p><p>Q：闲事的资源就这么空着呢？如何提高资源利用率，提高物理资源的价值转换率？</p><p>用户层面：</p><p>Q：上了云原生微服务后，服务之间的通信开销较大，应该如何做成本优化？</p><p>Q：微服务看起来没有那么美好，抖动导致的运维成本较高，如何解决？</p><p>Q：异构的物理环境应该对用户是透明的，如何屏蔽这些细节？</p><h4 id="离在线资源并池">离在线资源并池</h4><p>考虑到在线业务的 <strong>潮汐性</strong> ，物理资源的用量不是一成不变的。离在线资源并池，可以：</p><ul><li>提高物理资源利用率</li><li>提供更多的弹性资源</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1355784a0ae446d8c29b846baa20503~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><h4 id="微服务亲合性部署">微服务亲合性部署</h4><p>微服务之间的通信成本较高，是否可以：</p><ul><li>形态上是微服务架构</li><li>通信上是单体架构</li></ul><p>亲合性部署，通过将微服务调用形态与资源调度系统结合，将一些调用关系紧密、通信量大的服务部署在同一个机器上，并且使用 IPC 代替 RPC 的方式，降低网络通信带来的开销</p><h4 id="流量治理">流量治理</h4><p>Q：微服务之间的通信流量为什么需要治理？</p><p>Q：都有哪些常用的治理手段？</p><p>Q：微服务中心件和服务网格在其中扮演着怎样的角色？</p><h4 id="屏蔽异构环境的算力差异">屏蔽异构环境的算力差异</h4><p>Q：基础设施层往往是个复杂的异构环境，比如，有些机器的 CPU 是英特尔的，而有些是 AMD 的。就算是同一个品牌，也可能是不同代际。如何将这些差异屏蔽掉，使用户尽可能不感知呢？</p><p>Q：什么情况下，我们觉得，服务需要扩容了？异构环境会对这个评判标准产生怎样的影响？</p><h3 id="后端架构实战-2">后端架构实战</h3><h4 id="问题">问题</h4><p>如何设计一个根据主机层面的资源信息，实时进行流量调度的系统，打平不同宿主机异构环境的算力差异。</p><p>关键点：</p><ul><li>紧急回滚能力</li><li>大规模</li><li>极端场景</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69fd09e29bb94ccb9ca50f05c9590aa8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><h2 id="课后">课后</h2><h5 id="课后作业-兰师傅蛋糕房要支持线上售卖了！请帮忙做整套系统的架构设计">课后作业-兰师傅蛋糕房要支持线上售卖了！请帮忙做整套系统的架构设计</h5><p><strong>设计需求：</strong></p><ol><li>多端支持<ol><li>微信/支付宝小程序</li><li>App</li><li>网页</li></ol></li><li>使用云原生基础设施</li><li>用户画像很重要</li><li>积极参加妇女节/光棍节等活动</li></ol><p><strong>注意：</strong> 不需要考虑与做蛋糕相关服务的交互</p><h2 id="尾声">尾声</h2><ol><li>没有最好的架构，只有最合适的架构</li><li>做架构设计<ol><li>先从需求出发。要满足什么样的需求？预期规模有多大？</li><li>做足够的业界调研。业界对于类似的需求是怎么做的？有无成熟的方案可以借鉴？直接拿来用有什么问题？</li><li>技术选型。涉及的技术组件是自研，还是使用开源的？</li><li>异常情况。任何时候，都不能做『输入合法』的假设。容灾能力一定要有</li></ol></li><li>学好架构，是工程师成长的一个重要标志</li></ol><h2 id="参考文献">参考文献</h2><ul><li><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.kegel.com%2Fc10k.html" title="http://www.kegel.com/c10k.html">C10K 问题</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cncf.io%2F" title="https://www.cncf.io/">CNCF</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Flandscape.cncf.io%2F" title="https://landscape.cncf.io/">CNCF landscape</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824 Distributed Systems-Lab 2 Raft</title>
    <link href="/2023/01/29/6.824/Distributed-Systems-MIT-6.824-Lab-2/"/>
    <url>/2023/01/29/6.824/Distributed-Systems-MIT-6.824-Lab-2/</url>
    
    <content type="html"><![CDATA[<p>MIT-6.824（Spring 2022）Lab 2 Raft</p><span id="more"></span><p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">6.824 Lab 2: Raft</a></p><h1>简介</h1><p><a href="https://raft.github.io/">https://raft.github.io/</a></p><p>这是构建容错k/v存储系统的一系列实验室中的第一个。这个实验室将实现复制状态机协议Raft。</p><p>复制服务通过在多个副本服务器上存储其状态（即数据）的完整副本来实现容错。复制允许服务继续运行，即使某些服务器出现故障（崩溃或网络问题）。挑战在于，故障可能会导致复制副本保存不同的数据副本。</p><p>Raft将客户端请求组织成一个序列，称为日志，并确保所有副本服务器都看到相同的日志。每个副本按日志顺序执行客户端请求，并将它们应用于服务状态的本地副本。由于所有活动副本都看到相同的日志内容，因此它们都以相同的顺序执行相同的请求，从而继续具有相同的服务状态。如果服务器出现故障，但稍后恢复，Raft会负责更新其日志。只要有大多数服务器处于活动状态，并且可以相互通信，Raft就会继续运行。如果没有这样的大多数，Raft将会暂时停机，但一旦大多数服务器能够再次通信，Raft就会恢复原来的状态。</p><p>在这个实验中，将会把Raft实现为一个Go对象类型，并实现相关的方法，这意味着要在更大的服务中将Raft用作模块。一组Raft实例通过RPC相互通信，以维护复制的日志。Raft接口将支持无限序列的编号命令，也称为日志条目。条目用索引编号进行编号。具有给定索引的日志条目最终会被提交。此时，Raft应该将日志条目发送到更大的服务以供其执行。</p><p>您应该遵循扩展的Raft论文中的设计，尤其是图2。您将实现本文中的大部分内容，包括保存持久状态，并在节点发生故障后重新启动后读取该状态。不实现第6节提到的集群成员资格更改。</p><p>最具挑战性的部分可能不是实现解决方案，而是调试解决方案。为了帮助解决这一挑战，您可能需要花时间思考如何使实现更易于调试。</p><p>我们还提供了一个Raft交互的图表，可以帮助阐明Raft代码如何与上面的层进行交互。</p><p><a href="https://imgse.com/i/pSdAYtS"><img src="https://s1.ax1x.com/2023/01/29/pSdAYtS.jpg" alt="pSdAYtS.jpg"></a></p><h1>参考资料</h1><h2 id="Students-Guide-to-Raft"><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">Students' Guide to Raft</a></h2><p>（几年前编写，特别是2D部分已经发生了变化）</p><h3 id="背景">背景</h3><p>Raft 是一种共识算法，旨在轻松理解。它与Paxos的容错和性能相当。不同的是，它被分解成相对独立的子问题，它干净地解决了所有主要部分的实际系统需求。我们希望Raft可供更广泛的受众使用，并且这些更广泛的受众将是能够开发各种更高质量的基于共识的系统。</p><p><a href="http://thesecretlivesofdata.com/raft/">可视化网站</a></p><p>与所有分布式共识协议一样，细节很难理解。在没有故障的稳定状态下，Raft 的行为易于理解，并且可以直观地解释。例如，从可视化中很容易看出， 假设没有失败，最终将选出Leader，并且最终，发送给Leader的所有操作都将由Follower按照顺序正确执行。但是，当消息延迟，网络分区或者服务故障，细节变得至关重要。特别是，我们可能一遍又一遍地重复许多错误，仅仅是由于阅读论文时的误解或疏忽。这个问题并非Raft所独有。</p><h3 id="实现Raft">实现Raft</h3><p>Raft 的最终指南在 Raft 论文的图 2 中。这个图片指定在Raft服务器之间交换的每个RPC的行为， 给出服务器必须维护的各种不变量，并指定何时应执行某些操作。我们将在本文的其余部分大量讨论图 2。它需要一字不差地遵循。</p><p>图 2 定义了每个服务器在各种状态下应该对每个传入的 RPC应该做什么，以及何时发生某些其他事情（例如就像在日志中应用条目是安全的一样）。图 2 非常精确，每一条语句在规范术语中，它应该被视为必须，而不是应该。例如，您可以合理地重置一台服务器的选举计时器，只要您收到或RPC，都表明其他服务器要么认为它是Leader，或者是努力成为Leader。直觉上，这意味着我们不应该干扰。但是，如果您仔细阅读图 2，它会说：如果选举超时过去而没有收到当前Leader的RPC或投票给其他的服务器，则转换为Candidate。</p><p>事实证明，区别很重要，因为前一种实现在某些情况下，可能导致活性显著降低。</p><h4 id="细节的重要性">细节的重要性</h4><p>考虑一个例子。Raft论文在许多地方提到了心跳RPC。具体来说，领导者将偶尔（每个检测信号间隔至少一次）向所有服务器发送 RPC，以防止它们启动新的选举。如果领导者没有要发送到特定对等方的新条目， RPC 不包含任何条目，被视为心跳。</p><p>我们的许多学生认为心跳在某种程度上是“特别的”，当服务器收到心跳时，它应该以不同的方式对待它。特别是，许多人会只在收到心跳时重置他们的选举计时器，然后返回成功，而不执行图2中指定的任何检查。这是极其危险的。通过接受 RPC， Follower隐式地告诉Leader他们的日志与Leader匹配并包括参数中包含的内容。收到回复后，领导可能错误地确定某个条目已被复制到大多数服务器，并开始提交它。</p><p>许多人遇到的另一个问题是在收到心跳时，他们会截断Follower的记录，然后添加参数中包含的日志条目。这也是不正确的。图 2说明，如果现有条目与新条目冲突（相同的索引但 不同的任期），删除现有条目及其后面的所有条目。</p><p>这里的如果至关重要。如果Follower拥有Leader的所有条目，Follower不得截断其日志。必须保留Leader发送的条目之后的任何元素。这是因为我们可能从Leader收到过期的RPC，截断日志将意味着“收回”我们可能已经告诉Leader的我们的日志。</p><h3 id="调试Raft">调试Raft</h3><p>在调试时，Raft通常有四个主要的错误来源： 活锁、不正确或不完整的 RPC 处理程序、未能遵循规则和术语混淆。死锁也是一个常见问题，但它们通常可以通过记录所有锁和解锁来调试，并且弄清楚你正在占有哪些锁且没有释放。</p><h4 id="活锁">活锁</h4><p>当系统活锁时，系统中的每个节点都在执行一些东西，但总的来说，你的节点没有取得进展。一个活锁场景特别频繁出现：没有领导人被选举出来，或者一个领导者被选举出来后另一个节点马上开始选举，迫使最近当选的领导人立即退位。</p><p>出现这种情况的原因有很多：</p><p>确保在图 2说明的时候准确重置选举计时器。具体来说，有三种情况：</p><ul><li>从当前Leader那里获得 RPC （如果参数中的任期已过时，则不应重置计时器）</li><li>正在开始选举</li><li>向其他服务器投票。</li></ul><p>最后一种情况在不可靠的网络中尤其重要，其中Follower可能有不同的日志，在这些情况下， 只有少量的服务器使得大多数服务器都愿意投票支持。如果每当有人要求您投票给他们时都重置选举计时器，会使日志过时的服务器同样有可能向前迈进</p><p>事实上，因为很少的服务器有足够的最新的日志，这些服务器不太可能在足够和平的情况下进行选举。如果您遵循图 2，具有最新日志的服务器不会被过时的服务器选举打断，因此更有可能完成选举并成为Leader。</p><p>按照图 2 的说明操作了解何时应开始选举。 特别要注意的是，如果您是Candidate，但选举计时器触发，应该开始另一次选举。这对于避免由于 RPC 延迟或丢弃而导致系统停止非常重要。</p><p>在处理传入的 RPC 之前 ，请确保遵循“服务器规则”中的第二条规则。第二条规则规定：如果 RPC 请求或响应包含术语set ，则转换为Follower</p><p>例如，如果您已经在当前任期内投票，并且传入的RPC有一个更高的任期号，你应该首先下台并采用他们的任期（从而重置），然后处理RPC，处理的过程中就会进行投票</p><h4 id="不正确的-RPC-处理程序">不正确的 RPC 处理程序</h4><p>尽管图 2 准确地说明了每个 RPC 处理程序应该执行的操作， 一些细节仍然很容易被忽略。</p><p>如果步骤显示“回复错误”，这意味着您应该立即回复，不要执行任何后续步骤。</p><p>如果你得到一个指向日志末尾的RPC，应该像确实有该条目，但该任期不匹配处理这个。</p><p>如果领导者没有发送任何条目，RPC处理程序的检查 2 应执行。</p><p>#5 是必要的， 并且需要使用最后一个新条目的索引进行计算。 这是因为日志中可能存在与领导者日志不同的条目。因为 #3 规定您只有在有冲突的条目情况下才会截断日志，这些条目不会被删除，如果超出领导发送给您的条目，您可能会应用不正确的条目。</p><p>实施“最新日志”检查非常重要。只是检查长度！</p><h4 id="不遵守规则">不遵守规则</h4><p>虽然 Raft 论文非常明确地说明了如何实现每个 RPC 处理程序，它还留下了许多规则的实现和未指定的不变量。这些列在“服务器规则”中 图 2 右侧的块。虽然其中一些是不言自明的，也有一些需要非常小心地设计，以免违反规则：</p><p>如果在执行过程中的任何时候应用特定的日志条目。请务必确保仅由一个实体完成此应用程序。具体来说，您需要有一个专门的 “应用器”，或者锁定这些应用，以便其他一些例程不会同时检测到需要应用条目。</p><p>确保定期更新，或更新后进行检查。例如，如果您在发送给同行的同时进行检查，您可能需要等到下一个条目追加到日志中后再应用您刚刚发送并得到确认的条目。</p><p>如果领导者发出 RPC，并且被拒绝，但不是因为日志不一致（这只有在我们的任期中才会发生），那么您应该立即下台并且不更新。</p><p>领导者不允许更新到上一任期（或就此而言，未来任期）的某个地方。因此特别需要检查。这是因为如果这不是他们目前的任期，Raft 领导者无法确定条目是否实际提交（并且将来永远不会更改）。</p><p>一个常见的问题来源是nextIndex和matchIndex之间的区别。特别是，你可能会观察到matchIndex = nextIndex - 1，而干脆不实现matchIndex。这是不安全的。虽然nextIndex和matchIndex通常在同一时间被更新为类似的值（具体来说，nextIndex = matchIndex + 1），但两者的作用完全不同。它通常是相当乐观的（我们分享一切），并且只在消极的反应中向后移动。例如，当一个领导者刚刚当选时，nextIndex被设置为日志末尾的索引指数。在某种程度上，nextIndex是用于性能的–你只需要将这些东西发送给这个对等体。</p><p>matchIndex是用于安全的。MatchIndex不能被设置为一个太高的值，因为这可能会导致commitIndex被向前移动得太远。这就是为什么matchIndex被初始化为-1（也就是说，我们不同意任何前缀），并且只在跟随者肯定地确认AppendEntries RPC时才更新。</p><h4 id="任期混淆">任期混淆</h4><p>任期混淆是指服务器被来自旧任期的RPC所迷惑。一般来说，在收到RPC时，这不是一个问题，因为图2中的规则确切地说明了当你看到一个旧任期时你应该做什么。然而，图2一般没有讨论当你收到旧的RPC回复时你应该做什么。根据经验，我们发现到目前为止，最简单的做法是首先记录回复中的任期（它可能比你当前的任期高），然后将当前任期与你在原始RPC中发送的任期进行比较。如果两者不同，就放弃回复并返回。只有当这两个任期相同时，你才应该继续处理回复。</p><p>一个相关但不完全相同的问题是，预设你的状态在你发送RPC和你收到回复之间没有变化。这方面的一个很好的例子是，当你收到RPC的响应时，设置matchIndex = nextIndex - 1，或者matchIndex = len(log)。这并不安全，因为这两个值都可能在你发送RPC后被更新。相反，正确的做法是将 matchIndex 更新为你最初在 RPC 中发送的参数中 prevLogIndex + len( entries[]) 。</p><h2 id="Raft的结构">Raft的结构</h2><p>一个Raft实例必须处理外部事件的到来（Start（）调用、AppendEntries和RequestVote RPC以及RPC回复），它必须执行定期任务（选举和心跳）。有许多方法可以构造Raft代码来管理这些活动，下面是一些想法。</p><ul><li>每个Raft实例都有一组状态（日志、当前索引、&amp;c） 必须根据在goroutine并行同时发生的事件进行更新。Go文档指出，goroutine可以使用共享数据结构和锁直接执行更新操作，或者通过在channel上传递消息。经验表明，对于Raft使用共享数据和锁是最简单的。</li><li>Raft实例有两个时间驱动的活动：Leader必须发送心跳信号，如果距离上一次接收到心跳信号的时间太长，其他人必须开始选举。每一个活动最好单独启动一个专门的长时间运行的goroutine，而不是将多个活动组合成一个单独的goroutine</li><li>选举超时的管理是很头痛的。最简单的方法是在Raft数据结构中包括上一次Follower接收到Leader消息的时间，然后让负责选举的goroutine定期检查这个时间是否超时。使用time.Sleep()和一个小常量参数驱动定期检查是很容易的。不要使用time.Ticker和time.Timer，它们很难正确使用。</li><li>需要有一个单独的长时间运行的goroutine在applyCh上按顺序提交日志条目。它必须是单独的，因为在applyCh上发送可以被阻止；而且必须是单个<br>goroutine，否则很难确保发送日志是按照日志顺序的。advance commitIndex的代码需要kick apply goroutine；使用sync.Cond可能最简单。</li><li>每个RPC应该以自己的方式发送（并处理其回复）自己的goroutine，原因有两个：这样无法访问的服务器不会延迟大多数回复的收集，而且心跳信号和<br>选举计时器可以一直计时。如果RPC应答处理在同一个goroutine中就很容易做到，而不是通过channel发送回复的信息。</li><li>请记住，网络可能会延迟RPC和RPC响应，而且如果发送并行的RPC，网络可以对请求和答复进行重新排序。图2很好地指出了RPC处理程序必须对此小心（例如，RPC处理程序应该忽略具有旧日志条目的RPC）。图2并不总是明确说明RPC响应的处理过程。Leader在处理RPC响应时必须小心，它必须检查自从发送RPC之后日志条目没有改变，并且必须考虑对同一Follower的并发的RPC改变了Leader的状态（例如nextIndex）。</li></ul><h2 id="Raft中的锁">Raft中的锁</h2><ol><li>当有多个goroutine使用的数据时，且至少有一个goroutine可以修改数据，那么goroutine应该使用锁防止同时使用数据。Go race检测器非常擅长检测违反此规则的情况。</li><li>每当代码对共享数据进行一系列修改时，如果其他goroutine查看了数据，可能会出错，因此在整个过程中都应该使用锁。</li><li>每当代码对共享数据进行一系列读取时（或读取和写入），如果另一个goroutine在中途修改数据，则会发生错误。因此在整个过程中都应该使用锁。真正的Raft代码需要使用很长代码的锁，例如，一个Raft RPC处理程序可能需要在整个处理过程都要加锁。</li><li>在做一些可能会等待的事情的时候都加锁是个坏主意，例如：读取Go channel，在channel上发送，等待计时器、调用time.Sleep()或发送RPC并等待回复。一个原因是你可能想让其他的goroutine在等待期间照常执行。另一个原因是避免死锁。想象两个服务器在保持锁的同时彼此发送RPC；两个RPC<br>处理程序需要接收对方的锁；两个RPC处理程序都不能完成，因为它需要等待的RPC调用所持有的锁。等待的代码应该首先释放锁。如果这不方便，有时创建一个单独的goroutine来执行等待是很有用的。</li><li>要小心扔掉和重新获取锁的情况。一个可能出现这种情况的地方是避免带锁等待。例如，下面的发送投票RPC的代码是不正确的：</li></ol><div class="code-wrapper"><pre><code class="hljs go">rf.mu.Lock() rf.currentTerm += <span class="hljs-number">1</span> rf.state = Candidate <span class="hljs-keyword">for</span> &lt;each peer&gt; &#123;   <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;     rf.mu.Lock()     args.Term = rf.currentTerm     rf.mu.Unlock()     Call(<span class="hljs-string">&quot;Raft.RequestVote&quot;</span>, &amp;args, ...)     <span class="hljs-comment">// handle the reply...</span>   &#125; () &#125; rf.mu.Unlock()</code></pre></div><p>这个代码在单独的goroutine中发送每个RPC。这是不正确的，因为如果周围的代码是决定成为Candidate，args.Term可能与rf.currentTerm不同。当周围的代码创建goroutine和当goroutine读取rf.currentTerm时可能过去了很多的时间，这台服务器也可能不再是Candidate。一种方法是当外部代码持有锁的时候创建rf.currentTerm的副本从而让goroutine去使用。同样的，在调用之后的回复处理代码重新获取锁后必须重新检查所有相关的假设，例如，它应该检查自从决定成为Candidate后rf.currentTerm没有再次改变。</p><p>一种方法是从没有锁的代码开始，然后仔细考虑需要在哪里添加锁以变得正确。另一个更务实的方法从观察开始，如果没有并发性（没有同时执行goroutine）则根本不需要锁。但是当RPC系统创建goroutine以执行RPC处理程序时，以及<br>因为您需要在单独的goroutine中发送RPC以避免等待，并发性就有了。可以通过识别所有goroutine开始的位置（RPC处理程序、在Make()中创建的后台goroutine，&amp;c），并且在每个goroutine开始的时候获得锁，只有当goroutine<br>完全完成并返回的时候才释放锁，从而消除并发性。这个锁定协议确保任何重要的事情都不会并行执行；锁确保每个goroutine在其他goroutine执行之前完成，没有并行执行，很难违反规则1、2、3或5。如果每个goroutine的代码正确，在使用锁抑制并发时仍然是正确的。</p><p>然而，规则4可能是一个问题。所以下一步是找到代码等待的位置，然后根据需求添加锁释放和重新获取（或goroutine的创建），记得小心重新建立和重新获取后的情况。</p><h1>代码相关</h1><p>框架代码：src/raft/raft.go</p><p>测试代码：src/raft/test_test.go，运行go test即可</p><p>通过在src/raft/raft.go中增加代码实现Raft，必须遵循下面的接口：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// create a new Raft server instance:</span>rf := Make(peers, me, persister, applyCh)<span class="hljs-comment">// start agreement on a new log entry:</span>rf.Start(command <span class="hljs-keyword">interface</span>&#123;&#125;) (index, term, isleader)<span class="hljs-comment">// ask a Raft for its current term, and whether it thinks it is leader</span>rf.GetState() (term, isLeader)<span class="hljs-comment">// each time a new entry is committed to the log, each Raft peer</span><span class="hljs-comment">// should send an ApplyMsg to the service (or tester).</span><span class="hljs-keyword">type</span> ApplyMsg</code></pre></div><p>服务调用 <code>Make(peers, me, ...)</code>创建一个 Raft peer。<code>peers</code> 参数是所有 Raft peers（包括这一个）的网络标识符数组，用于 RPC。<code>me</code>参数是网络标识符数组中，属于这个peer的网络标识符的下标。<code>Start(command)</code> 要求 Raft 启动处理，将命令追加到日志副本中。<code>Start()</code>应立即返回，无需等待日志追加完成。该服务希望你将每个新的日志条目，封装为 <code>ApplyMsg</code>，发送给Make函数中的 <code>applyCh</code>参数（这是一个channel）。</p><p><code>raft.go</code>包含发送 RPC <code>sendRequestVote()</code>和处理传入 RPC <code>RequestVote()</code>的样例代码。您的 Raft peers 应该使用 labrpc Go 包（源代码在 <code>src/labrpc</code>）交换 RPC。测试代码可以告诉 <code>labrpc</code> 延迟 RPC请求，重新排列它们，并丢弃它们以模拟各种网络故障。Raft 实例必须仅与 RPC 交互;例如，不允许它们使用共享的 Go 变量或文件进行通信。</p><p>后续的实验也在此实验上进行构建。</p><p>参考翻译：<a href="https://zhuanlan.zhihu.com/p/248686289">https://zhuanlan.zhihu.com/p/248686289</a></p><h1>Part 2A：选举Leader</h1><h2 id="指导">指导</h2><p>实现Raft算法中的Leader选举和心跳机制（<code>AppendEntries RPC</code> 且没有日志条目）。确保只有一个Leader被选中，且若无错误该Leader会一直唯一存在，当该Leader下线或发生其他错误导致发出的数据无法被成功接收，则会产生新的Leader来替代。</p><ol><li>运行 <code>go test -run 2A</code> 来验证代码的正确性</li><li>参考论文的Figure 2实现，需要关注发送和接收RequestVote RPCs，与选举相关的服务器的规则，和与选举相关的服务器的状态</li><li>在 <code>raft.go</code>中添加Figure 2的Leader选举的状态，同时也需要定义一个结构体保留日志条目的信息</li><li>填充 <code>RequestVoteArgs</code>和 <code>RequestVoteReply</code>结构。修改 <code>Make()</code>以创建一个后台 go 协程，该协程将在一段时间未从其他 peers 那里听到请求投票 RPC 时，发送 <code>RequestVote</code> RPC 来定期启动 Leader 选举。这样，如果已经有一个 Leader，或者自己成为 Leader，其他 peers 就会知道谁是Leader。实现 <code>RequestVote()</code> RPC 函数，以便服务器投票给别人。</li><li>为了实现心跳检测，请提前定义 <code>AppendEntries</code> RPC 结构（尽管您可能还不需要所有参数），并让 Leader 定期发送它们。<code>AppendEntries</code> RPC 函数需要重置选举超时时间，以便其他服务器已当选时，不会以 Leader 的身份继续运行。</li><li>确保不同 Peers 不会在同一时间选举超时，否则所有 Peers 将只为自己投票，没有人会成为 Leader。</li><li>测试要求 Leader 发送心跳检测 RPC 的频率不超过 10 次/秒。</li><li>测试要求您的 Raft 在旧 Leader 失败后5秒内选出新 Leader（如果大多数同行仍然可以沟通）。但是，请记住，在发生分裂投票的情况下（如果数据包丢失或候选人不幸地选择相同的随机回票时间，则可能发生），领导人选举可能需要多轮投票。您必须选择足够短的选举超时（心跳间隔也是如此），确保即使选举需要多次轮断，也能在5秒内完成。</li><li>论文第 5.2 节提到选举超时应该在 150 到 300 毫秒范围内。只有当 Leader 发送一次心跳包的远小于 150 毫秒，这种范围才有意义。由于测试将您发送心跳包的频率限制在 10 次/秒内（译者注：也就是大于 100 毫秒），因此您必须使用比论文 150 到 300 毫秒更大的选举超时时间，但请不要太大，因为那可能导致无法在 5 秒内选出 Leader。</li><li>Go 的 rand 很有用。</li><li>您将需要定期执行某些操作，或在一段时间后做些什么。最简单的方法是新起一个协程，在协程的循环中调用time.Sleep()。不要使用 <code>time.Timer</code>或 <code>time.Ticker</code>，这两个并不好用，容易出错。</li><li>如果代码在通过测试时遇到问题，请再次阅读论文的 Figure 2 ；Leader 选举的逻辑分布在Figure 2 的多个部分。</li><li>别忘了实现 <code>GetState()</code>。</li><li>测试调用您的 Raft 的 <code>rf.Kill()</code>时，您可以先调用 <code>rf.killed()</code>再检查是否 <code>Kill()</code>。您可能希望在所有循环中执行此功能，以避免已经死亡的 Raft 实例打印令人困惑的信息。</li><li>调试代码的一个好方法，就是在 Peer 发送或收到消息时打印自己的状态，并在测试时运行 <code>go test -run 2A &gt; out</code>，将日志收集到文件中。然后，通过研究 <code>out</code> 文件，可以确定实现中不正确的地方。您可能会喜欢用 <code>util.go</code>中的 <code>Dprintf</code>函数来调试，其可以在不同情况下打开和关闭日志。</li><li>Go RPC 仅发送以大写字母为首的结构体字段（译者注：可导出的字段）。子结构体还必须具有大写字段名称（例如数组中的日志记录字段）。<code>labgob</code>包会警告您这一点，不要忽略警告。</li><li>用 <code>go test -race</code>测试你的代码，并修复它报告的任何问题。</li></ol><p>输出应该如下面所示：</p><div class="code-wrapper"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -run 2ATest (2A): initial election ...  ... Passed --   3.5  3   58   16840    0Test (2A): election after network failure ...  ... Passed --   5.4  3  118   25269    0Test (2A): multiple elections ...  ... Passed --   7.3  7  624  138014    0PASSok  6.824/raft16.265s$</code></pre></div><p>每一个“通过”的测试用例会输出五个数字;他们分别是</p><ol><li>测试所用的时间（单位：秒）</li><li>Raft Peer 的数量（通常为 3 或 5）</li><li>测试期间发送 RPC 的次数</li><li>RPC 消息中的字节总数</li><li>Raft 确定并提交的日志条目数。</li></ol><h2 id="实现">实现</h2><p><a href="https://juejin.cn/post/6913883115567972359">参考资料</a></p><h3 id="定义-global-go">定义 global.go</h3><p>首先需要对代码中不完整的结构体进行填充，论文中的Figure 2有的字段一定保留，其他的字段看情况保留</p><p>首先定义服务器的状态，用字符串常量表示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 定义Peer的状态</span><span class="hljs-keyword">type</span> State <span class="hljs-type">string</span><span class="hljs-keyword">const</span> (Follower  State = <span class="hljs-string">&quot;follower&quot;</span>Candidate State = <span class="hljs-string">&quot;candidate&quot;</span>Leader    State = <span class="hljs-string">&quot;leader&quot;</span>)</code></pre></div><p>然后定义Raft结构体：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Raft <span class="hljs-keyword">struct</span> &#123;mu        sync.Mutex          <span class="hljs-comment">// Lock to protect shared access to this peer&#x27;s state</span>peers     []*labrpc.ClientEnd <span class="hljs-comment">// RPC end points of all peers</span>persister *Persister          <span class="hljs-comment">// Object to hold this peer&#x27;s persisted state</span>me        <span class="hljs-type">int</span>                 <span class="hljs-comment">// this peer&#x27;s index into peers[]</span>dead      <span class="hljs-type">int32</span>               <span class="hljs-comment">// set by Kill()</span><span class="hljs-comment">// Your data here (2A, 2B, 2C).</span><span class="hljs-comment">// Look at the paper&#x27;s Figure 2 for a description of what</span><span class="hljs-comment">// state a Raft server must maintain.</span><span class="hljs-comment">// 在所有peer上面的持久性的状态</span><span class="hljs-comment">// 在对RPC进行响应之后要在稳定存储上更新</span>currentTerm <span class="hljs-type">int</span> <span class="hljs-comment">// this peer 看到的最新的任期号</span>votedFor    <span class="hljs-type">int</span> <span class="hljs-comment">// 在当前任期获得选票的Candidate的id（如果没有则为-1）</span>log []LogEntry <span class="hljs-comment">// 日志信息</span><span class="hljs-comment">// 在所有peer上面的变化的状态</span>commitIndex <span class="hljs-type">int</span> <span class="hljs-comment">// 已知的已经被提交的日志条目的最大索引值</span>lastApplied <span class="hljs-type">int</span> <span class="hljs-comment">// 最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）</span><span class="hljs-comment">// 在Leader上面的变化的状态</span><span class="hljs-comment">// 每一次选举后都要重新进行初始化</span>nextIndex  []<span class="hljs-type">int</span> <span class="hljs-comment">// 对于每⼀个服务器，需要发送给他的下⼀个日志条目的索引值（初始化为Leader最后索引值加1）</span>matchIndex []<span class="hljs-type">int</span> <span class="hljs-comment">// 对于每⼀个服务器，已经复制给他的日志的最高索引值</span><span class="hljs-comment">// 与时间相关的变量</span>electTimeout     <span class="hljs-type">int64</span> <span class="hljs-comment">// 选举超时时间</span>randomTimeout    <span class="hljs-type">int64</span> <span class="hljs-comment">// 随机时间</span>heartBeatTimeout <span class="hljs-type">int64</span> <span class="hljs-comment">// 心跳周期</span><span class="hljs-comment">// 当前状态</span>state        State <span class="hljs-comment">// 当前Peer所处的状态（Leader、Candidate或Follower）</span>majorityVote <span class="hljs-type">int</span>   <span class="hljs-comment">// 成为Leader需要获得的最少票数</span>lastReceive  <span class="hljs-type">int64</span>&#125;</code></pre></div><p>其中多定义了6个变量，3个变量与时间相关，分别表示选举超时时间、随机的时间上限和Leader发送心跳的周期时间</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 与时间相关的变量</span>electTimeout     <span class="hljs-type">int64</span> <span class="hljs-comment">// 选举超时时间</span>randomTimeout    <span class="hljs-type">int64</span> <span class="hljs-comment">// 随机时间</span>heartBeatTimeout <span class="hljs-type">int64</span> <span class="hljs-comment">// 心跳周期</span></code></pre></div><p>最后3个变量，第1个表示服务器当前所处的状态，第2个表示成为Leader需要获得的最少票数，这个值提前计算出来，最后一个值表示最后一次接收到Leader的心跳信号的时间</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 当前状态</span>state        State <span class="hljs-comment">// 当前Peer所处的状态（Leader、Candidate或Follower）</span>majorityVote <span class="hljs-type">int</span>   <span class="hljs-comment">// 成为Leader需要获得的最少票数</span>lastReceive  <span class="hljs-type">int64</span> <span class="hljs-comment">// 最后一次接收到Leader的心跳信号的时间</span></code></pre></div><h3 id="工具-util-go">工具 util.go</h3><p>服务器不同状态之间的转换比较频繁，因此可以将这些服务器状态转换的代码提取出来编写成工具函数，方便后续直接调用</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 转为Leader</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> toLeader() &#123;DPrintf(<span class="hljs-string">&quot;[%d]: convert from [%s] to [%s], term [%d]&quot;</span>, rf.me, rf.state, Leader, rf.currentTerm)rf.state = Leader<span class="hljs-comment">// rf.lastReceive = time.Now().Unix()</span>&#125;<span class="hljs-comment">// 转为Follower</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> toFollower(newTerm <span class="hljs-type">int</span>) &#123;DPrintf(<span class="hljs-string">&quot;[%d]: convert from [%s] to [%s]&quot;</span>, rf.me, rf.state, Follower)rf.state = Followerrf.currentTerm = newTermrf.votedFor = <span class="hljs-number">-1</span>rf.lastReceive = time.Now().Unix()&#125;<span class="hljs-comment">// 转为Candidate</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> toCandidate() &#123;DPrintf(<span class="hljs-string">&quot;[%d]: convert from [%s] to [%s]&quot;</span>, rf.me, rf.state, Candidate)rf.state = Candidaterf.currentTerm += <span class="hljs-number">1</span>rf.votedFor = rf.me<span class="hljs-comment">// rf.lastReceive = time.Now().Unix()</span>&#125;</code></pre></div><ol><li>转为Leader只需更新自己的状态即可，不需要对其他值做任何的操作。</li><li>转为Follower除更新自己的状态之外，要更新自己的任期（因为变为Follower就是因为自己的任期落后），然后要初始化自己的投票状态，并且这个变化的过程隐含了从Leader那里收到心跳包，因此要更新自己的时间。</li><li>转为Follower除更新自己的状态之外，要将自己的任期+1（因为变为Candidate是因为接收不到Leader的心跳信息了，认为Leader已经挂了，这个任期不能再用了），然后要初始化自己的投票投给自己。</li></ol><p>然后补充一个预定义的获取服务器状态的方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// return currentTerm and whether this server</span><span class="hljs-comment">// believes it is the leader.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> GetState() (<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>) &#123;<span class="hljs-keyword">var</span> term <span class="hljs-type">int</span><span class="hljs-keyword">var</span> isleader <span class="hljs-type">bool</span><span class="hljs-comment">// Your code here (2A).</span>rf.mu.Lock()<span class="hljs-keyword">defer</span> rf.mu.Unlock()isleader = <span class="hljs-literal">false</span>term = rf.currentTerm<span class="hljs-keyword">if</span> rf.state == Leader &#123;isleader = <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span> term, isleader&#125;</code></pre></div><h3 id="请求投票RPC-requestVote-go">请求投票RPC requestVote.go</h3><p>结构体定义完全按照论文即可，目前不需要其他字段</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// example RequestVote RPC arguments structure.</span><span class="hljs-comment">// field names must start with capital letters!</span><span class="hljs-keyword">type</span> RequestVoteArgs <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// Your data here (2A, 2B).</span>Term         <span class="hljs-type">int</span> <span class="hljs-comment">// Candidate的任期号</span>CandidateId  <span class="hljs-type">int</span> <span class="hljs-comment">// Candidate的 Id</span>LastLogIndex <span class="hljs-type">int</span> <span class="hljs-comment">// Candidate最后一条日志条目的索引</span>LastLogTerm  <span class="hljs-type">int</span> <span class="hljs-comment">// Candidate最后一条日志条目的任期</span>&#125;<span class="hljs-comment">// example RequestVote RPC reply structure.</span><span class="hljs-comment">// field names must start with capital letters!</span><span class="hljs-keyword">type</span> RequestVoteReply <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// Your data here (2A).</span>Term        <span class="hljs-type">int</span>  <span class="hljs-comment">// 当前的任期，接收到了之后Candidate可以更新自己</span>VoteGranted <span class="hljs-type">bool</span> <span class="hljs-comment">// 是否给这个Candidate投票</span>&#125;</code></pre></div><p>核心RPC：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// example RequestVote RPC handler.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;<span class="hljs-comment">// Your code here (2A, 2B).</span><span class="hljs-comment">// RPC 请求不一定在什么时候应用，因此必须加锁</span>rf.mu.Lock()<span class="hljs-keyword">defer</span> rf.mu.Unlock()DPrintf(<span class="hljs-string">&quot;[%d]: received vote request from [%d]&quot;</span>, rf.me, args.CandidateId)reply.VoteGranted = <span class="hljs-literal">false</span><span class="hljs-comment">// 如果参数的任期号还没有我的大，不投票，直接默认值返回即可</span><span class="hljs-keyword">if</span> args.Term &lt; rf.currentTerm &#123;<span class="hljs-comment">// 响应中包含当前自己的任期号</span>reply.Term = rf.currentTerm<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 如果参数的任期号比我的大，则我在这个任期内就只能是它的Follower，则更改我的任期号，而且在这个任期内我要投票给它</span><span class="hljs-keyword">if</span> args.Term &gt; rf.currentTerm &#123;rf.toFollower(args.Term)&#125;reply.Term = rf.currentTerm <span class="hljs-comment">// 注意这里任期号已经变化了，因此要重新赋值</span>DPrintf(<span class="hljs-string">&quot;[%d]: status: term [%d], state [%s], vote for [%d]&quot;</span>, rf.me, rf.currentTerm, rf.state, rf.votedFor)<span class="hljs-comment">// 如果参数的任期号和我的相同，则任期号不变，需要通过日志确定是否投票给它</span><span class="hljs-comment">// 这里论文要求的 rf.VotedFor == args.CandidateId 不是很明白</span><span class="hljs-keyword">if</span> rf.votedFor == <span class="hljs-number">-1</span> || rf.votedFor == args.CandidateId &#123;<span class="hljs-comment">// Todo：判断日志是否至少更新才可以投票</span>rf.votedFor = args.CandidateIdrf.lastReceive = time.Now().Unix() <span class="hljs-comment">// 更新时间，上面操作相当于与可能的Leader通信过了</span>reply.VoteGranted = <span class="hljs-literal">true</span>DPrintf(<span class="hljs-string">&quot;[%d]: voted to [%d]&quot;</span>, rf.me, args.CandidateId)&#125;&#125;</code></pre></div><p>核心就是计算返回的reply中的两个值，第一个是是否投票，第二个是当前服务器的任期号。其中任期号一定要小心，可能服务器自己的状态改变后任期号会随之改变，因此一定要及时更新。</p><ol><li>如果请求我投票的任期号还没有我的大，不投票，直接默认值返回即可</li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> args.Term &lt; rf.currentTerm &#123;<span class="hljs-comment">// 响应中包含当前自己的任期号</span>reply.Term = rf.currentTerm<span class="hljs-keyword">return</span>&#125;</code></pre></div><ol start="2"><li>如果参数的任期号比我的大，则我在这个任期内就只能是它的Follower，则更改我的任期号，而且在这个任期内我要投票给它</li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> args.Term &gt; rf.currentTerm &#123;rf.toFollower(args.Term)&#125;</code></pre></div><p>（这个结构不返回，投票的逻辑在下一个结构）</p><ol start="3"><li>如果参数的任期号和我的相同，则任期号不变，需要通过日志确定是否投票给它</li></ol><p><code>rf.votedFor == -1</code> 承接上面的投票逻辑，把情况2的票投了</p><p><code>rf.VotedFor == args.CandidateId</code> 在后面要加上对于日志的判断，这里仅仅是简单投票给它</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> rf.votedFor == <span class="hljs-number">-1</span> || rf.votedFor == args.CandidateId &#123;<span class="hljs-comment">// Todo：判断日志是否至少更新才可以投票</span>rf.votedFor = args.CandidateIdrf.lastReceive = time.Now().Unix() <span class="hljs-comment">// 更新时间，上面操作相当于与可能的Leader通信过了</span>reply.VoteGranted = <span class="hljs-literal">true</span>DPrintf(<span class="hljs-string">&quot;[%d]: voted to [%d]&quot;</span>, rf.me, args.CandidateId)&#125;</code></pre></div><p>在调用的时候，Candidate请求每一台服务器投票给它，如果得到的响应说我的任期号比你还大，也就是上面的情况2，也自动放弃Candidate的地位成为Follower。否则这个Candidate就会得到自己的票。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 向每一个Peer请求投票</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> requestVoteToPeer(index <span class="hljs-type">int</span>, args *RequestVoteArgs, votesSum *<span class="hljs-type">int</span>, votesGet *<span class="hljs-type">int</span>, cond *sync.Cond) &#123;reply := RequestVoteReply&#123;&#125;ok := rf.sendRequestVote(index, args, &amp;reply)rf.mu.Lock()<span class="hljs-keyword">defer</span> rf.mu.Unlock()<span class="hljs-keyword">defer</span> cond.Broadcast()*votesSum += <span class="hljs-number">1</span><span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> reply.Term &gt; rf.currentTerm &#123;rf.toFollower(reply.Term)<span class="hljs-comment">// &#125; else if reply.VoteGranted &amp;&amp; reply.Term == rf.currentTerm &#123;</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> reply.VoteGranted &#123;*votesGet += <span class="hljs-number">1</span>&#125;&#125;</code></pre></div><h3 id="追加日志RPC-appendEntries-go">追加日志RPC appendEntries.go</h3><p>结构体定义完全按照论文即可，目前不需要其他字段</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AppendEntriesArgs <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// Your data here (2A, 2B).</span>Term         <span class="hljs-type">int</span>        <span class="hljs-comment">// Leader的任期号</span>LeaderId     <span class="hljs-type">int</span>        <span class="hljs-comment">// Follower可以通过这个LeaderId重定向客户端</span>PrevLogIndex <span class="hljs-type">int</span>        <span class="hljs-comment">// 新的日志条目紧随之前的索引值</span>PrevLogTerm  <span class="hljs-type">int</span>        <span class="hljs-comment">// PrevLogIndex日志条目的任期</span>Entries      []LogEntry <span class="hljs-comment">// 存储的日志条目，如果是心跳包则为空</span>LeaderCommit <span class="hljs-type">int</span>        <span class="hljs-comment">// Leader的提交索引</span>&#125;<span class="hljs-keyword">type</span> AppendEntriesReply <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// Your data here (2A).</span>Term    <span class="hljs-type">int</span>  <span class="hljs-comment">// 当前的任期，接收到了之后Leader可以更新自己</span>Success <span class="hljs-type">bool</span> <span class="hljs-comment">// Follower包含了匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</span>&#125;</code></pre></div><p>这个RPC既作为日志更新的来源，在没有日志携带的时候也作为心跳包用于维持Leader的地位</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;<span class="hljs-comment">// Your code here (2A, 2B).</span><span class="hljs-comment">// RPC 请求不一定在什么时候应用，因此必须加锁</span>rf.mu.Lock()<span class="hljs-keyword">defer</span> rf.mu.Unlock()<span class="hljs-comment">// 更新至少为当前的任期</span>reply.Term = rf.currentTermreply.Success = <span class="hljs-literal">false</span><span class="hljs-comment">// 如果Leader的任期还没有我的大，则直接拒绝请求</span><span class="hljs-keyword">if</span> args.Term &lt; rf.currentTerm &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 如果Leader的任期比我的大，则我转为这个任期的Follower</span><span class="hljs-keyword">if</span> args.Term &gt;= rf.currentTerm || rf.state == Candidate &#123;rf.toFollower(args.Term)&#125;<span class="hljs-comment">// 如果Leader的任期和我的相同，则操作日志</span><span class="hljs-comment">// Todo：日志操作</span>rf.lastReceive = time.Now().Unix()reply.Term = rf.currentTermreply.Success = <span class="hljs-literal">true</span>&#125;</code></pre></div><p>核心也是计算返回的reply中的两个值，第一个是是否更新成功，第二个是当前服务器的任期号。其中任期号一定要小心，可能服务器自己的状态改变后任期号会随之改变，因此一定要及时更新。</p><ol><li>如果Leader的任期还没有我的大，则直接拒绝请求</li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> args.Term &lt; rf.currentTerm &#123;<span class="hljs-keyword">return</span>&#125;</code></pre></div><ol start="2"><li>如果Leader的任期比我的大，则如果我是Candidate，放弃Candidate的地位，转为这个任期的Follower</li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 如果Leader的任期比我的大，则我转为这个任期的Follower</span><span class="hljs-keyword">if</span> args.Term &gt;= rf.currentTerm || rf.state == Candidate &#123;rf.toFollower(args.Term)&#125;</code></pre></div><p>（同时要对我自己的日志进行更新，目前还没有实现）</p><ol start="3"><li>如果Leader的任期和我的相同，则操作日志（这里没有操作）</li><li>更新服务器的时间和返回的参数</li></ol><div class="code-wrapper"><pre><code class="hljs go">rf.lastReceive = time.Now().Unix()reply.Term = rf.currentTermreply.Success = <span class="hljs-literal">true</span></code></pre></div><p>主要是要对服务器的收到Leader的请求的时间进行更新，从而避免Follower转为Candidate，在Leader存在的情况下发起选举</p><p>在调用的时候，Leader向其他的每一台服务器发送这个RPC，如果得到的响应说我的任期号比你还大，也就是上面的情况2，也自动放弃Leader的地位成为Follower。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 向指定的Peer增加日志条目或者发送心跳包</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> appendEntriesToPeer(index <span class="hljs-type">int</span>, args *AppendEntriesArgs) &#123;reply := AppendEntriesReply&#123;&#125;<span class="hljs-keyword">if</span> ok := rf.sendAppendEntries(index, args, &amp;reply); ok &#123;rf.mu.Lock()<span class="hljs-keyword">defer</span> rf.mu.Unlock()<span class="hljs-comment">// Todo：log相关</span><span class="hljs-comment">// 如果响应的任期比Leader更大了，说明Leader需要退位成Follower了</span><span class="hljs-keyword">if</span> reply.Term &gt; rf.currentTerm &#123;rf.toFollower(reply.Term)&#125;&#125;&#125;</code></pre></div><h3 id="主函数-raft-go">主函数 raft.go</h3><h4 id="初始化">初始化</h4><p>每一台服务器初始化的时候都是一个Follower，任期号为0</p><p>除此之外还要设置选举超时时间，心跳发送时间等</p><p>以及根据服务器的数量计算好需要多少张选票才能达成共识</p><p>然后直接开始选举</p><div class="code-wrapper"><pre><code class="hljs go">rf.toFollower(<span class="hljs-number">0</span>)rf.electTimeout = <span class="hljs-number">200</span>     <span class="hljs-comment">// 初始化选举超时时间</span>rf.heartBeatTimeout = <span class="hljs-number">100</span> <span class="hljs-comment">// 初始化心跳间隔时间</span>rf.randomTimeout = <span class="hljs-number">100</span>    <span class="hljs-comment">// 设置随机时间的最大范围</span><span class="hljs-comment">// 初始化成为Leader需要得到的票数</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.peers)%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;rf.majorityVote = <span class="hljs-built_in">len</span>(rf.peers)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125; <span class="hljs-keyword">else</span> &#123;rf.majorityVote = (<span class="hljs-built_in">len</span>(rf.peers) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>&#125;<span class="hljs-comment">// start ticker goroutine to start elections</span><span class="hljs-keyword">go</span> rf.leaderElection()</code></pre></div><p>所有的协程都不设置退出条件，因此内部要么是无限循环，要么是有状态变量等进行控制</p><h4 id="选举Leader">选举Leader</h4><p>选举Leader是一个无限循环，在每一次循环的时候记录当前的时间后进行睡眠（固定时间+随机时间），然后在循环内部进行判断，如果上一次循环到这里的实时时间比上一次接收到心跳包的时间还大，说明在睡眠时间内一直没有接收到心跳包，则认为超时，此时就要放弃自己的Follower身份，转为Candidate开始竞选。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// The ticker go routine starts a new election if this peer hasn&#x27;t received</span><span class="hljs-comment">// heartsbeats recently.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> leaderElection() &#123;lastElectTime := time.Now().Unix()<span class="hljs-keyword">for</span> !rf.killed() &#123;<span class="hljs-comment">// Your code here to check if a leader election should</span><span class="hljs-comment">// be started and to randomize sleeping time using</span><span class="hljs-comment">// time.Sleep().</span>time.Sleep(time.Duration(rf.electTimeout+rand.Int63n(rf.randomTimeout)) * time.Millisecond)rf.mu.Lock()<span class="hljs-comment">// lastStartTime := startTime</span><span class="hljs-comment">// 如果上一次循环到这里的实时时间比上一次接收到心跳包的时间还大，说明在睡眠时间内一直没有接收到心跳包，则认为超时</span><span class="hljs-keyword">if</span> lastElectTime &gt; rf.lastReceive &#123;<span class="hljs-comment">//DPrintf(&quot;[%d]: current state is [%s].&quot;, rf.me, rf.state)</span><span class="hljs-keyword">if</span> rf.state != Leader &#123;DPrintf(<span class="hljs-string">&quot;[%d]: is not leader, start election.&quot;</span>, rf.me)rf.tryLeader()&#125;&#125;lastElectTime = time.Now().Unix() <span class="hljs-comment">// 更新“上一次”的时间</span>rf.mu.Unlock()&#125;&#125;</code></pre></div><p>然后在 <code>rf.tryLeader()</code>中，首先将服务器的状态转为Candidate，然后构建请求，向其他的peer发送请求投票的RPC，收到响应后对收到的投票进行统计。如果得到了大多数的选票，则这个Candidate可以转为Leader，同时向其他的服务器发送心跳包说明自己已经成为了Leader，其他的peer需要放弃竞选。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> tryLeader() &#123;rf.toCandidate()votesSum := <span class="hljs-number">1</span>                <span class="hljs-comment">// 总共的票的数量</span>votesGet := <span class="hljs-number">1</span>                <span class="hljs-comment">// 收到的票数，自己首先给自己投票</span>cond := sync.NewCond(&amp;rf.mu) <span class="hljs-comment">// 条件变量，控制投票结果的返回</span>args := RequestVoteArgs&#123;Term:        rf.currentTerm,CandidateId: rf.me,&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(rf.peers); i++ &#123;<span class="hljs-keyword">if</span> i != rf.me &#123;<span class="hljs-keyword">go</span> rf.requestVoteToPeer(i, &amp;args, &amp;votesSum, &amp;votesGet, cond)&#125;&#125;<span class="hljs-comment">// 等待票数统计完毕并判断是否能成为Leader</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;rf.mu.Lock()<span class="hljs-keyword">defer</span> rf.mu.Unlock()<span class="hljs-keyword">for</span> votesGet &lt; rf.majorityVote &amp;&amp; votesSum &lt; <span class="hljs-built_in">len</span>(rf.peers) &amp;&amp; rf.state == Candidate &#123;cond.Wait()&#125;<span class="hljs-keyword">if</span> votesGet &gt;= rf.majorityVote &amp;&amp; rf.state == Candidate &#123;rf.toLeader()<span class="hljs-comment">// 发送心跳包</span><span class="hljs-keyword">go</span> rf.logReplication()&#125;&#125;()&#125;</code></pre></div><p>内部的协程同步使用状态变量控制（虽然不明白为什么使用WaitGroup不可以实现功能）</p><h4 id="心跳包发送">心跳包发送</h4><p>心跳包发送（或与日志更新一起）是只有Leader才可以发起的动作。</p><p>注意定时发起请求即可</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Leader定时发送更新log的请求，同时也作为心跳包</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> logReplication() &#123;<span class="hljs-keyword">for</span> !rf.killed() &#123;rf.mu.Lock()<span class="hljs-keyword">if</span> rf.state == Leader &#123;args := AppendEntriesArgs&#123;Term:     rf.currentTerm,LeaderId: rf.me,&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(rf.peers); i++ &#123;<span class="hljs-keyword">if</span> i != rf.me &#123;<span class="hljs-keyword">go</span> rf.appendEntriesToPeer(i, &amp;args)&#125;&#125;&#125;rf.mu.Unlock()time.Sleep(time.Duration(rf.heartBeatTimeout) * time.Millisecond)&#125;&#125;</code></pre></div><h2 id="运行结果">运行结果</h2><p>目前最快的结果：</p><div class="code-wrapper"><pre><code class="hljs bash">Test (2A): initial election ...  ... Passed --   3.0  3   72   18660    0Test (2A): election after network failure ...  ... Passed --   4.9  3  166   31952    0Test (2A): multiple elections ...  ... Passed --   5.3  7  522  111880    0PASSok      6.824/raft      13.335s</code></pre></div><p>运行10次后均成功</p><h1>Part 2B：日志</h1><h2 id="指导-2">指导</h2><p>完善 Leader 和 Follower 的代码，使他们可以追加新的日志条目，并通过 <code>go test -run 2B</code>。</p><ul><li>你的第一个目标应该是通过 <code>TestBasicAgree2B()</code>。首先实现 <code>Start()</code>，然后按照 Figure 2，实现 RPC 函数 <code>AppendEntries</code>来收发新的日志条目。通过 <code>applyCh</code>发送每一个新提交的日志条目。</li><li>您需要实现选举限制（论文第 5.4.1 节）。</li><li>在早期的 2B 实验中，测试中未能达成协议的解决办法是：即使领导人还活着，也举行重复的选举。在选举计时器中找到并修复这个 bug ，或在赢得选举后不要立即发送心跳包。</li><li>您的代码可能需要循环检测变量。不要让这些循环不间断连续执行，这将使您的服务运行变慢，最终导致测试失败。使用Go的条件变量或在循环中插入 <code>time.Sleep(10 * time.Millisecond)</code>。</li></ul><p>如果运行太慢，可能会没法通过接下来的测试。您可以使用 <code>time</code>命令检查您的解决方案使用了多少实时时间和CPU时间。这是典型的输出：</p><div class="code-wrapper"><pre><code class="hljs bash">$ <span class="hljs-keyword">time</span> go <span class="hljs-built_in">test</span> -run 2BTest (2B): basic agreement ...  ... Passed --   0.9  3   16    4572    3Test (2B): RPC byte count ...  ... Passed --   1.7  3   48  114536   11Test (2B): agreement after follower reconnects ...  ... Passed --   3.6  3   78   22131    7Test (2B): no agreement <span class="hljs-keyword">if</span> too many followers disconnect ...  ... Passed --   3.8  5  172   40935    3Test (2B): concurrent Start()s ...  ... Passed --   1.1  3   24    7379    6Test (2B): rejoin of partitioned leader ...  ... Passed --   5.1  3  152   37021    4Test (2B): leader backs up quickly over incorrect follower logs ...  ... Passed --  17.2  5 2080 1587388  102Test (2B): RPC counts aren<span class="hljs-string">&#x27;t too high ...</span><span class="hljs-string">  ... Passed --   2.2  3   60   20119   12</span><span class="hljs-string">PASS</span><span class="hljs-string">ok  6.824/raft35.557s</span><span class="hljs-string"></span><span class="hljs-string">real0m35.899s</span><span class="hljs-string">user0m2.556s</span><span class="hljs-string">sys0m1.458s</span><span class="hljs-string">$</span></code></pre></div><p>“ok 6.824/raft 35.557s” 意味着 Go 运行 2B 的测试所用的实时时间为 35.557 秒。“user 0m2.556s” 表示代码运行了 2.556 秒的 CPU 时间，或实际运行（而不是等待或睡眠）所花费的时间。如果测试 2B 使用超过 1 分钟的实时时间，或超过 5 秒的 CPU 时间，则以后的实验可能会遇到麻烦。检查睡眠时间、等待 RPC 超时所花费的时间、没有睡眠或等待地检查条件或channel信息的循环、或发送大量 RPC 的地方。</p><h2 id="实现-2">实现</h2><p><a href="https://juejin.cn/post/6928375496229158926">参考资料</a></p><h3 id="2A完善-util-go">2A完善 util.go</h3><p>无论是转为Leader、Follower或者转为Candidate，实际上都可以看成是有一个隐含存在的Leader告诉他们这样做的，因此都要同步更新自己的选举超时时间，防止在有Leader的时候就已经超时，导致Leader的存在时间过短。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 转为Leader</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> toLeader() &#123;DPrintf(<span class="hljs-string">&quot;[%d]: convert from [%s] to [%s], term [%d]&quot;</span>, rf.me, rf.state, Leader, rf.currentTerm)rf.state = Leaderrf.lastReceive = time.Now().Unix()<span class="hljs-comment">// 选举为Leader后重新对所有的peer进行初始化</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(rf.peers); i++ &#123;rf.nextIndex[i] = <span class="hljs-built_in">len</span>(rf.log)rf.matchIndex[i] = <span class="hljs-number">-1</span>&#125;&#125;<span class="hljs-comment">// 转为Follower</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> toFollower(newTerm <span class="hljs-type">int</span>) &#123;DPrintf(<span class="hljs-string">&quot;[%d]: convert from [%s] to [%s]&quot;</span>, rf.me, rf.state, Follower)rf.state = Followerrf.currentTerm = newTermrf.votedFor = <span class="hljs-number">-1</span>rf.lastReceive = time.Now().Unix()&#125;<span class="hljs-comment">// 转为Candidate</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> toCandidate() &#123;DPrintf(<span class="hljs-string">&quot;[%d]: convert from [%s] to [%s]&quot;</span>, rf.me, rf.state, Candidate)rf.state = Candidaterf.currentTerm += <span class="hljs-number">1</span>rf.votedFor = rf.merf.lastReceive = time.Now().Unix()&#125;</code></pre></div><h3 id="结构体字段理解">结构体字段理解</h3><p>首先要注意由于论文中的索引是从1开始计算的，而计算机上切片的索引是从0开始算的，因此论文说明的初始化为0的地方都要初始化为-1</p><p>nextIndex[]：leader要发送给follower的下一条log entry（各follower不同），follower与leader一致的时候只发最新一条log，有不一致的时候，nextIndex要减，一次发多条log。把不一致的部分都修正过来。</p><p>matchIndex[]：已知follower上，从0开始有多少条连续的log entry与leader一致。即: 有多少条log entry已经被成功replicate到follower上了。如果过半数，就可以增加commitIndex, apply到状态机, 答复客户端操作成功了</p><p>commitIndex: 已知被提交的最高日志项对应的index。当日志项被提交(committed)了，意味着该日志项已经成功复制到了集群中的多数派server上，属于“集体记忆”了。如果当前的leader宕机再次发生选举，只有拥有完整已提交日志的server才能够获得多数派选票，才能被选举为leader。根据Leader完整性(Leader Completeness)，如果一个日志项在某个term被提交了，则该Entry会存在于所有更高term的leader日志中。</p><p>lastApplied: 应用(apply)给状态机的最高日志项的index，也就是上层应用“消费”到Raft日志项的最新index。Leader使用nextIndex和matchIndex两个数组来维护集群中其它server的日志状态。</p><p>其他结构体字段：</p><ul><li>applyCh: 由实验提供，通过该channel将ApplyMsg发送给上层应用。</li><li>moreApply: 示意有更多的日志项已经被提交，可以apply。</li><li>applyCond: apply时用于多goroutine之间同步的Condition。</li></ul><h3 id="Start函数">Start函数</h3><p>Start函数是raft顶层的服务最开始调用的类似初始化的函数</p><p>如果server不是leader则返回false。如果是leader的话，那么将command组装成LogEntry后追加到自己的日志中。此处要同时更新leader自己的matchIndex（由于自己就是Leader，自己肯定与自己一致）和nextIndex（如果自己是Follower，这条日志肯定就不能改了）</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> Start(command <span class="hljs-keyword">interface</span>&#123;&#125;) (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>) &#123;index := <span class="hljs-number">-1</span>term := <span class="hljs-number">-1</span>isLeader := <span class="hljs-literal">false</span><span class="hljs-comment">// Your code here (2B).</span><span class="hljs-keyword">if</span> !rf.killed() &#123;rf.mu.Lock()<span class="hljs-keyword">defer</span> rf.mu.Unlock()<span class="hljs-keyword">if</span> rf.state == Leader &#123;isLeader = <span class="hljs-literal">true</span><span class="hljs-comment">// 只有是Leader才可以接收日志信息</span><span class="hljs-comment">// 添加日志信息</span>rf.log = <span class="hljs-built_in">append</span>(rf.log, LogEntry&#123;Term:    rf.currentTerm,Command: command,&#125;)index = <span class="hljs-built_in">len</span>(rf.log) - <span class="hljs-number">1</span>term = rf.currentTermrf.matchIndex[rf.me] = index    <span class="hljs-comment">// 已经复制给他的日志的最高索引值</span>rf.nextIndex[rf.me] = index + <span class="hljs-number">1</span> <span class="hljs-comment">// 需要发送给他的下⼀个日志条目的索引值</span>&#125;<span class="hljs-comment">// 论文与代码起始位置索引不同</span>index += <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">return</span> index, term, isLeader&#125;</code></pre></div><h3 id="两个RPC的新增字段">两个RPC的新增字段</h3><p>请求投票RPC：新增了最后一个日志项的信息</p><ul><li>LastLogIndex 是 candidate 最后一个日志项的 index</li><li>LastLogTerm 是 candidate 最后一个日志项的 term</li></ul><p>新增日志RPC：（只有Leader才可能发出）</p><ul><li>Entries[]: 发送给对应server的新日志，如果是心跳则为空。这里要发送给对应server日志的index，是从nextIndex到最后一个日志项的index，注意也可能为空。</li><li>PrevLogIndex: 紧跟在新日志之前的日志项的index，是leader认为follower当前可能已经同步到了的最高日志项的index。对于第i个server，就是nextIndex[i] - 1。</li><li>PrevLogTerm: prevLogIndex对应日志项的term。</li><li>LeaderCommit: leader已经提交的commit index。用于通知follower更新自己的commit index。</li></ul><p>AppendEntryReply结构体新增了XTerm、XIndex和XLen几个变量用于nextIndex的快速回退。</p><p>论文中的nextIndex在AppendEntry RPC返回不匹配后，默认只是回退一个日志项(nextIndex[i]=PrevLogIndex)。如果follower能够返回更多信息，那么leader可以根据这些信息使对应server的nextIndex快速回退，减少AppendEntry RPC通信不匹配的次数，从而加快同步日志的步伐。这几个变量的具体含义：</p><ul><li>XLen: 当前follower所拥有的的日志长度。</li><li>XTerm: 当前follower的日志中，PrevLogIndex所对应日志项的term。可能为空。</li><li>XIndex: 当前follower的日志中，拥有XTerm的日志项的最低index，可能为空。</li></ul><h3 id="主函数-Make">主函数 Make</h3><p>make()函数中除做一些初始化的工作之外，新增了将已经被提交的日志项返回给上层应用的goroutine</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 初始化日志相关</span>rf.log = <span class="hljs-built_in">make</span>([]LogEntry, <span class="hljs-number">0</span>)rf.commitIndex = <span class="hljs-number">-1</span>rf.lastApplied = <span class="hljs-number">-1</span>rf.nextIndex = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(peers))rf.matchIndex = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(peers))rf.applyCh = applyChrf.moreApply = <span class="hljs-literal">false</span>rf.applyCond = sync.NewCond(&amp;rf.mu)<span class="hljs-keyword">go</span> rf.appMsgApplier()</code></pre></div><p>这个新增的goroutine无限循环判断rf.moreApply字段，一旦发现为真，则触发返回的操作，返回新的提交过的日志给上层应用</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> sendApplyMsg() &#123;rf.moreApply = <span class="hljs-literal">true</span>rf.applyCond.Broadcast()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> appMsgApplier() &#123;<span class="hljs-keyword">for</span> &#123;rf.mu.Lock()<span class="hljs-comment">// 等待这个字段为真才可以继续</span><span class="hljs-keyword">for</span> !rf.moreApply &#123;rf.applyCond.Wait()&#125;rf.moreApply = <span class="hljs-literal">false</span>commitIndex := rf.commitIndexlastApplied := rf.lastAppliedentries := rf.logrf.mu.Unlock()<span class="hljs-comment">// 发送已经提交但是还没有返回的日志字段</span><span class="hljs-keyword">for</span> i := lastApplied + <span class="hljs-number">1</span>; i &lt;= commitIndex; i++ &#123;msg := ApplyMsg&#123;CommandValid: <span class="hljs-literal">true</span>,Command:      entries[i].Command,CommandIndex: i + <span class="hljs-number">1</span>,&#125;DPrintf(<span class="hljs-string">&quot;[%d]: apply index %d - 1&quot;</span>, rf.me, msg.CommandIndex)rf.applyCh &lt;- msg<span class="hljs-comment">// 及时加锁更新，否则可能会变化</span>rf.mu.Lock()rf.lastApplied = irf.mu.Unlock()&#125;&#125;&#125;</code></pre></div><p>返回给上层应用的情况两种：</p><ul><li>Leader在将日志项复制到多数派后更新commitIndex的同时，要调用sendApplyMsg()</li><li>Follower在AppendEntry RPC收到LeaderCommit的更新时，也要调用sendApplyMsg()</li></ul><h3 id="选举限制">选举限制</h3><p>在前面选举Leader时，并没有对日志做限制，在这里需要补充日志层面的选举限制</p><p>首先要在请求投票的结构体中附带自己最后一条日志的信息</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Candidate最后一条日志的信息</span>lastLogIndex := <span class="hljs-built_in">len</span>(rf.log) - <span class="hljs-number">1</span>lastLogTerm := <span class="hljs-number">-1</span><span class="hljs-comment">// 如果日志为空需要添加判断</span><span class="hljs-keyword">if</span> lastLogIndex != <span class="hljs-number">-1</span> &#123;lastLogTerm = rf.log[lastLogIndex].Term&#125;args := RequestVoteArgs&#123;Term:         rf.currentTerm,CandidateId:  rf.me,LastLogIndex: lastLogIndex,LastLogTerm:  lastLogTerm,&#125;</code></pre></div><p>然后严格按照论文说明对请求投票的双方进行判断即可：</p><p>总体原则：candidate的log是否至少和接受者的log一样新</p><ol><li>我的log长度为0，那我肯定投票给他了 <code>len(rf.log) ==0</code></li><li>candidate的最后的log的任期比我的最后的log的任期大 <code>args.LastLogTerm &gt; rf.log[len(rf.log)-1].Term</code></li><li>candidate的最后的log的任期和我的最后的log的任期相同 <code>args.LastLogTerm == rf.log[len(rf.log)-1].Term</code>，但是它的日志长度比我长或一样（它先请求我投票，那么我就投票给他吧）<code>args.LastLogIndex &gt;=len(rf.log)-1</code></li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 是否没投票或者投给的是这个candidate</span><span class="hljs-keyword">if</span> rf.votedFor == <span class="hljs-number">-1</span> || rf.votedFor == args.CandidateId &#123;<span class="hljs-comment">// candidate的log是否至少和接受者的log一样新</span><span class="hljs-comment">// 1. 我的log长度为0，那我肯定投票给他了</span><span class="hljs-comment">// 2. candidate的最后的log的任期比我的最后的log的任期大</span><span class="hljs-comment">// 3. candidate的最后的log的任期和我的最后的log的任期相同，但是它的日志长度比我长</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.log) == <span class="hljs-number">0</span> || (args.LastLogTerm &gt; rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Term) ||(args.LastLogTerm == rf.log[<span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>].Term &amp;&amp; args.LastLogIndex &gt;= <span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span>) &#123;rf.votedFor = args.CandidateIdrf.lastReceive = time.Now().Unix() <span class="hljs-comment">// 更新时间，上面操作相当于与可能的Leader通信过了</span>reply.VoteGranted = <span class="hljs-literal">true</span>DPrintf(<span class="hljs-string">&quot;[%d]: voted to [%d]&quot;</span>, rf.me, args.CandidateId)&#125;&#125;</code></pre></div><h3 id="日志复制">日志复制</h3><h4 id="前期准备（构建请求）">前期准备（构建请求）</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 找到日志的同步位置</span>prevLogIndex := rf.nextIndex[index] - <span class="hljs-number">1</span>prevLogTerm := <span class="hljs-number">-1</span><span class="hljs-keyword">if</span> prevLogIndex != <span class="hljs-number">-1</span> &#123;prevLogTerm = rf.log[prevLogIndex].Term&#125;<span class="hljs-comment">// 找到要发送的日志</span><span class="hljs-keyword">var</span> entries []LogEntry<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rf.log)<span class="hljs-number">-1</span> &gt;= rf.nextIndex[index] &#123;entries = rf.log[rf.nextIndex[index]:]&#125;<span class="hljs-comment">// 补充结构体</span>args := AppendEntriesArgs&#123;Term:         rf.currentTerm,LeaderId:     rf.me,LeaderCommit: rf.commitIndex,PrevLogIndex: prevLogIndex,PrevLogTerm:  prevLogTerm,Entries:      entries,&#125;</code></pre></div><p>论文的日志匹配性质：</p><ul><li>如果来自不同日志的两个日志项有相同的index和term，那么它们存储了相同的command。</li><li>如果来自不同日志的两个日志项有相同的index和term，那么它们前面的日志完全相同。</li></ul><p>因此只需要判断PrevLogIndex和PrevLogTerm与follower的日志匹配的程度即可，这里只是Leader猜测一下，真正的判断在接收到RPC后完成</p><h4 id="Follower处理请求">Follower处理请求</h4><p>在处理AppendEntry RPC的代码中，新增了日志匹配的逻辑。</p><p>如果日志在prevLogIndex处不包含term为prevLogTerm的日志项，那么返回false，（需要回退才能找到对应的位置）。</p><ul><li>接收者的日志没有index为prevLogIndex的日志项</li><li>有对应index的日志项但是term不匹配。</li></ul><p>回退的逻辑：</p><ol><li>记录Follower的日志的长度</li><li>找到prevLogIndex的索引位置的任期号并记录任期（一定比prevLogTerm更小）</li><li>往回遍历日志，找到第一个是上一步记录的任期的索引，那么这个位置之前一定是与Leader相同的日志，记录索引</li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Reply false if log doesn’t contain an entry at prevLogIndex</span><span class="hljs-comment">// whose term matches prevLogTerm (§5.3)</span><span class="hljs-keyword">if</span> args.PrevLogIndex &gt;= <span class="hljs-built_in">len</span>(rf.log) || (args.PrevLogIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; rf.log[args.PrevLogIndex].Term != args.PrevLogTerm) &#123;reply.Term = rf.currentTerm<span class="hljs-comment">// 回退</span>reply.XLen = <span class="hljs-built_in">len</span>(rf.log)<span class="hljs-keyword">if</span> args.PrevLogIndex &gt;= <span class="hljs-number">0</span> &amp;&amp; args.PrevLogIndex &lt; <span class="hljs-built_in">len</span>(rf.log) &#123;reply.XTerm = rf.log[args.PrevLogIndex].Term<span class="hljs-keyword">for</span> i := args.PrevLogIndex; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<span class="hljs-keyword">if</span> rf.log[i].Term == reply.XTerm &#123;reply.XIndex = i&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>此外还要注意prevLogIndex可能为-1，意味着日志全都没有匹配上，或者leader此刻还没有日志，此时接收者就要完全服从。</p><p>接下来是PreLogIndex与PrevLogTerm匹配到的情况，还要额外检查新同步过来的日志和已存在的日志是否存在冲突。如果一个已经存在的日志项和新的日志项冲突（相同index但是不同term），那么要删除这个冲突的日志项及其往后的日志。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// If an existing entry conflicts with a new one (same index</span><span class="hljs-comment">// but different terms), delete the existing entry and all that</span><span class="hljs-comment">// follow it (§5.3)</span>misMatchIndex := <span class="hljs-number">-1</span><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> args.Entries &#123;<span class="hljs-keyword">if</span> args.PrevLogIndex+<span class="hljs-number">1</span>+i &gt;= <span class="hljs-built_in">len</span>(rf.log) || rf.log[args.PrevLogIndex+<span class="hljs-number">1</span>+i].Term != args.Entries[i].Term &#123;misMatchIndex = i<span class="hljs-keyword">break</span>&#125;&#125;</code></pre></div><p>将新的日志项追加到日志中</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Append any new entries not already in the log</span><span class="hljs-keyword">if</span> misMatchIndex != <span class="hljs-number">-1</span> &#123;rf.log = <span class="hljs-built_in">append</span>(rf.log[:args.PrevLogIndex+<span class="hljs-number">1</span>+misMatchIndex], args.Entries[misMatchIndex:]...)&#125;</code></pre></div><p>最后根据论文，如果 <code>leaderCommit &gt; commitIndex</code>，说明follower的commitIndex也需要更新。为了防止越界，commitIndex取 <code>min(leaderCommit, index of last new entry)</code>。同时要向上层应用发回响应。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)</span><span class="hljs-keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;newEntryIndex := <span class="hljs-built_in">len</span>(rf.log) - <span class="hljs-number">1</span><span class="hljs-keyword">if</span> args.LeaderCommit &gt;= newEntryIndex &#123;rf.commitIndex = newEntryIndex&#125; <span class="hljs-keyword">else</span> &#123;rf.commitIndex = args.LeaderCommit&#125;DPrintf(<span class="hljs-string">&quot;[%d]: commit index [%d]&quot;</span>, rf.me, rf.commitIndex)rf.sendApplyMsg()&#125;</code></pre></div><h4 id="Leader处理响应">Leader处理响应</h4><p>由于RPC在网络中可能乱序或者延迟，我们要确保当前RPC发送时的term、当前接收时的currentTerm以及RPC的reply.term三者一致，丢弃过去term的RPC，避免对当前currentTerm产生错误的影响。</p><div class="code-wrapper"><pre><code class="hljs go">reply.Term == rf.currentTerm &amp;&amp; rf.currentTerm == args.Term</code></pre></div><p>当reply.Success为true，说明follower包含了匹配prevLogIndex和prevLogTerm的日志项，更新nextIndex[serverTo]和matchIndex[serverTo]。这里只能用prevLogIndex和entries来更新，而不能用nextIndex及len(log)，因为后两者可能已经被别的RPC更新了，进而导致数据不一致。</p><p>由于matchIndex发生了变化，我们要检查是否更新commitIndex。根据论文，如果存在一个N，这个N大于commitIndex，多数派的matchIndex[i]都大于等于N，并且log[N].term等于currentTerm，那么更新commitIndex为N。这里必须注意，日志提交是有限制的，Raft从不提交过去term的日志项，即使已经复制达到了多数派。如果要更新commitIndex为N，那么N所对应的日志项的term必须是当前currentTerm。</p><p>在检查是否更新commitIndex的实现上，我们将matchIndex复制到了matches数组中，通过sort升序排序以方便遍历。然后对matches数组进行遍历，找到大多数都提交的索引位置，随后调用sendApplyMsg()，通知有更多的日志项已经被提交，上层应用可以应用。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> reply.Success &#123;<span class="hljs-comment">// 更新服务器的状态</span>rf.nextIndex[index] = prevLogIndex + <span class="hljs-built_in">len</span>(entries) + <span class="hljs-number">1</span>rf.matchIndex[index] = prevLogIndex + <span class="hljs-built_in">len</span>(entries)<span class="hljs-comment">// If there exists an N such that N &gt; commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm:</span><span class="hljs-comment">// set commitIndex = N</span>matches := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(rf.peers))<span class="hljs-built_in">copy</span>(matches, rf.matchIndex)sort.Ints(matches)<span class="hljs-keyword">for</span> i := rf.majorityVote - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; matches[i] &gt; rf.commitIndex; i-- &#123;<span class="hljs-keyword">if</span> rf.log[matches[i]].Term == rf.currentTerm &#123;rf.commitIndex = matches[i]DPrintf(<span class="hljs-string">&quot;[%d]: commit index [%d]&quot;</span>, rf.me, rf.commitIndex)rf.sendApplyMsg()<span class="hljs-keyword">break</span>&#125;&#125;&#125;</code></pre></div><p>当reply.Success为false，说明follower的日志不包含在prevLogIndex处并匹配prevLogTerm的日志项，要将nextIndex缩减。此处更新不宜采用自减的方式更新，因为RPC可能会重发，正确的方式是 <code>rf.nextIndex[serverTo] = prevLogIndex</code>。</p><p>在AppendEntryReply中增加了几个变量，以使nextIndex能够快速回退(back up)。如果接下来要尝试匹配的prevLogIndex比follower当前所拥有的的日志长度（XLen）还要大，那么显然直接从XLen尝试匹配即可。如果接下来要尝试匹配的prevLogIndex在XLen以内，因为我们已经知道了follower的日志从XIndex到当前prevLogIndex的日志项的term都是XTerm，那么我们可以直接在leader侧遍历匹配一遍，而无需多次往返RPC通信。</p><div class="code-wrapper"><pre><code class="hljs go">&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// In Test (2C): Figure 8 (unreliable), the AppendEntry RPCs are reordered</span><span class="hljs-comment">// So rf.nextIndex[index]-- would be wrong</span>rf.nextIndex[index] = prevLogIndex<span class="hljs-comment">// 如果接下来要尝试匹配的prevLogIndex比follower当前所拥有的的日志长度（XLen）还要大，那么显然直接从XLen尝试匹配即可。</span><span class="hljs-keyword">if</span> rf.nextIndex[index]<span class="hljs-number">-1</span> &gt;= reply.XLen &#123;rf.nextIndex[index] = reply.XLen&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 如果接下来要尝试匹配的prevLogIndex在XLen以内，因为我们已经知道了follower的日志从XIndex到当前prevLogIndex的日志项的term都是XTerm，那么我们可以直接在leader侧遍历匹配一遍，而无需多次往返RPC通信</span><span class="hljs-keyword">for</span> i := rf.nextIndex[index] - <span class="hljs-number">1</span>; i &gt;= reply.XIndex; i-- &#123;<span class="hljs-keyword">if</span> rf.log[i].Term != reply.XTerm &#123;rf.nextIndex[index] -= <span class="hljs-number">1</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;&#125;&#125;</code></pre></div><h2 id="运行结果-2">运行结果</h2><div class="code-wrapper"><pre><code class="hljs bash">Test (2B): basic agreement ...  ... Passed --   1.3  3   16    4546    3Test (2B): RPC byte count ...  ... Passed --   2.7  3   48  114510   11Test (2B): agreement after follower reconnects ...  ... Passed --   7.1  3  116   31767    8Test (2B): no agreement <span class="hljs-keyword">if</span> too many followers disconnect ...  ... Passed --   4.1  5  160   37664    3Test (2B): concurrent Start()s ...  ... Passed --   1.2  3   12    3466    6Test (2B): rejoin of partitioned leader ...  ... Passed --   5.6  3  166   40233    4Test (2B): leader backs up quickly over incorrect follower logs ...  ... Passed --  34.1  5 2352 2038228  102Test (2B): RPC counts aren<span class="hljs-string">&#x27;t too high ...</span><span class="hljs-string">  ... Passed --   2.5  3   42   12630   12</span><span class="hljs-string">PASS</span><span class="hljs-string">ok      6.824/raft      58.652s</span><span class="hljs-string"></span><span class="hljs-string">real    0m59.353s</span><span class="hljs-string">user    0m1.744s</span><span class="hljs-string">sys     0m1.630s</span></code></pre></div><h1>Part 2C：持久性</h1><h2 id="指导-3">指导</h2><p>如果基于 Raft 的服务器重新启动，它应该在中断的地方恢复服务。这要求 Raft 在重启后，依旧能确保数据持久化。本文的Figure 2 提到的那些状态应该被持久化。</p><p>真正的实现会在每次 persistent state 被修改时写磁盘，并在重新启动后从磁盘读取状态。您不需要使用磁盘，而应该通过 <code>Persister</code> 对象保存和恢复 persistent state （请参阅 <code>persister.go</code>）。调用 <code>Raft.Make()</code>时会提供一个 <code>Persister</code>， 其可能会包含 Raft 最近的 persistent state（也可能没有） 。Raft 应从 <code>Persister</code> 初始化其状态（对应方法 <code>ReadRaftState()</code>），并在每次 president state 更改后使用 <code>Persister</code> 保存（对应方法 <code>SaveRaftState()</code>）。</p><p>完善 <code>raft.go</code>中的 <code>persist()</code>和 <code>readPerisit()</code>函数，实现保存和读取 persistent state。你可能需要使用 <code>labgob</code> encoder 来编码（或者说序列化）persistent state，让 <code>Persister</code>来存储二进制流。欢迎查看 <code>persist()</code>和 <code>readPerisit()</code>的注释了解更多。<code>labgob</code>很像 go 的 <code>gob</code>，只是会在序列化非导出字段时报错。实现完“ 在每次 persistent state 改变时调用 <code>presist()</code>”后，应通过其余测试。</p><p>您可能想优化为一次性保存多条日志。查看论文第7页的顶部到第 8 页顶部（用灰色线标记的地方）。论文没有描述清楚细节，你需要自己多考虑一下。 6.824 Raft 的讲座或许也能提供一些帮助。</p><p>您的代码应通过所有 2C 测试：</p><div class="code-wrapper"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -run 2CTest (2C): basic persistence ...  ... Passed --   5.0  3   86   22849    6Test (2C): more persistence ...  ... Passed --  17.6  5  952  218854   16Test (2C): partitioned leader and one follower crash, leader restarts ...  ... Passed --   2.0  3   34    8937    4Test (2C): Figure 8 ...  ... Passed --  31.2  5  580  130675   32Test (2C): unreliable agreement ...  ... Passed --   1.7  5 1044  366392  246Test (2C): Figure 8 (unreliable) ...  ... Passed --  33.6  5 10700 33695245  308Test (2C): churn ...  ... Passed --  16.1  5 8864 44771259 1544Test (2C): unreliable churn ...  ... Passed --  16.5  5 4220 6414632  906PASSok  6.824/raft123.564s$</code></pre></div><p>最好能多次运行：<code>for i in {0..10}; do go test; done</code></p><h2 id="实现-3">实现</h2><h1>Part 2D：日志压缩</h1><h2 id="指导-4">指导</h2><p>就目前情况而言，重新启动的服务器会重放完整的Raft日志，以恢复其状态。然而，对于长期运行的服务来说，永远记住完整的Raft日志是不现实的。相反，您将修改Raft以与持久存储其状态的“快照”的服务协作，此时Raft将丢弃快照之前的日志条目。其结果是持久数据量更少，重启速度更快。然而，现在有可能一个追随者远远落后，以至于领导者放弃了需要追赶的日志条目；然后领导者必须发送快照以及快照时开始的日志。</p><p>您的Raft必须提供以下函数 <code>Snapshot(index int, snapshot []byte)</code>，服务可以使用其状态的序列化快照调用该函数。</p><p>在Lab 2D中，测试代码定期调用 <code>Snapshot()</code>。在Lab 3中，您将编写一个k/v服务器调用 <code>Snapshot()</code>；快照将包含k/v对的完整表。服务层对每个对等方（而不仅仅是Leader）调用 <code>Snapshot()</code>。</p><p>index参数指示快照中包括的最高日志条目。raft应该在这个参数之前丢弃其日志条目。您需要修改Raft代码以只存储日志尾部。</p><p>您需要实现论文中讨论的 <code>InstallSnapshot RPC</code>，该RPC允许raft的Leader告诉落后的Raft服务器用快照替换其状态。您可能需要考虑 <code>InstallSnapshot</code>应该如何与图2中的状态和规则交互。</p><p>当Follower的Raft代码接收到 <code>InstallSnapshot RPC</code>时，它可以使用 <code>applyCh</code>将快照发送到 <code>ApplyMsg</code>中的服务。<code>ApplyMsg</code>结构定义已经包含了您需要的字段（并且是测试代码期望的）。请注意，这些快照只会增加服务的状态，而不会导致服务向后移动。</p><p>如果服务器崩溃，它必须从持久数据重新启动。您的Raft应该保持Raft状态和相应的快照。使用 <code>persister.SaveStateAndSnapshot()</code>，它对于Raft状态和相应的快照有单独的参数。如果没有快照，则传递nil作为快照参数。</p><p>当服务器重新启动时，应用程序层读取持久化快照并恢复其保存状态。</p><p>以前，建议您实现一个名为 <code>CondInstallSnapshot</code>的函数，以避免在 <code>applyCh</code>上发送的快照和日志条目需要协调。这个残留的API接口仍然存在，但不希望实现它：相反，我们建议您只需将其返回true。</p><p>任务：实现 <code>Snapshot()</code>和 <code>InstallSnapshot RPC</code>，以及对Raft的更改以支持这些（例如，使用修剪日志的操作）。</p><p>提示：</p><ol><li>修改代码以便能够存储从某个索引X开始的日志部分是一个好的开始。最初，您可以将X设置为零并运行2B/2C测试。然后使用 <code>Snapshot(index)</code>放弃索引之前的日志，并将X设置为索引。如果一切顺利，您现在应该通过第一个2D测试。</li><li>您将无法将日志存储在Go切片中，并将Go切片索引与Raft日志索引互换使用；您需要以一种方式对切片进行索引，以说明日志中被丢弃的部分。</li><li>下一步：如果Leader没有更新Follower所需的日志条目，则让Leader发送 <code>InstallSnapshot RPC</code>。</li><li>在单个 <code>InstallSnapshot RPC</code>中发送整个快照。不要实现图13的用于分割快照的偏移机制。</li><li>Raft必须以允许Go垃圾收集器释放和重新使用内存的方式丢弃旧日志条目；这要求对丢弃的日志条目没有可访问的引用（指针）。</li><li>即使日志被修剪，您的实现仍然需要在 <code>AppendEntries RPC</code>中的新条目之前正确发送条目的术语和索引；这可能需要保存和引用最新快照的 <code>lastIncludedTerm/lastIncludedIndex</code>（请考虑是否应持久化）。</li><li>在不检测竞争的情况下，全套Lab 2测试（2A+2B+2C+2D）所需的合理时间是6分钟的实时时间和1分钟的CPU时间。使用–race运行时，大约需要10分钟的实时时间和2分钟的CPU时间。</li></ol><p>输出示例：</p><div class="code-wrapper"><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> -run 2DTest (2D): snapshots basic ...  ... Passed --  11.6  3  176   61716  192Test (2D): install snapshots (disconnect) ...  ... Passed --  64.2  3  878  320610  336Test (2D): install snapshots (disconnect+unreliable) ...  ... Passed --  81.1  3 1059  375850  341Test (2D): install snapshots (crash) ...  ... Passed --  53.5  3  601  256638  339Test (2D): install snapshots (unreliable+crash) ...  ... Passed --  63.5  3  687  288294  336Test (2D): crash and restart all servers ...  ... Passed --  19.5  3  268   81352   58PASSok      6.824/raft      293.456s</code></pre></div><h2 id="实现-4">实现</h2>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Distributed Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【实践课】规则引擎设计与实现</title>
    <link href="/2023/01/29/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day06/"/>
    <url>/2023/01/29/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day06/</url>
    
    <content type="html"><![CDATA[<p>【实践课】规则引擎设计与实现</p><span id="more"></span><h1>【实践课】规则引擎设计与实现</h1><h2 id="一、概述">一、概述</h2><h3 id="1-1-前言">1.1 前言</h3><p>规则引擎是一种嵌入在应用服务中的组件，可以将灵活多变的业务决策从服务代码中分离出来。通过使用预定义的语义模块来编写业务逻辑规则。在执行时接受数据输入、解释业务规则，并做出决策。规则引擎能大大提高系统的灵活性和扩展性。</p><p>在字节跳动，规则引擎已经在风控识别、活动运营、配置下发等场景得到了广泛的应用。开发人员可以将业务逻辑与服务代码解耦，实现灵活、高效的业务策略发布。目前公司内部基于规则引擎的动态决策系统已经承接了千万级别QPS的决策请求。</p><p>规则引擎的实现需要在满足大容量、高请求、低延迟的基础上尽可能做到简单易上手。本次课程将会带领大家实现一个简单版的规则引擎。</p><h3 id="1-2-课程目标">1.2 课程目标</h3><ul><li>了解规则引擎的组成部分和应用场景。</li><li>学习并掌握规则引擎的设计与实现原理。</li><li>明确一个规则引擎的设计目标，并完成各部分的设计与实现步骤拆解。</li><li>动手实现规则引擎项目，完成预定目标。</li><li><em>[课外扩展] 结合其他课程，完成一个在线</em> <em>规则引擎</em> <em>服务。</em></li></ul><h3 id="1-3-课程重难点">1.3 课程重难点</h3><p><strong>重点</strong></p><ul><li>规则引擎的设计 。明确设计目标、完成步骤拆解、完成各部分状态机的详细设计</li><li>规则引擎的实现。基于项目工程完成词法分析、语法分析、抽象语法树的执行功能</li></ul><p><strong>难点</strong></p><ul><li>规则引擎的核心原理（理论）。词法分析、语法分析、类型检查、语法树执行</li></ul><p>主要涉及到编译原理的部分</p><h2 id="二、课前预习">二、课前预习</h2><p><strong>课前必看！！！</strong></p><p>本部分是需要大家在上课之前了解的内容，主要是一些基本的概念和原理。</p><p>在这门课程之前你可能根本没有听说过规则引擎这个东西，当然也可能是浅浅的大概知道这是个什么东西，或者是个规则引擎方面的资深专家（还没毕业，五年工作经验那种🐶，如果是这样请赶紧找我内推）。都没有关系，这门课包教包会！！！（学不会的下课后可以找我们运营人员联系我一对一教学）</p><p>当然，这门课程还是有一定的门槛的，这也就是我为什么要说这么多一定要让你仔细看看这部分的原因。经过实验，课程的内容如果只依赖于课上老师的讲解，只能做到：能听懂，能跟上，来不及思考。要想能够理解掌握这部分内容，能跟别人battle下，再向自己的知识山峰上加那么一块小石头，得好好预习。</p><p>开始之前先百度或者Google一下 “规则引擎”简单浏览下哈，📪📪📪另外掘金app上面也有许多不错的文章。可以先浏览看看。</p><h3 id="2-1-数据结构基础">2.1 数据结构基础</h3><p>数据结构得学过吧，考多少分？😁</p><p>这块的预习目标呢，包括以下几个部分</p><ul><li>精通常用数据结构：数组、结构体、指针、队列、二叉树 等等等，课本上有的都得看看</li><li>熟练掌握二叉树的各种遍历方式：前中后序遍历，层序遍历，打印二叉树，有时间可以自己写几个小demo，当然最基础的是需要知道各种遍历方式的区别</li></ul><h3 id="2-2-Go语言基础">2.2 Go语言基础</h3><ul><li>掌握Go语言的基础语法，能读懂项目代码</li></ul><p>是的，就这一个要求，其实学完青训营的前几节课就可以达到了</p><h3 id="2-3-编译原理基础">2.3 编译原理基础</h3><p>编译原理被誉为&quot;程序员的三大浪漫&quot;之一，足以可见这块知识的深度与广度，我们这次课程也是简单的介绍一下与规则引擎相关的概念。</p><p>那么可能会有疑问了，不是讲规则引擎么？为啥还得学编译原理？</p><p>规则引擎的本质呢就是我们自己定义一套语法，然后去解析用这套语法写的表达式，然后根据解析的内容执行表达式。这个过程其实就是编译和执行的过程。</p><p>因此呢需要自行了解以下的内容</p><ul><li><strong>编译的概念:</strong><ul><li>编译的过程发生了什么？</li><li>一般分为哪几个步骤，每个步骤的中间结果是什么？</li></ul></li><li><strong>词法分析：</strong><ul><li>词法如何表示？| <em>正则文法</em></li><li>词法分析阶段的输出是什么</li><li>词法分析阶段是怎么做的？</li><li>词法分析可能会产生什么问题？</li><li>如何解决词法分析过程中产生的问题？| <em>左递归问题怎么解决</em></li></ul></li><li><strong>语法分析</strong><ul><li>语法如何表示？上下文无关语法、巴克斯范式怎么理解</li><li>语法分析阶段的输出是什么？ 一般怎么表示</li><li>语法分析有哪些方式？什么是递归下降算法？</li></ul></li><li><strong>抽象语法树</strong><ul><li>抽象语法树是什么？</li><li>抽象语法树如何执行？</li></ul></li><li><strong>类型检查</strong><ul><li>类型检查怎么做？有哪些方式？</li><li>类型检查什么时候做？有什么区别？</li></ul></li></ul><h3 id="2-4-环境搭建">2.4 环境搭建</h3><p>课程之前，大家需要根据项目工程，来完成环境的搭建和Demo的运行</p><p><strong>项目地址：</strong></p><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fqimengxingyuan%2Fyoung_engine" title="https://github.com/qimengxingyuan/young_engine">github.com/qimengxingy…</a></p><p>相信大家已经完成了Go环境的搭建，项目工程依赖了hertz框架，如果在之前的课程中完成了项目环境搭建可以直接复用。</p><p><strong>项目环境：</strong></p><ul><li>go语言环境搭建</li></ul><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fgo%2Fgo-environment.html" title="https://www.runoob.com/go/go-environment.html">www.runoob.com/go/go-envir…</a></p><ul><li>需要安装docker环境</li></ul><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fdocker%2Fwindows-docker-install.html" title="https://www.runoob.com/docker/windows-docker-install.html">www.runoob.com/docker/wind…</a></p><ul><li>安装docker-compose工具</li></ul><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fdocker%2Fdocker-compose.html" title="https://www.runoob.com/docker/docker-compose.html">www.runoob.com/docker/dock…</a></p><p>项目clone到本地后，可以执行测试脚本来测试环境的可用性。如果有错误欢迎百度和Google解决</p><div class="code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/qimengxingyuan/young_engine.git<span class="hljs-built_in">chmod</span> a+x ./setup.sh./setup.sh</code></pre></div><p>脚本执行成功，则环境可以支持项目的执行</p><p><strong>项目说明：</strong></p><p>本项目是一个简单的规则引擎的实现，<a href="http://xn--README-2x8i454aslat68gui8cpxt5vd928c.md">详细目录可以参考README.md</a></p><p>项目实现时间有限，没有做比较完备的测试，如果在demo执行的过程中出现某些bug或者执行异常可以直接在github提交issue或者修复后提起PR</p><p><a href="https://juejin.cn/post/7117987884937773086" title="https://juejin.cn/post/7117987884937773086">juejin.cn/post/711798…</a></p><h2 id="三、课中知识点补充">三、课中知识点补充</h2><h3 id="3-1-什么是编译">3.1 什么是编译</h3><p>编译的过程就是 把某种语言的源程序， <strong>在不改变语义的条件下</strong> ，转换成另一种语言程序(目标语言程序)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be32c9bd4c234fecb66e183ba7bc83ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>如果源代码编译后要在操作系统上运行，那目标代码就是汇编/机器代码。</li><li>如果编译后是在虚拟机里执行，那目标代码就可以不是汇编代码，而是一种解释器可以理解的中间形式的代码即可。</li></ul><p><strong>解释型语言和编译型语言</strong></p><ul><li>有的语言提前把代码一次性转换完毕，这种就是编译型语言，用的转换工具就叫编译器，比如C、C++、Go。一次编译可重复执行<ul><li>编译后产物不能跨平台，不同系统对可执行文件的要求不同。.exe</li><li>特殊的，c、c++、汇编、源代码也不能跨平台</li></ul></li><li>有的语言则可以一边执行一边转化，用到哪里了就转哪里，这种就是解释性语言，用的转化工具叫虚拟机或者解释器，比如java python、javascript</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a98e9ce76f8a4b2384914f8ad088541f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p><strong>关于</strong> <strong>Java</strong> <strong>和</strong> <strong>Python</strong> <strong>.</strong></p><ul><li>Java既有编译又有解释。但是编译并没有直接编译成机器码，而是编译成字节码，然后再放到虚拟机中执行。</li><li>Python执行过程也是经过两个阶段，先编译成字节码 .pyc 再放到虚拟机中去执行</li></ul><p><a href="https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F441824%2Fjava-virtual-machine-vs-python-interpreter-parlance%2F441973%23441973" title="https://stackoverflow.com/questions/441824/java-virtual-machine-vs-python-interpreter-parlance/441973#441973">JVM 和 Python解释器</a> | 为什么一个叫虚拟机一个叫解释器</p><ol><li>“虚拟机”对二进制字节码进行解释，而“解释器”是对程序文本进行解释。</li><li>从历史上看，Java 是为解释二进制字节码而设计和实现的，而 Python 最初是为解释程序文本而设计和实现的。因此，“Java 虚拟机”这个术语在 Java 社区中具有历史意义并且非常成熟，“Python 解释器”这个术语在 Python 社区中具有历史意义并且非常成熟。人们倾向于延长传统并使用很久以前使用的相同术语。</li><li>对于 Java，二进制字节码解释是程序执行的主要方式，而 JIT 编译只是一种可选的和透明的优化。而对于 Python，目前，程序文本解释是 Python 程序执行的主要方式，而编译成 Python VM 字节码只是一种可选的透明优化。</li></ol><h3 id="3-2-词法分析">3.2 词法分析</h3><p>把源代码字符串转换为词法单元(Token)的这个过程。</p><p><strong>确定的有限自动机 DFA |</strong> <strong>Deterministic Finite Automaton</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fb1507b67fb41d6860254c2266ab00e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>确定的有限自动机就是一个状态机，它的状态数量是有限的。该状态机在任何一个状态，基于输入的字符，都能做一个确定的状态转换。</p><h3 id="3-3-语法分析">3.3 语法分析</h3><p>词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。这个结构是一个树状结构。这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫“语法”。每个节点还可以有下级节点。</p><p>Token -&gt; AST</p><p><strong>上下文无关语法 Context-Free Grammar</strong></p><p>语言句子无需考虑上下文，就可以判断正确性</p><blockquote><div class="code-wrapper"><pre><code class="hljs ini">...<span class="hljs-attr">a</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>...这是一个赋值语句，无论此语句的前后是什么代码，此语句所代表的操作是确定的。即给变量a赋值等于0</code></pre></div></blockquote><p>编程语言为什么不用人类的语言（自然语言），而是用上下文无关的文法呢？ 因为</p><ol><li>便于设计编译器。 客观上技术目前无法实现，如果使用了上下文相关文法，那就是真正实现了人工智能，NLP领域将会有重大突破。</li><li>便于代码开发维护。 如果开发出来的代码像高考的语文阅读理解一样，每个人都有不同的理解，那么，到底哪个才是作者真正想要表达的？如果人类都确定不了含义，那计算机同样也确定不了，最终结果就是错误执行或无法执行。</li><li>汇编语言/机器语言是上下文无关的。CPU执行指令时，读到哪条执行哪条。如果CPU需要考虑上下文，来决定一个语句到底要做什么，那么CPU执行一条语句会比现在慢千倍万倍。考虑上下文的事情，完全可以用户在编程的时候用算法实现。既然机器语言是上下文无关的，那高级语言也基本上是上下文无关的，可能有某些个别语法为了方便使用，设计成了上下文相关的，比如脚本语言的弱类型。在便于使用的同时，增加了解析器的复杂度。</li></ol><p><strong>上下文无关语法G：终结符集合T + 非终结符集合N + 产生式集合P + 起始符号S</strong></p><p>G由T、N、S和P组成，由语法G推导出来的所有句子的集合称为G语言！</p><p><strong>终结符：</strong> 组成串的基本符号。可以理解为词法分析器产生的token集合。比如 <code>+</code> <code>Id</code> <code>(</code> <code>)</code> 等</p><p><strong>非终结符：</strong> 表示token的的集合的语法变量。比如 <code>stmt</code> <code>varDecl</code> 等等</p><div class="code-wrapper"><pre><code class="hljs scss">start：blockStmts ;               <span class="hljs-comment">//起始</span>block : <span class="hljs-string">&#x27;&#123;&#x27;</span> blockStmts <span class="hljs-string">&#x27;&#125;&#x27;</span> ;      <span class="hljs-comment">//语句块</span>blockStmts : stmt* ;              <span class="hljs-comment">//语句块中的语句</span>stmt = varDecl | expStmt | returnStmt | block;   <span class="hljs-comment">//语句</span>varDecl : type Id varInitializer？ <span class="hljs-string">&#x27;;&#x27;</span> ;         <span class="hljs-comment">//变量声明</span>type : Int | Long ;                              <span class="hljs-comment">//类型</span>varInitializer : <span class="hljs-string">&#x27;=&#x27;</span> exp ;                       <span class="hljs-comment">//变量初始化</span>expStmt : exp <span class="hljs-string">&#x27;;&#x27;</span> ;                              <span class="hljs-comment">//表达式语句</span>returnStmt : Return exp <span class="hljs-string">&#x27;;&#x27;</span> ;                    <span class="hljs-comment">//return语句</span>exp : add ;                                      <span class="hljs-comment">//表达式   </span>add : add <span class="hljs-string">&#x27;+&#x27;</span> mul | mul;                         <span class="hljs-comment">//加法表达式</span>mul : mul <span class="hljs-string">&#x27;*&#x27;</span> pri | pri;                         <span class="hljs-comment">//乘法表达式</span>pri : IntLiteral | Id | <span class="hljs-string">&#x27;(&#x27;</span> exp <span class="hljs-string">&#x27;)&#x27;</span> ;            <span class="hljs-comment">//基础表达式 </span></code></pre></div><p>产生式：表示形式，S : AB ，就是说S的含义可以用语法AB进行表达</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">S :</span> <span class="hljs-string">AB</span><span class="hljs-attr">A :</span> <span class="hljs-string">aA</span> <span class="hljs-string">|</span> <span class="hljs-string">ε</span><span class="hljs-attr">B :</span> <span class="hljs-string">b</span> <span class="hljs-string">|</span> <span class="hljs-string">bB</span></code></pre></div><p>展开(expand)：将P(A-&gt;<em>u</em> )应用到符号串vAw中，得到新串v<em>u</em> **w</p><p>折叠(reduce)：将P(A-&gt;<em>uu</em> )应用到符号串v<em>uu</em> w中，得到新串vAw</p><p>推导(derivate)：符号串<em>u</em> 应用一系列产生式，变成符号串<em>v</em> ，则<em>u</em> =&gt;<em>v：S =&gt; ab | b | bb</em></p><p><strong>巴科斯范式</strong></p><p>BNF是描述上下文无关理论的一种具体方法，通过BNF可以实现上下文无关文法的具体化、公式化、科学化，是实现代码解析的必要条件。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span> ::= <span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span> + <span class="hljs-tag">&lt;<span class="hljs-name">term</span>&gt;</span>         | <span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span> - <span class="hljs-tag">&lt;<span class="hljs-name">term</span>&gt;</span>         | <span class="hljs-tag">&lt;<span class="hljs-name">term</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">term</span>&gt;</span> ::= <span class="hljs-tag">&lt;<span class="hljs-name">term</span>&gt;</span> * <span class="hljs-tag">&lt;<span class="hljs-name">factor</span>&gt;</span>         | <span class="hljs-tag">&lt;<span class="hljs-name">term</span>&gt;</span> / <span class="hljs-tag">&lt;<span class="hljs-name">factor</span>&gt;</span>         | <span class="hljs-tag">&lt;<span class="hljs-name">factor</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">factor</span>&gt;</span> ::= ( <span class="hljs-tag">&lt;<span class="hljs-name">expr</span>&gt;</span> )           | Num</code></pre></div><blockquote><p>BNF本质上就是树形分解，分解成一棵抽象语法树</p></blockquote><ul><li>每个产生式就是一个子树，在写编译器时，每个子树对应一个解析函数。</li><li>叶子节点叫做  <strong>终结符</strong> ，非叶子节点叫做  <strong>非终结符</strong> 。</li></ul><p><strong>递归下降算法 Recursive Descent Parsing</strong></p><p>基本思路就是按照语法规则去匹配 Token 串。比如说，变量声明语句的规则如下：</p><div class="code-wrapper"><pre><code class="hljs scss">varDecl : types Id varInitializer？ <span class="hljs-string">&#x27;;&#x27;</span> ;        <span class="hljs-comment">//变量声明</span>varInitializer : <span class="hljs-string">&#x27;=&#x27;</span> exp ;                       <span class="hljs-comment">//变量初始化</span>exp : add ;                                      <span class="hljs-comment">//表达式   </span>add : add <span class="hljs-string">&#x27;+&#x27;</span> mul | mul;                         <span class="hljs-comment">//加法表达式</span>mul : mul <span class="hljs-string">&#x27;*&#x27;</span> pri | pri;                         <span class="hljs-comment">//乘法表达式</span>pri : IntLiteral | Id | <span class="hljs-string">&#x27;(&#x27;</span> exp <span class="hljs-string">&#x27;)&#x27;</span> ;            <span class="hljs-comment">//基础表达式</span></code></pre></div><p>如果写成产生式格式，是下面这样：</p><div class="code-wrapper"><pre><code class="hljs rust">varDecl <span class="hljs-punctuation">-&gt;</span> types Id varInitializer <span class="hljs-string">&#x27;;&#x27;</span> varInitializer <span class="hljs-punctuation">-&gt;</span> <span class="hljs-string">&#x27;=&#x27;</span> exp      varInitializer <span class="hljs-punctuation">-&gt;</span> εexp <span class="hljs-punctuation">-&gt;</span> addadd <span class="hljs-punctuation">-&gt;</span> add + muladd <span class="hljs-punctuation">-&gt;</span> mulmul <span class="hljs-punctuation">-&gt;</span> mul * primul <span class="hljs-punctuation">-&gt;</span> pripri <span class="hljs-punctuation">-&gt;</span> IntLiteralpri <span class="hljs-punctuation">-&gt;</span> Idpri <span class="hljs-punctuation">-&gt;</span> ( exp )</code></pre></div><p>而基于这个规则做解析的算法如下：</p><div class="code-wrapper"><pre><code class="hljs rust">匹配一个数据类型(types)匹配一个标识符(Id)，作为变量名称匹配初始化部分(varInitializer)，而这会导致下降一层，使用一个新的语法规则：   匹配一个等号   匹配一个表达式(在这个步骤会导致多层下降：exp<span class="hljs-punctuation">-&gt;</span>add<span class="hljs-punctuation">-&gt;</span>mul<span class="hljs-punctuation">-&gt;</span>pri<span class="hljs-punctuation">-&gt;</span>IntLiteral)   创建一个varInitializer对应的AST节点并返回如果没有成功地匹配初始化部分，则回溯，匹配ε，也就是没有初始化部分。匹配一个分号   创建一个varDecl对应的AST节点并返回</code></pre></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/998b747d23e048abac8cdd225ba28461~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><blockquote><p>int a = 2</p></blockquote><ul><li>对于一个非终结符，要从左到右依次匹配其产生式中的每个项，包括非终结符和终结符。</li><li>在匹配产生式右边的非终结符时，要下降一层，继续匹配该非终结符的产生式。</li><li>如果一个语法规则有多个可选的产生式，那么只要有一个产生式匹配成功就行。如果一个产生式匹配不成功，那就回退回来，尝试另一个产生式。这种回退过程，叫做回溯（Backtracking）。</li></ul><h2 id="四、课后作业">四、课后作业</h2><h3 id="4-1-实现一个在线规则引擎">4.1 实现一个在线规则引擎</h3><p>课上我们重点讲了规则引擎的设计和实现，结合前面课程的内容课后实现一个在线版本的规则引擎</p><h4 id="4-1-1-项目要求">4.1.1 项目要求</h4><p>使用Hertz框架开发一个HTTP服务，服务使用mysql，支持表达式的增删查改和编译执行。</p><p>并实现以下接口</p><h5 id="直接表达式执行">直接表达式执行</h5><p>请求参数为待执行的表达式和表达式中参数的值，并输出编译结果</p><p>实时编译并执行结果，不需要写入DB中</p><ul><li><code>POST api/engine/run</code></li><li>Request</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;uid == 12345 &amp;&amp; did &gt; 0&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;params&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123456</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;did&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><ul><li>Response</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;success&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 执行结果</span>        <span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h5 id="新增表达式">新增表达式</h5><p>新增一条表达式到DB中，并返回表达式在DB中的ID</p><p>需要检测表达式 <strong>是否已经存在</strong> ，如果已经存在，直接返回表达式的ID</p><p>需要检测表达式<strong>是否合法(编译是否通过)</strong> ，如果编译失败，返回错误码 <code>20001</code>和编译错误</p><ul><li><code>POST api/engine/exp/new</code></li><li>Request</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;uid == 12345 &amp;&amp; did &gt; 0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-punctuation">&#125;</span></code></pre></div><ul><li>Response</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;success&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 表达式ID</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-comment">// 编译失败时</span><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;compile error: xxxxx&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 编译失败的信息</span>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 表达式ID</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h5 id="查询表达式">查询表达式</h5><p>查询数据库中所有的表达式</p><ul><li><code>GET api/engine/exp/list</code></li><li>Response</li></ul><div class="code-wrapper"><pre><code class="hljs css">&#123;    &quot;<span class="hljs-selector-tag">code</span>&quot;: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,    <span class="hljs-string">&quot;data&quot;</span>: [          &#123;            &quot;id&quot;: <span class="hljs-number">1</span>,            <span class="hljs-string">&quot;exp&quot;</span>: <span class="hljs-string">&quot;uid &gt; 0&quot;</span>        &#125;    ]&#125;</code></pre></div><h5 id="删除表达式">删除表达式</h5><p>根据ID删除表达式，表达式不存在时返回错误码 <code>20002</code> , 和错误信息</p><p>删除成功返回被删除的表达式信息</p><ul><li><code>DELETE api/engine/exp/:id</code></li><li>Response</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">// 删除成功时</span><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;success&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 表达式ID</span>        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;uid &gt; 0&quot;</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-comment">// 删除失败时</span><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;exp id 1 not exist&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//查询失败的信息</span>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><h5 id="执行表达式">执行表达式</h5><p>根据表达式的ID，查询出表达式内容，并编译执行。表达式不存在时返回错误码 <code>20002</code> , 和错误信息</p><ul><li><code>POST api/engine/exp/run</code></li><li>Request</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;exp_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;parmas&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>        <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123456</span><span class="hljs-punctuation">,</span>        <span class="hljs-attr">&quot;did&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div><ul><li>Response</li></ul><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;success&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 执行结果</span>        <span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-comment">// 表达式不存在时</span><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">-1</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;exp id 1 not exist&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">//查询失败的信息</span>    <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824 Distributed Systems-LEC 7 Fault Tolerance-Raft-2</title>
    <link href="/2023/01/28/6.824/Distributed-Systems-MIT-6.824-LEC-7/"/>
    <url>/2023/01/28/6.824/Distributed-Systems-MIT-6.824-LEC-7/</url>
    
    <content type="html"><![CDATA[<p>MIT-6.824（Spring 2022）LEC 7 Fault Tolerance-Raft-2</p><span id="more"></span><h2 id="Raft">Raft</h2><h3 id="Leader选举规则">Leader选举规则</h3><ol><li>获得大多数的投票</li><li>至少是最新的-最后一个term相同就可以给选票</li><li>任期号相同则最长的一个获得Leader</li><li>如果存在最后一个term号比当前发起选举的Candidate大，则Candidate自动放弃选举</li></ol><h3 id="日志追赶">日志追赶</h3><ol><li>Leader发送心跳信号，连带自己的前一个term和前一个日志达到的索引号</li><li>follower查看自己的前一个term，如果小于Leader的term，返回不允许追加的信息，因为自己落后了</li><li>Leader的nextIndex减1，然后与Follower反复迭代，直到找到了两者第一个相同的位置</li><li>然后Leader更新自己与这个Follower的matchIndex。可以认为nextIndex是乐观的，从最后一个开始往前遍历，而matchIndex是悲观的，最开始的时候直接设置为0</li><li>Leader与Follower进行日志同步</li></ol><p>日志擦除可能会带来一些问题，论文中的Figure 8 说明了这个问题，因此需要有日志提交条件的<strong>额外限制</strong>： <strong>Leader 在当前任期至少有一条日志被提交</strong></p><p>前面的协议中一直是减1操作，因此如果Follower落后过多，通信开销会很大</p><p>追赶更快的优化算法：并不按照索引后退，而是按照term后退，然后再扫描相同的位置</p><p>此时Follower并不只是拒绝，而是返回前一个term以及这个term开始的索引</p><h3 id="持久化">持久化</h3><p>重启机器会发生什么？</p><ul><li>看成一台新机器加入，可能会复制大量的日志</li><li>从自己的最后的持久化状态开始追赶</li></ul><p>需要持久化什么信息？我们应该尽量不保存信息，因为需要存入磁盘，开销很大，只需要保留必要的信息</p><ul><li>投票的信息</li><li>日志信息：承诺Leader这些条目都是已经提交过的</li><li>当前的term：term不可以下降，需要监控term上升，获得自己的投票信息</li></ul><h3 id="服务恢复">服务恢复</h3><ul><li>根据全部日志重建状态，一定会获得与之前完全相同的状态，太长了可能开销过大</li><li>周期性进行快照操作，持久化到磁盘上，可以通过快照对日志进行裁剪，开销不会过大</li></ul><p>状态机通过apply channel获得一个快照，然后使用它来进行恢复</p><h3 id="使用Raft">使用Raft</h3><p>步骤：</p><ol><li>客户端发送操作给Leader的K/V服务器</li><li>K/V服务器将操作传递给Raft</li><li>Raft写入日志</li><li>Raft与其他服务器通信传送日志</li><li>其他服务器发送响应给Leader</li><li>Leader提交操作（其他的Followers需要等到下一次交互才确认前面的操作并提交）</li><li>操作按照顺序传送到K/V服务器</li><li>K/V服务器执行操作</li><li>Leader返回操作结果给客户端</li></ol><p>客户端也需要保存Raft的Leader和Follower的信息，可以切换它的通信对象</p><p>客户端如果没有接收到服务器的响应会进行重试，而服务器可鞥已经执行过这些操作了，因此需要对这些重复的操作进行检测。</p><p>一种实现方法：客户端的每一个操作都带有一个id，通过id对重复的操作进行过滤</p><h3 id="正确性">正确性</h3><p>模糊定义：多台机器的行为如同单独的一台机器一样</p><p>精确定义：</p><p>线性一致性：</p><ul><li>有一个整体的顺序，操作按照顺序逐步执行</li><li>实时匹配</li><li>读取操作应该始终返回最后一次写入的值</li></ul><p>查看历史操作，即使是并行的程序是否可以在一台机器上执行相同的结果，从而判断是否满足线性一致性。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Distributed Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简易抖音项目-视频模块</title>
    <link href="/2023/01/24/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Project-Videos/"/>
    <url>/2023/01/24/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Project-Videos/</url>
    
    <content type="html"><![CDATA[<p>简易抖音项目-视频模块</p><span id="more"></span><h1>简易抖音项目-视频模块设计说明</h1><h2 id="需求分析">需求分析</h2><p>视频模块包括包括视频Feed流获取、视频投稿和获取用户投稿列表三个模块</p><h3 id="1-视频流接口-douyin-feed">1. 视频流接口 /douyin/feed/</h3><p>不限制登录状态，返回按投稿时间倒序的视频列表，视频数由服务端控制，单次最多30个。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs proto"><span class="hljs-keyword">service </span><span class="hljs-title class_">Feed</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Feed (douyin_feed_request) <span class="hljs-keyword">returns</span> (douyin_feed_response) </span>&#123;&#125;&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_feed_request</span>&#123;    <span class="hljs-type">int64</span> latest_time = <span class="hljs-number">1</span>; <span class="hljs-comment">// 可选参数，限制返回视频的最新投稿时间戳，精确到秒，不填表示当前时间</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 可选参数，登录用户设置</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_feed_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 视频列表</span>    <span class="hljs-type">int64</span> next_time = <span class="hljs-number">4</span>; <span class="hljs-comment">// 本次返回的视频中，发布最早的时间，作为下次请求时的latest_time</span>&#125;</code></pre></div><h3 id="2-发布列表-douyin-publish-list">2. 发布列表 /douyin/publish/list/</h3><p>登录用户的视频发布列表，直接列出用户所有投稿过的视频。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs proto"><span class="hljs-keyword">service </span><span class="hljs-title class_">PublishList</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">rpc</span> PublishList (douyin_publish_list_request) <span class="hljs-keyword">returns</span> (douyin_publish_list_response) </span>&#123;&#125;&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_publish_list_request</span>&#123;    <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_publish_list_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    <span class="hljs-keyword">repeated</span> Video video_list = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户发布的视频列表</span>&#125;</code></pre></div><h3 id="3-视频投稿-douyin-publish-action">3. 视频投稿 /douyin/publish/action/</h3><p>登录用户选择视频上传。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs proto"><span class="hljs-keyword">service </span><span class="hljs-title class_">PublishAction</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">rpc</span> PublishAction (douyin_publish_action_request) <span class="hljs-keyword">returns</span> (douyin_publish_action_response) </span>&#123;&#125;&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_publish_action_request</span>&#123;    <span class="hljs-type">string</span> token = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户鉴权token</span>    <span class="hljs-type">bytes</span> data = <span class="hljs-number">2</span>; <span class="hljs-comment">// 视频数据</span>    <span class="hljs-type">string</span> title = <span class="hljs-number">3</span>; <span class="hljs-comment">// 视频标题</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_publish_action_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>&#125;</code></pre></div><h2 id="整体架构设计">整体架构设计</h2><p><a href="https://imgse.com/i/pSodXSP"><img src="https://s1.ax1x.com/2023/02/13/pSodXSP.png" alt="pSodXSP.png"></a></p><p>返回的状态码（虽然客户端并没有逻辑进行处理）：</p><ul><li>用户不存在，状态码为2</li><li>应该携带Token但是没有携带，状态码为4</li><li>备份文件夹操作失败，状态码为5</li><li>无法写入视频文件，状态码为6</li><li>无法写入图片文件，状态码为7</li><li>无法上传文件到OSS，状态码为8</li></ul><h2 id="详细设计">详细设计</h2><h3 id="视频流接口">视频流接口</h3><p><a href="https://imgse.com/i/pSowAS0"><img src="https://s1.ax1x.com/2023/02/13/pSowAS0.png" alt="pSowAS0.png"></a></p><ol><li>DY-api.Feed处理请求，准备请求服务</li><li>首先请求DY-srv.Feed服务，根据时间戳查询数据库，查询出不超过时间戳的前30个视频，查询后返回视频列表</li><li>随后并行请求视频列表中的每一个视频（即最大并发数为30）</li><li>对每一个视频，根据前一个服务响应的作者的id并行请求DY-srv.UserInfo、DY-srv.GetFollowList和DY-srv.GetFollowerList，等待全部成功返回后记录Author响应相关的5个字段</li><li>对每一个视频，根据视频id并行请求DY-srv.和DY-srv.，对于每个视频<ol><li>commentCount通过获取DY-srv.返回的切片长度获取</li><li>favoriteCount通过获取DY-srv.返回的切片长度获取</li><li>通过Token获取当前的登录用户id，在DY-srv.切片内部查询，如果查询到为True，否则为False</li></ol></li><li>等待全部的视频返回响应后，构建响应结构体并返回给客户端</li></ol><h3 id="发布列表">发布列表</h3><p><a href="https://imgse.com/i/pSow3Sx"><img src="https://s1.ax1x.com/2023/02/13/pSow3Sx.png" alt="pSow3Sx.png"></a></p><ol><li>DY-api.PublishList处理请求，准备请求服务</li><li>首先请求DY-srv.PublishList服务，根据id查询数据库，如果id在数据库中不存在，则直接返回错误，然后根据用户id查询发布的视频列表并返回</li><li>随后并行请求DY-srv.UserInfo、DY-srv.GetFollowList和DY-srv.GetFollowerList，等待全部成功返回后记录User响应相关的5个字段</li><li>对每一个视频，根据视频id并行请求DY-srv.和DY-srv.，对于每个视频<ol><li>commentCount通过获取DY-srv.返回的切片长度获取</li><li>favoriteCount通过获取DY-srv.返回的切片长度获取</li><li>通过Token获取当前的登录用户id，在DY-srv.切片内部查询，如果查询到为True，否则为False</li></ol></li><li>等待全部的视频返回响应后，构建响应结构体并返回给客户端</li></ol><h3 id="视频投稿">视频投稿</h3><p><a href="https://imgse.com/i/pSsa6xK"><img src="https://s1.ax1x.com/2023/02/03/pSsa6xK.png" alt="pSsa6xK.png"></a></p><ol><li>DY-api.PublishAction处理请求，将请求中的字段传递到服务端DY-srv.PublishAction</li><li>服务端从Token中获取id信息，如果无法获取id，直接返回错误</li><li>服务端根据id信息查询数据库，获取用户信息，如果id并不存在于数据库，则直接返回错误</li><li>服务端判断本地存放视频与图片文件的文件夹是否存在，如果不存在则创建文件夹</li><li>服务端将接收到的请求中的字节流写入文件，并调用ffmpeg对视频的第一帧进行截图作为封面，同样写入图片文件</li><li>服务端将文件上传信息传递给消息队列，直接返回成功响应给客户端</li><li>消息队列接收到消息后并行上传视频和图片文件，两者都上传成功后将视频信息写入数据库</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简易抖音项目-用户模块</title>
    <link href="/2023/01/24/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Project-Users/"/>
    <url>/2023/01/24/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Project-Users/</url>
    
    <content type="html"><![CDATA[<p>简易抖音项目-用户模块</p><span id="more"></span><h1>简易抖音项目-用户模块设计说明</h1><h2 id="需求分析">需求分析</h2><p>用户模块包括用户注册、用户登录和用户信息三个部分。</p><h3 id="1-用户注册接口-douyin-user-register">1. 用户注册接口 /douyin/user/register/</h3><p>新用户注册时提供用户名，密码，昵称即可，用户名需要保证唯一。创建成功后返回用户 id 和权限token.</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs proto"><span class="hljs-keyword">service </span><span class="hljs-title class_">UserRegister</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">rpc</span> UserRegister (douyin_user_register_request) <span class="hljs-keyword">returns</span> (douyin_user_register_response) </span>&#123;&#125;&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_register_request</span>&#123;    <span class="hljs-type">string</span> username = <span class="hljs-number">1</span>; <span class="hljs-comment">// 注册用户名，最长32个字符</span>    <span class="hljs-type">string</span> password = <span class="hljs-number">2</span>; <span class="hljs-comment">// 密码，最长32个字符</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_register_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    <span class="hljs-type">int64</span> user_id = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户id</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">4</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;</code></pre></div><h3 id="2-用户登录接口-douyin-user-login">2. 用户登录接口 /douyin/user/login/</h3><p>通过用户名和密码进行登录，登录成功后返回用户 id 和权限 token</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs proto"><span class="hljs-keyword">service </span><span class="hljs-title class_">UserLogin</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">rpc</span> UserLogin (douyin_user_login_request) <span class="hljs-keyword">returns</span> (douyin_user_login_response) </span>&#123;&#125;&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_login_request</span>&#123;    <span class="hljs-type">string</span> username = <span class="hljs-number">1</span>; <span class="hljs-comment">// 登录用户名</span>    <span class="hljs-type">string</span> password = <span class="hljs-number">2</span>; <span class="hljs-comment">// 登录密码</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_login_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    <span class="hljs-type">int64</span> user_id = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户id</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">4</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;</code></pre></div><h3 id="3-用户信息接口-douyin-user">3. 用户信息接口 /douyin/user/</h3><p>获取登录用户的 id、昵称，如果实现社交部分的功能，还会返回关注数和粉丝数。</p><p>接口定义：</p><div class="code-wrapper"><pre><code class="hljs proto"><span class="hljs-keyword">service </span><span class="hljs-title class_">UserInfo</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">rpc</span> UserInfo (douyin_user_request) <span class="hljs-keyword">returns</span> (douyin_user_response) </span>&#123;&#125;&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_request</span>&#123;    <span class="hljs-type">int64</span> user_id = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用户id</span>    <span class="hljs-type">string</span> token = <span class="hljs-number">2</span>; <span class="hljs-comment">// 用户鉴权token</span>&#125;<span class="hljs-keyword">message </span><span class="hljs-title class_">douyin_user_response</span>&#123;    <span class="hljs-type">int32</span> status_code = <span class="hljs-number">1</span>; <span class="hljs-comment">// 状态码，0-成功，其他值-失败</span>    <span class="hljs-type">string</span> status_msg = <span class="hljs-number">2</span>; <span class="hljs-comment">// 返回状态描述</span>    User user = <span class="hljs-number">3</span>; <span class="hljs-comment">// 用户信息</span>&#125;</code></pre></div><h2 id="整体架构设计">整体架构设计</h2><p><a href="https://imgse.com/i/pSsNise"><img src="https://s1.ax1x.com/2023/02/03/pSsNise.png" alt="pSsNise.png"></a></p><p>返回的状态码（虽然客户端并没有逻辑进行处理）：</p><ul><li>注册时用户已经存在，状态码为1</li><li>用户不存在，状态码为2</li><li>登录时用户存在但是密码错误，状态码为3</li></ul><h2 id="详细设计">详细设计</h2><h3 id="用户注册">用户注册</h3><p><a href="https://imgse.com/i/pSsl600"><img src="https://s1.ax1x.com/2023/02/03/pSsl600.png" alt="pSsl600.png"></a></p><ol><li>DY-api.UserRegister处理请求，将请求中带有的用户名和密码字段传递到服务端DY-srv.UserRegister</li><li>服务端根据用户名查询数据库，如果发现重名用户名，则直接返回错误</li><li>未发现重名用户名，则通过md5加盐（用户名）对密码进行加密，加密后插入数据库，数据库返回唯一自增ID</li><li>服务端返回成功响应给DY-api.UserRegister</li><li>DY-api.UserRegister利用响应中的ID信息，调用jwt进行Token生成，生成后构建客户端相应结构体给客户端</li></ol><h3 id="用户登录">用户登录</h3><p><a href="https://imgse.com/i/pSs80pD"><img src="https://s1.ax1x.com/2023/02/03/pSs80pD.png" alt="pSs80pD.png"></a></p><ol><li>DY-api.UserLogin处理请求，将请求中带有的用户名和密码字段传递到服务端DY-srv.UserLogin</li><li>服务端根据用户名查询数据库，如果未发现相同用户名，则直接返回错误，否则返回通过用户名查询出来的用户id和密码</li><li>对用户输入的密码进行md5加盐（用户名）加密，与上一步返回的密码进行比较，如果不匹配直接返回错误</li><li>密码匹配，则服务端返回成功响应给DY-api.UserLogin</li><li>DY-api.UserLogin利用响应中的ID信息，调用jwt进行Token生成，生成后构建客户端相应结构体给客户端</li></ol><h3 id="用户信息">用户信息</h3><p><a href="https://imgse.com/i/pSst2rQ"><img src="https://s1.ax1x.com/2023/02/03/pSst2rQ.png" alt="pSst2rQ.png"></a></p><ol><li>DY-api.UserInfo处理请求，将请求中带有的id字段传递到服务端DY-srv.UserInfo、DY-srv.GetFollowList和DY-srv.GetFollowerList</li><li>并行请求三个服务，其中DY-srv.UserInfo根据id字段查询数据库，如果id有效，则返回用户姓名，否则返回错误</li><li>等待三个服务全部成功返回后，填充响应中的User的五个字段<ol><li>id与name字段通过DY-srv.UserInfo的响应直接获取</li><li>followcount通过获取DY-srv.GetFollowList返回的切片长度获取</li><li>followercount通过获取DY-srv.GetFollowerList返回的切片长度获取</li><li>通过Token获取当前的登录用户id，在DY-srv.GetFollowerList切片内部查询，如果查询到为True，否则为False</li></ol></li><li>构建响应结构体并返回给客户端</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言内存管理详解</title>
    <link href="/2023/01/20/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day05/"/>
    <url>/2023/01/20/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day05/</url>
    
    <content type="html"><![CDATA[<p>Go 语言内存管理详解</p><span id="more"></span><h1>Go 语言内存管理详解</h1><p>本节课程主要分为四个方面：</p><ol><li>自动内存管理</li><li>Go 内存管理及优化</li><li>编译器和静态分析</li><li>Go 编译器优化</li></ol><p>课前部分主要罗列课程中涉及到的概念。对于不熟悉的概念，同学们可以提前查询预习；课中部分主要罗列每一部分的关键思路，帮助同学们跟上课程的进度；课后部分是一些问题，帮助同学们在课后梳理本课程的重点。</p><h1>课前</h1><h2 id="自动内存管理">自动内存管理</h2><ul><li><p>Auto memory management: 自动内存管理</p></li><li><p>Grabage collction: 垃圾回收</p></li><li><p>Mutator: 业务线程</p></li><li><p>Collector: GC 线程</p></li><li><p>Concurrent GC: 并发 GC</p></li><li><p>Parallel GC: 并行 GC</p></li><li><p>Tracing garbage collection: 追踪垃圾回收</p><ul><li>Copying GC: 复制对象 GC</li><li>Mark-sweep GC: 标记-清理 GC</li><li>Mark-compact GC: 标记-压缩 GC</li></ul></li><li><p>Reference counting: 引用计数</p></li><li><p>Generational GC: 分代 GC</p><ul><li>Young generation: 年轻代</li><li>Old generation: 老年代</li></ul></li></ul><h2 id="Go-内存管理及优化">Go 内存管理及优化</h2><ul><li>TCMalloc</li><li><code>mmap()</code> 系统调用</li><li>scan object 和 noscan object</li><li>mspan, mcache, mentral</li><li>Bump-pointer object allocation: 指针碰撞风格的对象分配</li></ul><h2 id="编译器和静态分析">编译器和静态分析</h2><ul><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>Intermediate representation (IR) 中间表示</li><li>代码优化</li><li>代码生成</li><li>Control flow: 控制流</li><li>Data flow: 数据流</li><li>Intra-procedural analysis 过程内分析</li><li>Inter-procedural analysis: 过程间分析</li></ul><h2 id="Go-编译器优化">Go 编译器优化</h2><ul><li>Function inlining: 函数内联</li><li>Escape analysis: 逃逸分析</li></ul><h1>课中</h1><ul><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7142749780140097550">https://juejin.cn/course/bytetech/7140987981803814919/section/7142749780140097550</a></li><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7142746789945278500">https://juejin.cn/course/bytetech/7140987981803814919/section/7142746789945278500</a></li></ul><h2 id="引言">引言</h2><ul><li><p>什么是性能优化？</p><ul><li><strong>提升软件系统处理能力</strong> ， <strong>减少不必要的消耗</strong> ，充分发掘计算机算力</li></ul></li><li><p>为什么要做性能优化？</p><ul><li>用户体验：<strong>带来用户体验的提升</strong> —— 让刷抖音更丝滑，让双十一购物不再卡顿</li><li>资源高效利用：<strong>降低成本，提高效率</strong> —— 很小的优化乘以海量机器会是显著的性能提升和成本节约</li></ul></li><li><p>性能优化</p><ul><li>业务层优化<ul><li>针对特定场景，具体问题，具体分析</li><li>容易获得较大性能收益</li></ul></li><li>语言运行时优化<ul><li>解决更通用的性能问题</li><li>考虑更多场景</li><li>Tradeoffs</li></ul></li><li>数据驱动<ul><li>自动化性能分析工具 —— pprof</li><li>依靠数据而非猜测</li><li>首先优化最大瓶颈</li></ul></li></ul></li><li><p>软件质量</p><ul><li><strong>保证接口稳定的前提下改进实现</strong></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c0cd4519f49412093a6c01aa176242f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p></li><li><p>测试驱动</p></li><li><p>通过清晰的文档告诉用户这一项优化 <strong>做了什么</strong> ， <strong>没做什么</strong> ，<strong>能达到怎样的效果</strong></p></li><li><p>隔离，优化代码用选项和原先的路径隔离，保证优化未启用时的行为同以前一致</p></li><li><p>可观测、可灰度、可回滚</p></li></ul><h2 id="自动内存管理-2">自动内存管理</h2><h3 id="基本概念">基本概念</h3><ul><li><p>自动内存管理：由程序语言的运行时系统管理动态内存</p></li><li><p>避免手动内存管理，专注于实现业务逻辑</p></li><li><p>保证内存使用的<strong>正确性</strong>和 <strong>安全性</strong> : double-free problem, use-after-free problem</p></li><li><p>三个任务</p><ul><li>为新对象分配空间</li><li>找到存活对象</li><li>回收死亡对象的内存空间</li></ul></li><li><p>概念<br>Mutator: 业务线程，分配新对象，修改对象指向关系<br>Collector: GC 线程，找到存活对象，回收死亡对象的内存空间</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f559f53d773c4d17b0818b5c8651eab4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>Serial GC: 只有一个 collector</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40e0af197ac4482792910e4fa2d0587a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>Parallel GC: 并行 GC，支持多个 collectors 同时回收的 GC 算法</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bc39c15985447adb70edf3e8651a34a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>Concurrent GC: 并发 GC，支持 mutator(s) 和 collector(s) <strong>同时执行</strong>的 GC 算法</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54decbf62ce4415e8b20736fa07162d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p><strong>Collectors 必须感知对象指向关系的改变！</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e29f0298f37a4003a941d077741dd10e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="追踪垃圾回收">追踪垃圾回收</h3><ul><li>Tracing garbage collection: 追踪垃圾回收<ul><li>被回收的条件：不可达对象</li><li>过程<ul><li>标记根对象 (GC roots): 静态变量、全局变量、常量、线程栈等</li><li>标记：找到所有可达对象</li><li>清理：回收所有不可达对象占据的内存空间<ul><li>Copying GC: 将存活对象从一块内存空间复制到另外一块内存空间，原先的空间可以直接进行对象分配</li><li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84cc77d72bcc4172a3d17d051a570a94~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></li><li>Mark-sweep GC: 将死亡对象所在内存块标记为可分配，使用 free list 管理可分配的空间</li><li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/292a8af3697e4252b1dac783e84b24c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></li><li>Mark-compact GC: 将存活对象复制到同一块内存区域的开头</li><li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f497303e69ba4bf690758bc3fcad1aed~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></li></ul></li></ul></li></ul></li></ul><h3 id="引用计数">引用计数</h3><ul><li><p>每个对象都有一个与之关联的引用数目</p></li><li><p>对象存活的条件：当且仅当引用数大于 0</p></li><li><p>优点</p><ul><li>内存管理的操作被 <strong>平摊到程序运行中</strong> ：指针传递的过程中进行引用计数的增减</li><li>不需要了解 runtime 的细节：因为不需要标记 GC roots，因此不需要知道哪里是全局变量、线程栈等</li></ul></li><li><p>缺点</p><ul><li>开销大，因为对象可能会被多线程访问，对引用计数的修改需要<strong>原子****操作</strong>保证原子性和可见性</li><li>无法回收环形数据结构</li><li>每个对象都引入额外存储空间存储引用计数</li><li>虽然引用计数的操作被平摊到程序运行过程中，但是回收大的数据结构依然可能引发暂停</li></ul></li><li><p><strong>说明</strong></p><ul><li>以上我们所讲述的技术的缺点并非是无法解决的问题。学术界和工业界在一直在致力于解决自动内存管理技术的不足之处。例如，最新的 PLDI’22 的文章 <a href="https://link.juejin.cn?target=https%3A%2F%2Fusers.cecs.anu.edu.au%2F~steveb%2Fpubs%2Fpapers%2Flxr-pldi-2022.pdf" title="https://link.juejin.cn?target=https%3A%2F%2Fusers.cecs.anu.edu.au%2F~steveb%2Fpubs%2Fpapers%2Flxr-pldi-2022.pdf">Low-Latency, High-Throughput Garbage Collection </a>感兴趣的同学可以阅读。</li></ul></li></ul><h2 id="Go-内存管理及优化-2">Go 内存管理及优化</h2><h3 id="Go-内存管理">Go 内存管理</h3><ul><li><p>TCMalloc: TC is short for thread caching</p></li><li><p>目标：为对象在 heap 上分配内存</p></li><li><p>提前将<strong>内存分块</strong></p><ul><li>调用系统调用 mmap() 向 OS 申请一大块内存，例如 4 MB</li><li>先将内存划分成大块，例如 8 KB，称作 mspan</li><li>再将大块继续划分成<strong>特定大小</strong>的小块，用于对象分配</li><li>noscan mspan: 分配不包含指针的对象 —— GC 不需要扫描</li><li>scan mspan: 分配包含指针的对象 —— GC 需要扫描</li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de5857a08c3c49de8e887f9a8e6895a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li><p>对象分配：根据对象的大小，选择最合适的块返回</p></li><li><p><strong>内存缓存</strong></p><ul><li>Go 内存管理构成了多级缓存机制，从 OS 分配得的内存被内存管理回收后，也不会立刻归还给 OS，而是在 Go runtime 内部先缓存起来，从而避免频繁向 OS 申请内存。内存分配的路线图如下。</li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97ea16a0b28460a8a64ec28384e8425~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="Go-内存管理的问题">Go 内存管理的问题</h3><p>mspan, mcache 和 mcentral 构成了内存管理的多级缓存机制。</p><ul><li>对象分配是<strong>非常高频</strong>的操作：每秒分配 GB 级别的内存</li><li>线上 profiling 发现，Go 的内存分配占用很多 CPU</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/348e7f5a306246ab9efde577769f59b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>可以看到，用于分配对象的函数 <code>mallocgc()</code> 占用 CPU 较高</p><ul><li>小对象分配占大多数</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d1b1aa4e544cc0b3f5fa2ec53f3794~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>横轴是对象大小，纵轴是数目，可以看到绝大多数对象都小于 80 B。因此 <strong>优化小对象分配是关键</strong> 。</p><h3 id="字节跳动的优化方案">字节跳动的优化方案</h3><ul><li><strong>Balanced GC</strong></li><li>核心：将 noscan 对象在 per-g allocation buffer (GAB) 上分配，并使用移动对象 GC 管理这部分内存，提高对象分配和回收效率</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2430d70a8e642b593f9de816e1359d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>每个 g 会附加一个较大的 allocation buffer (例如 1 KB) 用来分配小于 128 B 的 noscan 小对象</li><li>bump pointer 风格的对象分配。示意如下。</li></ul><div class="code-wrapper"><pre><code class="hljs arduino"><span class="hljs-keyword">if</span> g.ab.end - g.ab.top &lt; size &#123;    <span class="hljs-comment">// Allocate a new allocation buffer</span>&#125;addr := g.ab.topg.ab.top += size<span class="hljs-keyword">return</span> addr</code></pre></div><ul><li>分配对象时，根据对象大小移动 <code>top</code> 指针并返回，快速完成一次对象分配</li><li>同原先调用 <code>mallocgc()</code> 进行对象分配的方式相比，balanced GC 缩短了对象分配的路径，减少了对象分配执行的指令数目，降低 CPU 使用</li></ul><p>从 Go runtime 内存管理模块的角度看，一个 allocation buffer 其实是一个大对象。本质上 balanced GC 是 <strong>将多次小对象的分配合并成一次大对象的分配</strong> 。因此，当 GAB 中哪怕只有一个小对象存活时，Go runtime 也会认为整个大对象（即 GAB）存活。为此，balanced GC 会根据 GC 策略， <strong>将 GAB 中存活的对象移动到另外的 GAB 中</strong> ，从而压缩并清理 GAB 的内存空间，原先的 GAB 空间由于不再有存活对象，可以全部释放，如下图所示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5047892408624904bcf3d81bc1ad3481~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>上图上方是两个 GAB，其中虚线表示 GAB 中对象的分界线。黑色表示 GAB 中存活的对象，白色表示死掉的对象。由于 GAB 中有存活对象，整个 GAB 无法被回收。</p><p>Balanced GC 会将 GAB 中存活的对象移动到下面的 GAB 中，这样原先的两个 GABs 就可以被释放，压缩并清理 GAB 的内存空间。</p><p>Balanced GC 只负责 noscan 对象的分配和移动，对象的标记和回收依然依赖 Go GC 本身，并和 Go GC 保持兼容。</p><h2 id="编译器和静态分析-2">编译器和静态分析</h2><ul><li>编译器的结构</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/785239f8cf584b32971639d0e4342c1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>静态分析： <strong>不执行代码</strong> ，推导程序的行为，分析程序的性质。</li><li>控制流：程序的执行流程</li><li>数据流：数据在控制流上的传递</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ed11d5bf31043deb1276800178a14c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>上图的程序转换成控制流图 (control-flow graph)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abe10aadf22041fe91169eaa671d5fdb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>通过分析控制流和数据流，我们可以知道<strong>更多关于程序的性质(properties)</strong> ，这些事实可以帮助我们做编译优化。<ul><li>例如上面的程序。我们通过分析数据流和控制流，知道这个程序始终返回 4。编译器可以根据这个结果做出优化。</li></ul></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7edffee4a9a8480d89a65ca829f310cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><ul><li>Intra-procedural analysis: 函数内分析：在函数内进行控制流和数据流的分析</li><li>Inter-procedural analysis: 函数间分析：除了函数内的分析，还需要考虑跨函数的数据流和控制流，例如参数传递，函数返回值等</li></ul><h2 id="Go-编译器优化-2">Go 编译器优化</h2><h3 id="目的">目的</h3><ul><li>用户无感知，重新编译即可获得性能收益</li><li>通用的优化手段</li></ul><h3 id="现状">现状</h3><ul><li>采用的优化较少</li><li>追求编译时间短，因此没有进行复杂的代码分析和优化</li></ul><h3 id="思路">思路</h3><ul><li>面向后端长期执行的任务</li><li>用适当增加编译时间换取更高性能的代码</li></ul><h3 id="函数内联">函数内联</h3><ul><li><p>定义：将被调用函数的函数体的副本替换到调用位置上，同时重写代码以反映参数的绑定</p></li><li><p>优点</p><ul><li>消除调用开销</li><li>将过程间分析的问题转换为过程内分析，帮助其他分析</li></ul></li><li><p>缺点</p><ul><li>函数体变大</li><li>编译生成的 Go 镜像文件变大</li></ul></li><li><p>函数内联在大多数情况下是正向优化，即多内联，会提升性能</p></li><li><p>采取一定的策略决定是否内联</p><ul><li>调用和被调用函数的规模</li></ul></li><li><p>Go 内联的限制</p><ul><li>语言特性：interface, defer 等等，限制了内联优化</li><li>内联策略非常保守</li></ul></li><li><p>字节跳动的优化方案</p><ul><li>修改了内联策略，让更多函数被内联</li><li>增加了其他优化的机会：逃逸分析</li></ul></li><li><p>开销</p><ul><li>Go 镜像大小略有增加</li><li>编译时间增加</li><li>运行时栈扩展开销增加</li></ul></li></ul><h3 id="逃逸分析">逃逸分析</h3><ul><li><p>定义：分析代码中指针的动态作用域，即指针在何处可以被访问</p></li><li><p>大致思路</p><ul><li>从对象分配处出发，沿着控制流，观察数据流。若发现指针 p 在当前作用域 s:<ul><li>作为参数传递给其他函数；</li><li>传递给全局变量；</li><li>传递给其他的 goroutine;</li><li>传递给已逃逸的指针指向的对象；</li></ul></li><li>则指针 p 逃逸出 s，反之则没有逃逸出 s.</li></ul></li><li><p><strong>优化：未逃逸出当前函数的指针指向的对象可以在栈上分配</strong></p><ul><li>对象在栈上分配和回收很快：移动 sp 即可完成内存的分配和回收；</li><li>减少在堆上分配对象，降低 GC 负担。</li></ul></li></ul><h1>课后</h1><ol><li>从业务层和语言运行时层进行优化分别有什么特点？</li><li>从软件工程的角度出发，为了保证语言 SDK 的可维护性和可拓展性，在进行运行时优化时需要注意什么？</li><li>自动内存管理技术从大类上分为哪两种，每一种技术的特点以及优缺点有哪些？</li><li>什么是分代假说？分代 GC 的初衷是为了解决什么样的问题？</li><li>Go 是如何管理和组织内存的？</li><li>为什么采用 bump-pointer 的方式分配内存会很快？</li><li>为什么我们需要在编译器优化中进行静态代码分析？</li><li>函数内联是什么，这项优化的优缺点是什么？</li><li>什么是逃逸分析？逃逸分析是如何提升代码性能的？</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 高质量编程与性能调优</title>
    <link href="/2023/01/19/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day04/"/>
    <url>/2023/01/19/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day04/</url>
    
    <content type="html"><![CDATA[<p>Go 高质量编程与性能调优</p><span id="more"></span><h1>Go 高质量编程与性能调优</h1><h2 id="课程概述">课程概述</h2><ul><li>介绍编码规范，帮助大家写出高质量程序</li><li>介绍 Go 语言的性能优化建议，分析对比不同方式对性能的影响和背后的原理</li><li>讲解常用性能分析工具 pprof 的使用和工作原理，熟悉排查程序性能问题的基本流程</li><li>分析性能调优实际案例，介绍实际性能调优时的工作内容</li></ul><h2 id="课前">课前</h2><ul><li>课程内容概要</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/551a67231c244f4aad77cbaabc10e2cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png"></p><h3 id="实践准备-必须">实践准备 (必须)</h3><ul><li>克隆 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwolfogre%2Fgo-pprof-practice" title="https://github.com/wolfogre/go-pprof-practice">github.com/wolfogre/go…</a> 到本地，保证能够编译运行</li><li>尝试使用 test 命令，编写并运行简单测试 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.dev%2Fdoc%2Ftutorial%2Fadd-a-test" title="https://go.dev/doc/tutorial/add-a-test">go.dev/doc/tutoria…</a></li><li>尝试使用 -bench 参数，对编写的函数进行性能测试，<a href="https://link.juejin.cn?target=https%3A%2F%2Fpkg.go.dev%2Ftesting%23hdr-Benchmarks" title="https://pkg.go.dev/testing#hdr-Benchmarks">pkg.go.dev/testing#hdr…</a></li></ul><h3 id="推荐阅读">推荐阅读</h3><ul><li>Go 代码 Review 建议<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fwiki%2FCodeReviewComments" title="https://github.com/golang/go/wiki/CodeReviewComments">github.com/golang/go/w…</a></li><li>Uber 的 Go 编码规范，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fuber-go%2Fguide" title="https://github.com/uber-go/guide">github.com/uber-go/gui…</a></li></ul><h2 id="课程笔记">课程笔记</h2><ul><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7142746789941084197">https://juejin.cn/course/bytetech/7140987981803814919/section/7142746789941084197</a></li><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7142746472319025182">https://juejin.cn/course/bytetech/7140987981803814919/section/7142746472319025182</a></li><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7142747721789603848">https://juejin.cn/course/bytetech/7140987981803814919/section/7142747721789603848</a></li><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7142747721793798158">https://juejin.cn/course/bytetech/7140987981803814919/section/7142747721793798158</a></li></ul><h3 id="高质量编程">高质量编程</h3><h4 id="简介">简介</h4><ul><li>编写的代码能够达到正确可靠、简洁清晰、无性能隐患的目标就能称之为高质量代码</li><li>实际应用场景千变万化，各种语言的特性和语法各不相同，但是高质量编程遵循的原则是相通的</li><li>高质量的编程需要注意以下原则：简单性、可读性、生产力</li></ul><h4 id="常见编码规范">常见编码规范</h4><h5 id="代码格式">代码格式</h5><ul><li>使用 gofmt 自动格式化代码，保证所有的 Go 代码与官方推荐格式保持一致</li></ul><p><strong>总结</strong></p><ul><li>提升可读性，风格一致的代码更容易维护、需要更少的学习成本、团队合作成本，同时可以降低 Review 成本</li></ul><h5 id="注释">注释</h5><ul><li><p>注释应该解释代码作用</p><ul><li>适合注释公共符号，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fos%2Ffile.go%23L313" title="https://github.com/golang/go/blob/master/src/os/file.go#L313">github.com/golang/go/b…</a></li></ul></li><li><p>注释应该解释代码如何做的</p><ul><li>适合注释方法，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fnet%2Fhttp%2Fclient.go%23L678" title="https://github.com/golang/go/blob/master/src/net/http/client.go#L678">github.com/golang/go/b…</a></li></ul></li><li><p>注释应该解释代码实现的原因</p><ul><li>解释代码的外部因素，<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fnet%2Fhttp%2Fclient.go%23L521" title="https://github.com/golang/go/blob/master/src/net/http/client.go#L521">github.com/golang/go/b…</a></li></ul></li><li><p>注释应该解释代码什么情况会出错</p></li><li><p>公共符号始终要注释</p><ul><li>包中声明的每个公共的符号：变量、常量、函数以及结构都需要添加注释</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fio%2Fio.go%23L638" title="https://github.com/golang/go/blob/master/src/io/io.go#L638">github.com/golang/go/b…</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fio%2Fio.go%23L455" title="https://github.com/golang/go/blob/master/src/io/io.go#L455">github.com/golang/go/b…</a></li></ul></li></ul><p><strong>总结</strong></p><ul><li>代码是最好的注释</li><li>注释应该提供代码未表达出的上下文信息</li></ul><h5 id="命名规范">命名规范</h5><ul><li><p>variable</p><ul><li>简洁胜于冗长</li><li>缩略词全大写，但当其位于变量开头且不需要导出时，使用全小写</li><li>变量距离其被使用的地方越远，则需要携带越多的上下文信息</li><li>全局变量在其名字中需要更多的上下文信息，使得在不同地方可以轻易辨认出其含义</li></ul></li><li><p>function</p><ul><li>函数名不携带包名的上下文信息，因为包名和函数名总是成对出现的</li><li>函数名尽量简短</li><li>当名为 foo 的包某个函数返回类型 Foo 时，可以省略类型信息而不导致歧义</li><li>当名为 foo 的包某个函数返回类型 T 时（T 并不是 Foo），可以在函数名中加入类型信息</li></ul></li><li><p>package</p><ul><li>只由小写字母组成。不包含大写字母和下划线等字符</li><li>简短并包含一定的上下文信息。例如 schema、task 等</li><li>不要与标准库同名。例如不要使用 sync 或者 strings</li></ul></li></ul><p><strong>总结</strong></p><ul><li>关于命名的大多数规范核心在于考虑上下文</li><li>人们在阅读理解代码的时候也可以看成是计算机运行程序，好的命名能让人把关注点留在主流程上，清晰地理解程序的功能，避免频繁切换到分支细节，增加理解成本</li></ul><h5 id="控制流程">控制流程</h5><ul><li><p>避免嵌套，保持正常流程清晰</p></li><li><p>如果两个分支中都包含 return 语句，则可以去除冗余的 else</p></li><li><p>尽量保持正常代码路径为最小缩进，优先处理错误情况/特殊情况，并尽早返回或继续循环来减少嵌套，增加可读性</p><ul><li>Go 公共库的代码</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fbufio%2Fbufio.go%23L277" title="https://github.com/golang/go/blob/master/src/bufio/bufio.go#L277">github.com/golang/go/b…</a></li></ul></li></ul><p><strong>总结</strong></p><ul><li>线性原理，处理逻辑尽量走直线，避免复杂的嵌套分支</li><li>提高代码的可读性</li></ul><h5 id="错误和异常处理">错误和异常处理</h5><ul><li><p>简单错误处理</p><ul><li>优先使用 errors.New 来创建匿名变量来直接表示该错误。有格式化需求时使用 fmt.Errorf</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fnet%2Fhttp%2Fclient.go%23L802" title="https://github.com/golang/go/blob/master/src/net/http/client.go#L802">github.com/golang/go/b…</a></li></ul></li><li><p>错误的 Wrap 和 Unwrap</p><ul><li>在 fmt.Errorf 中使用 %w 关键字来将一个错误 wrap 至其错误链中</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go%23L983" title="https://github.com/golang/go/blob/master/src/cmd/go/internal/work/exec.go#L983">github.com/golang/go/b…</a></li><li>Go1.13 在 errors 中新增了三个新 API 和一个新的 format 关键字，分别是 <a href="http://errors.Is">errors.Is</a>、<a href="http://errors.As">errors.As</a> 、errors.Unwrap 以及 fmt.Errorf 的 %w。如果项目运行在小于 Go1.13 的版本中，导入 <a href="http://golang.org/x/xerrors">golang.org/x/xerrors</a> 来使用。以下语法均已 Go1.13 作为标准。</li></ul></li><li><p>错误判定</p><ul><li>使用 <a href="http://errors.Is">errors.Is</a> 可以判定错误链上的所有错误是否含有特定的错误。</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go%23L208" title="https://github.com/golang/go/blob/master/src/cmd/go/internal/modfetch/sumdb.go#L208">github.com/golang/go/b…</a></li><li>在错误链上获取特定种类的错误，使用 <a href="http://errors.As">errors.As</a></li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Ferrors%2Fwrap_test.go%23L255" title="https://github.com/golang/go/blob/master/src/errors/wrap_test.go#L255">github.com/golang/go/b…</a></li></ul></li><li><p>panic</p><ul><li>不建议在业务代码中使用 panic</li><li>如果当前 goroutine 中所有 deferred 函数都不包含 recover 就会造成整个程序崩溃</li><li>当程序启动阶段发生不可逆转的错误时，可以在 init 或 main 函数中使用 panic</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FShopify%2Fsarama%2Fblob%2Fmain%2Fexamples%2Fconsumergroup%2Fmain.go%23L94" title="https://github.com/Shopify/sarama/blob/main/examples/consumergroup/main.go#L94">github.com/Shopify/sar…</a></li></ul></li><li><p>recover</p><ul><li>recover 只能在被 defer 的函数中使用，嵌套无法生效，只在当前 goroutine 生效</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Fblob%2Fmaster%2Fsrc%2Ffmt%2Fscan.go%23L247" title="https://github.com/golang/go/blob/master/src/fmt/scan.go#L247">github.com/golang/go/b…</a></li><li>如果需要更多的上下文信息，可以 recover 后在 log 中记录当前的调用栈。</li><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fwebsite%2Fblob%2Fmaster%2Finternal%2Fgitfs%2Ffs.go%23L228" title="https://github.com/golang/website/blob/master/internal/gitfs/fs.go#L228">github.com/golang/webs…</a></li></ul></li></ul><p><strong>总结</strong></p><ul><li>panic 用于真正异常的情况</li><li>error 尽可能提供简明的上下文信息，方便定位问题</li><li>recover 生效范围，在当前 goroutine 的被 defer 的函数中生效</li></ul><h4 id="性能优化建议">性能优化建议</h4><ul><li><p>在满足正确性、可靠性、健壮性、可读性等质量因素的前提下，设法提高程序的效率</p></li><li><p>性能对比测试代码，可参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FRaymondCode%2Fgo-practice" title="https://github.com/RaymondCode/go-practice">github.com/RaymondCode…</a></p></li><li><h5 id="slice-预分配内存">slice 预分配内存</h5><ul><li>在尽可能的情况下，在使用 make() 初始化切片时提供容量信息，特别是在追加切片时</li><li>原理<ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fueokande.github.io%2Fgo-slice-tricks%2F" title="https://ueokande.github.io/go-slice-tricks/">ueokande.github.io/go-slice-tr…</a></li><li>切片本质是一个数组片段的描述，包括了数组的指针，这个片段的长度和容量(不改变内存分配情况下的最大长度)</li><li>切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的</li><li>切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景：<ul><li>当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间</li><li>当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组</li></ul></li><li>因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能</li></ul></li><li>另一个陷阱：大内存得不到释放<ul><li>在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组</li><li>因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放</li><li>推荐的做法，使用 copy 替代 re-slice</li></ul></li></ul></li><li><h5 id="map-预分配内存">map 预分配内存</h5><ul><li>原理<ul><li>不断向 map 中添加元素的操作会触发 map 的扩容</li><li>根据实际需求提前预估好需要的空间</li><li>提前分配好空间可以减少内存拷贝和 Rehash 的消耗</li></ul></li></ul></li><li><h5 id="使用-strings-Builder">使用 strings.Builder</h5><ul><li>常见的字符串拼接方式<br>*<ul><li>strings.Builder</li><li>bytes.Buffer</li></ul></li><li>strings.Builder 最快，bytes.Buffer 较快，+ 最慢</li><li>原理<ul><li>字符串在 Go 语言中是不可变类型，占用内存大小是固定的，当使用 + 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和</li><li>strings.Builder，bytes.Buffer 的内存是以倍数申请的</li><li>strings.Builder 和 bytes.Buffer 底层都是 []byte 数组，bytes.Buffer 转化为字符串时重新申请了一块空间，存放生成的字符串变量，而 strings.Builder 直接将底层的 []byte 转换成了字符串类型返回</li></ul></li></ul></li><li><h5 id="使用空结构体节省内存">使用空结构体节省内存</h5><ul><li>空结构体不占据内存空间，可作为占位符使用</li><li>比如实现简单的 Set<ul><li>Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。对于集合场景，只需要用到 map 的键而不需要值</li></ul></li></ul></li><li><h5 id="使用-atomic-包">使用 atomic 包</h5><ul><li>原理<ul><li>锁的实现是通过操作系统来实现，属于系统调用，atomic 操作是通过硬件实现的，效率比锁高很多</li><li>sync.Mutex 应该用来保护一段逻辑，不仅仅用于保护一个变量</li><li>对于非数值系列，可以使用 atomic.Value，atomic.Value 能承载一个 interface{}</li></ul></li></ul></li></ul><h5 id="总结">总结</h5><ul><li>避免常见的性能陷阱可以保证大部分程序的性能</li><li>针对普通应用代码，不要一味地追求程序的性能，应当在满足正确可靠、简洁清晰等质量要求的前提下提高程序性能</li></ul><h3 id="性能调优实战">性能调优实战</h3><h4 id="性能调优简介">性能调优简介</h4><ul><li>性能调优原则<ul><li>要依靠数据不是猜测</li><li>要定位最大瓶颈而不是细枝末节</li><li>不要过早优化</li><li>不要过度优化</li></ul></li></ul><h4 id="性能分析工具">性能分析工具</h4><p>性能调优的核心是性能瓶颈的分析，对于 Go 应用程序，最方便的就是 pprof 工具</p><ul><li><h5 id="pprof-功能说明">pprof 功能说明</h5><ul><li>pprof 是用于可视化和分析性能分析数据的工具</li><li>可以知道应用在什么地方耗费了多少 CPU、memory 等运行指标<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b91cd175657042f5ab0430cbc8784172~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></li></ul></li><li><h4 id="pprof-实践">pprof 实践</h4><ul><li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwolfogre%2Fgo-pprof-practice" title="https://github.com/wolfogre/go-pprof-practice">github.com/wolfogre/go…</a></li><li>前置准备，熟悉简单指标，能够编译运行 pprof 测试项目</li><li>实际分析排查过程<ul><li>排查 CPU 问题<ul><li>命令行分析<ul><li>go tool pprof “<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fprofile%3Fseconds%3D10" title="http://localhost:6060/debug/pprof/profile?seconds=10">http://localhost:6060/debug/pprof/profile?seconds=10</a>”</li></ul></li><li>top 命令</li><li>list 命令</li><li>熟悉 web 页面分析</li><li>调用关系图，火焰图</li><li>go tool pprof -http=:8080 “<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fcpu" title="http://localhost:6060/debug/pprof/cpu">http://localhost:6060/debug/pprof/cpu</a>”</li></ul></li><li>排查堆内存问题<ul><li>go tool pprof -http=:8080 “<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fheap" title="http://localhost:6060/debug/pprof/heap">http://localhost:6060/debug/pprof/heap</a>”</li></ul></li><li>排查协程问题<ul><li>go tool pprof -http=:8080 “<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fgoroutine" title="http://localhost:6060/debug/pprof/goroutine">http://localhost:6060/debug/pprof/goroutine</a>”</li></ul></li><li>排查锁问题<ul><li>go tool pprof -http=:8080 “<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fmutex" title="http://localhost:6060/debug/pprof/mutex">http://localhost:6060/debug/pprof/mutex</a>”</li></ul></li><li>排查阻塞问题<ul><li>go tool pprof -http=:8080 “<a href="https://link.juejin.cn?target=http%3A%2F%2Flocalhost%3A6060%2Fdebug%2Fpprof%2Fblock" title="http://localhost:6060/debug/pprof/block">http://localhost:6060/debug/pprof/block</a>”</li></ul></li></ul></li></ul></li><li><h5 id="pprof-的采样过程和原理">pprof 的采样过程和原理</h5><ul><li>CPU 采样</li><li>堆内存采样</li><li>协程和系统线程采样</li><li>阻塞操作和锁竞争采样</li></ul></li></ul><h4 id="性能调优案例">性能调优案例</h4><ul><li><h5 id="基本概念">基本概念</h5><ul><li>服务：能单独部署，承载一定功能的程序</li><li>依赖：Service A 的功能实现依赖 Service B 的响应结果，称为 Service A 依赖 Service B</li><li>调用链路：能支持一个接口请求的相关服务集合及其相互之间的依赖关系</li><li>基础库：公共的工具包、中间件</li></ul></li><li><h5 id="业务优化">业务优化</h5><ul><li>流程<ul><li>建立服务性能评估手段</li><li>分析性能数据，定位性能瓶颈</li><li>重点优化项改造</li><li>优化效果验证</li></ul></li><li>建立压测评估链路<ul><li>服务性能评估</li><li>构造请求流量</li><li>压测范围</li><li>性能数据采集</li></ul></li><li>分析性能火焰图，定位性能瓶颈<ul><li>pprof 火焰图</li></ul></li><li>重点优化项分析<ul><li>规范组件库使用</li><li>高并发场景优化</li><li>增加代码检查规则避免增量劣化出现</li><li>优化正确性验证</li></ul></li><li>上线验证评估<ul><li>逐步放量，避免出现问题</li></ul></li><li>进一步优化，服务整体链路分析<ul><li>规范上游服务调用接口，明确场景需求</li><li>分析业务流程，通过业务流程优化提升服务性能</li></ul></li></ul></li><li><h5 id="基础库优化">基础库优化</h5><ul><li>适应范围更广，覆盖更多服务</li><li>AB 实验 SDK 的优化<ul><li>分析基础库核心逻辑和性能瓶颈</li><li>完善改造方案，按需获取，序列化协议优化</li><li>内部压测验证</li><li>推广业务服务落地验证</li></ul></li></ul></li><li><h5 id="Go-语言优化">Go 语言优化</h5><ul><li>适应范围最广，Go 服务都有收益</li><li>优化方式<ul><li>优化内存分配策略</li><li>优化代码编译流程，生成更高效的程序</li><li>内部压测验证</li><li>推广业务服务落地验证</li></ul></li></ul></li></ul><h2 id="课后">课后</h2><ul><li>了解下其他语言的编码规范，是否和 Go 语言编码规范有相通之处，注重理解哪些共同点</li><li>编码规范或者性能优化建议大部分是通用的，有没有方式能够自动化对代码进行检测？</li><li>从 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgolang%2Fgo%2Ftree%2Fmaster%2Fsrc" title="https://github.com/golang/go/tree/master/src">github.com/golang/go/t…</a> 中选择感兴趣的包，看看官方代码是如何编写的</li><li>使用 Go 进行并发编程时有哪些性能陷阱或者优化手段？</li><li>在真实的线上环境中，每个场景或者服务遇到的性能问题也是各种各样，搜索下知名公司的官方公众号或者博客，里面有哪些性能优化的案例？比如 <a href="https://link.juejin.cn?target=https%3A%2F%2Feng.uber.com%2Fcategory%2Foss-projects%2Foss-go%2F" title="https://eng.uber.com/category/oss-projects/oss-go/">eng.uber.com/category/os…</a></li><li>Go 语言本身在持续更新迭代，每个版本在性能上有哪些重要的优化点？</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 框架三件套详解(Web/RPC/ORM)</title>
    <link href="/2023/01/17/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day03/"/>
    <url>/2023/01/17/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day03/</url>
    
    <content type="html"><![CDATA[<p>Go 框架三件套详解(Web/RPC/ORM)</p><span id="more"></span><h1>Go 框架三件套详解(Web/RPC/ORM)</h1><h2 id="环境搭建部分">环境搭建部分</h2><p>搭建课程所需要的开发环境以及安装需要用到的软件。</p><h3 id="学习如何安装-Docker-Postman-Git-Golang">学习如何安装 Docker/Postman/Git/Golang</h3><ul><li>安装 Minikube 或 Docker Desktop 用于使用 Docker <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Fdocker%2Fwindows-docker-install.html" title="https://www.runoob.com/docker/windows-docker-install.html">安装教程</a><ul><li>可以使用 Minikube 或者使用 Docker Desktop 启动 Docker</li></ul></li><li>安装 Postman（使用更新的Apifox替代）</li><li>安装 Git <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.liaoxuefeng.com%2Fwiki%2F896043488029600%2F896067074338496" title="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">安装教程</a></li><li>安装 Go(Golang &gt;= 1.15) <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.dev%2Fdoc%2Finstall" title="https://go.dev/doc/install">安装教程</a></li></ul><h2 id="框架体验部分">框架体验部分</h2><p>提前体验一下课程涉及的 HTTP/RPC/ORM 框架</p><h3 id="HTTP-框架-Hertz-初体验">HTTP 框架 Hertz 初体验</h3><p>通过阅读 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cloudwego.io%2Fzh%2Fdocs%2Fhertz%2Fgetting-started%2F" title="https://www.cloudwego.io/zh/docs/hertz/getting-started/">www.cloudwego.io/zh/docs/her…</a> 尝试运行 Hertz 的示例代码（Hertz 框架地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcloudwego%2Fhertz" title="https://github.com/cloudwego/hertz">github.com/cloudwego/h…</a>）</p><ol><li>首先安装命令行工具hz：<code>go install github.com/cloudwego/hertz/cmd/hz@latest</code></li><li>生成代码 <code>hz new -module github.com/cloudwego/hertz-examples</code></li><li>整理 &amp; 拉取依赖 <code>go mod tidy</code></li><li>编译并启动 <code>go build -o hertz_demo &amp;&amp; ./hertz_demo</code></li></ol><h3 id="RPC-框架-Kitex-初体验">RPC 框架 Kitex 初体验</h3><p>通过阅读 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.cloudwego.io%2Fzh%2Fdocs%2Fkitex%2Fgetting-started%2F" title="https://www.cloudwego.io/zh/docs/kitex/getting-started/">www.cloudwego.io/zh/docs/kit…</a> 尝试运行 Kitex 的示例代码（KItex 框架地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcloudwego%2Fkitex%2F" title="https://github.com/cloudwego/kitex/">github.com/cloudwego/k…</a>）</p><ol><li>安装 kitex：<code>go install github.com/cloudwego/kitex/tool/cmd/kitex@latest</code></li><li>安装 thriftgo：<code>go install github.com/cloudwego/thriftgo@latest</code></li><li>克隆该示例仓库到本地 <code>git clone https://github.com/cloudwego/kitex-examples.git</code></li><li>进入示例仓库的 <code>hello</code> 目录 <code>cd kitex-examples/hello</code></li><li>运行 server <code>go run .</code></li><li>运行 client 另起一个终端后，<code>go run ./client</code></li></ol><h3 id="ORM-框架-Gorm-初体验">ORM 框架 Gorm 初体验</h3><p>通过阅读 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgorm.cn%2Fdocs%2F%23Install" title="https://gorm.cn/docs/#Install">gorm.cn/docs/#Insta…</a> 尝试运行 Gorm 的示例代码（Gorm 框架地址: <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgo-gorm%2Fgorm" title="https://github.com/go-gorm/gorm">github.com/go-gorm/gor…</a>）</p><div class="code-wrapper"><pre><code class="hljs bash">go get -u gorm.io/gormgo get -u gorm.io/driver/sqlite</code></pre></div><h2 id="其它知识">其它知识</h2><ul><li>了解一下什么IDL以及IDL的语法</li><li>了解一下什么是 opentracing 以及 etcd</li></ul><h3 id="Etcd-与-Opentracing-是什么">Etcd 与 Opentracing 是什么</h3><ul><li>了解 etcd 是什么 <a href="https://link.juejin.cn?target=https%3A%2F%2Fetcd.io%2F" title="https://etcd.io/">参考文档</a><ul><li>etcd是一种高度一致的分布式键值存储，它提供了一种可靠的方式来存储需要由分布式系统或机器集群访问的数据。它可以在网络分区期间优雅地处理领导人选举，并且可以容忍机器故障，即使在领导人节点中也是如此。</li></ul></li><li>了解 opentracing 是什么 <a href="https://link.juejin.cn?target=https%3A%2F%2Fopentracing.io%2F" title="https://opentracing.io/">参考文档</a><ul><li>OpenTracing是一种分布式系统链路跟踪的设计原则、规范、标准。</li></ul></li></ul><h3 id="IDL-是什么">IDL 是什么</h3><ul><li>了解 IDL 是什么 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.m.wikipedia.org%2Fzh-hans%2F%25E6%258E%25A5%25E5%258F%25A3%25E6%258F%258F%25E8%25BF%25B0%25E8%25AF%25AD%25E8%25A8%2580" title="https://zh.m.wikipedia.org/zh-hans/%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80">zh.m.wikipedia.org/zh-hans/%E6…</a><ul><li><strong>接口描述语言</strong> （Interface description language，缩写 <strong>IDL</strong> ），是用来描述<a href="https://zh.m.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E7%BB%84%E4%BB%B6" title="软件组件">软件组件</a><a href="https://zh.m.wikipedia.org/wiki/%E4%BB%8B%E9%9D%A2_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">介面</a> “介面 (程式设计)”)的一种<a href="https://zh.m.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80" title="计算机语言">计算机语言</a>。IDL通过一种独立于编程语言的方式来描述接口，使得在不同平台上运行的对象和用不同语言编写的程序可以相互通信交流；比如，一个组件用<a href="https://zh.m.wikipedia.org/wiki/C%2B%2B" title="C++">C++</a>写成，另一个组件用<a href="https://zh.m.wikipedia.org/wiki/Java" title="Java">Java</a>写成。</li><li>IDL通常用于<a href="https://zh.m.wikipedia.org/wiki/%E9%81%A0%E7%A8%8B%E8%AA%BF%E7%94%A8" title="远程调用">远程调用</a>软件。在这种情况下，一般是由远程客户终端调用不同操作系统上的对象组件，并且这些对象组件可能是由不同计算机语言编写的。IDL建立起了两个不同操作系统间通信的桥梁。</li></ul></li><li>Thrift IDL 语法 <a href="https://link.juejin.cn?target=https%3A%2F%2Fthrift.apache.org%2Fdocs%2Fidl" title="https://thrift.apache.org/docs/idl">thrift.apache.org/docs/idl</a></li><li>proto3 IDL 语法 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdevelopers.google.com%2Fprotocol-buffers%2Fdocs%2Fproto3" title="https://developers.google.com/protocol-buffers/docs/proto3">developers.google.com/protocol-bu…</a></li></ul><h2 id="课程笔记">课程笔记</h2><p>直播链接：<a href="https://live.juejin.cn/4354/9899243">https://live.juejin.cn/4354/9899243</a></p><h3 id="课程目标">课程目标</h3><ol><li>将前面几节课所学到的知识应用到项目中。</li><li>掌握 Hertz/Kitex/Gorm 的基本用法。</li><li>通过学习实战案例，可以使用 Hertz/Kitex/Gorm 完成日常后端开发任务</li></ol><h3 id="三件套介绍">三件套介绍</h3><p>Gorm是一个已经迭代了10年+的功能强大的ORM框架，在字节内部被广泛使用并且拥有非常丰富的开源扩展。</p><p>Kitex是字节内部的Golang微服务RPC框架，具有高性能、强可扩展的主要特点，支持多协议并且拥有丰富的开源扩展。</p><p>Hertz是字节内部的HTTP框架，参考了其他开源框架的优势，结合字节跳动内部的需求，具有高易用性、高性能、高扩展性特点。</p><h3 id="Gorm的基本使用">Gorm的基本使用</h3><h4 id="CRUD">CRUD</h4><p><a href="https://imgse.com/i/pS1dwvD"><img src="https://s1.ax1x.com/2023/01/17/pS1dwvD.png" alt="pS1dwvD.png"></a><a href="https://imgse.com/i/pS1wJsg"><img src="https://s1.ax1x.com/2023/01/17/pS1wJsg.png" alt="pS1wJsg.png"></a><a href="https://imgse.com/i/pS10Mm4"><img src="https://s1.ax1x.com/2023/01/17/pS10Mm4.png" alt="pS10Mm4.png"></a><a href="https://imgse.com/i/pS10sht"><img src="https://s1.ax1x.com/2023/01/17/pS10sht.png" alt="pS10sht.png"></a><a href="https://imgse.com/i/pS1bm36"><img src="https://s1.ax1x.com/2023/01/17/pS1bm36.png" alt="pS1bm36.png"></a></p><h4 id="其他操作">其他操作</h4><p><a href="https://imgse.com/i/pS1bDEj"><img src="https://s1.ax1x.com/2023/01/17/pS1bDEj.png" alt="pS1bDEj.png"></a><a href="https://imgse.com/i/pS1bo5R"><img src="https://s1.ax1x.com/2023/01/17/pS1bo5R.png" alt="pS1bo5R.png"></a><a href="https://imgse.com/i/pS1bb26"><img src="https://s1.ax1x.com/2023/01/17/pS1bb26.png" alt="pS1bb26.png"></a><a href="https://imgse.com/i/pS1qixf"><img src="https://s1.ax1x.com/2023/01/17/pS1qixf.png" alt="pS1qixf.png"></a></p><p>Gorm拥有丰富的扩展生态，可以使用代码生成工具、分片库方案、手动索引、乐观锁、读写分离、OpenTelemetry 扩展等等</p><h3 id="Kitex">Kitex</h3><h3 id="Hertz">Hertz</h3>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言进阶 - 工程进阶</title>
    <link href="/2023/01/16/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day02/"/>
    <url>/2023/01/16/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day02/</url>
    
    <content type="html"><![CDATA[<p>Go 语言进阶 - 工程进阶</p><span id="more"></span><h1>Go 语言进阶 - 工程进阶</h1><h2 id="概述">概述</h2><p>本节课程主要分为四个方面：</p><ol><li>并发编程</li><li>依赖管理</li><li>单元测试</li><li>项目实战</li></ol><h2 id="详述">详述</h2><ul><li>罗列课程中涉及到的概念和相关资料，对于不熟悉的知识点，希望同学们可以提前查询预习，届时跟上直播课程进度。</li><li>【必须】课程内容相关代码链接：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FMoonlight-Zhao%2Fgo-project-example%2Ftree%2FV0" title="https://github.com/Moonlight-Zhao/go-project-example/tree/V0">github.com/Moonlight-Z…</a></li></ul><h2 id="并发编程">并发编程</h2><ul><li>协程Goroutine</li><li>通道Channel</li><li>锁Lock <a href="https://link.juejin.cn?target=https%3A%2F%2Fpkg.go.dev%2Fsync" title="https://pkg.go.dev/sync">pkg.go.dev/sync</a></li><li>线程同步WaitGroup <a href="https://link.juejin.cn?target=https%3A%2F%2Fpkg.go.dev%2Fsync" title="https://pkg.go.dev/sync">pkg.go.dev/sync</a></li></ul><p>属于编程进阶内容，考虑到工程项目的可用性和可靠性，工程实践中经常会用到。</p><h3 id="依赖管理">依赖管理</h3><ul><li>Gopath</li><li>Go Vendor</li><li>Go Module : <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.dev%2Fblog%2Fusing-go-modules" title="https://go.dev/blog/using-go-modules">go.dev/blog/using-…</a></li></ul><p>了解Go依赖管理演进的历程，通过课程学习以及课后实践能能够熟练使用go module 管理依赖。</p><h3 id="单元测试">单元测试</h3><ul><li>单元测试概念和规则：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.dev%2Fdoc%2Ftutorial%2Fadd-a-test%25EF%25BC%259Bhttps%3A%2F%2Fpkg.go.dev%2Ftesting" title="https://go.dev/doc/tutorial/add-a-test%EF%BC%9Bhttps://pkg.go.dev/testing">go.dev/doc/tutoria…</a></li><li>Mock测试：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbouk%2Fmonkey" title="https://github.com/bouk/monkey">github.com/bouk/monkey</a></li><li>基准测试：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpkg.go.dev%2Ftesting%23hdr-Benchmarks" title="https://pkg.go.dev/testing#hdr-Benchmarks">pkg.go.dev/testing#hdr…</a></li></ul><h3 id="项目实战">项目实战</h3><p><strong>需求模型来源</strong></p><p>青训营话题页<a href="https://forum.juejin.cn/youthcamp/post/7081211487762513928?from=1" title="https://forum.juejin.cn/youthcamp/post/7081211487762513928?from=1">forum.juejin.cn/youthcamp/p…</a></p><p><strong>需求</strong></p><ol><li>实现一个展示话题（标题，文字描述）和回帖列表的后端http接口；</li><li>本地文件存储数据</li></ol><p><strong>组件及技术点</strong></p><ul><li>web框架：Gin - <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgin-gonic%2Fgin%23quick-start" title="https://github.com/gin-gonic/gin#quick-start">github.com/gin-gonic/g…</a><ul><li>了解go web框架的简单使用</li></ul></li><li>分层结构设计：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbxcodec%2Fgo-clean-arch" title="https://github.com/bxcodec/go-clean-arch">github.com/bxcodec/go-…</a><ul><li>了解分层设计的概念</li></ul></li><li>文件操作：读文件<a href="https://link.juejin.cn?target=https%3A%2F%2Fpkg.go.dev%2Fio" title="https://pkg.go.dev/io">pkg.go.dev/io</a></li><li>数据查询：索引<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.baike.com%2Fwikiid%2F5527083834876297305%3Fprd%3Dresult_list%26view_id%3D5di0ak8h3ag000" title="https://www.baike.com/wikiid/5527083834876297305?prd=result_list&amp;view_id=5di0ak8h3ag000">www.baike.com/wikiid/5527…</a></li></ul><h2 id="课程笔记">课程笔记</h2><p>课程链接：</p><ul><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7141271987174768676">https://juejin.cn/course/bytetech/7140987981803814919/section/7141271987174768676</a></li><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7141273296397402148">https://juejin.cn/course/bytetech/7140987981803814919/section/7141273296397402148</a></li></ul><h3 id="语言进阶">语言进阶</h3><p>Go可以充分发挥多核的优势，高效运行</p><p>线程：内核态，比较重量级</p><p>协程：用户态，线程可以跑多个协程，比较轻量</p><h4 id="Goroutine">Goroutine</h4><p>快速打印：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hello goroutine : &quot;</span> + fmt.Sprint(i))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloGoRoutine</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;hello(j)&#125;(i)&#125;time.Sleep(time.Second)&#125;</code></pre></div><p>最后是使用time.sleep进行阻塞，防止在协程未运行结束前主线程先运行结束了。</p><h4 id="Channel">Channel</h4><p>协程通过通信来共享内存</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CalSquare</span><span class="hljs-params">()</span></span> &#123;src := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)dest := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(src)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;src &lt;- i&#125;&#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(dest)<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> src &#123;dest &lt;- i * i&#125;&#125;()<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dest &#123;<span class="hljs-comment">//复杂操作</span><span class="hljs-built_in">println</span>(i)&#125;&#125;</code></pre></div><h4 id="锁">锁</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (x    <span class="hljs-type">int64</span>lock sync.Mutex)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addWithLock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++ &#123;lock.Lock()x += <span class="hljs-number">1</span>lock.Unlock()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addWithoutLock</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++ &#123;x += <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">()</span></span> &#123;x = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<span class="hljs-keyword">go</span> addWithoutLock()&#125;time.Sleep(time.Second)<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WithoutLock:&quot;</span>, x)x = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<span class="hljs-keyword">go</span> addWithLock()&#125;time.Sleep(time.Second)<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;WithLock:&quot;</span>, x)&#125;</code></pre></div><h4 id="WaitGroup并发同步">WaitGroup并发同步</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ManyGoWait</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> wg sync.WaitGroupwg.Add(<span class="hljs-number">5</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done()hello(j)&#125;(i)&#125;wg.Wait()&#125;</code></pre></div><h3 id="依赖管理-2">依赖管理</h3><p>GOPATH：环境变量，项目代码直接依赖src下的代码，go get下载最新的包到src目录下</p><p>Go Vendor：增加vendor文件，存放依赖包的副本，优先从vendor文件里面查找，但是仍然无法控制依赖的版本</p><p>Go Module：go.mod：依赖管理基本单元、原生库、单元依赖</p><h3 id="测试">测试</h3><h4 id="单元测试-2">单元测试</h4><ul><li>所有测试文件以_test.go结尾</li><li>func TestXxx(*testing.T)</li><li>初始化逻辑放到TestMain中</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HelloTom</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Tom&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHelloTom</span><span class="hljs-params">(t *testing.T)</span></span> &#123;output := HelloTom()expectOutput := <span class="hljs-string">&quot;Tom&quot;</span>assert.Equal(t, expectOutput, output)&#125;</code></pre></div><p>添加–cover参数可以评价测试代码的覆盖率</p><h4 id="Mock测试">Mock测试</h4><p>一些函数对本地的数据库、文件等有强依赖，在测试的同时找到这些依赖要求过高</p><p>可以使用Mock进行测试，在函数执行的时候替换成另外一个函数（打桩），从而规避掉对本地其他的强依赖</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFirstLine</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;open, err := os.Open(<span class="hljs-string">&quot;log&quot;</span>)<span class="hljs-keyword">defer</span> open.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125;scanner := bufio.NewScanner(open)<span class="hljs-keyword">for</span> scanner.Scan() &#123;<span class="hljs-keyword">return</span> scanner.Text()&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ProcessFirstLine</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;line := ReadFirstLine()destLine := strings.ReplaceAll(line, <span class="hljs-string">&quot;11&quot;</span>, <span class="hljs-string">&quot;00&quot;</span>)<span class="hljs-keyword">return</span> destLine&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestProcessFirstLine</span><span class="hljs-params">(t *testing.T)</span></span> &#123;firstLine := ProcessFirstLine()assert.Equal(t, <span class="hljs-string">&quot;line00&quot;</span>, firstLine)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestProcessFirstLineWithMock</span><span class="hljs-params">(t *testing.T)</span></span> &#123;monkey.Patch(ReadFirstLine, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;line110&quot;</span>&#125;)<span class="hljs-keyword">defer</span> monkey.Unpatch(ReadFirstLine)line := ProcessFirstLine()assert.Equal(t, <span class="hljs-string">&quot;line000&quot;</span>, line)&#125;</code></pre></div><h4 id="基准测试">基准测试</h4><p>对函数的运行时间进行测试：go test -bench=.</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ServerIndex [<span class="hljs-number">10</span>]<span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitServerIndex</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;ServerIndex[i] = i+<span class="hljs-number">100</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Select</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> ServerIndex[rand.Intn(<span class="hljs-number">10</span>)]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FastSelect</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> ServerIndex[fastrand.Intn(<span class="hljs-number">10</span>)]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSelect</span><span class="hljs-params">(b *testing.B)</span></span> &#123;InitServerIndex()b.ResetTimer()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;Select()&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSelectParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;InitServerIndex()b.ResetTimer()b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<span class="hljs-keyword">for</span> pb.Next() &#123;Select()&#125;&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFastSelectParallel</span><span class="hljs-params">(b *testing.B)</span></span> &#123;InitServerIndex()b.ResetTimer()b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<span class="hljs-keyword">for</span> pb.Next() &#123;FastSelect()&#125;&#125;)&#125;</code></pre></div><h3 id="项目实战：社区话题页面">项目实战：社区话题页面</h3><p><strong>需求</strong></p><ol><li>实现一个展示话题（标题，文字描述）和回帖列表的后端http接口；</li><li>本地文件存储数据</li></ol><p><strong>分层结构</strong></p><ol><li>数据层：数据Model，处理外部数据的增删改查</li><li>逻辑层：业务Entity，处理核心业务逻辑输出</li><li>视图层：视图View，处理和外部的交互逻辑</li></ol><p><strong>组件及技术点</strong></p><ul><li>web框架：Gin - <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fgin-gonic%2Fgin%23quick-start" title="https://github.com/gin-gonic/gin#quick-start">github.com/gin-gonic/g…</a><ul><li>了解go web框架的简单使用</li></ul></li><li>分层结构设计：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbxcodec%2Fgo-clean-arch" title="https://github.com/bxcodec/go-clean-arch">github.com/bxcodec/go-…</a><ul><li>了解分层设计的概念</li></ul></li><li>文件操作：读文件<a href="https://link.juejin.cn?target=https%3A%2F%2Fpkg.go.dev%2Fio" title="https://pkg.go.dev/io">pkg.go.dev/io</a></li><li>数据查询：索引</li></ul><p>具体逻辑见代码</p><h2 id="课后实践">课后实践</h2><ol><li>支持对话题发布回帖。</li><li>回帖id生成需要保证不重复、唯一性。</li><li>新加回帖追加到本地文件，同时需要更新索引，注意Map的并发安全问题 <strong>。</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 语言基础 - 基础语法</title>
    <link href="/2023/01/15/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day01/"/>
    <url>/2023/01/15/ByteDanceYouthTrainCamp/ByteDanceYouthTrainCamp-Day01/</url>
    
    <content type="html"><![CDATA[<p>Go 语言基础 - 基础语法</p><span id="more"></span><h1>Go 语言基础 - 基础语法</h1><h2 id="概述">概述</h2><p>本节课程主要分为四个方面：</p><ol><li>Go 语言简介</li><li>Go 语言开发入门，包括开发环境配置、基础语法、标准库</li><li>Go 实战，包括三个实战项目</li></ol><p>课前部分主要罗列课程中涉及到的概念。对于不熟悉的概念，同学们可以提前查询预习；课中部分主要罗列每一部分的关键思路，帮助同学们跟上课程的进度；课后部分是一些问题，帮助同学们在课后梳理本课程的重点。</p><h2 id="课前">课前</h2><h3 id="安装-Go-语言">安装 Go 语言</h3><ol><li>访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgo.dev%2F" title="https://go.dev/">go.dev/</a> ，点击 Download ，下载对应平台安装包，安装即可</li><li>如果无法访问上述网址，可以改为访问 <a href="https://link.juejin.cn?target=https%3A%2F%2Fstudygolang.com%2Fdl" title="https://studygolang.com/dl">studygolang.com/dl</a> 下载安装</li><li>如果访问 github 速度比较慢，建议配置 go mod proxy，参考 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgoproxy.cn%2F" title="https://goproxy.cn/">goproxy.cn/</a> 里面的描述配置，下载第三方依赖包的速度可以大大加快</li></ol><h3 id="配置-Go-语言开发环境">配置 Go 语言开发环境</h3><p>可以选择安装 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcode.visualstudio.com%2F" title="https://code.visualstudio.com/">VS Code</a> ， 或者 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jetbrains.com%2Fzh-cn%2Fgo%2F" title="https://www.jetbrains.com/zh-cn/go/">Goland</a> ，对于 VS Code，需要安装 <a href="https://link.juejin.cn?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Dgolang.go" title="https://marketplace.visualstudio.com/items?itemName=golang.go">Go 插件</a></p><h3 id="下载课程示例代码">下载课程示例代码</h3><ol><li>Windows 平台建议安装 git，其它系统自带，<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.liaoxuefeng.com%2Fwiki%2F896043488029600%2F896067074338496" title="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">安装教程</a></li><li>打开 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwangkechun%2Fgo-by-example" title="https://github.com/wangkechun/go-by-example">github.com/wangkechun/…</a> 克隆课程示例项目</li><li>进入课程示例项目代码目录，运行 <code>go run example/01-hello/main.go</code> 如果正确输出 hello world，则说明环境配置正确</li></ol><h3 id="学习-Go-语言基础语法">学习 Go 语言基础语法</h3><p>空余时间阅读 <a href="https://link.juejin.cn?target=https%3A%2F%2Fbooks.studygolang.com%2Fgopl-zh%2F" title="https://books.studygolang.com/gopl-zh/">Go语言圣经（中文版）</a></p><h2 id="课程笔记">课程笔记</h2><p>课程链接：</p><ul><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7140988735222448165">https://juejin.cn/course/bytetech/7140987981803814919/section/7140988735222448165</a></li><li><a href="https://juejin.cn/course/bytetech/7140987981803814919/section/7141265019756675103">https://juejin.cn/course/bytetech/7140987981803814919/section/7141265019756675103</a></li></ul><h3 id="Go语言的优势">Go语言的优势</h3><ol><li>高性能、高并发：不需要另外的库对并发进行支持</li><li>语法简单、学习曲线平缓：一周时间即可上手</li><li>丰富的标准库：与Python一样有大量的标准库，非常稳定</li><li>完善的工具链：保证代码正确稳定运行</li><li>静态链接：只需要编译后的一个文件就可以运行</li><li>快速编译：静态语言几乎最快的编译速度</li><li>跨平台：几乎支持所有设备</li><li>垃圾回收：无需考虑内存的分配释放</li></ol><h3 id="基础语法">基础语法</h3><h4 id="1-Hello-World">1. Hello World</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)&#125;</code></pre></div><h4 id="2-变量">2. 变量</h4><p>注意常量没有类型，会根据使用的上下文自动推断类型</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;initial&quot;</span><span class="hljs-keyword">var</span> b, c <span class="hljs-type">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><span class="hljs-keyword">var</span> d = <span class="hljs-literal">true</span><span class="hljs-keyword">var</span> e <span class="hljs-type">float64</span>f := <span class="hljs-type">float32</span>(e)g := a + <span class="hljs-string">&quot;foo&quot;</span>fmt.Println(a, b, c, d, e, f) <span class="hljs-comment">// initial 1 2 true 0 0</span>fmt.Println(g)                <span class="hljs-comment">// initialapple</span><span class="hljs-keyword">const</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;constant&quot;</span><span class="hljs-keyword">const</span> h = <span class="hljs-number">500000000</span><span class="hljs-keyword">const</span> i = <span class="hljs-number">3e20</span> / hfmt.Println(s, h, i, math.Sin(h), math.Sin(i))&#125;</code></pre></div><h4 id="3-循环">3. 循环</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;i := <span class="hljs-number">1</span><span class="hljs-keyword">for</span> &#123;fmt.Println(<span class="hljs-string">&quot;loop&quot;</span>)<span class="hljs-keyword">break</span>&#125;<span class="hljs-keyword">for</span> j := <span class="hljs-number">7</span>; j &lt; <span class="hljs-number">9</span>; j++ &#123;fmt.Println(j)&#125;<span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">5</span>; n++ &#123;<span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">continue</span>&#125;fmt.Println(n)&#125;<span class="hljs-keyword">for</span> i &lt;= <span class="hljs-number">3</span> &#123;fmt.Println(i)i = i + <span class="hljs-number">1</span>&#125;&#125;</code></pre></div><h4 id="4-if-else">4. if else</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-number">7</span>%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;7 is even&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;7 is odd&quot;</span>)&#125;<span class="hljs-keyword">if</span> <span class="hljs-number">8</span>%<span class="hljs-number">4</span> == <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;8 is divisible by 4&quot;</span>)&#125;<span class="hljs-keyword">if</span> num := <span class="hljs-number">9</span>; num &lt; <span class="hljs-number">0</span> &#123;fmt.Println(num, <span class="hljs-string">&quot;is negative&quot;</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">10</span> &#123;fmt.Println(num, <span class="hljs-string">&quot;has 1 digit&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(num, <span class="hljs-string">&quot;has multiple digits&quot;</span>)&#125;&#125;</code></pre></div><h4 id="5-switch">5. switch</h4><p>默认不需要添加break</p><p>可以使用任意的变量类型</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-number">2</span><span class="hljs-keyword">switch</span> a &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">&quot;one&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">&quot;two&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:fmt.Println(<span class="hljs-string">&quot;three&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>, <span class="hljs-number">5</span>:fmt.Println(<span class="hljs-string">&quot;four or five&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;other&quot;</span>)&#125;t := time.Now()<span class="hljs-keyword">switch</span> &#123;<span class="hljs-keyword">case</span> t.Hour() &lt; <span class="hljs-number">12</span>:fmt.Println(<span class="hljs-string">&quot;It&#x27;s before noon&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;It&#x27;s after noon&quot;</span>)&#125;&#125;</code></pre></div><h4 id="6-数组">6. 数组</h4><p>真实场景下很少用，一般使用切片</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>a[<span class="hljs-number">4</span>] = <span class="hljs-number">100</span>fmt.Println(<span class="hljs-string">&quot;get:&quot;</span>, a[<span class="hljs-number">2</span>])fmt.Println(<span class="hljs-string">&quot;len:&quot;</span>, <span class="hljs-built_in">len</span>(a))b := [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;fmt.Println(b)<span class="hljs-keyword">var</span> twoD [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;twoD[i][j] = i + j&#125;&#125;fmt.Println(<span class="hljs-string">&quot;2d: &quot;</span>, twoD)&#125;</code></pre></div><h4 id="7-切片">7. 切片</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">3</span>)s[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;a&quot;</span>s[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;b&quot;</span>s[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;c&quot;</span>fmt.Println(<span class="hljs-string">&quot;get:&quot;</span>, s[<span class="hljs-number">2</span>])   <span class="hljs-comment">// c</span>fmt.Println(<span class="hljs-string">&quot;len:&quot;</span>, <span class="hljs-built_in">len</span>(s)) <span class="hljs-comment">// 3</span>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-string">&quot;d&quot;</span>)s = <span class="hljs-built_in">append</span>(s, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>)fmt.Println(s) <span class="hljs-comment">// [a b c d e f]</span>c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(s))<span class="hljs-built_in">copy</span>(c, s)fmt.Println(c) <span class="hljs-comment">// [a b c d e f]</span>fmt.Println(s[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]) <span class="hljs-comment">// [c d e]</span>fmt.Println(s[:<span class="hljs-number">5</span>])  <span class="hljs-comment">// [a b c d e]</span>fmt.Println(s[<span class="hljs-number">2</span>:])  <span class="hljs-comment">// [c d e f]</span>good := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>&#125;fmt.Println(good) <span class="hljs-comment">// [g o o d]</span>&#125;</code></pre></div><h4 id="8-map">8. map</h4><p>实际中使用最频繁，完全无序</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)m[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">1</span>m[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-number">2</span>fmt.Println(m)           <span class="hljs-comment">// map[one:1 two:2]</span>fmt.Println(<span class="hljs-built_in">len</span>(m))      <span class="hljs-comment">// 2</span>fmt.Println(m[<span class="hljs-string">&quot;one&quot;</span>])    <span class="hljs-comment">// 1</span>fmt.Println(m[<span class="hljs-string">&quot;unknow&quot;</span>]) <span class="hljs-comment">// 0</span>r, ok := m[<span class="hljs-string">&quot;unknow&quot;</span>]fmt.Println(r, ok) <span class="hljs-comment">// 0 false</span><span class="hljs-built_in">delete</span>(m, <span class="hljs-string">&quot;one&quot;</span>)m2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">var</span> m3 = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>&#125;fmt.Println(m2, m3)&#125;</code></pre></div><h4 id="9-range">9. range</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;nums := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;sum := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i, num := <span class="hljs-keyword">range</span> nums &#123;sum += num<span class="hljs-keyword">if</span> num == <span class="hljs-number">2</span> &#123;fmt.Println(<span class="hljs-string">&quot;index:&quot;</span>, i, <span class="hljs-string">&quot;num:&quot;</span>, num) <span class="hljs-comment">// index: 0 num: 2</span>&#125;&#125;fmt.Println(sum) <span class="hljs-comment">// 9</span>m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;B&quot;</span>&#125;<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;fmt.Println(k, v) <span class="hljs-comment">// b 8; a A</span>&#125;<span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;fmt.Println(<span class="hljs-string">&quot;key&quot;</span>, k) <span class="hljs-comment">// key a; key b</span>&#125;&#125;</code></pre></div><h4 id="10-函数">10. 函数</h4><p>一般返回两个值，第一个值是真正需要的，第二个值是错误信息</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add2</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> a + b&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exists</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, k <span class="hljs-type">string</span>)</span></span> (v <span class="hljs-type">string</span>, ok <span class="hljs-type">bool</span>) &#123;v, ok = m[k]<span class="hljs-keyword">return</span> v, ok&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;res := add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)fmt.Println(res) <span class="hljs-comment">// 3</span>v, ok := exists(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;A&quot;</span>&#125;, <span class="hljs-string">&quot;a&quot;</span>)fmt.Println(v, ok) <span class="hljs-comment">// A True</span>&#125;</code></pre></div><h4 id="11-指针">11. 指针</h4><p>对传入的参数进行修改</p><p>功能比较有限，不如C++丰富</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add2</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;n += <span class="hljs-number">2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add2ptr</span><span class="hljs-params">(n *<span class="hljs-type">int</span>)</span></span> &#123;*n += <span class="hljs-number">2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;n := <span class="hljs-number">5</span>add2(n)fmt.Println(n) <span class="hljs-comment">// 5</span>add2ptr(&amp;n)fmt.Println(n) <span class="hljs-comment">// 7</span>&#125;</code></pre></div><h4 id="12-结构体">12. 结构体</h4><p>传入指针避免传递的开销过大，同时也可以对结构体进行修改</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> &#123;name     <span class="hljs-type">string</span>password <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := user&#123;name: <span class="hljs-string">&quot;wang&quot;</span>, password: <span class="hljs-string">&quot;1024&quot;</span>&#125;b := user&#123;<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;1024&quot;</span>&#125;c := user&#123;name: <span class="hljs-string">&quot;wang&quot;</span>&#125;c.password = <span class="hljs-string">&quot;1024&quot;</span><span class="hljs-keyword">var</span> d userd.name = <span class="hljs-string">&quot;wang&quot;</span>d.password = <span class="hljs-string">&quot;1024&quot;</span>fmt.Println(a, b, c, d)                 <span class="hljs-comment">// &#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125; &#123;wang 1024&#125;</span>fmt.Println(checkPassword(a, <span class="hljs-string">&quot;haha&quot;</span>))   <span class="hljs-comment">// false</span>fmt.Println(checkPassword2(&amp;a, <span class="hljs-string">&quot;haha&quot;</span>)) <span class="hljs-comment">// false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkPassword</span><span class="hljs-params">(u user, password <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> u.password == password&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkPassword2</span><span class="hljs-params">(u *user, password <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> u.password == password&#125;</code></pre></div><h4 id="13-结构体方法">13. 结构体方法</h4><p>相当于一个类成员函数</p><p>带指针就能对结构体进行修改</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> &#123;name     <span class="hljs-type">string</span>password <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u user)</span></span> checkPassword(password <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> u.password == password&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *user)</span></span> resetPassword(password <span class="hljs-type">string</span>) &#123;u.password = password&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := user&#123;name: <span class="hljs-string">&quot;wang&quot;</span>, password: <span class="hljs-string">&quot;1024&quot;</span>&#125;a.resetPassword(<span class="hljs-string">&quot;2048&quot;</span>)fmt.Println(a.checkPassword(<span class="hljs-string">&quot;2048&quot;</span>)) <span class="hljs-comment">// true</span>&#125;</code></pre></div><h4 id="14-错误处理">14. 错误处理</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> &#123;name     <span class="hljs-type">string</span>password <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findUser</span><span class="hljs-params">(users []user, name <span class="hljs-type">string</span>)</span></span> (v *user, err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">for</span> _, u := <span class="hljs-keyword">range</span> users &#123;<span class="hljs-keyword">if</span> u.name == name &#123;<span class="hljs-keyword">return</span> &amp;u, <span class="hljs-literal">nil</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;not found&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;u, err := findUser([]user&#123;&#123;<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;1024&quot;</span>&#125;&#125;, <span class="hljs-string">&quot;wang&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err)<span class="hljs-keyword">return</span>&#125;fmt.Println(u.name) <span class="hljs-comment">// wang</span><span class="hljs-keyword">if</span> u, err := findUser([]user&#123;&#123;<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;1024&quot;</span>&#125;&#125;, <span class="hljs-string">&quot;li&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;fmt.Println(err) <span class="hljs-comment">// not found</span><span class="hljs-keyword">return</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(u.name)&#125;&#125;</code></pre></div><h4 id="15-字符串操作">15. 字符串操作</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := <span class="hljs-string">&quot;hello&quot;</span>fmt.Println(strings.Contains(a, <span class="hljs-string">&quot;ll&quot;</span>))                <span class="hljs-comment">// true</span>fmt.Println(strings.Count(a, <span class="hljs-string">&quot;l&quot;</span>))                    <span class="hljs-comment">// 2</span>fmt.Println(strings.HasPrefix(a, <span class="hljs-string">&quot;he&quot;</span>))               <span class="hljs-comment">// true</span>fmt.Println(strings.HasSuffix(a, <span class="hljs-string">&quot;llo&quot;</span>))              <span class="hljs-comment">// true</span>fmt.Println(strings.Index(a, <span class="hljs-string">&quot;ll&quot;</span>))                   <span class="hljs-comment">// 2</span>fmt.Println(strings.Join([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>&#125;, <span class="hljs-string">&quot;-&quot;</span>)) <span class="hljs-comment">// he-llo</span>fmt.Println(strings.Repeat(a, <span class="hljs-number">2</span>))                     <span class="hljs-comment">// hellohello</span>fmt.Println(strings.Replace(a, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-number">-1</span>))         <span class="hljs-comment">// hEllo</span>fmt.Println(strings.Split(<span class="hljs-string">&quot;a-b-c&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>))              <span class="hljs-comment">// [a b c]</span>fmt.Println(strings.ToLower(a))                       <span class="hljs-comment">// hello</span>fmt.Println(strings.ToUpper(a))                       <span class="hljs-comment">// HELLO</span>fmt.Println(<span class="hljs-built_in">len</span>(a))                                   <span class="hljs-comment">// 5</span>b := <span class="hljs-string">&quot;你好&quot;</span>fmt.Println(<span class="hljs-built_in">len</span>(b)) <span class="hljs-comment">// 6</span>&#125;</code></pre></div><h4 id="16-字符串格式化">16. 字符串格式化</h4><p>+和#号可以打印更为详细的信息</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;x, y <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := <span class="hljs-string">&quot;hello&quot;</span>n := <span class="hljs-number">123</span>p := point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;fmt.Println(s, n) <span class="hljs-comment">// hello 123</span>fmt.Println(p)    <span class="hljs-comment">// &#123;1 2&#125;</span>fmt.Printf(<span class="hljs-string">&quot;s=%v\n&quot;</span>, s)  <span class="hljs-comment">// s=hello</span>fmt.Printf(<span class="hljs-string">&quot;n=%v\n&quot;</span>, n)  <span class="hljs-comment">// n=123</span>fmt.Printf(<span class="hljs-string">&quot;p=%v\n&quot;</span>, p)  <span class="hljs-comment">// p=&#123;1 2&#125;</span>fmt.Printf(<span class="hljs-string">&quot;p=%+v\n&quot;</span>, p) <span class="hljs-comment">// p=&#123;x:1 y:2&#125;</span>fmt.Printf(<span class="hljs-string">&quot;p=%#v\n&quot;</span>, p) <span class="hljs-comment">// p=main.point&#123;x:1, y:2&#125;</span>f := <span class="hljs-number">3.141592653</span>fmt.Println(f)          <span class="hljs-comment">// 3.141592653</span>fmt.Printf(<span class="hljs-string">&quot;%.2f\n&quot;</span>, f) <span class="hljs-comment">// 3.14</span>&#125;</code></pre></div><h4 id="17-json">17. json</h4><p>注意结构体要保证大写，小写传参的问题使用反射解决</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> userInfo <span class="hljs-keyword">struct</span> &#123;Name  <span class="hljs-type">string</span>Age   <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;age&quot;`</span>Hobby []<span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;a := userInfo&#123;Name: <span class="hljs-string">&quot;wang&quot;</span>, Age: <span class="hljs-number">18</span>, Hobby: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Golang&quot;</span>, <span class="hljs-string">&quot;TypeScript&quot;</span>&#125;&#125;buf, err := json.Marshal(a)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;fmt.Println(buf)         <span class="hljs-comment">// [123 34 78 97...]</span>fmt.Println(<span class="hljs-type">string</span>(buf)) <span class="hljs-comment">// &#123;&quot;Name&quot;:&quot;wang&quot;,&quot;age&quot;:18,&quot;Hobby&quot;:[&quot;Golang&quot;,&quot;TypeScript&quot;]&#125;</span>buf, err = json.MarshalIndent(a, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;\t&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;fmt.Println(<span class="hljs-type">string</span>(buf))<span class="hljs-keyword">var</span> b userInfoerr = json.Unmarshal(buf, &amp;b)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, b) <span class="hljs-comment">// main.userInfo&#123;Name:&quot;wang&quot;, Age:18, Hobby:[]string&#123;&quot;Golang&quot;, &quot;TypeScript&quot;&#125;&#125;</span>&#125;</code></pre></div><h4 id="18-时间处理">18. 时间处理</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;now := time.Now()fmt.Println(now) <span class="hljs-comment">// 2022-03-27 18:04:59.433297 +0800 CST m=+0.000087933</span>t := time.Date(<span class="hljs-number">2022</span>, <span class="hljs-number">3</span>, <span class="hljs-number">27</span>, <span class="hljs-number">1</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">0</span>, time.UTC)t2 := time.Date(<span class="hljs-number">2022</span>, <span class="hljs-number">3</span>, <span class="hljs-number">27</span>, <span class="hljs-number">2</span>, <span class="hljs-number">30</span>, <span class="hljs-number">36</span>, <span class="hljs-number">0</span>, time.UTC)fmt.Println(t)                                                  <span class="hljs-comment">// 2022-03-27 01:25:36 +0000 UTC</span>fmt.Println(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute()) <span class="hljs-comment">// 2022 March 27 1 25</span>fmt.Println(t.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))                    <span class="hljs-comment">// 2022-03-27 01:25:36</span>diff := t2.Sub(t)fmt.Println(diff)                           <span class="hljs-comment">// 1h5m0s</span>fmt.Println(diff.Minutes(), diff.Seconds()) <span class="hljs-comment">// 65 3900</span>t3, err := time.Parse(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="hljs-string">&quot;2022-03-27 01:25:36&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;fmt.Println(t3 == t)    <span class="hljs-comment">// true</span>fmt.Println(now.Unix()) <span class="hljs-comment">// 1648738080</span>&#125;</code></pre></div><h4 id="19-数字解析">19. 数字解析</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f, _ := strconv.ParseFloat(<span class="hljs-string">&quot;1.234&quot;</span>, <span class="hljs-number">64</span>)fmt.Println(f) <span class="hljs-comment">// 1.234</span>n, _ := strconv.ParseInt(<span class="hljs-string">&quot;111&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)fmt.Println(n) <span class="hljs-comment">// 111</span>n, _ = strconv.ParseInt(<span class="hljs-string">&quot;0x1000&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>)fmt.Println(n) <span class="hljs-comment">// 4096</span>n2, _ := strconv.Atoi(<span class="hljs-string">&quot;123&quot;</span>)fmt.Println(n2) <span class="hljs-comment">// 123</span>n2, err := strconv.Atoi(<span class="hljs-string">&quot;AAA&quot;</span>)fmt.Println(n2, err) <span class="hljs-comment">// 0 strconv.Atoi: parsing &quot;AAA&quot;: invalid syntax</span>&#125;</code></pre></div><h4 id="20-进程信息">20. 进程信息</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;os/exec&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// go run example/20-env/main.go a b c d</span>fmt.Println(os.Args)           <span class="hljs-comment">// [/var/folders/8p/n34xxfnx38dg8bv_x8l62t_m0000gn/T/go-build3406981276/b001/exe/main a b c d]</span>fmt.Println(os.Getenv(<span class="hljs-string">&quot;PATH&quot;</span>)) <span class="hljs-comment">// /usr/local/go/bin...</span>fmt.Println(os.Setenv(<span class="hljs-string">&quot;AA&quot;</span>, <span class="hljs-string">&quot;BB&quot;</span>))buf, err := exec.Command(<span class="hljs-string">&quot;grep&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-string">&quot;/etc/hosts&quot;</span>).CombinedOutput()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;fmt.Println(<span class="hljs-type">string</span>(buf)) <span class="hljs-comment">// 127.0.0.1       localhost</span>&#125;</code></pre></div><h3 id="实战案例">实战案例</h3><h4 id="猜谜游戏">猜谜游戏</h4><ol><li>生成随机数之前需要生成不同的随机种子，否则每一次运行都会输出相同的数字，一般使用时间戳来初始化</li></ol><div class="code-wrapper"><pre><code class="hljs go">rand.Seed(time.Now().UnixNano())secretNumber := rand.Intn(maxNum)</code></pre></div><ol start="2"><li>bufio.NewReader读取输入并对输入进行处理，是工程中比较常用的做法。注意读取后需要对字符串进行处理</li></ol><div class="code-wrapper"><pre><code class="hljs go">reader := bufio.NewReader(os.Stdin)input, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)input = strings.Trim(input, <span class="hljs-string">&quot;\r\n&quot;</span>)</code></pre></div><p>最终代码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-string">&quot;strings&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;maxNum := <span class="hljs-number">100</span>rand.Seed(time.Now().UnixNano())secretNumber := rand.Intn(maxNum)<span class="hljs-comment">// fmt.Println(&quot;The secret number is &quot;, secretNumber)</span>fmt.Println(<span class="hljs-string">&quot;Please input your guess&quot;</span>)reader := bufio.NewReader(os.Stdin)<span class="hljs-keyword">for</span> &#123;input, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;An error occured while reading input. Please try again&quot;</span>, err)<span class="hljs-keyword">continue</span>&#125;input = strings.Trim(input, <span class="hljs-string">&quot;\r\n&quot;</span>)guess, err := strconv.Atoi(input)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Invalid input. Please enter an integer value&quot;</span>)<span class="hljs-keyword">continue</span>&#125;fmt.Println(<span class="hljs-string">&quot;You guess is&quot;</span>, guess)<span class="hljs-keyword">if</span> guess &gt; secretNumber &#123;fmt.Println(<span class="hljs-string">&quot;Your guess is bigger than the secret number. Please try again&quot;</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> guess &lt; secretNumber &#123;fmt.Println(<span class="hljs-string">&quot;Your guess is smaller than the secret number. Please try again&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;Correct, you Legend!&quot;</span>)<span class="hljs-keyword">break</span>&#125;&#125;&#125;</code></pre></div><h4 id="命令行在线词典">命令行在线词典</h4><p>抓包：找到<a href="https://fanyi.caiyunapp.com/#/">翻译网站</a>，提交一个翻译后去控制台抓包，然后copy as cURL，可以将这个请求转到本地进行运行</p><p>为了方便，可以将这个请求copy到一些在线将请求转换为Go代码的网站，最终得到可以直接运行的代码，运行代码获得与网页返回相同的结果。</p><p>将请求的部分单独提取出来，通过用户的输入进行序列化</p><p>解析返回的响应，进行反序列化提取真正需要的部分</p><p>返回的响应也使用<a href="https://oktools.net/json2go">在线工具</a>转换为go代码，减少工作量</p><p>最后通过命令行读入即可</p><p>最终代码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bytes&quot;</span><span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-keyword">type</span> DictRequest <span class="hljs-keyword">struct</span> &#123;TransType <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;trans_type&quot;`</span>Source    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;source&quot;`</span>UserID    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;user_id&quot;`</span>&#125;<span class="hljs-keyword">type</span> DictResponse <span class="hljs-keyword">struct</span> &#123;Rc   <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;rc&quot;`</span>Wiki <span class="hljs-keyword">struct</span> &#123;KnownInLaguages <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;known_in_laguages&quot;`</span>Description     <span class="hljs-keyword">struct</span> &#123;Source <span class="hljs-type">string</span>      <span class="hljs-string">`json:&quot;source&quot;`</span>Target <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;target&quot;`</span>&#125; <span class="hljs-string">`json:&quot;description&quot;`</span>ID   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;id&quot;`</span>Item <span class="hljs-keyword">struct</span> &#123;Source <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;source&quot;`</span>Target <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;target&quot;`</span>&#125; <span class="hljs-string">`json:&quot;item&quot;`</span>ImageURL  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;image_url&quot;`</span>IsSubject <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;is_subject&quot;`</span>Sitelink  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sitelink&quot;`</span>&#125; <span class="hljs-string">`json:&quot;wiki&quot;`</span>Dictionary <span class="hljs-keyword">struct</span> &#123;Prons <span class="hljs-keyword">struct</span> &#123;EnUs <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;en-us&quot;`</span>En   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;en&quot;`</span>&#125; <span class="hljs-string">`json:&quot;prons&quot;`</span>Explanations []<span class="hljs-type">string</span>      <span class="hljs-string">`json:&quot;explanations&quot;`</span>Synonym      []<span class="hljs-type">string</span>      <span class="hljs-string">`json:&quot;synonym&quot;`</span>Antonym      []<span class="hljs-type">string</span>      <span class="hljs-string">`json:&quot;antonym&quot;`</span>WqxExample   [][]<span class="hljs-type">string</span>    <span class="hljs-string">`json:&quot;wqx_example&quot;`</span>Entry        <span class="hljs-type">string</span>        <span class="hljs-string">`json:&quot;entry&quot;`</span>Type         <span class="hljs-type">string</span>        <span class="hljs-string">`json:&quot;type&quot;`</span>Related      []<span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-string">`json:&quot;related&quot;`</span>Source       <span class="hljs-type">string</span>        <span class="hljs-string">`json:&quot;source&quot;`</span>&#125; <span class="hljs-string">`json:&quot;dictionary&quot;`</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">query</span><span class="hljs-params">(word <span class="hljs-type">string</span>)</span></span> &#123;client := &amp;http.Client&#123;&#125;request := DictRequest&#123;TransType: <span class="hljs-string">&quot;en2zh&quot;</span>, Source: word&#125;buf, err := json.Marshal(request)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">var</span> data = bytes.NewReader(buf)req, err := http.NewRequest(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;https://api.interpreter.caiyunai.com/v1/dict&quot;</span>, data)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;req.Header.Set(<span class="hljs-string">&quot;Authority&quot;</span>, <span class="hljs-string">&quot;api.interpreter.caiyunai.com&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json, text/plain, */*&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Accept-Language&quot;</span>, <span class="hljs-string">&quot;zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;App-Name&quot;</span>, <span class="hljs-string">&quot;xy&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=UTF-8&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Origin&quot;</span>, <span class="hljs-string">&quot;https://fanyi.caiyunapp.com&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Os-Type&quot;</span>, <span class="hljs-string">&quot;web&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Referer&quot;</span>, <span class="hljs-string">&quot;https://fanyi.caiyunapp.com/&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Sec-Ch-Ua&quot;</span>, <span class="hljs-string">&quot;\&quot;Not?A_Brand\&quot;;v=\&quot;8\&quot;, \&quot;Chromium\&quot;;v=\&quot;108\&quot;, \&quot;Microsoft Edge\&quot;;v=\&quot;108\&quot;&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Sec-Ch-Ua-Mobile&quot;</span>, <span class="hljs-string">&quot;?0&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Sec-Ch-Ua-Platform&quot;</span>, <span class="hljs-string">&quot;\&quot;Windows\&quot;&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Sec-Fetch-Dest&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Sec-Fetch-Mode&quot;</span>, <span class="hljs-string">&quot;cors&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;Sec-Fetch-Site&quot;</span>, <span class="hljs-string">&quot;cross-site&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.76&quot;</span>)req.Header.Set(<span class="hljs-string">&quot;X-Authorization&quot;</span>, <span class="hljs-string">&quot;token:qgemv4jr1y38jyq6vhvi&quot;</span>)resp, err := client.Do(req)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">defer</span> resp.Body.Close()bodyText, err := io.ReadAll(resp.Body)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">if</span> resp.StatusCode != <span class="hljs-number">200</span> &#123;log.Fatal(<span class="hljs-string">&quot;bad StatusCode:&quot;</span>, resp.StatusCode, <span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-type">string</span>(bodyText))&#125;<span class="hljs-keyword">var</span> dictResponse DictResponseerr = json.Unmarshal(bodyText, &amp;dictResponse)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;fmt.Println(word, <span class="hljs-string">&quot;UK:&quot;</span>, dictResponse.Dictionary.Prons.En, <span class="hljs-string">&quot;US:&quot;</span>, dictResponse.Dictionary.Prons.EnUs)<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> dictResponse.Dictionary.Explanations &#123;fmt.Println(item)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) != <span class="hljs-number">2</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">`usage: simpleDict WORD</span><span class="hljs-string">example: simpleDict hello</span><span class="hljs-string">`</span>)os.Exit(<span class="hljs-number">1</span>)&#125;word := os.Args[<span class="hljs-number">1</span>]query(word)&#125;</code></pre></div><h4 id="Socks5代理服务器">Socks5代理服务器</h4><p>正常浏览器访问一个网站，先和对方的网站建立TCP连接，然后正常发起HTTP请求，服务器返回响应</p><p>如果设置了代理服务器，浏览器要先和代理服务器建立TCP连接，然后代理服务器再去和真正的网站建立TCP连接，可以分为4个阶段：</p><ol><li>协商（握手）：用户的浏览器会向Socks5服务器发起请求，发送一个报文，这个报文里面包括协议版本号，支持的认证的种类等，代理服务器会从里面选择一个它自己支持的认证方式，返回给浏览器，如果返回00表示不需要认证。</li><li>认证：（这个代理不加密，认证步骤跳过）</li><li>请求：认证通过之后，浏览器会向Socks5服务器发送下一个报文，包括协议的版本号，请求的类型，一般是Connection请求，代表浏览器命令代理服务器要和某个域名，某个端口建立连接。代理服务器收到后会去和真正的网站后端服务器建立TCP连接，然后返回一个报文告诉用户浏览器已经成功建立连接了。</li><li>Relay：浏览器正常发送请求，代理服务器收到请求后将请求转发到真正的服务器上，将返回的响应转发到浏览器。代理服务器并不关注流量的类别，可以是TCP或者HTTP</li></ol><p>实现流程：</p><ol><li>实现TCP echo server，就是发送什么就回复什么，用来测试server写的是否正确（使用 <code>nc 127.0.0.1 1080</code>）进行测试</li><li>实现协商阶段：测试时可以使用 <code>curl --socks5 127.0.0.1:1080 -v http://www.qq.com</code>进行测试，但是仅为协商，因此不会成功，但是服务器端会有正确的输出。</li><li>实现请求阶段</li><li>实现Relay阶段</li></ol><p>最终代码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-string">&quot;context&quot;</span><span class="hljs-string">&quot;encoding/binary&quot;</span><span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net&quot;</span>)<span class="hljs-keyword">const</span> socks5Ver = <span class="hljs-number">0x05</span><span class="hljs-keyword">const</span> cmdBind = <span class="hljs-number">0x01</span><span class="hljs-keyword">const</span> atypIPV4 = <span class="hljs-number">0x01</span><span class="hljs-keyword">const</span> atypeHOST = <span class="hljs-number">0x03</span><span class="hljs-keyword">const</span> atypeIPV6 = <span class="hljs-number">0x04</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;server, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:1080&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;<span class="hljs-keyword">for</span> &#123;client, err := server.Accept()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Printf(<span class="hljs-string">&quot;Accept failed %v&quot;</span>, err)<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">go</span> process(client)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<span class="hljs-keyword">defer</span> conn.Close()reader := bufio.NewReader(conn)err := auth(reader, conn)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Printf(<span class="hljs-string">&quot;client %v auth failed:%v&quot;</span>, conn.RemoteAddr(), err)<span class="hljs-keyword">return</span>&#125;err = connect(reader, conn)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Printf(<span class="hljs-string">&quot;client %v auth failed:%v&quot;</span>, conn.RemoteAddr(), err)<span class="hljs-keyword">return</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">auth</span><span class="hljs-params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="hljs-type">error</span>) &#123;<span class="hljs-comment">// +----+----------+----------+</span><span class="hljs-comment">// |VER | NMETHODS | METHODS  |</span><span class="hljs-comment">// +----+----------+----------+</span><span class="hljs-comment">// | 1  |    1     | 1 to 255 |</span><span class="hljs-comment">// +----+----------+----------+</span><span class="hljs-comment">// VER: 协议版本，socks5为0x05</span><span class="hljs-comment">// NMETHODS: 支持认证的方法数量</span><span class="hljs-comment">// METHODS: 对应NMETHODS，NMETHODS的值为多少，METHODS就有多少个字节。RFC预定义了一些值的含义，内容如下:</span><span class="hljs-comment">// X’00’ NO AUTHENTICATION REQUIRED</span><span class="hljs-comment">// X’02’ USERNAME/PASSWORD</span>ver, err := reader.ReadByte()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read ver failed:%w&quot;</span>, err)&#125;<span class="hljs-keyword">if</span> ver != socks5Ver &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;not supported ver:%v&quot;</span>, ver)&#125;methodSize, err := reader.ReadByte()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read methodSize failed:%w&quot;</span>, err)&#125;method := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, methodSize)_, err = io.ReadFull(reader, method)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read method failed:%w&quot;</span>, err)&#125;<span class="hljs-comment">// +----+--------+</span><span class="hljs-comment">// |VER | METHOD |</span><span class="hljs-comment">// +----+--------+</span><span class="hljs-comment">// | 1  |   1    |</span><span class="hljs-comment">// +----+--------+</span>_, err = conn.Write([]<span class="hljs-type">byte</span>&#123;socks5Ver, <span class="hljs-number">0x00</span>&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;write failed:%w&quot;</span>, err)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(reader *bufio.Reader, conn net.Conn)</span></span> (err <span class="hljs-type">error</span>) &#123;<span class="hljs-comment">// +----+-----+-------+------+----------+----------+</span><span class="hljs-comment">// |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |</span><span class="hljs-comment">// +----+-----+-------+------+----------+----------+</span><span class="hljs-comment">// | 1  |  1  | X&#x27;00&#x27; |  1   | Variable |    2     |</span><span class="hljs-comment">// +----+-----+-------+------+----------+----------+</span><span class="hljs-comment">// VER 版本号，socks5的值为0x05</span><span class="hljs-comment">// CMD 0x01表示CONNECT请求</span><span class="hljs-comment">// RSV 保留字段，值为0x00</span><span class="hljs-comment">// ATYP 目标地址类型，DST.ADDR的数据对应这个字段的类型。</span><span class="hljs-comment">//   0x01表示IPv4地址，DST.ADDR为4个字节</span><span class="hljs-comment">//   0x03表示域名，DST.ADDR是一个可变长度的域名</span><span class="hljs-comment">// DST.ADDR 一个可变长度的值</span><span class="hljs-comment">// DST.PORT 目标端口，固定2个字节</span>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">4</span>)_, err = io.ReadFull(reader, buf)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read header failed:%w&quot;</span>, err)&#125;ver, cmd, atyp := buf[<span class="hljs-number">0</span>], buf[<span class="hljs-number">1</span>], buf[<span class="hljs-number">3</span>]<span class="hljs-keyword">if</span> ver != socks5Ver &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;not supported ver:%v&quot;</span>, ver)&#125;<span class="hljs-keyword">if</span> cmd != cmdBind &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;not supported cmd:%v&quot;</span>, ver)&#125;addr := <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">switch</span> atyp &#123;<span class="hljs-keyword">case</span> atypIPV4:_, err = io.ReadFull(reader, buf)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read atyp failed:%w&quot;</span>, err)&#125;addr = fmt.Sprintf(<span class="hljs-string">&quot;%d.%d.%d.%d&quot;</span>, buf[<span class="hljs-number">0</span>], buf[<span class="hljs-number">1</span>], buf[<span class="hljs-number">2</span>], buf[<span class="hljs-number">3</span>])<span class="hljs-keyword">case</span> atypeHOST:hostSize, err := reader.ReadByte()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read hostSize failed:%w&quot;</span>, err)&#125;host := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, hostSize)_, err = io.ReadFull(reader, host)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read host failed:%w&quot;</span>, err)&#125;addr = <span class="hljs-type">string</span>(host)<span class="hljs-keyword">case</span> atypeIPV6:<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;IPv6: no supported yet&quot;</span>)<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;invalid atyp&quot;</span>)&#125;_, err = io.ReadFull(reader, buf[:<span class="hljs-number">2</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read port failed:%w&quot;</span>, err)&#125;port := binary.BigEndian.Uint16(buf[:<span class="hljs-number">2</span>])dest, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;%v:%v&quot;</span>, addr, port))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;dial dst failed:%w&quot;</span>, err)&#125;<span class="hljs-keyword">defer</span> dest.Close()log.Println(<span class="hljs-string">&quot;dial&quot;</span>, addr, port)<span class="hljs-comment">// +----+-----+-------+------+----------+----------+</span><span class="hljs-comment">// |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |</span><span class="hljs-comment">// +----+-----+-------+------+----------+----------+</span><span class="hljs-comment">// | 1  |  1  | X&#x27;00&#x27; |  1   | Variable |    2     |</span><span class="hljs-comment">// +----+-----+-------+------+----------+----------+</span><span class="hljs-comment">// VER socks版本，这里为0x05</span><span class="hljs-comment">// REP Relay field,内容取值如下 X’00’ succeeded</span><span class="hljs-comment">// RSV 保留字段</span><span class="hljs-comment">// ATYPE 地址类型</span><span class="hljs-comment">// BND.ADDR 服务绑定的地址</span><span class="hljs-comment">// BND.PORT 服务绑定的端口DST.PORT</span>_, err = conn.Write([]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">0x05</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;write failed: %w&quot;</span>, err)&#125;ctx, cancel := context.WithCancel(context.Background())<span class="hljs-keyword">defer</span> cancel()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;_, _ = io.Copy(dest, reader)cancel()&#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;_, _ = io.Copy(conn, dest)cancel()&#125;()&lt;-ctx.Done()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><h2 id="课后">课后</h2><p><a href="https://bytedance.feishu.cn/docs/doccn3SFTuFIAVr4CDZGx48KKdd" title="https://bytedance.feishu.cn/docs/doccn3SFTuFIAVr4CDZGx48KKdd">Go 语言学习路线图</a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>ByteDance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用软件常用命令</title>
    <link href="/2023/01/13/Software-Commands/"/>
    <url>/2023/01/13/Software-Commands/</url>
    
    <content type="html"><![CDATA[<p>常用软件常用命令</p><span id="more"></span><h1>产生随机字符串</h1><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> -c 32 /dev/random | <span class="hljs-built_in">base64</span></code></pre></div><h1>sudo免密码设置</h1><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> visudo</code></pre></div><h1>压缩相关</h1><div class="code-wrapper"><pre><code class="hljs bash">tar -cvf temp.tar temp.txt temp/tar -xvf temp.tar -C temp/tar cvzf - pic | <span class="hljs-built_in">split</span> -b 10m -d - pic<span class="hljs-built_in">cat</span> pic* &gt; pic.tar.gztar xvzf pic.tar.gz</code></pre></div><h1>Conda</h1><table><thead><tr><th>描述</th><th>命令</th></tr></thead><tbody><tr><td>查看都有什么环境</td><td>conda info --envs</td></tr><tr><td>查看当前环境有什么包</td><td>conda list</td></tr><tr><td>创建环境</td><td>conda create -n env_name python=version package_names</td></tr><tr><td>安装包</td><td>conda install name=version</td></tr><tr><td>离线安装包</td><td>conda install --use-local name</td></tr><tr><td>导出当前环境</td><td>conda env export &gt; name.yaml</td></tr><tr><td>导出base环境需要更换名称</td><td>conda create -n new_name --clone base</td></tr><tr><td>复制后导入</td><td>conda env create -f name.yaml</td></tr><tr><td>删除环境下的某个包</td><td>conda env remove -n your_env_name package_name</td></tr><tr><td>删除环境</td><td>conda env remove --name your_env_name</td></tr><tr><td>打包环境</td><td>conda pack -n my_env -o out_name.tar.gz</td></tr><tr><td>利用打包的环境复现</td><td>tar -xzf my_env.tar.gz -C my_env &amp;&amp; source my_env/bin/activate</td></tr></tbody></table><p><a href="https://blog.csdn.net/FY_2018/article/details/119710831">Anaconda环境离线迁移移植</a></p><h1>Linux 系统安装</h1><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<span class="hljs-built_in">sudo</span> apt install vim<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list.bak<span class="hljs-built_in">sudo</span> vim /etc/apt/sources.list<span class="hljs-built_in">sudo</span> apt update<span class="hljs-built_in">sudo</span> apt upgrade<span class="hljs-built_in">sudo</span> apt install python3-pip<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mkdir</span> ~/.pip<span class="hljs-built_in">cd</span> ~/.pip<span class="hljs-built_in">sudo</span> vim pip.conf<span class="hljs-comment"># [global]</span><span class="hljs-comment"># index-url=https://mirrors.aliyun.com/pypi/simple/ </span><span class="hljs-comment"># https://pypi.org/simple</span>vim ~/.bashrc<span class="hljs-built_in">export</span> PATH=~/mypath/bin:<span class="hljs-variable">$PATH</span><span class="hljs-built_in">source</span> ~/.bashrc</code></pre></div><p>添加%zhangzhao ALL=(ALL:ALL) NOPASSWD: ALL 到最后一行 , 后 ctrl+o, 回车 , ctrl+x 退出</p><h1>VSCode</h1><p><a href="https://stackoverflow.com/questions/56671520/how-can-i-install-vscode-server-in-linux-offline">How can I install vscode-server in linux offline</a></p><h1>科学上网相关</h1><h2 id="V2ray安装">V2ray安装</h2><p>安装说明：<a href="https://www.v2fly.org/guide/install.html">https://www.v2fly.org/guide/install.html</a></p><p>脚本下载地址：<a href="https://github.com/v2fly/fhs-install-v2ray">https://github.com/v2fly/fhs-install-v2ray</a></p><p>执行脚本前首先临时更改hosts，避免github连接不上的情况</p><p>参考仓库：<a href="https://github.com/521xueweihan/GitHub520">https://github.com/521xueweihan/GitHub520</a></p><p>执行脚本下载安装V2ray</p><div class="code-wrapper"><pre><code class="hljs bash">bash install-release.sh</code></pre></div><p>安装后的文件位置：</p><div class="code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/usr/</span>local<span class="hljs-keyword">/bin/</span>v2ray<span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/usr/</span>local<span class="hljs-keyword">/share/</span>v2ray/geoip.dat<span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/usr/</span>local<span class="hljs-keyword">/share/</span>v2ray/geosite.dat<span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/usr/</span>local<span class="hljs-keyword">/etc/</span>v2ray/config.json<span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/var/</span>log<span class="hljs-keyword">/v2ray/</span><span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/var/</span>log<span class="hljs-keyword">/v2ray/</span>access.log<span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/var/</span>log<span class="hljs-keyword">/v2ray/</span>error.log<span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/etc/</span>systemd<span class="hljs-keyword">/system/</span>v2ray.service<span class="hljs-symbol">installed:</span> <span class="hljs-keyword">/etc/</span>systemd<span class="hljs-keyword">/system/</span>v2ray@.service</code></pre></div><p>按照上面的配置文件路径写入配置文件（可以直接从Windows客户端中copy过来）</p><p>V2ray命令：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 启动V2ray</span>systemctl start v2ray<span class="hljs-comment"># 检查V2ray状态</span>systemctl status v2ray<span class="hljs-comment"># 设置V2ray开机自启动</span>systemctl <span class="hljs-built_in">enable</span> v2ray</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs bash">curl -x socks5://127.0.0.1:10808 https://www.google.com -v</code></pre></div><h2 id="clash安装">clash安装</h2><p>下载地址：<a href="https://github.com/Dreamacro/clash/releases/tag/v1.12.0">https://github.com/Dreamacro/clash/releases/tag/v1.12.0</a></p><p>解压并赋予权限：</p><div class="code-wrapper"><pre><code class="hljs bash">gzip -d clash-linux-amd64-v1.11.4.gz<span class="hljs-built_in">chmod</span> a+x clash-linux</code></pre></div><p>有的代理服务商会直接给出配置文件config.yaml，如果没有，可以将订阅链接直接粘贴在浏览器网址栏，然后搜索，会直接下载下来文件或者展示出配置文件，如果搜索到的是一大堆字符则需要在订阅链接的后面添加 <strong>&amp;flag=clash</strong> ，然后会下载下来一个文件，将其更名为config.yaml即可</p><p>然后替换~/.config/clash下自动生成的config.yaml，删除Country.mmdb文件，然后再次执行 <strong>./clash-linux</strong></p><p>即可以使用</p><p>释放9090端口后可以通过Web端查看：<a href="http://clash.razord.top">http://clash.razord.top</a></p><p>（WSL2 git push时候可能会遇到错误，解决方法：将下述代码粘贴到~/.ssh/config文件中）</p><div class="code-wrapper"><pre><code class="hljs bash">Host github.comHostname ssh.github.comPort 443</code></pre></div><h2 id="proxychains安装">proxychains安装</h2><p>安装proxychains从而避免全局代理</p><div class="code-wrapper"><pre><code class="hljs bash">apt install proxychains4</code></pre></div><p>配置文件：(/etc/proxychains.conf)</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># proxychains.conf  VER 4.x</span><span class="hljs-comment">#</span><span class="hljs-comment">#        HTTP, SOCKS4a, SOCKS5 tunneling proxifier with DNS.</span><span class="hljs-comment"># The option below identifies how the ProxyList is treated.</span><span class="hljs-comment"># only one option should be uncommented at time,</span><span class="hljs-comment"># otherwise the last appearing option will be accepted</span><span class="hljs-comment">#</span><span class="hljs-comment"># dynamic_chain</span><span class="hljs-comment">#</span><span class="hljs-comment"># Dynamic - Each connection will be done via chained proxies</span><span class="hljs-comment"># all proxies chained in the order as they appear in the list</span><span class="hljs-comment"># at least one proxy must be online to play in chain</span><span class="hljs-comment"># (dead proxies are skipped)</span><span class="hljs-comment"># otherwise EINTR is returned to the app</span><span class="hljs-comment">#</span>strict_chain<span class="hljs-comment">#</span><span class="hljs-comment"># Strict - Each connection will be done via chained proxies</span><span class="hljs-comment"># all proxies chained in the order as they appear in the list</span><span class="hljs-comment"># all proxies must be online to play in chain</span><span class="hljs-comment"># otherwise EINTR is returned to the app</span><span class="hljs-comment">#</span><span class="hljs-comment">#round_robin_chain</span><span class="hljs-comment">#</span><span class="hljs-comment"># Round Robin - Each connection will be done via chained proxies</span><span class="hljs-comment"># of chain_len length</span><span class="hljs-comment"># all proxies chained in the order as they appear in the list</span><span class="hljs-comment"># at least one proxy must be online to play in chain</span><span class="hljs-comment"># (dead proxies are skipped).</span><span class="hljs-comment"># the start of the current proxy chain is the proxy after the last</span><span class="hljs-comment"># proxy in the previously invoked proxy chain.</span><span class="hljs-comment"># if the end of the proxy chain is reached while looking for proxies</span><span class="hljs-comment"># start at the beginning again.</span><span class="hljs-comment"># otherwise EINTR is returned to the app</span><span class="hljs-comment"># These semantics are not guaranteed in a multithreaded environment.</span><span class="hljs-comment">#</span><span class="hljs-comment">#random_chain</span><span class="hljs-comment">#</span><span class="hljs-comment"># Random - Each connection will be done via random proxy</span><span class="hljs-comment"># (or proxy chain, see  chain_len) from the list.</span><span class="hljs-comment"># this option is good to test your IDS :)</span><span class="hljs-comment"># Make sense only if random_chain or round_robin_chain</span><span class="hljs-comment">#chain_len = 2</span><span class="hljs-comment"># Quiet mode (no output from library)</span><span class="hljs-comment"># quiet_mode</span><span class="hljs-comment"># Proxy DNS requests - no leak for DNS data</span>proxy_dns<span class="hljs-comment"># set the class A subnet number to use for the internal remote DNS mapping</span><span class="hljs-comment"># we use the reserved 224.x.x.x range by default,</span><span class="hljs-comment"># if the proxified app does a DNS request, we will return an IP from that range.</span><span class="hljs-comment"># on further accesses to this ip we will send the saved DNS name to the proxy.</span><span class="hljs-comment"># in case some control-freak app checks the returned ip, and denies to </span><span class="hljs-comment"># connect, you can use another subnet, e.g. 10.x.x.x or 127.x.x.x.</span><span class="hljs-comment"># of course you should make sure that the proxified app does not need</span><span class="hljs-comment"># *real* access to this subnet. </span><span class="hljs-comment"># i.e. dont use the same subnet then in the localnet section</span><span class="hljs-comment">#remote_dns_subnet 127 </span><span class="hljs-comment">#remote_dns_subnet 10</span>remote_dns_subnet 224<span class="hljs-comment"># Some timeouts in milliseconds</span>tcp_read_time_out 15000tcp_connect_time_out 8000<span class="hljs-comment">### Examples for localnet exclusion</span><span class="hljs-comment">## localnet ranges will *not* use a proxy to connect.</span><span class="hljs-comment">## Exclude connections to 192.168.1.0/24 with port 80</span><span class="hljs-comment"># localnet 192.168.1.0:80/255.255.255.0</span><span class="hljs-comment">## Exclude connections to 192.168.100.0/24</span><span class="hljs-comment"># localnet 192.168.100.0/255.255.255.0</span><span class="hljs-comment">## Exclude connections to ANYwhere with port 80</span><span class="hljs-comment"># localnet 0.0.0.0:80/0.0.0.0</span><span class="hljs-comment">## RFC5735 Loopback address range</span><span class="hljs-comment">## if you enable this, you have to make sure remote_dns_subnet is not 127</span><span class="hljs-comment">## you&#x27;ll need to enable it if you want to use an application that </span><span class="hljs-comment">## connects to localhost.</span><span class="hljs-comment"># localnet 127.0.0.0/255.0.0.0</span><span class="hljs-comment">## RFC1918 Private Address Ranges</span><span class="hljs-comment"># localnet 10.0.0.0/255.0.0.0</span><span class="hljs-comment"># localnet 172.16.0.0/255.240.0.0</span><span class="hljs-comment"># localnet 192.168.0.0/255.255.0.0</span><span class="hljs-comment"># ProxyList format</span><span class="hljs-comment">#       type  ip  port [user pass]</span><span class="hljs-comment">#       (values separated by &#x27;tab&#x27; or &#x27;blank&#x27;)</span><span class="hljs-comment">#</span><span class="hljs-comment">#       only numeric ipv4 addresses are valid</span><span class="hljs-comment">#</span><span class="hljs-comment">#</span><span class="hljs-comment">#        Examples:</span><span class="hljs-comment">#</span><span class="hljs-comment">#            socks5192.168.67.781080lamersecret</span><span class="hljs-comment">#http192.168.89.38080justuhidden</span><span class="hljs-comment"># socks4192.168.1.491080</span><span class="hljs-comment">#        http192.168.39.938080</span><span class="hljs-comment">#</span><span class="hljs-comment">#</span><span class="hljs-comment">#       proxy types: http, socks4, socks5</span><span class="hljs-comment">#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks )</span><span class="hljs-comment">#</span>[ProxyList]<span class="hljs-comment"># add proxy here ...</span><span class="hljs-comment"># meanwile</span><span class="hljs-comment"># defaults set to &quot;tor&quot;</span>socks5 127.0.0.1 10808http 127.0.0.1 10809</code></pre></div><p>需要走代理的命令在命令开头添加proxychains即可</p><p>全局代理：（似乎对软件内部，例如go没有作用）</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> http_proxy=http://127.0.0.1:10809<span class="hljs-built_in">export</span> https_proxy=https://127.0.0.1:10809</code></pre></div><h1>Go安装</h1><h2 id="下载安装">下载安装</h2><p>网站说明：<a href="https://golang.google.cn/doc/install">https://golang.google.cn/doc/install</a></p><div class="code-wrapper"><pre><code class="hljs bash">wget https://golang.google.cn/dl/go1.19.5.linux-amd64.tar.gz</code></pre></div><p>删除旧版本并解压安装包：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.5.linux-amd64.tar.gz</code></pre></div><p>编辑配置文件，增加环境变量：</p><div class="code-wrapper"><pre><code class="hljs bash">vim ~/.bashrc<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/go/bin<span class="hljs-built_in">source</span> ~/.bashrc</code></pre></div><p>验证安装：</p><div class="code-wrapper"><pre><code class="hljs bash">go version</code></pre></div><h2 id="配置">配置</h2><p>查看配置：</p><div class="code-wrapper"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span></code></pre></div><p>修改配置：</p><div class="code-wrapper"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GO111MODULE=ongo <span class="hljs-built_in">env</span> -w GOPROXY=https://goproxy.io,direct</code></pre></div><p>拉取私有仓库的包</p><div class="code-wrapper"><pre><code class="hljs bash">go <span class="hljs-built_in">env</span> -w GOPRIVATE=gitlab.appshahe.com</code></pre></div><p>除配置私有仓库的地址外，还需要将走http或者https的协议转到git协议上</p><p>具体命令：</p><div class="code-wrapper"><pre><code class="hljs bash">git config --global url.<span class="hljs-string">&quot;git@gitlab.appshahe.com:&quot;</span>.insteadOf <span class="hljs-string">&quot;https://gitlab.appshahe.com/&quot;</span>git config --global url.<span class="hljs-string">&quot;git@gitlab.appshahe.com:&quot;</span>.insteadOf <span class="hljs-string">&quot;http://gitlab.appshahe.com/&quot;</span></code></pre></div><p>具体的更改会体现在 <code>~/.gitconfig</code>里面</p><h1>MySQL</h1><p>docker安装直接可以远程访问，不需要任何配置操作</p><div class="code-wrapper"><pre><code class="hljs bash">apt install mysql-server</code></pre></div><p>运行mysql服务并查看是否正在运行</p><div class="code-wrapper"><pre><code class="hljs bash">service mysql startservice mysql status</code></pre></div><p>刚开始安装不能使用用户名和密码访问，需要更换为原来的密码验证方式</p><div class="code-wrapper"><pre><code class="hljs bash">mysqlALTER USER <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="hljs-string">&#x27;root&#x27;</span>;FLUSH PRIVILEGES;</code></pre></div><p>创建数据库：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE DATABASE simpledy</code></pre></div><h2 id="增加远程访问的用户">增加远程访问的用户</h2><p><strong>取消bind-address=127.0.0.1</strong></p><div class="code-wrapper"><pre><code class="hljs bash">vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre></div><p>密码生成为随机字符串：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">head</span> -c 8 /dev/random | <span class="hljs-built_in">base64</span></code></pre></div><p>创建用户：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE USER &#x27;dymysql&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;gxnw21XxRhY&#x27;;</code></pre></div><p>更改密码验证方式：</p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER USER &#x27;dymysql&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;gxnw21XxRhY&#x27;;</code></pre></div><p>授予用户某个数据库的全部权限：</p><div class="code-wrapper"><pre><code class="hljs mysql">GRANT ALL PRIVILEGES ON `simpledy`.* TO `dymysql`@`%` WITH GRANT OPTION;</code></pre></div><p>撤销某个用户对某个数据库的全部权限：</p><div class="code-wrapper"><pre><code class="hljs mysql">REVOKE ALL PRIVILEGES, GRANT OPTION FROM &#x27;dymysql&#x27;;</code></pre></div><p>刷新缓存：</p><div class="code-wrapper"><pre><code class="hljs mysql">FLUSH PRIVILEGES;</code></pre></div><p>展示某个用户的权限：</p><div class="code-wrapper"><pre><code class="hljs mysql">SHOW GRANTS FOR &#x27;dymysql&#x27;@&#x27;%&#x27;;</code></pre></div><p>查看已有用户以及是否可以远程登录：</p><div class="code-wrapper"><pre><code class="hljs mysql">select host,user,plugin from mysql.user;</code></pre></div><h1>Redis</h1><p>docker安装配置成功</p><div class="code-wrapper"><pre><code class="hljs bash">apt install redis-server</code></pre></div><p>运行并查看是否正在运行</p><div class="code-wrapper"><pre><code class="hljs bash">service redis-server startservice redis-server status</code></pre></div><h2 id="设置redis密码">设置redis密码</h2><p>打开redis配置文件 <code>/etc/redis/redis.conf</code></p><p>找到requirepass，修改即可</p><h2 id="配置-Redis-远程访问">配置 Redis 远程访问</h2><p>默认情况下，Redis 不允许远程连接。只能从127.0.0.1（localhost）连接 Redis 服务器</p><p>打开redis配置文件 <code>/etc/redis/redis.conf</code></p><p>注释掉 <code>bind 127.0.0.1 ::1</code></p><p>关闭保护模式 <code>protected-mode no</code></p><p>重启Redis服务：<code>service redis-server restart</code></p><p>（注意WSL的ip要到WSL里面去看）</p><h1>RabbitMQ</h1><p>官网安装脚本：<a href="https://www.rabbitmq.com/install-debian.html#apt-cloudsmith">https://www.rabbitmq.com/install-debian.html#apt-cloudsmith</a></p><p>注意修改apt-get为apt，将软件源设置为对应版本（如Ubuntu22.04为jammy）</p><p>查看安装状态：</p><div class="code-wrapper"><pre><code class="hljs bash">service rabbitmq-server status</code></pre></div><p>打开管理界面：</p><div class="code-wrapper"><pre><code class="hljs bash">rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_management</code></pre></div><p>通过<a href="http://localhost:15672/#/">http://localhost:15672/#/</a>进行查看</p><p>默认的guest用户，密码为guest，具有超级管理员权限，无法远程登录</p><p>创建用户并设置密码：</p><div class="code-wrapper"><pre><code class="hljs bash">add_user root QxdkQeiIUNY</code></pre></div><p>管理用户角色：</p><ul><li>超级管理员(administrator)：可登陆管理控制台(启用management plugin的情况下)，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</li><li>监控者(monitoring)：可登陆管理控制台(启用management plugin的情况下)，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)。</li><li>策略制定者(policymaker)：可登陆管理控制台(启用management plugin的情况下), 同时可以对policy进行管理。但无法查看节点的相关信息。</li><li>普通管理者(management)：仅可登陆管理控制台(启用management plugin的情况下)，无法看到节点信息，也无法对策略进行管理。</li><li>其他：无法登陆管理控制台，通常就是普通的生产者和消费者。（最后项目中使用的）</li></ul><div class="code-wrapper"><pre><code class="hljs bash">rabbitmqctl set_user_tags root administrator</code></pre></div><p>查看当前的用户及角色：</p><div class="code-wrapper"><pre><code class="hljs bash">rabbitmqctl list_users</code></pre></div><p>不需要开启远程连接，自动支持</p><p>然后进入到管理页面中，对virtual hosts进行设置（相当于数据库中的db）</p><p>然后即可使用程序等跑通</p><h1>FFmpeg</h1><div class="code-wrapper"><pre><code class="hljs bash">apt install ffmpeg</code></pre></div><h1>Nginx</h1><div class="code-wrapper"><pre><code class="hljs bash">apt install nginx</code></pre></div><p>配置文件：/etc/nginx/nginx.conf</p><p>增加mp4支持：</p><div class="code-wrapper"><pre><code class="hljs bash">apt install nginx-extras</code></pre></div><h1>vsftpd</h1><div class="code-wrapper"><pre><code class="hljs bash">apt install vsftpd</code></pre></div><h1>Protobuf</h1><p>下载protobuf官方的protoc工具（<a href="https://github.com/protocolbuffers/protobuf/releases">tar.gz版本</a>）</p><p>编译安装：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 安装需要的工具包</span>apt install autoconf automake libtool curl make g++ unzip<span class="hljs-comment"># 解压安装包</span>tar xvf protobuf-21.12.tar.gz &amp;&amp; <span class="hljs-built_in">cd</span> protobuf-21.12<span class="hljs-comment"># 编译安装</span>./autogen.sh./configuremake &amp;&amp; make installldconfig<span class="hljs-comment"># 验证安装</span>protoc --version</code></pre></div><p>安装go语言插件：</p><div class="code-wrapper"><pre><code class="hljs bash">go get -u google.golang.org/protobuf/cmd/protoc-gen-gogo get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc</code></pre></div><p>将执行文件添加到环境变量中：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/root/go/bin</code></pre></div><p>执行：</p><div class="code-wrapper"><pre><code class="hljs bash">protoc --go_out=. video.proto</code></pre></div><h1>Consul</h1><p>下载地址：<a href="https://developer.hashicorp.com/consul/downloads">https://developer.hashicorp.com/consul/downloads</a></p><p>解压后直接执行即可</p><h1>Docker</h1><p><a href="https://docs.docker.com/engine/install/ubuntu/">官网安装方法</a></p><p>核心思想：</p><ol><li>Add Docker’s official GPG key</li></ol><div class="code-wrapper"><pre><code class="hljs bash">root@hecs-296470:/etc/apt/keyrings# <span class="hljs-built_in">cd</span> /etc/apt/keyringsroot@hecs-296470:/etc/apt/keyrings# <span class="hljs-built_in">ls</span>docker.gpg</code></pre></div><ol start="2"><li>添加可以下载docker的源</li></ol><div class="code-wrapper"><pre><code class="hljs bash">root@hecs-296470:/etc/apt/sources.list.d# <span class="hljs-built_in">ls</span>docker.listroot@hecs-296470:/etc/apt/sources.list.d# <span class="hljs-built_in">cat</span> docker.listdeb [<span class="hljs-built_in">arch</span>=amd64 signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu   jammy stableroot@hecs-296470:/etc/apt/sources.list.d#</code></pre></div><ol start="3"><li>安装docker</li></ol><div class="code-wrapper"><pre><code class="hljs bash">apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</code></pre></div><p>换源：</p><div class="code-wrapper"><pre><code class="hljs bash">vim /etc/docker/daemon.json</code></pre></div><p>写入源：</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;https://ghcr.io&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;https://mirror.baidubce.com&quot;</span>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">&#125;</span></code></pre></div><p>重启docker：</p><div class="code-wrapper"><pre><code class="hljs bash">systemctl daemon-reloadsystemctl restart docker</code></pre></div><h1>环境相关</h1><p>准备重装编程环境，以Docker为基础，既能开发，又能方便部署，同时不损害原有的其他环境</p><p>但是Docker Desktop坑点太多，且占用资源巨大，因此不安装Windows环境下面的Docker，而是在WSL内部安装Docker，VSCode通过SSH方式跨过WSL访问容器。</p><h2 id="Docker安装">Docker安装</h2><p>与上面的Docker安装基本相同，不过注意每一次重启WSL的时候要手动重启Docker，否则无法使用Docker</p><div class="code-wrapper"><pre><code class="hljs bash">service docker start</code></pre></div><h2 id="网络桥接">网络桥接</h2><p>由于WSL的ip会总变化，这里准备配桥接模式，我的理解是WSL与主机的地位相同，在内网中都有自己的ip，这样无论是互相访问还是访问外网都没有什么问题。</p><p>参考资料：</p><p><a href="https://learn.microsoft.com/zh-cn/windows-server/virtualization/hyper-v/get-started/create-a-virtual-switch-for-hyper-v-virtual-machines?tabs=powershell">官方文档</a></p><p><a href="https://zhuanlan.zhihu.com/p/593263088">WSL2 网络的最终解决方案</a></p><p><a href="https://zhuanlan.zhihu.com/p/598300224">WSL2 静态IP（固定IP）不需要自动化脚本的设置方案</a></p><h2 id="常用命令">常用命令</h2><table><thead><tr><th>描述</th><th>命令</th></tr></thead><tbody><tr><td>查询容器</td><td>sudo docker ps -a</td></tr><tr><td>删除容器</td><td>sudo docker rm 容器ID</td></tr><tr><td>查询镜像</td><td>sudo docker images</td></tr><tr><td>删除镜像</td><td>sudo docker rmi 镜像ID（要先删除掉容器才能删除掉镜像）</td></tr><tr><td>拉取镜像</td><td>sudo docker pull python:3.8.13（去dockerhub上找合适的版本）</td></tr><tr><td>根据镜像启动容器并挂载数据</td><td>docker run -v 绝对路径:/mnt --gpus all --shm-size=6g -it python:3.8.13 /bin/bash</td></tr><tr><td>启动已经停止的容器</td><td>sudo docker start ID</td></tr><tr><td>进入某个容器的终端</td><td>sudo docker exec -it ID /bin/bash</td></tr><tr><td>将容器转为镜像并上传到dockerhub-登录</td><td>docker login</td></tr><tr><td>将容器转为镜像并上传到dockerhub-提交</td><td>sudo docker commit 容器ID zhangzhao219/仓库名（也是将容器写回到镜像中的操作）</td></tr><tr><td>将容器转为镜像并上传到dockerhub-打标签</td><td>sudo docker tag zhangzhao219/仓库名 zhangzhao219/TAG</td></tr><tr><td>将容器转为镜像并上传到dockerhub-上传</td><td>sudo docker push zhangzhao219/仓库名:TAG</td></tr><tr><td>导出容器到文件</td><td>sudo docker export -o *.tar 容器ID</td></tr><tr><td>从文件导入容器（会直接变为镜像）</td><td>sudo docker import IR.tar 名称</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Backend</tag>
      
      <tag>Softwarer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824 Distributed Systems-LEC 5 Fault Tolerance-Raft-1</title>
    <link href="/2023/01/10/6.824/Distributed-Systems-MIT-6.824-LEC-5/"/>
    <url>/2023/01/10/6.824/Distributed-Systems-MIT-6.824-LEC-5/</url>
    
    <content type="html"><![CDATA[<p>MIT-6.824（Spring 2022）LEC 5 Fault Tolerance-Raft-1</p><span id="more"></span><h1>In Search of an Understandable Consensus Algorithm (Raft) 论文阅读</h1><p><a href="https://zhuanlan.zhihu.com/p/524885008">参考翻译</a></p><p><a href="https://zhuanlan.zhihu.com/p/514512060">参考总结</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/6.824/raft-extended.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="摘要">摘要</h2><p>一致性算法，或者说 <strong>共识算法</strong> ，让⼀组机器像⼀个整体⼀样工作，即使其中⼀些机器出现故障也能够继续工作。</p><p>Raft 是⼀种为了管理复制日志的⼀致性算法。</p><p>它将⼀致性算法分解成了几个关键模块：领导人选举、日志复制和安全性。同时它通过更强的⼀致性来 <strong>减少状态机的数量</strong> 。</p><p>总之，对比传统的一致性算法 Paxos，Raft 更清晰易懂，易于实现。</p><h2 id="1-简介">1. 简介</h2><p>一致性算法允许多台机器作为一个集群协同工作，并且在其中的某几台机器出故障时集群仍然能正常工作。正因为如此，一致性算法在建立可靠的大规模软件系统方面发挥了重要作用。在过去十年中，Paxos 主导了关于一致性算法的讨论：大多数一致性的实现都是基于 Paxos 或受其影响，Paxos 已经成为教授学生关于一致性知识的主要工具。然而尽管很多人一直在努力尝试使 Paxos 更易懂，Paxos 还是太难理解了。此外，Paxos 的架构需要复杂的改变来支持实际系统。</p><p>我们开始着手寻找一个新的一致性算法，希望可以为系统开发和教学提供更好的基础。 我们的方法是不寻常的，因为我们的主要目标是可理解性。在该算法的设计中，重要的不仅是如何让算法起作用，还要清晰地知道该算法为什么会起作用。这项工作的结果是一个称为 Raft 的一致性算法。在设计 Raft 时，我们使用了特定的技术来提高它的可理解性，包括：</p><ul><li>分解（Raft 分离出三个关键点：leader election、log replication、safety）</li><li>减少状态空间（相比于 Paxos，Raft 降低了不确定性的程度和服务器之间的不一致）</li></ul><p>一项针对 2 所大学共 43 名学生的用户研究表明，Raft 比 Paxos 更容易理解：在学习两种算法后，其中 33 名学生能够更好地回答 Raft 的相关问题。</p><p>Raft 在许多方面类似于现有的公式算法，但它有几个新特性：</p><ul><li><strong>Strong leader（强领导性）</strong>：相比于其他算法，Raft 使用了更强的领导形式。比如，日志条目只能从 leader 流向 follower（集群中除 leader 外其他的服务器）。这在使 Raft 更易懂的同时简化了日志复制的管理流程。</li><li><strong>Leader election（领导选举）</strong>：Raft 使用随机计时器来进行领导选举。任何一致性算法都需要心跳机制，Raft 只需要在这个基础上，添加少量机制，就可以简单快速地解决冲突。</li><li><strong>Membership changes（成员变更）</strong>：Raft 在更改集群中服务器集的机制中使用了 <strong>联合一致性</strong> 的方法。在联合一致性下，在集群配置的转换过程中，新旧两种配置大多数是重叠的，这使得集群在配置更改期间可以继续正常运行。</li></ul><p>我们认为 Raft 跟 Paxos 以及其他一致性算法相比是更优的，这不仅体现在教学方面，还体现在工程实现方面。</p><ul><li>它比其他算法更简单且更易于理解</li><li>它被描述得十分详细足以满足实际系统的需要</li><li>它有多个开源实现，并被多家公司使用</li><li>它的安全性已被正式规定和验证</li><li>它的效率与其他算法相当</li></ul><h2 id="2-复制状态机">2. 复制状态机</h2><p><strong>一致性算法基于复制状态机</strong></p><p>一致性算法一般都是在 <strong>复制状态机</strong> 的背景下实现的。在这种方法下，一组服务器在的状态机计算相同状态的相同副本，即使某些服务器崩溃，它们也可以继续运行。</p><p>复制状态机是用来解决分布式系统中的各种容错问题。比如说，具有单个 leader 的大规模的系统，如 GFS，HDFS 和 RAMCloud ，他们通常都使用单独的复制状态机来管理 leader election 和保存 leader 崩溃后重新选举所需的配置信息。像 Chubby 和 ZooKeeper 都是复制状态机。</p><p>复制状态机通常都是使用日志复制（log replication）来实现。</p><p><img src="https://pic4.zhimg.com/80/v2-8b70c07436669ef9d2ff1854e0f7cdaf_720w.webp" alt=""></p><p>如图：每个服务器都保存着一份拥有一系列命令的日志，然后服务器上的状态机会按顺序执行日志中的命令。每一份日志中命令相同并且顺序也相同，因此每个状态机可以处理相同的命令序列。所以状态机是可确定的，每个状态机都执行相同的状态和相同的输出序列。</p><p><strong>一致性算法的主要工作就是保证复制日志（replicated log）的一致性</strong> 。每台服务器上的一致性模块接收来自客户端的命令，并将这些命令添加到其日志当中。一致性模块与其他服务器上的一致性模块进行通信，以确保每台服务器上最终以相同的顺序包含相同的命令，即使部分服务器崩溃了，这个条件也可以满足。一旦命令被正确复制，每台服务器上的状态机就会按日志顺序处理它们，并将输出返回给客户端。这样就形成了高可用的复制状态机。</p><p>适用于实际系统的 <strong>一致性算法通常都包含以下几点特征</strong> ：</p><ul><li><strong>安全性</strong>：非拜占庭错误（出现故障（crash 或 fail-stop，即不响应）但不会伪造信息）情况下，绝不会返回错误的结果</li><li><strong>可用性</strong>：只要大多数机器（过半）正常就可保证可用。假设服务器崩溃了，一小段时间后，它们很可能会根据已经稳定存储的状态来进行恢复，并重新加入集群。</li><li><strong>不依赖时序保证一致性</strong>：错误的时钟和极端消息延迟在最坏的情况下会产生影响可用性的一系列问题。</li><li>在通常情况下，只要集群中大部分（过半）服务器已经响应了单轮远程过程调用（RPC），命令就可以被视为完成， <strong>小部分慢节点不影响整体性能</strong> 。</li></ul><h2 id="3-Paxos-算法的问题">3. Paxos 算法的问题</h2><p>在过去的十年间，Leslie Lamport 的 Paxos 协议 几乎成为一致性的同义词。它是课堂上被教授最多的一致性协议，大多数一致性的实现也是以它为起点。Paxos 首先定义了能在单个决策问题（例如单个复制日志条目）上达成一致性的协议。我们将这个子集称为  <em>single-decree Paxos</em> 。然后 Paxos 组合该协议的多个实例去实现一系列决策，比如日志（<em>multi-Paxos</em>）。Paxos 保证了安全性和活性，它也支持改变集群中的成员，它的安全性也已经被论证了，并且大多数情况下都是高效的。</p><p>美中不足的是，Paxos 有两个严重的缺点：</p><h3 id="Paxos-非常难理解">Paxos 非常难理解</h3><p>众所周知，Paxos 非常晦涩难懂，除非下了很大的功夫，很少有人能够成功理解它。因此，尽管目前已经有几个尝试希望将 Paxos 解释得通俗易懂一些，而且这些解释都集中在 single-decree Paxos，但是它们还是很难懂。在对 NSDI 2012 参会者的非正式调查中，我们发现很少人会喜欢 Paxos，即使是经验丰富的研究人员。我们自己也一直在跟 Paxos 作斗争，我们也无法完全理解整个 Paxos 协议，直到阅读了几个更简单的描述和自己设计了替代 Paxos 的协议，我们才对 Paxos 有了比较深刻的理解。但这个过程，花了将近一年。我们推测 Paxos 这么晦涩难懂，主要是因为作者选择了 Single-decree Paxos 来作为基础。Single-decree Paxso 非常搞人：它分为两个阶段，但是并没有对这两个阶段进行简单直观的说明，而且这两个阶段也不能分开了单独理解，所以使用者将就很难理解为什么该算法能起作用。Multi-Paxos 的合成规则又增加了许多复杂性。我们相信，对多个决定（日志，并非单个日志条目）达成一致性的总体问题可以用其他更直接和更明显的方式进行分解。</p><h3 id="Paxos-没有为实际实现提供一个良好的基础">Paxos 没有为实际实现提供一个良好的基础</h3><p>其中一个原因是没有广泛认同的针对 Multi-Paxos 的算法。Lamport 的描述主要是针对 signle-decree Paxos 的，他描述了针对 multi-Paxos 的可能方法，但缺少了很多细节。目前已经有人在尝试具体化和优化 Paxos，但是这些尝试都互不相同并且它们跟 Lamport 描述的也不尽相同。虽然像 Chubby 这样的系统已经实现了类 Paxos 算法，但是他们并没有透露出很多的实现细节。</p><p>此外，Paxos 的架构对于构建实际系统来说其实是一个糟糕的设计，这是 single-decree Paxos 分解的另一个结果。举个例子，这对于独立选择地日志条目的集合，然后再将它们合并到顺序日志当中没有任何好处，这只会增加复杂性。围绕日志来设计系统是更加简单和高效的方法，其中新条目按受约束的顺序依次附加。另外一个问题是 Paxos 在其核心使用了 <strong>对称对等方法</strong> （尽管它最终表明了这会被用作一种性能优化的弱领导模式）。这在只有一个决策的情况下是有意义的，但是尽管如此，还是很少有实际系统采用了这种方法。如果有一系列的决策需要制定，更简单和更快速的方法应该是首先选择一个 leader，然后由 leader 去协调这些决策。</p><p>因此，按照 Paxos 来实现的实际系统往往跟 Paxos 相差很大。几乎所有的实现都是从 Paxos 开始，然后在实现的过程中发现了一系列的难题，在解决难题的过程中，开发出了跟 Paxos 完全不一样的架构。这样既费时又容易出错，而且 Paxos 本身的晦涩难懂又使得问题变得更加严重。Paxos 公式可能是证明其正确性的一个很好的公式，但真正的实现与 Paxos 又相差很大，这证明了它其实没有什么价值。来自 Chubby 作者的评论非常典型：在 Paxos 算法描述和现实实现系统之间有着巨大的鸿沟，如果一直按照 Paxos 算法走下去，最终的系统往往会建立在一个还未被证明的协议之上。</p><p>综合上述问题，我们觉得 Paxos 在教学端和系统构建端都没有提供一个良好的基础。考虑到共识性在大规模软件系统中的重要性，我们决定去尝试一下看看能不能设计一个替代 Paxos 并且具有更好特性的共识算法。</p><p>Raft 算法就是尝试克服以上缺点，替代 Paxos 的一致性算法。</p><h2 id="4-为了可理解性的设计">4. 为了可理解性的设计</h2><p>设计 Raft 的初衷：</p><ul><li>提供⼀个<strong>完整的实际的系统实现基础</strong>：大大减少开发者的工作</li><li>任何情况下都是<strong>安全的</strong></li><li>大多数的情况下都是<strong>可用的</strong></li><li>大部分操作必须是<strong>高效的</strong></li><li><strong>可理解性</strong>：（最重要、最大挑战）保证大多数人都可以容易理解。</li><li>能够让人形成<strong>直观的认识</strong>：使系统的构建者能够在现实中进行必然的扩展。</li></ul><p>在设计 Raft 算法的过程中，很多情况下我们需要在多个备选方案下做出抉择。在这种情况下，我们往往会基于可理解性来进行抉择：</p><ul><li>解释各个备选方案的难度有多大？例如，它的状态空间有多复杂？它是否具有难以理解的含义？</li><li>对于一个读者来说，完成理解这个方案和方案中的各种含义是否简单？</li></ul><p>我们意识到这一的分析具有高度的主观性。所以我们采取了两种通用的措施来解决这个问题。</p><ol><li>第一个措施就是众所周知的 <strong>问题分解</strong> ：只要有可能，我们就将问题划分成几个相对独立地解决、解释和理解的子问题。例如，Raft 算法被我们划分成 leader 选举、日志复制、安全性和成员变更几个部分。</li><li>第二个措施是 <strong>通过减少状态的数量来简化状态空间</strong> ，尽可能地使系统变得更加连贯和尽可能地消除不确定性。很明显的一个例子就是，所有的日志都是不允许有空挡的，并且 Raft 限制了日志之间可能不一样的方式。尽管在大多数情况下我们都极力去消除不确定性，但是在某些情况下不确定性却可以提高可理解性。一个重要的例子就是随机化方法，它们虽然引入了不确定性，但是它们往往能够通过以类似的方式处理所有可能的选择来减少状态空间（随便选，没关系）。所以我们使用了随机化来简化 Raft 中的 leader election 算法。</li></ol><h2 id="5-Raft-一致性算法">5. Raft 一致性算法</h2><p>Raft 是一种用来管理第2节中提到的复制日志（replicated log）的算法</p><p>Raft算法的关键特性：</p><p><a href="https://imgse.com/i/pSn0Ve0"><img src="https://s1.ax1x.com/2023/01/11/pSn0Ve0.png" alt="pSn0Ve0.png"></a></p><p>Raft算法的简略版：</p><p><a href="https://imgse.com/i/pSnwXLt"><img src="https://s1.ax1x.com/2023/01/11/pSnwXLt.jpg" alt="pSnwXLt.jpg"></a></p><p>Raft 选举一个  <strong>Leader</strong> ，给予管理所有复制日志的权限，由此实现一致性。</p><p>Leader 从客户接受指令，写入日志，复制到其他 Backup Server 上，在保证安全性时通知其他 Server 根据日志执行指令更新状态机。</p><p>Leader 大大简化了对复制日志的管理。leader 可以自行决定新日志写入位置，数据都从 Leader 流向其他 Server。<strong>当 Leader 宕机，从其他 Server 中选举一个新 Leader。</strong></p><p>Raft 将一致性问题分解为 <strong>三个子问题</strong> ：</p><ul><li><strong>Leader election（领导选举）</strong>：一个 leader 倒下之后，一定会有一个新的 leader 站起来。</li><li><strong>Log replication（日志复制）</strong>：leader 必须接收来自客户端的日志条目然后复制到集群中的其他节点，并且强制其他节点的日志和自己的保持一致。</li><li><strong>Safety（安全性）</strong>：Raft 中安全性的关键是状态机的安全性：只要有任何服务器节点将一个特定的日志条目应用到它的状态机中，那么其他服务器节点就不能在同一个日志索引位置上存储另外一条不同的指令。此处还涉及一个额外的选举机制上的限制。</li></ul><h3 id="5-0-Raft算法的关键特性与简略说明">5.0 Raft算法的关键特性与简略说明</h3><h4 id="State（状态）">State（状态）</h4><p><strong>所有服务器上持久存在的：</strong></p><p>（在响应RPCs之前已在稳定存储上进行更新）</p><table><thead><tr><th>状态变量</th><th>说明</th></tr></thead><tbody><tr><td>currentTerm</td><td>服务器最后⼀次知道的最新的任期号（初始化为 0，持续递增）</td></tr><tr><td>votedFor</td><td>在当前任期获得选票的候选人的id（如果没有则为 null）</td></tr><tr><td>log[]</td><td>日志条目集；每⼀个条目包含⼀个用户状态机执行的指令，和收到时的任期号</td></tr></tbody></table><p><strong>所有服务器上经常变的：</strong></p><table><thead><tr><th>状态变量</th><th>说明</th></tr></thead><tbody><tr><td>commitIndex</td><td>已知的最大的已经被提交的日志条目的索引值</td></tr><tr><td>lastApplied</td><td>最后被应用到状态机的日志条目索引值（初始化为 0，持续递增）</td></tr></tbody></table><p><strong>在leader里面经常改变的：</strong></p><p>（选举后重新初始化）</p><table><thead><tr><th>状态变量</th><th>说明</th></tr></thead><tbody><tr><td>nextIndex[]</td><td>对于每⼀个服务器，需要发送给他的下⼀个日志条目的索引值（初始化为领导人最后索引值加1）</td></tr><tr><td>matchIndex[]</td><td>对于每⼀个服务器，已经复制给他的日志的最高索引值</td></tr></tbody></table><h4 id="AppendEntries-RPC（追加待同步日志-RPC）">AppendEntries RPC（追加待同步日志 RPC）</h4><p>由 Leader 负责调用来复制日志（5.3）；也会用作心跳机制（5.2）</p><p><strong>传入参数：</strong></p><table><thead><tr><th>状态变量</th><th>说明</th></tr></thead><tbody><tr><td>term</td><td>Leader的任期号</td></tr><tr><td>leaderId</td><td>Leader的 id，以便于跟随者重定向请求</td></tr><tr><td>prevLogIndex</td><td>新的日志条目紧随之前的索引值</td></tr><tr><td>prevLogTerm</td><td>prevLogIndex 条目的任期号</td></tr><tr><td>entries[]</td><td>准备存储的日志条目（表示心跳时为空；⼀次性发送多个是为了提高效率）</td></tr><tr><td>leaderCommit</td><td>Leader已经提交的日志的索引值</td></tr></tbody></table><p><strong>返回值：</strong></p><table><thead><tr><th>状态变量</th><th>说明</th></tr></thead><tbody><tr><td>term</td><td>当前的任期号，用于Leader去更新自己</td></tr><tr><td>success</td><td>跟随者包含了匹配上 prevLogIndex 和 prevLogTerm 的日志时为真</td></tr></tbody></table><p><strong>接收者实现：</strong></p><ol><li>如果 term &lt; currentTerm 就返回 <code>false</code> （5.1 节）</li><li>如果日志在 <code>prevLogIndex</code> 位置处的日志条目的任期号和 <code>prevLogTerm</code> 不匹配，则返回 <code>false</code> （5.3 节）</li><li>如果现有的日志条目和新的产⽣冲突（索引值相同但是任期号不同），删除现有的和之后所有的条目 （5.3 节）</li><li>追加日志中尚未存在的任何新条目</li><li>如果 <code>leaderCommit</code> &gt; <code>commitIndex</code> ，令 commitIndex = min(leaderCommit, 新日志条目索引)</li></ol><h4 id="RequestVote-RPC（请求投票-RPC）">RequestVote RPC（请求投票 RPC）</h4><p>由候选人调用用来征集选票（5.2 节）</p><p><strong>传入参数</strong> ：</p><table><thead><tr><th>状态变量</th><th>说明</th></tr></thead><tbody><tr><td>term</td><td>候选人的任期号</td></tr><tr><td>candidateId</td><td>请求选票的候选人的 Id</td></tr><tr><td>lastLogIndex</td><td>候选人的最后日志条目的索引值</td></tr><tr><td>lastLogTerm</td><td>候选人最后日志条目的任期号</td></tr></tbody></table><p><strong>返回值</strong> ：</p><table><thead><tr><th>状态变量</th><th>说明</th></tr></thead><tbody><tr><td>term</td><td>当前任期号，以便于候选人去更新自己的任期号</td></tr><tr><td>voteGranted</td><td>候选人赢得了此张选票时为 true</td></tr></tbody></table><p><strong>接收者实现：</strong></p><ol><li>如果 term &lt; currentTerm 返回 <code>false</code> （5.2 节）</li><li>如果 <code>votedFor</code> 为 <code>null</code> 或者为 <code>candidateId</code>，并且候选人的日志至少和接受者一样新，那么就给它投票（5.2 节，5.4 节）</li></ol><h4 id="Rules-for-Servers（服务器的规则）">Rules for Servers（服务器的规则）</h4><p><strong>所有服务器</strong> ：</p><ul><li>如果 commitIndex &gt; lastApplied，那么就将 <code>lastApplied</code> 加一，并把 <code>log[lastApplied]</code> 应用到状态机中（5.3 节）</li><li>如果接收到的 RPC 请求或响应中，任期号 T &gt; currentTerm，那么就令 <code>currentTerm</code> 等于 <code>T</code>，并切换状态为 Follower（5.1 节）</li></ul><p><strong>Followers（跟随者）（5.2 节）：</strong></p><ul><li>响应来自候选人和 Leader 的 RPC 请求</li><li>如果选举超时，都没有收到现任 Leader 的 AppendEntries RPC，也没有给候选人投票：则自己转变成候选人。</li></ul><p><strong>Candidates（候选人）（5.2 节）：</strong></p><ul><li>在转变成候选人后就立即开始选举过程<ul><li>自增当前的任期号（<code>currentTerm</code>）</li><li>给自己投票</li><li>重置选举超时计时器</li><li>发送 RequestVote RPC 给其他所有服务器</li></ul></li><li>如果接收到大多数服务器的选票，那么就变成 Leader</li><li>如果接收到来自新的 Leader 的 AppendEntries RPC，转变成 follower</li><li>如果选举过程超时，再次发起一轮选举</li></ul><p><strong>Leader（领导人）：</strong></p><ul><li>一旦成为Leader：发送初始的空 AppendEntries RPCs（心跳）给每个服务器；在空闲期间重复发送，防止选举超时（5.2 节）</li><li>如果接收到来自客户端的请求：附加条目到本地日志中，在条目被应用到状态机后响应客户端（5.3 节）</li><li>如果一个 follower 最后日志条目的索引值 index ≥ nextIndex，那么：使用 AppendEntries RPC 发送从 <code>nextIndex</code> 开始的所有日志条目：<ul><li>如果成功：更新相应跟随者的 <code>nextIndex</code> 和 <code>matchIndex</code></li><li>如果 AppendEntries 因为日志不一致而失败，减少 <code>nextIndex</code> 并重试</li></ul></li><li>如果存在一个满足 N &gt; commitIndex 的 N，并且大多数的 matchIndex[i] ≥ N 成立，并且 log[N].term == currentTerm 成立，那么令 commitIndex = N （5.3 和 5.4 节）</li></ul><h4 id="关键特性">关键特性</h4><table><thead><tr><th>特性</th><th>解释</th></tr></thead><tbody><tr><td>选举安全</td><td>对于一个给定的任期号，最多只会有一个 Leader 被选举出来（5.2 节）</td></tr><tr><td>Leader 只追加</td><td>Leader 绝对不会删除或者覆盖自己的日志，只会增加（5.3 节）</td></tr><tr><td>日志匹配特性</td><td>如果两个日志在相同的索引位置的日志条目的任期号相同，那么我们就认为这个日志从头到这个索引位置之间全部完全相同（5.3 节）</td></tr><tr><td>领导人完全特性</td><td>如果某个日志条目在某个任期号中已经被提交，那么这个条目必然出现在更大任期号的所有领导人中（5.4 节）</td></tr><tr><td>状态机安全特性</td><td>如果一个 Leader 已经在给定的索引值位置的日志条目应用到状态机中，那么其他任何的服务器在这个索引位置不会提交一个不同的日志（5.4.3 节）</td></tr></tbody></table><h3 id="5-1-Raft-基础">5.1 Raft 基础</h3><p>一个 Raft 集群通常包含 5 个节点，能容忍 2 个节点宕机。</p><p><strong>Raft 集群的服务器都处于三个状态之一：</strong></p><ul><li><strong>Leader</strong> <strong>：只有一个，响应所有客户端请求</strong></li><li><strong>Follower</strong> <strong>：其余都是，不发送只响应 Leader 或 Candidate 的请求。若客户向其请求，会重定向到 Leader。</strong></li><li><strong>Candidate</strong> <strong>：选举新 Leader 时使用（5.2）</strong></li></ul><p><img src="https://pic3.zhimg.com/80/v2-b37458496c3b52b1b92f3ca38dd7b5ee_720w.webp" alt=""></p><p>服务器状态。Follower 只响应来自其他服务器的请求。如果 Follower 接收不到消息，那么他就会变成 Candidate 并发起一次选举。获得集群中大多数选票的 Candidate 将成为 Leader。在一个任期内，Leader 保持身份直到自己宕机。</p><p>Raft 把时间分割成任意长度的 <strong>任期（term）</strong> ，用 <strong>连续递增整数编号</strong> ，任期开始即选举。Raft 保证一个任期只有一个 Leader。在某些情况下，一次选举无法选出 leader，这个时候这个任期会以没有 leader 而结束。同时一个新的任期（包含一次新的选举）会很快重新开始。</p><p><img src="https://pic1.zhimg.com/80/v2-292861fa0ecc898d223b59fafd239a04_720w.webp" alt=""></p><p>时间被划分成一个个的任期（term），每个任期开始都是一次选举。在选举成功后，领导人会管理整个集群直到任期结束。有时候选举会失败，那么这个任期就会没有领导人而结束。任期之间的切换可以在不同的时间不同的服务器上观察到。</p><p>任期编号在 Raft 算法中充当逻辑时钟，每个节点都储存当前任期号， <strong>节点之间通信会交换任期号</strong> ，当一个节点：</p><ul><li>当前任期号比其他节点小，更新自己的任期号</li><li>Leader 或 Candidate 发现自己任期号过期，立即转为 Follower（也就是放弃成为Leader的机会）</li><li>收到过期的任期号请求，拒绝请求。</li></ul><p><strong>节点之间通信使用远程过程调用（RPCs）</strong> ，包含两种（第7节还增加了<strong>第三种传送快照</strong>的）：</p><ul><li><strong>请求投票（RequestVote） RPCs</strong>：Candidate 在选举期间发起（5.2）</li><li><strong>追加条目（AppendEntries）RPCs</strong>：Leader 发起，用于复制日志和心跳（5.3）</li></ul><p>当节点没有及时的收到 RPC 的响应时，会进行重试，而且节点之间都是以并行的方式发送 RPC 请求，以此来获得更好的性能。</p><h3 id="5-2-Leader-选举">5.2 Leader 选举</h3><ul><li><strong>服务器启动时所有节点都是 Follower</strong> 。<ul><li>Follower 一段时间没接收到消息即 <strong>选举超时</strong> ，发起新选举。</li><li>Leader 周期性发送 <strong>心跳包（不含日志的 AE RPC）</strong> 给所有 Follower 来维持自己地位。</li><li>Follower 只要能收到 Leader 或 Candidate 的 RPC 就保持当前状态。</li></ul></li><li><strong>开始选举</strong> 。Follower 自增 <code>term</code>（任期号）并转为 Candidate，并行向其他节点发送 RV RPC 等待给自己投票。<ul><li>等待时 <strong>收到 Leader 的心跳</strong> ，且心跳中的任期不小于自己的当前任期，则自己变为 Follower。若小于自己的任期，则拒绝并保持 Candidate。</li><li>如果同时出现多个 Candidate，选票可能被瓜分， <strong>没有人得到多数选票</strong> 。则等待超时后重新选举。</li><li>Raft 使用 <strong>随机选举超时时间</strong> （例如 150-300 毫秒）防止多次无人上任。每个节点 <strong>开始选举时重制超时时间</strong> 。可以让多数情况只有一个节点超时，进入下一轮赢得选举。</li></ul></li><li><strong>获得多数选票的 Candidate 变为 Leader</strong> 。<ul><li>每个节点在一个任期内，按先来先服务（5.4节还有额外限制） <strong>最多为一个 Candidate 投票</strong> 。</li><li>成为 Leader 后向其他节点发送心跳建立权威。</li></ul></li></ul><h3 id="5-3-日志复制">5.3 日志复制</h3><h4 id="5-3-1-Leader-日志复制流程">5.3.1 Leader 日志复制流程</h4><ul><li>把客户端请求指令追加到日志，然后并行发 AE RPC 给其他节点让其追加日志。</li><li>在日志被其他节点<strong>安全复制</strong>后（多数节点已复制），Leader 应用该指令到状态机并返回结果给客户端。</li><li>如果中途出现问题，Leader 会不断重复 AE RPC（甚至已回复客户端后）直到所有 Follower 都追加了该日志。</li></ul><h4 id="5-3-2-日志提交">5.3.2 日志提交</h4><ul><li>一条日志包含<strong>当前任期号</strong>和 <strong>一条指令</strong> ，也都有一个整数<strong>索引</strong>来表明它在日志中的位置。</li><li>Leader 决定什么时候能把日志安全应用到状态机，这样的日志条目为 <strong>已提交</strong> （ <strong>committed</strong> ）。Raft 保证所有已提交日志都是持久化并最终被所有状态机执行。</li><li>Leader 把日志设为已提交后，还需要 <strong>通知 Follower 应用日志到状态机</strong> ，这个通知通过下一次 AE RPC（也许是心跳）附加 <code>commitIndex</code>。</li><li>日志条目<strong>复制到大多数节点上</strong>时，就是 <strong>已提交</strong> ，且 Leader 中当前条目 <strong>之前的日志也都已提交</strong> ，包括其他 Leader 创建的条目（5.4）。<strong>Leader 记录最大已提交索引</strong> <code>leaderCommit</code>，并放进所有 AE PRCs，其他节点由此得知 Leader 已提交位置，并按日志顺序应用到自己的状态机。</li></ul><p><img src="https://pic4.zhimg.com/80/v2-6d1bfe856121e8b633625c2e4fb3e75f_720w.webp" alt=""></p><p>日志由序号标记的条目组成。每个条目都包含创建时的任期号和一个状态机需要执行的指令。一个条目当可以安全的被应用到状态机中去的时候，就认为是可以提交了。</p><h4 id="5-3-3-日志一致性">5.3.3 日志一致性</h4><p>这样 Raft 能维持 <strong>日志的一致性</strong> （<strong>日志匹配特性</strong>）：</p><ul><li>在不同的日志中的两个条目拥有 <strong>相同的索引和任期号</strong> ，那么他们 <strong>存储了相同的指令</strong> 。</li><li>在不同的日志中的两个条目拥有 <strong>相同的索引和任期号</strong> ，那么他们 <strong>之前的所有日志条目也全部相同</strong> 。</li><li><strong>追加日志的一致性检查</strong> ：每次新条目 AE RPC 给 Follower，如果上一条索引任期不一致，则拒收新条目。所以 <strong>一旦 AE RPC 返回成功，说明 Follower 所有日志和 Leader 相同</strong> 。</li></ul><h4 id="5-3-4-日志不一致情况">5.3.4 日志不一致情况</h4><p>正常情况下一致性检查不会失败，能一直保持一致。 <strong>但是 Leader 在未完全复制日志时宕机会使日志不一致</strong> 。例如 Follower 可能没有新 Leader 有的条目，也可能有新 Leader 没有的条目，或者都有，如下图。</p><p><img src="https://pic3.zhimg.com/80/v2-4729931f5622ce01028d68169117ddaa_720w.webp" alt=""></p><p>当一个领导人成功当选时，跟随者可能是任何情况（a-f）。每一个盒子表示是一个日志条目；里面的数字表示任期号。跟随者可能会缺少一些日志条目（a-b），可能会有一些未被提交的日志条目（c-d），或者两种情况都存在（e-f）。</p><p>例如，场景 f 可能会这样发生：f 对应的服务器在任期2的时候是 Leader，它追加了一些日志条目到自己的日志中，一条日志还没提交就宕机了，但是它很快就恢复重启了，然后再在任期3重新被选举为 Leader，又追加了一些日志条目到自己的日志中，在这些任期2和任期3的日志还没有被提交之前，该服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p><h4 id="5-3-5-不一致的恢复">5.3.5 不一致的恢复</h4><p>Raft 中处理这种不一致方法是， <strong>Leader 强制 Follower 复制自己的日志，即覆盖 Follower 中所有冲突日志</strong> （安全性在5.4）。</p><p>Leader 找到最后和 Follower 一致的地方，删除 Follower 之后的冲突日志，发送自己的日志附加给 Follower。这些操作 <strong>在 AE RPCs 一致性检查时完成</strong> ：</p><ul><li>Leader 对每个 Follower 维护下一个需发送的条目索引 <code>nextIndex</code>，在刚上任时初始化为最新日志索引+1。</li><li><strong>Follower 日志不一致则拒绝 AE PRC</strong> ，Leader <strong>减小</strong> <code>nextIndex</code> <strong>重试直到成功</strong> ，Follower 删除冲突日志并追加 Leader 日志。日志即保持一致。<br>这里可以优化，Follower 拒绝时返回冲突任期号的最早地址，Leader 下次就可以越过同任期号的冲突。但是此优化不一定有必要，因为实际很少发生。</li></ul><p>所以  <strong>Leader 无需特殊操作就能恢复一致性</strong> ，Leader 也从不会覆盖删除自己的日志（图3 Leader 只追加特性）。</p><p>日志复制机制展示了一致性特征：</p><ul><li>只要<strong>大部分的机器是工作的</strong>就能正常复制日志和应用保证可用性；</li><li>一条指令大多数节点可一轮 RPC 完成，<strong>小部分慢节点不影响整体性能</strong>。</li></ul><h3 id="5-4-安全性">5.4 安全性</h3><p>目前为止所讨论的机制并不能充分地保证每一个状态机会按相同的顺序执行相同的指令。比如说，一个 follower 可能会进入不可用状态，在此期间，leader 可能提交了若干的日志条目， <strong>然后这个 follower 可能被选举为新的 leader 并且用新的日志条目去覆盖这些日志条目</strong> 。这样就会造成不同的状态机执行不同的指令的情况。</p><p>故需 <strong>增加选举限制</strong> ，保证图 3 中的领导人完整性，即 <strong>Leader 一定包含所有已提交日志条目</strong> 。</p><h4 id="5-4-1-选举限制">5.4.1 选举限制</h4><p>某些一致性算法中需要额外复杂机制把缺少的日志传给 Leader。但是 Raft 保证 Leader 本来就有所有日志，所有日志都是单向从 Leader 传出去。</p><p>Raft 在等待投票时，RV PRC 包含 Candidate 的日志信息， <strong>投票人会拒绝日志没有自己新的 Candidate 的投票请求</strong>。</p><p>投票人 <strong>比较最后一条日志的索引值和任期号</strong> ：</p><ul><li>任期号不同，则任期号大的比较新</li><li>任期号相同，索引值大的（日志较长的）比较新</li></ul><h4 id="5-4-2-提交之前任期内的日志条目">5.4.2 提交之前任期内的日志条目</h4><p>（本小节是一种错误情况）</p><p>前面介绍，一旦当前任期内的某个日志条目以及存储到过半的服务器节点上，Leader 就知道此日志在自己任期已提交。</p><p>但  <strong>Leader 可能在提交之前崩溃</strong> ，新 Leader 不知道保存在多数节点的的条目是否提交。例如下图，存在多数节点的老日志仍可能被覆盖。</p><p><img src="https://pic3.zhimg.com/80/v2-ff671ae206a55470d2814e77e5eaed12_720w.webp" alt=""></p><ul><li>在(a)中，S1是Leader，复制了索引位置2的日志条目给S2，这时还没过半。</li><li>在(b)中，S1宕机了，然后S5在任期3中通过S3、S4和它自己的投票赢得了选举，然后从客户端接收了一条不一样的日志条目放在了索引位置2上面。</li><li>在©中，S5宕机了，S1重启，此时S1和S2都可能成为leader，假如 S1贏得选举，然后 S1继续复制它之前在任期2中放在索引2上的日志条目。此时，来自任期2的那条日志已经被复制到了集群中过半的节点上了，但是它还没被提交。</li><li>情况一，在(d)中，假如S1在提交日志之前宕机了，然后S5重启，这个时候S5最后的日志条目上的任期号比S2、S3和S4都大，所以它可以获得到S2、S3、S4和自己的投票成功当选leader。S5当选leader后，它就继续复制在任期3期间存储在索引位置2上的日志条目，那么该日志条目就会覆盖之前引复制在节点S1、S2、S3索引2处的日志中 。</li><li>情况二， 在(e)中，如果在宕机之前，S1在自己任期内复制了日志条目到人多数机器上。那么S5就不可能贏得选举，这种情况下，之前的所有日志也被提交了。</li></ul><p>所以 Raft 对日志提交条件增加一个<strong>额外限制</strong>： <strong>Leader 在当前任期至少有一条日志被提交</strong> （即超过半数节点复制），如图 8 中的(e)所示。而©中并没有提交4任期的日志。</p><p>所以<strong>新上任的 Leader 在接受客户写入命令前先提交一个 no-op（空命令）</strong>，携带自己任期号的日志复制到多数节点，这样能保证选举限制成立。</p><h4 id="5-4-3-安全性证明">5.4.3 安全性证明</h4><p><img src="https://pic3.zhimg.com/80/v2-387f6e83ddbeaadbe549a262bae5d166_720w.webp" alt="img"></p><p><strong>假设：</strong></p><p>假设任期 T 的 leaderT 在任期内提交了一个日志条目，但是该日志条目没有存在未来某些任期的 leader 中，假设 U 是大于 T 的没有存储该日志条目的最小任期号，处在任期 U 的 leader 称为 leaderU。</p><p><strong>反证法论证：</strong></p><ol><li>因为 leader 从来不删除或重写自己的日志条目，所以如果一个已提交的日志要做到不存在未来的 leaderU 中的话，那么它只可能在 leaderU 选举的过程中被丢失。</li><li>leaderT 将该日志复制给了集群中过半的节点，leaderU 从集群中过半的节点得到了投票。因此，至少有一个节点（这里称它为 voter）同时接收了来自 leaderT 的日志条目并且给 leaderU 投票了。</li><li>voter 必然在给 leaderU 投票之前就已经接收了这个已经提交的日志条目了。否则，它就会拒绝来自 leaderT 的 AppendEntries RPC 请求，因为如果它在给 leaderU 投票之后再接收条目的话，那么它的当前任期号会比 T 大。<br>译者注：因为要举行 Leader election 的话需要开一轮新的任期，这个时候前一轮任期已经结束了。我们这里假设了 T &lt; U，上述所说的已提交日志条目是在任期 T 中的，如果 voter 先投票的话，那么就说明它已经进入了任期 U 了，而 U &gt; T，voter 是不可能接受 leaderT 的 AppendEntries 请求的。</li><li>而且，voter 在给 leaderU 投票的时候，它依旧保有该日志条目，因为任何 U、T 之间的 leader 都包含该日志条目（因为我们前面假设了 U 是大于 T 的没有存储该日志条目的最小任期号），而且 leader 从来不会删除条目，并且 follower 只有再跟 leader 冲突的时候才会删除条目。</li><li>该投票者把自己的选票投给 leaderU 的时候，leaderU 的日志至少跟 voter 一样新（可以更新），这就导致了以下的两个矛盾之一了。</li><li><strong>第一个矛盾：如果 voter 和 leaderU 最后一个日志条目的任期号相同的话，那么 leaderU 的日志至少和 voter 的一样长，所以 leaderU 的日志一定包含 voter 日志中的所有日志条目。 这是一个矛盾，因为 voter 包含了该已提交的日志条目，所以 leaderU 必定也包含该日志条目，而前面我们假设了 leaderU 是不包含的，这就产生了矛盾。</strong></li><li><strong>第二个矛盾：如果不是上面描述的情况的话，那么 leaderU 最后一个日志条目的任期号必然需要比 voter 的更大。此外，它还比 T 要大，因为 voter 拥有在任期号为 T 提交的日志条目，所以 voter 最后一个日志条目的任期号至少为 T。创建了 leaderU 的最后一个日志条目的之前的 leader 一定已经包含了该已被提交的日志条目（因为我们上面假设了 leaderU 是第一个没有该日志条目的 leader）。所以，根据日志匹配特性，leaderU 一定也包含了该已被提交的日志条目，这样也产生了矛盾</strong> 。</li><li>上述讨论就证明了假设是不成立的。因此，所有比 T 大的任期的 leader 一定包含了任期 T 中提交的所有日志条目。</li><li>日志匹配特性保证了未来的 leader 也会包含被间接提交的日志条目，如图中的索引 2。</li></ol><p>通过 leader 的完整性特性，我们就可以证明状态机安全特性了，即如果某个节点已经将某个给定的索引处的日志条目应用到自己的状态机里了，那么其他的节点就不会在相同的索引处应用一个不同的日志条目。在一个节点应用一个日志条目到自己的状态机中时，它的日志和 leader 的日志从开始到该日志条目都是相同的，并且该日志条目必须被提交。现在考虑一个最小的任期号，在该任期中任意节点应用了一个给定的最小索引上面的日志条目，那么 Log 的完整性特性就会保证该任期之后的所有 leader 将存储相同的日志条目，因此在后面的任期中应用该索引上的日志条目的节点会应用相同的值。所以，状态机安全特性是可以得到保证的。</p><p>因为 Raft 要求服务器节点按照日志索引顺序应用日志条目，再加上状态机安全特性，这样就意味着我们可以保证所有的服务器都会按照相同的顺序应用相同的日志条目到自己的状态机中了。</p><h3 id="5-5-Follower-和-Candidate-崩溃">5.5 Follower 和 Candidate 崩溃</h3><p>前面都是讨论 Leader 崩溃，Follower和 Candidate 崩溃后的处理方式简单的多，<strong>Raft 只需要不断重试发送 RPCs</strong> 即可，崩溃重启后再执行 RPC。</p><p>Raft 的 RPCs 都是幂等的，重试不会产生问题。如果 Follower 发现 AE RPC 中的日志已经有了，它直接忽略这个请求。</p><h3 id="5-6-时间和可用性">5.6 时间和可用性</h3><p>Raft 的要求之一就是 <strong>安全性不能依赖时间</strong> ：整个系统不能因为某些事件运行的比预期快一点或者慢一点就产生了错误的结果。</p><p>但可用性不可避免要依赖时间，最关键在于 Leader 选举，需要满足如下时间要求：</p><p>broadcastTime&lt;&lt;electionTimeout&lt;&lt;MTB</p><ul><li><strong>广播时间（broadcastTime）</strong>：一个节点并行发送 RPCs 给其他节点并接收响应的平均时间<ul><li>应比选举超时时间小一个数量级才能保证稳定的心跳。</li><li>广播时间大约是 0.5 毫秒到 20 毫秒，取决于存储的技术</li></ul></li><li><strong>选举超时时间（electionTimeout）</strong>：选举超时时间限制。随机化使之难以瓜分选票。<ul><li><strong>只有选举超时时间是我们自己选择的</strong> 。可能需要在 10 毫秒到 500 毫秒之间。</li><li>应比平均故障时间小几个数量级。Leader 崩溃后系统将在一个选举超时时间中不可用，此情况应很少出现。</li></ul></li><li><strong>平均故障间隔时间（MTBF）</strong>：一个节点两次故障之间的平均时间。<ul><li>大多数服务器平均故障时间在几个月甚至更长，很容易满足时间的需求。</li></ul></li></ul><h2 id="6-集群成员变化">6. 集群成员变化</h2><p>到目前为止，我们都假设集群的配置（参与共识算法的服务器节点集合）是固定不变的。但是在实际情况中，我们有时候是需要去改变集群配置的，比如说在服务器崩溃的时候去更换服务器或者是更改副本的数量。尽管可以通过下线整个集群，更新所有配置，然后重启整个集群的方式来实现这个需求，但是这会导致集群在更改过程中是不可用的。另外，如果这个过程中存在一些操作需要人工干预，那么就会有操作失误的风险。为了避免这些问题，我们决定将<strong>配置变更自动化</strong>并将其纳入到 Raft 的共识算法中来。</p><h3 id="6-1-两阶段提交：Joint-Consensus">6.1 两阶段提交：Joint Consensus</h3><p>为了让配置修改机制安全，在转换的过程中同一个任期里 <strong>不能够存在两个 Leader 同时当选</strong> 。问题在于， <strong>一次性自动的转换所有服务器是不可能的</strong> ，任何切换方法都是不安全的，所以在转换期间 <strong>整个集群可能分裂成两个独立的多数</strong> 。</p><p><img src="https://pic2.zhimg.com/80/v2-526f64e7b228ef9c0d4a190450635511_720w.webp" alt=""></p><p>直接从一种配置转到新的配置是十分不安全的，因为各个机器可能在不同时候进行转换。在中间位置 Server1 可以通过自身和 Server2 的选票成为 leader（满足旧配置下收到大多数选票的原则）；Server3 可以通过自身和 Server4、Server5 的选票成为 leader（满足新配置线，即集群有 5 个节点的情况下的收到大多数选票的原则）；此时整个集群可能在同一任期中出现了两个 leader，这和 Raft 协议是违背的。</p><p>为了保证安全性，配置更改必须使用 <strong>两阶段方法</strong> 。有些系统在第一阶段停掉旧的配置，集群就不能处理客户端请求；然后在第二阶段在启用新的配置。</p><p>在 Raft 中，集群先切换到一个过渡性配置，我们称之为  <strong>Joint Consensus</strong> （ <strong>联合共识</strong> ）；一旦联合共识被提交，那么系统就切换到新的配置上。</p><p><strong>Joint Consensus</strong> 是老配置和新配置的结合：</p><ul><li>日志条目被复制给集群中新、老配置的所有服务器。</li><li>新、旧配置的服务器都可以成为领导人。</li><li>达成一致（针对选举和提交）需要 <strong>分别在两种配置上获得大多数的支持</strong> 。</li></ul><p><strong>Joint Consensus</strong> 允许独立的服务器在不影响安全性的前提下，在不同的时间进行配置转换，还可以让集群在配置转换的过程中依然响应客户端的请求。</p><h3 id="6-2-实现细节">6.2 实现细节</h3><p>集群配置在复制日志中以特殊的日志条目来存储和通信。下图展示了配置转换的过程：</p><ul><li>当一个 Leader 接收到一个改变配置从 C-old 到 C-new 的请求，他将创建联合共识的配置（图中的 C-old,new）并存储为一个新日志条目。</li><li>Leader 将 C-old,new 发给所有 Follower 进行复制。<ul><li>如果 C-old,new 被半数以上节点同步，则此配置已提交，之后遵循 Raft 安全性机制， <strong>只有拥有 C-old,new 日志条目的服务器才有可能被选为新 Leader</strong> 。</li><li>如果半数同步前 Leader 崩溃，新 Leader 可能有 C-old,new 也可能没有，若没有则退回老配置重试更新即可</li><li>在这一时期，C-new 不会有任何影响。</li></ul></li><li>C-old,new 已提交后，C-old 已不会产生影响，Leader 再创建和提交 C-new 就是安全的了。</li></ul><p>在整个过程中 <strong>没有哪个时候让 C-old 和 C-new 同时产生影响</strong> ，保证了安全性。</p><p><img src="https://pic3.zhimg.com/80/v2-b1ec6fef44bee3fb0132cd2dc1b0bbf6_720w.webp" alt="img"></p><h3 id="6-3-问题讨论">6.3 问题讨论</h3><ul><li>没有存储任何的日志条目新节点加入，复制日志条目需要时间，此时无法作为提交和选举决策的节点。<ul><li>新节点设置保护期，此期间<strong>以没有投票权身份加入到集群</strong>中来，不参加选举投票和日志提交决策，直到日志同步完毕。</li></ul></li><li>Leader 不是新配置成员。<ul><li>Leader 在 <strong>提交了 C-new 日志之后主动退位</strong> （回到 Follower 状态）。并且在 <strong>复制提交 C-new 时自己不算半数之一</strong> 。</li></ul></li><li>被移除的服务器未关闭，可能会扰乱集群。因为它们不再收到心跳，就会一直超时发起带有新任期号的选举。<ul><li>集群中节点在 <strong>未达到选举超时时间前，不响应 RV RPC</strong> 。即如果当前 Leader 能够在超时时间内发送心跳，Follwer 就能确认当前 Leader 存在而不响应新的投票请求。</li></ul></li></ul><h2 id="7-日志压缩">7. 日志压缩</h2><h3 id="7-1-快照基本思路">7.1 快照基本思路</h3><p>日志不能无限增长， <strong>Snapshotting</strong> （ <strong>快照</strong> ）是最简单的压缩方法。在快照系统中，整个系统的状态都以快照的形式写入到稳定的持久化存储中，那个时间点之前的日志全部丢弃。</p><p><strong>增量压缩</strong> ，例如<strong>日志清理</strong>或者<strong>日志结构合并树</strong>也可行，这些方法每次只对一小部分数据进行操作，分散了负载压力。首先，选择一个已经积累的大量已经被删除或者被覆盖对象的区域，然后重写那个区域还活跃的对象，之后释放那个区域。</p><p>增量压缩需要增加复杂的机制来实现，而快照总是简单操作整个数据集合，简化了这个问题。日志清除方法需要修改 Raft，但是 <strong>状态机可以使用和快照相同的接口实现 LSM tree（日志结构合并树）</strong> 。</p><p><img src="https://pic1.zhimg.com/80/v2-fc71344c00549641181f094868590834_720w.webp" alt=""></p><p>上图展示了 Raft 中快照的基本思路：</p><ul><li><strong>每个服务器独立的创建快照</strong> ，只包括已经被提交的日志。大部分由状态机将当前状态写入到快照中，也包括少量元数据：</li><li><code>lastIncludedIndex</code>：被快照取代的最后的条目在日志中的索引值（状态机最后应用的日志）</li><li><code>lastIncludedTerm</code>：该条目的任期号</li></ul><p>保留这些数据是为了支持快照后第一个 AE RPC 时的一致性检查，因为这个条目需要前一日志条目的索引值和任期号。</p><ul><li>为了支持集群成员更新（第 6 节），快照中也将 <strong>最后的集群配置作为最后一个状态条目存下来</strong> 。一旦服务器完成一次快照，他就可以删除最后索引位置之前的所有日志和快照了。</li></ul><h3 id="7-2-InstallSnapshot-RPC">7.2 InstallSnapshot RPC</h3><p>Leader 必须偶尔 <strong>通过 RPC 发送快照给一些落后的 Follower</strong> 。一般发生于当 Leader 已经删除下一条需要发送给某 Follower 的日志条目的时候。例如一个运行非常缓慢的 Follower 或者新加入集群的服务器（第 6 节），这时让这个 Follower 更新到最新的状态的方式就是通过网络把快照发送给他们。</p><p>当 Follower 接收到 IS RPC 时，自己决定对于已经存在的日志该如何处理。</p><ul><li>通常快照会 <strong>包含没有在接收者日志中存在的信息</strong> 。此时跟随者 <strong>丢弃其整个日志，全部被快照取代</strong> ，即使包含与快照冲突的未提交条目。</li><li>如果接收到的 <strong>快照是自己日志的前面部分</strong> （由于网络重传或者错误），那么被快照包含的条目将会被全部删除，但是 <strong>快照后面的条目仍然有效，必须保留</strong> 。</li></ul><p><a href="https://imgse.com/i/pSu1L80"><img src="https://s1.ax1x.com/2023/01/12/pSu1L80.png" alt="pSu1L80.png"></a></p><p>由 Leader 调用，将快照的分块发送给 Follower。Leader 总是按顺序发送分块。</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>领导人的任期号</td></tr><tr><td>leaderId</td><td>领导人的 Id，以便于跟随者重定向请求</td></tr><tr><td>lastIncludedIndex</td><td>快照中包含的最后日志条目的索引值</td></tr><tr><td>lastIncludedTerm</td><td>快照中包含的最后日志条目的任期号</td></tr><tr><td>offset</td><td>分块在快照中的字节偏移量</td></tr><tr><td>data[]</td><td>原始数据</td></tr><tr><td>done</td><td>如果这是最后一个分块则为 true</td></tr></tbody></table><table><thead><tr><th>返回结果</th><th>解释</th></tr></thead><tbody><tr><td>term</td><td>当前任期号（currentTerm），便于领导人更新自己</td></tr></tbody></table><p><strong>接收者实现</strong> ：</p><ol><li>如果 term &lt; currentTerm 就立即回复</li><li>如果是第一个分块（offset = 0）就创建一个新的快照</li><li>在指定偏移量写入数据</li><li>如果 done = false，则继续等待更多的数据</li><li>保存快照文件，丢弃具有较小索引的任何现有或部分快照</li><li>如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复</li><li>丢弃整个日志</li><li>使用快照重置状态机（并加载快照的集群配置）</li></ol><h3 id="7-3-问题讨论">7.3 问题讨论</h3><p>这种快照的方式背离了 Raft 的强 Leader 原则，因为 Follower 可以在 Leader 不知情情况下创建快照，但是这是值得的。Leader 的存在，是为了解决在达成一致性的时候的冲突，创建快照的时候一致性已经达成，不存在冲突了，所以没有 Leader 也是可以的。数据依然是从 Leader 传给 Follower，只是Follower 可以重新组织他们的数据。</p><p>而只有 Leader 创建快照，发送给所有的 Follower 的方案有三个问题：</p><ul><li>浪费网络带宽并且延缓了快照处理的时间，Follower 已有快照所需信息显然更经济。</li><li>Leader 的实现会更加复杂。例如需要发送快照的同时并行的将新的日志条目发送给跟随者，这样才不会阻塞新的客户端请求。</li></ul><p>还有两个问题影响快照性能：</p><ul><li>什么时候应该创建快照？过于频繁会浪费大量的磁盘带宽和其他资源；频率太低要承受耗尽存储容量的风险，也增加了从日志重建的时间。<ul><li>当 <strong>日志大小达到一个固定大小的时候就创建一次快照</strong> 。如果这个阈值设置的显著大于期望的快照的大小，那么快照对磁盘压力的影响就会很小了。</li></ul></li><li>写入快照需要花费显著的一段时间，并且我们还不希望影响到正常操作，如何处理？<ul><li><strong>写时复制的技术</strong> ，这样新的更新就可以被接收而不影响到快照。具有函数式数据结构的状态机天然支持这样的功能。另外，操作系统的写时复制技术的支持（如 Linux 上的 fork）可以被用来创建完整的状态机的内存快照（我们的实现就是这样的）。</li></ul></li></ul><h2 id="8-客户端交互">8. 客户端交互</h2><p>这一节将介绍客户端是如何和 Raft 进行交互的，包括：</p><ul><li>客户端如何发现 Leader</li><li>Raft 如何支持线性化语义</li></ul><p>这些问题对于所有基于一致性的系统都存在，并且 Raft 的解决方案和其他的也差不多。</p><ul><li><strong>客户端发送所有请求都要给 Leader</strong> 。<ul><li>第一次通信会 <strong>随机联系一个节点</strong> ，如果不是 Leader ，会被拒绝并提供最近接收的 Leader 信息（AE RPC 包含 Leader 地址），即 <strong>重定向</strong> 。<br>如果 Leader 宕机，请求超时，客户重试即可。</li></ul></li><li><strong>Raft 的目标是要实现线性化语义</strong> （每次操作立即执行，在调用和收到回复之间只执行一次）<ul><li>若 Leader 提交了客户端的操作日志，在回复客户端之前宕机，客户端重试。此时该指令可能执行两次。<br>解决方案是 <strong>客户端对每条指令赋予唯一序列号，状态机接受的序列号被执行的指令直接返回结果</strong> 。</li></ul></li><li><strong>只读操作</strong>可以不需要记录日志，但是旧 Leader 响应客户端时可能已经卸任，此时返回的是脏数据。需要两个额外机制 <strong>保证不返回脏数据</strong> ：</li></ul><ol><li>Leader 必须有关于被提交日志的最新信息，<strong>刚上任时</strong>可能不知道哪些已提交，所以需要<strong>提交一个 no-op（空命令）</strong> 日志条目。</li><li>Leader 在响应选举请求前，检查自己是否已被卸任。只需要和集群中大多数节点交换一次心跳信息即可。</li></ol><p>可选项： <strong>Leader 可以通过心跳机制实现租约机制</strong> ，但是这种方法依赖时间来保证安全性（假设时间误差是有界的）。</p><h2 id="9-算法实现与评估">9. 算法实现与评估</h2><h2 id="10-相关工作">10. 相关工作</h2><h2 id="11-结论">11. 结论</h2><p>算法的设计通常以<strong>正确性、效率和简洁性</strong>为主要目标。虽然这些都是有价值的目标，但我们相信<strong>可理解性</strong>同样重要。在开发人员将算法转化为实际实现之前，其他任何目标都不能实现，而实际实现将不可避免地偏离和扩展发布的形式。除非开发人员对算法有深刻的理解，并能对算法有直观的认识，否则他们很难在实现中保留算法理想的特性。</p><p>在本文中，我们讨论了分布式共识的问题，在这个问题上，一个被广泛接受但难以理解的算法：Paxos，多年来一直让学生和开发人员非常挣扎。我们开发了一种新的算法：Raft，我们已经证明它比 Paxos 更容易理解。我们也相信 Raft 会为系统建设提供更好的基础。将可理解性作为主要设计目标改变了我们处理 Raft 设计的方式。随着设计的进展，我们发现自己反复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提高了 Raft 的可理解性，而且使我们更容易证实它的正确性。</p><h1>LEC 5</h1><h2 id="模式">模式</h2><p>前面的系统都有单点故障：例如Coordinator、Master等等。因为要避免脑裂问题，因此并不设计成分布式的。</p><p>这种在一般情况下是没有问题的，出错的概率很小，即使出错了也可以在很短的时间内恢复回来。</p><p>Raft协议就是处理这种类型的问题，不允许单点故障产生，即使产生了也会更快恢复。</p><p>客户端访问两台服务器，一台得到了响应，另一台没有得到响应，如果另一台服务器挂掉了最好，但是如果仅仅是网络不通，会造成网络分区的问题，也就是脑裂，导致服务器不一致。因此前面的方案中都使用单点服务器的方式。</p><h2 id="网络分区问题">网络分区问题</h2><p>处理原则：少数服从多数</p><p>客户端的操作需要在大多数服务器都成功，否则一直等待恢复，这样可以实现强一致性</p><p>大多数：全部服务器，无论是开机的还是停机的，需要获得一半以上的服务器同意</p><p>两种前协议：Paxos和View-stamped replication</p><h2 id="Raft">Raft</h2><h3 id="构建复制状态机">构建复制状态机</h3><p><a href="https://imgse.com/i/pSUHKcd"><img src="https://s1.ax1x.com/2023/01/28/pSUHKcd.md.png" alt="pSUHKcd.md.png"></a></p><p>步骤：</p><ol><li>客户端发送操作给Leader的K/V服务器</li><li>K/V服务器将操作传递给Raft</li><li>Raft写入日志</li><li>Raft与其他服务器通信传送日志</li><li>其他服务器发送响应给Leader</li><li>Leader提交操作（其他的Followers需要等到下一次交互才确认前面的操作并提交）</li><li>操作按照顺序传送到K/V服务器</li><li>K/V服务器执行操作</li><li>Leader返回操作结果给客户端</li></ol><p>如果失败，需要选举新的Leader，重试操作</p><h3 id="日志">日志</h3><h4 id="为什么需要日志？">为什么需要日志？</h4><p>K/V服务器是保留操作表的，为什么还需要日志呢？</p><ul><li>重传：Leader发送的时候可能会丢失，因此Leader必须保留所有的日志条目从而具有重传的能力</li><li>顺序：每一个操作需要按照顺序传送，日志可以非常方便做到</li><li>持久化：服务器都有可能挂掉，因此需要持久化保留所有的操作</li><li>空间：需要空间进行一些试探性的操作，日志可以很方便做到</li></ul><p>最终需要保证日志在所有的服务器上都是相同的</p><h4 id="日志基本结构">日志基本结构</h4><p>日志条目包括序号、操作和Leader的任期（隐含表示了这个日志条目是哪个Leader追加的）</p><h3 id="选举Leader">选举Leader</h3><p>Follower如果接收不到Leader发送的周期性的心跳信号，就认为Leader挂掉了，开始选举Leader</p><p>具体实施：Follower自己有计时器，如果在一段的时间之内既没有接收到新的日志条目，也没有接收到Leader的心跳信号，则认为选举超时，开始进行选举。</p><ol><li>增加任期号，并给自己投票</li><li>联系其他的服务器（包括Follower和Leader）</li><li>收到大多数的选票，成为Leader</li></ol><p>此时新的Leader的任期号要大于原来的Leader的任期号，如果此时客户端与旧的Leader进行交互，Leader给新的Leader发送了增加日志的请求，会被拒绝，发送给旧的Leader自己的任期号。旧的Leader发现任期号比自己大，不会再成为Leader。从而避免了脑裂的问题。</p><p>挑战：两个Follower几乎同时发起选举，选不出Leader（分裂选举）</p><p>因此设置<strong>选举超时时间</strong>，但是是随机的，如果选不出Leader，经过一段时间后就不会同时开始选举Leader，就可以最终选出Leader了。</p><h4 id="选举超时时间">选举超时时间</h4><ul><li>不能小于心跳信号的间隔时间</li><li>三到四次RPC的时间</li><li>随机值越大停机的时间越长，越小可能仍然会选举失败</li><li>250-300ms</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Distributed Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022年终总结</title>
    <link href="/2022/12/31/diary/diary20221231/"/>
    <url>/2022/12/31/diary/diary20221231/</url>
    
    <content type="html"><![CDATA[<p>2022年终总结</p><span id="more"></span><p>到了一年的末尾，伴着客厅的电视声音和窗外若有若无的鞭炮声，还是要写一点总结。</p><p>我本想用“高开低走”来对这一年做一个精炼的总结，虽然说目前确实是“低”的状态，可是年初似乎也并没有什么“高”的事情，故这个词语还是不怎么恰当。</p><p>回想去年的这个时候，应该是在科一招和两位同学一起跑赛车吧，当时虽然屋子里面很冷，心是火热的，幻想着这样的生活可以一直持续下去。今天屋子里面还是很冷，不同的是心也很冷，目前过的不怎么样，也看不到什么未来。</p><p>再回想几年前，已经想不起来什么印象深刻的事情了，可能大多数都是在准备考试吧hh。</p><p>现在我自己的状态，或许和2018年初是相同的，又或许是2019年，又或许不同，只是我自己的内心深处偏要找一个相同的历史时刻才能让我自己获得某种慰藉。</p><p>我不知道应该写些什么关于今年的事情，写一写可能又写到了感情生活上，而这是我现在最不愿触及的部分之一。</p><p>突然想起了五年前看到过的一篇文章，翻出来，最后就用它做一个总结吧：</p><p>小时候，过年是头等大事。我们家的人不多，但是和父母一起，准备小零食，准备年夜饭，包饺子，看春晚。年少时的我总觉得，日子一天天过去，没有开端也没有终结。</p><p>那时我总以为，过完了今天，明天还是一样的会来，过完了今年，还有明天这个时候的“今年”。可曾经那个心心念念的过年，曾经的那个“今年”，都像天上的云彩和海上的浪花一样，早已不知所踪。</p><p><strong>人不能两次踏进同一条河流，也不能，重新过一遍2022。</strong></p><p>季节流转，日升月落，星移斗转，世事如白衣苍狗。这一年有多少遗憾和侥幸，有多少悲恼和欣欢，多少披星染雾的启程和多少戴月荷锄的归途。新的一年终将随着初生的太阳喷薄而出，我们如同站在两个世界的边缘，愧疚地送别过去，紧张地等候未来。</p><p>我不愿意用一句“新年新气象”，就将过去一年的得失通通扫净，尽管它们终将消失在记忆的犄角旮旯。</p><p><strong>新的一年，不是一切归零的重新开局，也不是一成不变的延续。</strong></p><p>回头再看看2022，我们有伤感的时候，有无奈的时候，有纠结的时候，也有骄傲的时候。总结过去，才能展望未来。</p><p><strong>2023，不是新的开始，而是新的征程。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研一上学期闭卷三科目考试重点</title>
    <link href="/2022/12/27/UCAS/exam-final-summary/"/>
    <url>/2022/12/27/UCAS/exam-final-summary/</url>
    
    <content type="html"><![CDATA[<p>研一上学期闭卷三科目考试重点</p><span id="more"></span><h1>模式识别与机器学习</h1><p>25道选择题，5道大题（简答题与计算题结合在一起）</p><h2 id="2022-12-27-二班苏荔老师">2022.12.27 二班苏荔老师</h2><p>非监督学习：不考死记硬背的概念，看一下作业题的例子，比如给一些具体样本分布的图，如果使用KMeans聚类会怎么样，Kmeans的判别界面应该是一个中垂线，两个簇的中垂线，如果不是大小均匀的球体可能KMeans就不适合，如果是有疏有密的，一个椭球形的，是不是考虑基于混合高斯的模型，或者簇是一个不规则的形状，比如是字母S或者C型，甚至有的簇是一个同心圆的，最适合的聚类算法应该是什么样的，可以考虑一下基于密度的聚类是不是可以，基于密度的聚类有没有不适合的情况，包括基于层次聚类会遇到什么问题，结合一些实际的例子请大家分析一下。</p><p>降维：PCA每年都考，可能和前面讲K-L变换的知识结合起来，比如PCA为什么要先做零均值的平移，特征值的选择，为什么先做倒序的排序，选排在前面的特征值最大的几个特征值对应的特征向量来构成对应的变换核，基本原理希望掌握。后面的非线性降维，核PCA的主要思想是什么，先升维再降维，基于流形的非线性降维方法，说出一些经典方法的名字就行，不可能考太细。（前面讲了一些降维，这里不可能考大题，可以看看Fisher线性判别怎么做降维，选择最佳投影方向等等）</p><p>半监督学习：半监督学习是基于一些假设的，最基本的假设有哪些，不同的半监督算法各自基于什么假设？比如半监督的SVM应该是基于低密度分割的假设，半监督SVM里面有一些比较关键的参数，C1，C2等等，分别表达什么意思，C2很小表达对未标注样本错分的容忍度比较大，很大表示不容忍错分，每一个未标注样本也要分对，但是所有的样本都必须要严格分对这种也可能有问题，过拟合等等，过拟合怎么办呢？可以把模型参数调简单点，怎么让模型参数调简单？不同的模型方法不一样，比如半监督SVM就可以把C2调小一点，或者把C1调小也行，如果是神经网络可以让结构简单一点，层数和节点变少参数就变少，欠拟合怎么办，如何让模型变复杂，除了从模型参数上调，增加数据样本是不是一定有用？</p><p>概率图模型每年都会有大题，要么是考贝叶斯球判断条件独立性，或者大题问维特比解码，一般只考前向的推导。</p><p>集成学习只考经典的bagging和boosting两种，其他的不考，考的时候从基本原理出发，比如bagging的基本原理是降低方差，但是不能改变偏差，boosting主要是降低偏差，考的时候可能会给实际的例子去判断哪种更适用，比如模型的单个基学习器都是偏差比较高的情况，要把多个集成起来增加学习能力，到底是用boosting还是bagging，如果选择boosting，不同的基学习器的权重是完全一样的吗，谁的权重大，或者是boosting作迭代训练的时候，训练样本每一次的权重在迭代的时候是不是都要改变，为什么要让分错的样本权重更大，分对的样本下一次权重就调小，要知道这些基本的调节权重的原则。</p><p>人工神经网络只考基本原理和卷积神经网络，可能让你设计一个人工神经网络的结构，和前面几章的内容有结合，比如线性分类器，非线性分类器，两类分类的，多类分类的，都怎么来设计，能画出大概的结构，写出能用什么（激励？）函数就可以。卷积神经网络主要是考察基本原理，比如为什么卷积神经网络能够进一步降低（深度，参数量？）但是又不会降低性能。可能是基于局部连接和参数重用，池化等等技术，这几个技术的基本的动机是什么，是因为有一些很有判别力的局部模式，他是之前局部出现，并且能够在不同的位置出现，还有有的时候下采样也不会影响这种局部模式的识别。可能会问一些深度神经网络训练的时候遇到一些问题怎么解决，比如说层数很深的时候，会遇到梯度消失、梯度爆炸的问题，遇到问题怎么办呢，激活函数从sigmoid换成relu为什么这样能解决这个问题，比如说使用batch normalization也可以缓解梯度消失的问题，甚至还能带来一些正则化的效果，或者是残差网络的技术，将前层的信息引入进来，可能还带有一些集成学习的思想，把这些基本的原理说清楚。人工神经网络的训练可能也会遇到过拟合，模型的参数可能就过于复杂，除了简化模型的结构之外，还有什么其他的技术，比如是不是可以考虑添加正则化项，正则化也分为L1和L2，L1正则能让系数=0也能做特征选择，L2可以让参数趋向于变小，对整体的影响就变小了，相当于参数变简单了，也能防止过拟合，包括做数据增强，增加训练样本集尽可能让他多样化，也是可以增加模型的泛化能力，还有做梯度下降的时候收敛速度变慢怎么办，陷入局部极值点怎么办，一般是这种实际一些的问题</p><h2 id="2022-12-28-三班卿来云老师">2022.12.28 三班卿来云老师</h2><p>不考：</p><p>势函数、决策树、贝叶斯参数估计、后向算法、马尔科夫随机场、SMO、拉普拉斯平滑</p><p>没有证明题，但是会有一点公式推导</p><p>EM算法不作为重点考察，最多知道概念是拿来干什么的就行，是对含有隐含变量的模型做优化，不会考很细节的</p><p>零碎考点：</p><p>判别器有讲过贝叶斯风险，是每年都会考的，感知器算法、朴素贝叶斯、Fisher判别分析，都有可能考到的，K-L变换作特征提取或者后面的PCA，还有像LR，SVM，还有线性回归，另外就是机器学习一般的概念，过拟合、欠拟合应该怎么办，怎么判断模型处于哪种状态，正则的概念，可能放到多种模型中，都要能理解。</p><p>降维需要掌握的知识点：PCA是怎么做的，Fisher判别分析要会</p><p>Fisher判别分析是要考的但是不考计算，除了两类也要看一下多类的</p><p>深度学习有一道大题，偏简答性质的</p><p>HMM有计算题，判断独立性是选择题</p><p>概率图掌握贝叶斯球就可以，概率的分布表示还是要的</p><p>多类LR不需要特别掌握，知道有这回事就行，比如用softmax函数做最后一层就可以</p><p>多类分类问题在SVM或者LR可以转化为两两的分类问题，算术题，转成多少个需要知道</p><p>支持向量考的挺多的，给一个图，哪些点是支持向量，或者自己画图</p><p>偏差方差分解具体的证明不考，但是要知道泛化误差是三部分，会判断模型什么时候偏差比较大，什么时候方差比较大，应该怎么办</p><p>高斯判别分析今年没有大题，Fisher判别分析多看看</p><p>SVM软间隔硬间隔都会有</p><p>一般对线性回归、LR、SVM公式推导方面严一点，比如损失函数是怎么推导来的，极大似然估计是怎么回事，MAP估计是怎么样，这些基本概念需要掌握，SVM的模型推导可能少一些。SVM更多理解margin、支持向量、不同的C的影响等等、核函数，RBF核模型复杂度的参数是核函数的宽度，多项式核模型复杂度还有多项式的项数。</p><p>类内类间散度矩阵应该怎么算是要求掌握的，与Fisher是什么关系，但是不会考察具体的数值计算</p><p>多类感知器不考，感知器是有的</p><p>PCA没有计算，需要知道PCA的计算过程，另外目的和达到的效果也需要知道。首先要减均值，然后再算协方差矩阵作矩阵分解，或者是作SVD分解都可以，测试的过程也一样，目的是去掉各个维度之间的相关性</p><p>bagging知道功效和怎么做就行，是多个模型做平均，目的是偏差不变，降低模型的方差，boosting是降低模型的偏差，方差不变</p><p>聚类：比如像K均值，GMM，DBSCAN这三类聚类方法需要掌握他的特点，我们什么时候用哪种方法来做，选择题</p><p>降维：今年考的不是很多，稍微看一看就行</p><p>半监督学习：不会考的特别细，但是半监督学习是基于一些假设的，最基本的假设有哪些，不同的半监督算法各自基于什么假设？</p><p>概率图模型一方面考对于有向图模型，判断给定观测到某些节点的情况下，这个变量和那个变量是否独立，可以通过贝叶斯球的方式做，需要记忆贝叶斯球的规则，根据一个图模型把联合分布写出来，HMM要求掌握前向算法求观测概率和利用维特比算法求给定一个观测后最可能的隐含状态的序列</p><p>集成学习主要是bagging和boosting，要知道bagging的原理是通过对训练样本进行bootstrap采样，然后训练多个模型，最后对多个模型作平均，得到最后的融合模型。它的好处是可以降低模型的方差，偏差不变。boosting对于Adaboost的过程，比如一开始初始化的时候每个样本的权重相同，经过一轮迭代之后哪些样本的权重会增加，哪些样本的权重会减小，最后模型是怎么融合的，没有计算题，知道Adabooost的过程就可以。对于boosting一般的原理也要知道，每次迭代顺序的把一些模型加进去，最后一些子模型的加权平均是我们最后的集成模型，boosting的好处是降低模型的偏差，方差不变。</p><p>深度学习：知道神经元的结构（线性组合+激活函数），一个神经元可以起到一个什么样的作用，神经网络是把神经元组合起来，卷积神经网络为什么要局部连接，为什么要权重共享，这样做的基于对数据的假设是什么，局部连接我们认为是一个模式在一个比较小的范围内，而不是要看全局，权值共享是说不同位置可能都有这样的模式，这样做可以使得模型的参数变少，另外多层感知器很多层并不能带来性能提升，现在的模型采用哪些技术使得训练深度模型成为可能？比如说激活函数，sigmoid容易梯度消失，使用relu使得梯度消失的问题会减弱，这样网络层数可以更深，另外batch normalization会使得我们的训练会和好多因素（学习率、初始化）的要求没有那么高，这样也是一种技术，另外采用预训练网络作初始化也是一种方式，或者核初始化等等，也可以让模型的层数更深。另外Resnet，或者叫skip-connect，通过跳接的方式使得梯度消失的问题能减弱，使得模型可以很深很深甚至上千层。神经网络设计的时候也讲了一些其他的技术。不要求全部掌握，至少知道几点。为什么要用mini-batch的梯度下降，随机的梯度下降，有什么样的好处或者特点等等。</p><h2 id="2022-12-31">2022.12.31</h2><p>第一章：模式识别和机器学习我们并不是很区分它们，可以看成一个问题的两个方面</p><p>第二章：统计判别，主要是讲了错误率最小，错误率最小对应到分类问题等价于后验概率最大，后验概率怎么算需要大家一定掌握，后面也把风险带进来</p><p>第三章：判别函数，作判别的时候一种方式可以使用生成式分类器，高斯分布的贝叶斯分类器采用的实际上是生成式分类器，指的是我们的联合分布可以由先验和似然相乘得到，有了联合分布可以从联合分布进行采样从而得到新的数据，也就是我们知道数据的产生过程，因此叫做生成式分类器。朴素贝叶斯，高斯判别分析，概率图模型，HMM都属于生成式分类器。好处是因为我们对数据的产生过程有比较强的假设，如果我们的数据符合这个假设，通常用很少量的数据就能得到很好的模型，或者说收敛的比较快，缺点是如果数据不符合这个假设，模型的性能就很不好。另外是判别式分类器，就是直接对后验概率进行建模，或者是定义一个判别函数，根据判别函数的值判断是哪一个类别。像逻辑斯蒂回归，决策树，SVM，深度学习都是判别式的。</p><p>线性判别函数如何将多类分类任务转化成两类分类任务或者是直接用多类分类任务去做。线性判别函数处理的都是线性可分的问题，如果不是线性可分的需要用广义的线性判别函数，或者是分段线性判别函数实现。模式空间和权空间只是一些基本概念。重点掌握Fisher线性判别，协方差矩阵、类内类间，向量等都是怎么定义的，Fisher线性判别的准则是什么，都需要掌握，两类的情况，多类的情况，大家都去想想，感知器算法需要重点掌握，它是线性判别函数，只能在线性可分的时候可以使用，感知器多类也需要大家掌握。</p><p>第四章：特征选择是很重要的内容，但是不作为重点考察。特征提取重点掌握K-L变换，比较简单，实际也比较有用，PCA实际上和K-L变换就是一回事。需要知道K-L变换的目的和过程，做了K-L变换之后能达到一个什么样的效果。</p><p>第五章：期望风险：在没有见过的数据上的误差，也就是期望风险。结构风险：正则项，L1正则和L2正则，泛化误差的分解，证明过程不要求，结论要知道，用VC维计算泛化误差的上界，基本概念比较多</p><p>第六章：线性回归的损失函数，目标函数包括两部分，L1损失或者L2损失，负log似然损失，需要掌握似然是怎么定义的，由负log似然损失怎么推到了L2损失，L2损失的问题是对噪声比较敏感，因为是平方的关系，预测差距比较大的时候损失也比较大，可以采用L1损失，但是是不连续的，因此一般采用Huber损失，实际上是L1损失和L2损失的分段的情况。正则可以是L1正则或者L2正则，目的是为了限制模型的复杂度，L2会使得w的绝对值会缩小，也叫权重缩减，但是一般不为0。L1会为0，可以起到特征选择的作用。然后讲了逻辑斯蒂回归，是一个分类问题，直接计算后验概率，多类分类需要softmax函数，损失也是负log似然，只是称为交叉熵损失，推导的时候都是从负log似然推导过来的。然后生成式分类器，高斯判别分析和朴素贝叶斯，两种分类器的先验是相同的，两类是伯努利分布，多类是多项式分布，两者不同的地方是类条件的定义不一样，高斯是在给定类别的条件下是高斯分布，朴素贝叶斯是独立的，</p><p>第七章：SVM，考察的重点，需要掌握线性的SVM，核化的SVM，回归了解一下就行，首先要知道间隔的概念，硬间隔和软间隔的目标函数分别是什么，可以写成损失+正则的情况，合页损失+正则，什么样的样本是支持向量，了解原问题和对偶问题，核化也是很重要的，后面的PCA，包括逻辑斯蒂回归都可以核化，但是模型比较复杂，大家用的比较少，线性核，多项式核的复杂度体现在基数，RBF核的复杂度是核函数的宽度，软间隔的复杂度还有松弛因子C，概念需要掌握</p><p>第八章：聚类：重点掌握K均值，GMM，DBSCAN，知道聚类的过程，对什么样的数据比较适合，K均值每一个类的都是高斯，方差相同等等，GMM更宽泛，不球形，DBSCAN不要求每一类的具体形式，找密度最大的作为中心，还可以处理带有噪声的情况。</p><p>第九章降维：PCA就是K-L变换，目标是重构误差最小，MDS不作重点考察，非线性降维知道一些常用的非线性降维方法的做法就可以了</p><p>第十章半监督学习：重点掌握三种基本假设，半监督学习算法了解就行，想一下每一种算法的背后是基于哪些假设在做</p><p>第十一章概率图模型，考试时候主要是考察有向的图模型，无向图模型了解一下就行，给定一个概率图模型，能不能写出概率分布来，根据有向图模型，判断给定观测到某些节点的情况下，这个变量和那个变量是否独立，可以通过贝叶斯球的方式做，需要记忆贝叶斯球的规则，缺失的边实际上也蕴含了独立的关系，HMM要求掌握前向算法求观测概率和利用维特比算法求给定一个观测后最可能的隐含状态的序列。HMM的模型参数学习，全监督的用极大似然估计，隐含状态不知道用EM算法。</p><p>第十二章集成学习主要是bagging和boosting，要知道bagging的原理是通过对训练样本进行bootstrap采样，然后训练多个模型，最后对多个模型作平均或者投票，得到最后的融合模型。可以并行训练，它的好处是可以降低模型的方差，偏差不变。基学习器的选择可以选方差比较大的模型。比如随机森林里面选取的决策树就是选层数比较深或者叶子节点比较多的。或者多个神经网络进行。boosting是多个基学习器采用顺序的方式进行训练，不能并行训练，每一个新加入的学习器希望能纠正前面的学习器的一些错误，实现的时候每个基学习器都是一样的，融合的方式是加权平均，权重和每个基学习器是相关的。boosting的好处是降低模型的偏差，方差不变。因此基学习器可以比较简单，决策树就树比较浅。重点考察Adaboost的过程，需要掌握。</p><p>第十三章深度学习：知道神经元的结构（多个输入线性组合+激活函数得到输出），与人类神经元比较像，线性回归实际上也可以用一个神经元来表示，相当于激活函数是一个线性的激活函数（恒等映射函数）。逻辑斯蒂回归就相当于一个神经元+sigmoid函数，SVM也可以写成这样的形式。多层叠加就可以实现非常复杂的非线性函数的拟合。80年代层数不深，当时的训练方法有一些问题，sigmoid或者tanh会产生梯度消失的问题，relu可以解决梯度消失，计算简单。梯度消失是梯度传几层就没了，一个原因是激活函数，另外的原因是乘很多次，也会没了。神经网络之间的连接方式：全连接，每一个神经元都和其他的神经元相连。为了简化，图像可以采用卷积神经网络，通常只是局部连接，为什么要局部连接，因为图像里面一些局部的输入就可以判断模式的存在。为什么要权重共享，权值共享是说不同位置可能都有这样的模式，这样做可以使得模型的参数变少，计算量并不会减少。数据不满足这种特点不能使用卷积做。另外多层感知器很多层并不能带来性能提升，现在的模型采用哪些技术使得训练深度模型成为可能？Resnet，或者叫skip-connect，通过跳接的方式使得梯度消失的问题能减弱，使得模型可以很深很深甚至上千层。另外batch normalization相当于做一个标准化，使得输入的范围的差异不至于这么大。相当于在神经网络里面增加了一个层，学习这个层的参数。会使得模型训练更快更稳定，性能更好。dropout使得某些输出是0，不往下传，相当于集成学习的高效的实现方式，主要使用在全连接层里面。另外讲了一些神经网络的训练技巧，基本算法是梯度下降，梯度爆炸就是乘多了很大很大，梯度的计算首先是利用网络结构进行反向传播，批处理梯度下降是所有的样本一起，算一次很慢，一般不采用，随机梯度下降是每一个只选取一个样本，比较快，但是受单个样本的影响比较大。梯度的方向可能是锯齿的形状。通常使用小批量梯度下降，两者取中间。走一步的步长叫做学习率，下降的方法不一定是梯度，因为鞍点可能不动，平滑的区域也不怎么动，因此考虑动量法，进行自适应调整。参数初始化也比较重要。另外关于抗过拟合的问题，每一层的节点很多，模型就非常复杂，需要抗过拟合。及早停止，监控验证集上的误差，正则，数据增广，收集更多的训练样本，但是收集样本需要费用，可以采用一些图像处理的方法。还有dropout。</p><p>非线性降维基本掌握流程就行</p><p>大题没有画模型结构图</p><p>RNN不作为重点考察内容</p><p>极大似然：给一个应用场景，写似然的式子，概率分布都写的，无非是取一个log然后对所有的样本求和</p><p>SVM二维计算量不大，侧重于概念，考了很多选择题</p><p>考试不涉及求矩阵的逆、特征值的具体计算</p><p>没有问概念的简答题</p><p>选择题重点：过拟合欠拟合、偏差方差、概率图、深度学习等等</p><p>MAP的概念需要知道，大题里面没有</p><p>LDA需要知道</p><p>K-L变换需要掌握过程，能达到什么目的，但是没有数值计算</p><p>逻辑斯蒂回归需要知道正则，损失函数的推导，实际上是负log似然，关于似然的计算，这个过程需要大家知道。</p><p>极大似然或贝叶斯求参数今年没有</p><p>线性回归逻辑斯蒂回归损失函数的推导需要掌握，+正则</p><p>Adaboost知道过程就行</p><p>核函数表示两个样本的相似度，常用的核函数，比如多项式核，RBF核，还有核函数控制模型复杂度的超参数，就差不多了</p><p>DBSCAN具体过程不考，需要知道对哪些数据合适</p><p>EM算法不考察</p><p>泛化误差不会考具体的公式，知道泛化误差的上界由两部分构成，一部分是和训练误差有关系，另外一部分是模型复杂度（VC维）有关系，是一个正关系还是反关系就行了</p><p>贝叶斯估计、高斯分布参数求解不作为大题考试内容，MLE的计算过程希望大家了解，考试可能不考</p><h1>高级人工智能</h1><p>20道选择题</p><p>3道简答题</p><p>3道综合应用题</p><h2 id="2022-11-17-罗平老师">2022.11.17 罗平老师</h2><p>确定性的知识：</p><p>命题逻辑：语法和语义，蕴含和形式推演</p><p>三种形式推演的系统：</p><ul><li>11条规则</li><li>归结原理：完备性和可靠性，计算机实现是一个搜索问题，联系前面的搜索算法考察</li><li>Modus Ponens规则：完备性和可靠性，Forward Chaining和Backward Chaining</li></ul><p>一阶谓词逻辑：与命题逻辑对应复习，不考证明</p><p>Logic Programming：一种新的编程的思路</p><ul><li>Logic Programming与正常的编程有什么差异？选择题</li><li>Prolog要能读得懂<ul><li>Prolog有时候会推出错误的答案，实现的时候并不可靠</li><li>有时候正确的答案也推不出来，也不完备</li></ul></li></ul><p>不确定性的知识：</p><p>模糊集合之间的运算，交并补、模糊关系、模糊关系的合成，用模糊逻辑表示自然语言</p><p>模糊逻辑比一阶谓词逻辑多了模糊谓词、模糊量词和模糊修饰词</p><h2 id="2022-12-29">2022.12.29</h2><p>深度学习部分：</p><p>受限玻尔兹曼机原理理解就可以了</p><p>卷积神经网络、循环神经网络用的比较多，对于具体模型来说，要了解模型的原理，为什么采用这种结构就可以</p><p>更倾向于概念</p><p>不会考公式，梯度下降应该熟练掌握的</p><p>综合应用题分三个小问题，每一个是一个方面，各自独立</p><p>A*树搜索和图搜索的最优性证明最好是了解一下</p><p>简答题是搜索方面的，搜索这些算法相应的原理了解一下就可以了</p><p>简答题不是要求证明的，没有证明题</p><p>简答题是单个题目</p><p>没有考公式推导</p><p>野人传教士问题，实际上是考你搜索问题的形式化描述，形式化描述了解的话应该是没问题的</p><p>对于GAN，基本概念和原理掌握，考试掌握基本原理就可以了</p><p>对于启发式搜索，主要是设计一个合适的启发式函数（可采纳性和一致性），针对实际问题用松弛问题的解来作为启发式函数就可以</p><p>综合应用题是神经网络相关</p><p>综合应用题有要求画神经网络结构的，说明具体采用的算法</p><p>选择题都是一些基本概念</p><h1>机器学习</h1><p>单选30题，每题1分</p><p>多选15题，每题1分</p><p>简答3题，每题5分</p><p>计算3题，每题10分</p><p>设计1题，每题10分</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
      <tag>Pattern Recognition and Machine Learning</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824 Distributed Systems-LEC 4 Primary-Backup Replication</title>
    <link href="/2022/12/18/6.824/Distributed-Systems-MIT-6.824-LEC-4/"/>
    <url>/2022/12/18/6.824/Distributed-Systems-MIT-6.824-LEC-4/</url>
    
    <content type="html"><![CDATA[<p>MIT-6.824（Spring 2022）LEC 4 Primary-Backup Replication</p><span id="more"></span><h1>Fault-Tolerant Virtual Machines 论文阅读</h1><p><a href="https://zhuanlan.zhihu.com/p/523109983">参考翻译</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/6.824/vm-ft.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="摘要">摘要</h2><p>通过提供故障容错性的虚拟机，我们实现了一个商业化的企业级系统，建立在复制一个主虚拟机的执行过程到另一个服务器上的备份虚拟机的基础上。系统很容易使用，同时保证了应用的性能<strong>仅有少于10%的降低</strong>。另外，为了让主VM和二级VM的执行活动保持一致，对于几个实际的应用而言，需要的数据带宽少于20Mbit/s，这也允许实现更长距离的故障容错的可能性。一种容易使用，在故障后自动恢复备份的商业化系统，在复制VM执行之前需要额外的组件。我们已经设计并且实现了这些额外的组件，并且解决了在支持VM运行企业级应用的时候，遇到的许多实际问题。</p><h2 id="1-简介">1. 简介</h2><p>一个实现故障容忍服务器的常见方法是<strong>主备机制</strong>，主服务器失败的同时另外一个备份服务器立即进行接管，此时对于外部客户端而言，故障就相当于被隐藏了起来，并且不会造成数据丢失。因此在任何时间，备份服务器的状态必须和主服务器几乎保持一致，在备份服务器上复制状态的一种方法是将主服务器的所有状态，包括<strong>CPU、memory、IO设备</strong>，连续地送给备份服务器。然而，这种发送状态的方法，尤其是涉及到内存中的变更，其需要的带宽非常大。</p><p>另一种可以用更少带宽复制服务器的方法类似于状态机。这种思路是将服务器建模为确定性的状态机，他们从相同的初始状态开始，并且确保以相同的顺序接收相同的输入请求，这样就能保持同步。因为大多数服务器或服务有一些不确定性的操作，因此必须使用额外的协调机制来确保主备同步。然而，需要保持主备一致性的额外信息数目，<strong>远远少于</strong>正在变更的主服务器上状态（主要是内存更新）的数目。</p><p>实现协调机制来确保物理服务器的确定性操作是困难的，尤其随着处理器频率增长。反之，一个运行在管理程序（hypervisor）上的VM，是一个实现状态机方法的很好的平台。 <strong>一个VM可以被当作一个定义好的状态机，它的操作是机器被虚拟化的操作（包括它所有的设备）</strong> 。和物理服务器一样，VM有相同的非确定性操作（例如读取时钟或发送中断），因此为了保持同步，额外的信息必须被发送给备份服务器。管理程序（hypervisor）有VM的<strong>全权控制权利</strong>，包括处理所有输入，因此它能够获得所有与主VM上的非确定性操作有关的必要信息，并且能正确地重放这些操作。</p><p>因此，这个状态机方法可以通过商业化软件上的VM来实现，它不需要硬件更改，允许在最新的微处理器上立刻实现故障容错。另外，状态机方法需要的低带宽允许了主备服务器能更好地进行物理分隔。例如，被复制的VM可以运行在横跨一个学校的物理机器上，相比于运行在同一建筑内的VM而言，可以提供更多的可靠性。</p><p>我们在VMware vSphere 4.0平台上使用主备机制实现了故障容忍的VMs，VMware vSphere实现了一个完整的x86虚拟机，所以我们自动地能够为任何x86操作系统和应用提供故障容忍。这种允许我们记录一个主服务器执行，并确保备份服务器一致执行的基础技术是确定性重放。VMware vSphere Fault Tolerance(FT)是基于<strong>确定性重放（Deterministic Replay）</strong> 的，但是为了建立一个完整的故障容忍系统，还增加了必要的额外协议和功能。除了提供硬件故障容忍，我们的系统在一次失败后，通过在局部集群中任何可接受的服务器上开始一个新的备份虚拟机，进行自动地存储备份。目前确定性重放和VMare FT的产品版本只支持单处理器的VMs。多处理器VM的操作记录和重放还在开发中，因为每个共享内存的操作都是一个非确定性的操作，因此还有重要的性能问题待解决。</p><p>Bressoud和Schneider描述了一个针对HP PA-RISC平台的故障容忍VMs的原型实现。我们的方法是相似的，但是出于性能原因，以及在调查了许多可替代设计后，我们已经做了一些基础性的改变。另外，为了建立一个完整的系统，而这个系统是有效的并且能够被正在运行企业级应用的客户使用，我们已经设计并实现了系统中许多额外的组件，可以处理许多实际问题。与大多数其他实际系统讨论的类似， <strong>我们只尝试应付fail-stop的故障</strong> ，这是一种服务器故障，可以在故障服务器造成一次不正确的外部可见行为之前被检测。（ <em>Hades注：fail-stop故障指的是，如果某些东西出现故障，只是单纯的停止运行，而不是运算出错误结果。比如电源线、服务器风扇导致CPU过热停止运行、网络等故障</em> ）</p><h2 id="2-基本的FT设计">2. 基本的FT设计</h2><p><img src="https://pic3.zhimg.com/80/v2-ff55c97e63c2b1571e41c736e5f07bf6_720w.webp" alt=""></p><p>图1展示了我们系统在故障容忍VMs的基本步骤。对于一个给定的VM，我们希望提供故障容忍（主VM），我们在一个完全不同的物理机器上运行一个备份VM，保持和主VM同步并且执行一致，虽然存在短时间的滞后。我们说这两个VMs是虚拟的步调一致。VMs的虚拟磁盘是在一个<strong>共享存储</strong>中的（例如一个Fibre Channel或者iSCSI磁盘阵列），因此可以接受主备服务器的输入和输出。（我们将在4.1节中讨论带有分隔的非共享虚拟磁盘的主备VM的设计）只有主VM会说明它在网络中的存在，因此所有网络输入都会来到主VM上。相似地，所有其他输入（例如键盘和鼠标）也只会来到主VM上。</p><p>所有主VM接收到的输入都会通过名为logging channel的网络连接，被发送到备份VM上。对于几个工作负载而言，主要的输入途径是网络和磁盘。为了保证备份VM和主VM使用相同的方式执行非确定性操作，下面2.1节讨论的额外的信息也需要发送。最终备份VM总是执行和主VM一致的操作。然而，备份VM的输出会被管理程序扔掉，因此只有主VM产生实际输出，并被返回给客户端。和2.2节中描述的一样，为了确保主VM失败后没有数据丢失，主备VM遵循一个具体的协议，包括备份VM明确的确认信息。</p><p>为了检测主或备份虚拟机是否失败，我们的系统<strong>既使用相关服务器间的心跳机制，同时也监测 logging channel 上的流量</strong>。另外，我们我们必须确保<strong>只有主或备份VM执行操作</strong>，即使存在脑裂（split brain）的场景（在这种场景中主备服务器互相之间会失去通信）。</p><h3 id="2-1-确定性重放的实现">2.1 确定性重放的实现</h3><p>正如我们已经提到的，复制服务器（或者VM）的操作可以被建模为确定性状态机的复制。如果两个确定性的状态机以相同的初始状态开始，并且以相同的顺序提供确切的输入，它们将经历相同的状态序列并且产生相同的输出。一个虚拟机有很宽泛的输入，包括到来的网络包，磁盘读，以及来自键盘和鼠标的输入。非确定性事件（例如虚拟中断）和非确定性操作（例如处理器的时钟周期计数器）也会影响虚拟机的状态。这显示了对于正在运行任何操作系统和工作负载的任何虚拟机而言，复制执行有 <strong>三个挑战</strong> ：</p><ol><li>为了保证一个备份虚拟机的确定性执行，正确地得到<strong>所有输入以及非确定性执行</strong>是必要的。</li><li><strong>正确地</strong>将输入与非确定性执行应用到备份虚拟机上。</li><li>以一种<strong>不会引起性能退化</strong>的方式执行。</li></ol><p>另外，许多在x86处理器上的复杂操作还未被定义，因此会引起非确定性以及副作用。捕获这些未定义的操作并且重放它们产生相同的状态是一个额外的挑战。</p><p>针对在VMare vSphere平台上的x86虚拟机，VMware确定性地重放恰好提供了这个功能。确定性重放记录了 VM 的输入以及与 VM执行相关的所有可能的不确定性的日志条目流，这些条目会被写入日志文件。在读取日志文件中的条目后，VM 操作会被精确地重放。 对于非确定性操作，为了允许操作以相同的状态变化和输出再现，需要记录足够的信息。 对于非确定性事件，例如定时器或 IO 完成中断，事件发生的确切指令也会被记录下来。 在重播期间，事件被传递在指令流中的同一位置。 VMware 确定性重放采用各种技术，<strong>实现了高效的事件记录和事件传递机制</strong>，包括使用AMD和英特尔联合开发的硬件性能计数器。</p><p>Bressoud 和 Schneider提到将VM执行切分成不同的<strong>epoch</strong>，其中非确定性事件，例如中断仅在一个epoch结束时传递。 epoch的概念似乎被用作批处理机制，因为在它发生的确切指令处单独传递每个中断的成本太高。然而，我们的事件传递机制足够高效，以至于 VMware确定性重放<strong>不需要使用epochs</strong>。 每次中断在发生时被记录，并且在重放时有效地传递到适当的指令处。</p><h3 id="2-2-FT协议">2.2 FT协议</h3><p>对于 VMware FT而言，我们使用确定性重放来生成必要的日志条目来记录主VM的执行情况，但是不是将日志条目写入磁盘，而是<strong>通过日志通道将它们发送到备份VM</strong>。备份 VM 实时重放日志条目，因此与主 VM 的执行保持一致。 然而，我们必须在日志通道中使用严格的 FT 协议以增强日志条目，从而确保我们实现故障容忍。 我们的基本要求如下：</p><p><strong>输出要求</strong> ：如果备份VM在主VM发生故障后接管，那么备份VM将继续以一种与主虚拟机发送到外部世界的所有输出<strong>完全一致</strong>的方式执行。</p><p>请注意，在发生故障转移后（即备份 VM 需要在主VM故障后接管），备份VM开始执行的方式可能与主 VM 相当不同，因为在执行期间发生了许多非确定性事件。但是，只要备份VM满足输出要求，在故障转移到备份 VM期间 <strong>没有外部可见状态或数据的丢失</strong> ，客户端将注意到他们的服务没有中断或不一致。</p><p>可以通过延迟任何外部输出（通常是网络数据包）直到备份VM 已收到重放的所有信息来确保输出要求，这些信息允许它至少执行到该输出操作的点。一个必要条件是备份 VM 必须接收到输出操作之前生成的所有日志条目。这些日志条目将允许它执行到最后一个日志条目的点。但是，假设失败是在主VM执行输出操作后立即发生。备份 VM 必须知道它必须继续重播到输出操作点，并且到那时只能“上线”（停止重播并作为主VM接管，如2.3 节所述）。如果备份将在输出操作之前的最后一个日志条目点上线，一些非确定性事件（例如计时器传递给 VM 的中断）可能会在执行输出操作之前改变其执行路径。</p><p>给定上述的限制，强制满足输入要求的最容易的方式是在每个输出操作时创建一个特殊的日志条目。然后，输出要求一定被下面特殊的规则限制：</p><p><strong>输出规则</strong> ：主VM可能不发送一个输出到外部世界，直到备份VM<strong>已收到并确认</strong>与产生输出的操作相关的日志条目。</p><p>如果备份 VM 已收到所有日志条目，包括生成输出操作的日志条目，然后备份 VM 将能够准确地重现主 VM在输出点的状态，所以如果主VM死了， <strong>备份将正确地达到一个与输出一致的状态</strong> 。相反，如果备份VM在没有收到所有必要的日志条目的情况下接管，那么它的状态可能会 <strong>迅速分歧</strong> ，以至于与主服务器的输出不一致。输出规则在某些方面类似于 [11] 中描述的方法，其中“外部同步” IO 实际上可以被缓存，只要它在下一次外部通信之前确实被写入磁盘了。</p><p>请注意，输出规则没有说明关于停止主VM执行的任何事。我们只需要延迟输出发送，但 VM 本身可以继续执行。由于操作系统通过异步中断来指示完成，因此可以执行非阻塞的网络和磁盘输出，VM可以轻松地继续执行并且不一定会立即受到输出延迟的影响。相比之下，以前的工作 [3, 9] 通常必须在执行输出之前完全停止主VM，直到备份 VM 已确认来自主 VM 的所有必要信息。</p><p><img src="https://pic3.zhimg.com/80/v2-3435bcea13d75fdb4741639f8e674282_720w.webp" alt=""></p><p>作为一个例子，我们在图2中展示了 FT 协议的需求。该图显示了一个主VM和备份VM上的事件时间线。从主线到备份线的箭头表示日志条目的传输，从备份线路到主线路的箭头表示确认。有关异步事件、输入和输出操作的信息必须作为日志条目发送到备份VM并确认。如图所示，到外部世界的输出被延迟，直到主VM收到来自备份 VM 的确认，它已经收到与输出操作相关的日志条目。<strong>鉴于遵循输出规则，备份VM将能够以这样一种状态接管，即与主VM最后的输出一致。</strong></p><p>我们不能保证一旦出现故障转移情况，所有输出都准确地产生一次。当主VM打算发送输出时， <strong>没有使用两阶段提交事务</strong> ，备份VM无法确定主VM是在发送它的最后一个输出之前还是之后立即崩溃。  <strong>幸运的是，网络基础设施（包括常用的TCP）旨在处理丢失的数据包和相同（重复）的数据包</strong> 。 请注意传入到主VM的数据包也可能在其故障的期间丢失，因此不会被传递给备份VM。 但是，传入的数据包可能会由于与服务器故障无关的任何原因被丢弃，因此网络基础设施、操作系统和应用程序都被写入，以确保他们可以弥补丢失的数据包。</p><h3 id="2-3-检测与故障响应">2.3 检测与故障响应</h3><p>如上所述，如果另一个 VM 出现故障，主备VMs必须快速响应。如果备份VM出现故障，主VM将上线，即离开记录模式（因此停止发送条目到日志通道）并开始正常执行。如果主VM失败，备份VM应该同样上线（go live），但过程更为复杂。由于其执行的滞后，备份 VM 可能会有许多它已收到并确认，但尚未消耗的日志条目，因为备份 VM 尚未达到执行的适当点。 <strong>备份VM必须继续重放日志条目，直到它消耗了最后一个日志条目</strong> 。此时，备份 VM 将停止重放模式并开始作为正常VM执行。本质上备份VM被提升为主VM（现在缺少备份VM）。由于它不再是备份 VM，当操作系统执行输出操作时，新的主VM现在将向外部世界生产输出。在过渡到正常模式期间，可能会有一些特定设备的操作需要允许正确地发送输出。特别是， <strong>出于联网目的，VMware FT 自动在网络上通告新的主VM的MAC 地址，以便物理网络交换机知道新的主 VM 所在的服务器</strong> 。此外，新提升的主VM可能需要重做一些磁盘 IO（如第 3.4 节所述）。</p><p>有许多可能的方法来尝试检测主备VMs的故障。VMware FT在运行容错VMs的服务器之间使用  <strong>UDP心跳</strong> ，来检测服务器何时崩溃。此外，VMware FT 监控日志流量，包括从主到备的发送以及从备到主的确认。因为定时器中断，日志流量应该是有规律的，并且永远不会停止。因此，在日志条目或确认流中的中断可能表明VM故障。如果心跳或记录流量已停止超过特定超时时间（大约几秒钟），就可能发生故障了。</p><p><strong>但是，任何此类故障检测方法都容易受到脑裂（split brain）问题的影响</strong> 。如果备份服务器停止接收来自主服务器的心跳，这可能表明主服务器出现故障，或者可能只是意味着所有仍在运行的服务器之间的网络连接丢失。如果备份VM随后上线，而主VM也仍然在运行，对于与VM通信的客户端而言可能会有数据损坏以及其他问题。因此，我们必须确保当检测到故障时，主VM和备份VM只有一个在线。为了避免脑裂问题，我们利用共享存储，来存储VM的虚拟磁盘。  <strong>当任一主或备份VM想要上线时，它会在共享存储中执行一个原子性的测试设置操作</strong> 。 如果操作成功，VM 被允许上线。 如果操作失败，那么另一个 VM 一定已经上线，所以当前虚拟机实际上停止了自己（“自杀”）。 如果尝试执行此原子操作时，VM 无法访问共享存储，然后它只是等待，直到可以访问。 注意如果由于存储网络上的某些故障而无法访问共享存储时，那么虚拟机可能无法做有用的工作，因为虚拟磁盘在同样的共享存储中，因此，为了解决脑裂问题而使用共享存储不会引入任何额外的不可接受性。（ <em>Hades注：使用共享存储这种解决方案本身使得主备又得以通信了，只不过是通过信号量，而非socket。</em> ）</p><p>这个设计的一个最终方面是一旦故障发生并且一个VM已经上线，VMware FT自动地通过在另一个主机上开始一个新的备份VM，来恢复备份。虽然这个过程不能覆盖过去大部分的工作，但是对于故障容忍的VM有用，它是基础，需要仔细设计。</p><h2 id="3-FT的实际执行">3. FT的实际执行</h2><p>第二节描述了我们基础的设计以及FT协议。然而，为了创建一个有用的、健壮的以及自动化的系统，有许多其他组件必须设计实现。</p><h3 id="3-1-启动与重启-FT-VMs">3.1 启动与重启 FT VMs</h3><p>一个必须被设计的最大的额外组件是这种机制，即 <strong>启动一个拥有和主VM状态一样的备份VM</strong> 。当故障发生后重启一个备份VM时，这个机制也将变得很有用。因此，这个机制一定可用于一个处于任意状态的正在运行中的主VM。此外，我们希望该机制<strong>不会显著地中断主VM</strong>的执行，因为这会影响 VM 的任何当前客户端。</p><p>对于 VMware FT而言，我们调整了VMware vSphere上现有的 <strong>VMotion</strong> 功能。 VMware VMotion [10] 允许以最少中断的方式，将正在运行的 VM 从一台服务器迁移到另一台服务器，VM的暂停时间通常不到一秒钟。我们创建了一个VMotion的修改形式，可在远程服务器上创建准确的 VM 运行副本，但不会破坏本地服务器的虚拟机。也就是说，我们修改后的 FT VMotion 将VM克隆到远程主机上而不是迁移它。 FT VMotion还设置了一个日志记录通道，并导致源VM作为主VM进入日志记录模式，而目的VM 作为备份进入重放模式。像平常的VMotion一样，FT VMotion 通常会中断主VM的执行不到一秒。因此，启用 FT在正在运行的 VM 上是一个简单的、无中断的操作。</p><p>启动备份 VM 的另一个方面是选择一个运行它的服务器。容错 VM 在服务器集群中运行，可以访问共享存储，因此所有 VM通常可以运行在集群上的任何服务器中。这种灵活性允许VMware vSphere恢复FT冗余，即使一个或多个服务器失效。 <strong>VMware vSphere 实现了一种集群服务，用于维护管理以及资源信息</strong> 。 当发生故障并且主VM 现在需要一个新的备份 VM 来重新建立冗余时，主 VM 通知集群服务它需要一个新的备份。 集群服务基于资源利用率以及其他约束，决定运行备份VM最好的服务器，并调用 FT VMotion 以创建新的备份 VM。 结果是 VMware FT通常可以在几分钟内重新建立VM冗余，在一个故障容忍VM的执行上，所有这些都没有任何明显的中断。</p><h3 id="3-2-管理日志通道">3.2 管理日志通道</h3><p><img src="https://pic1.zhimg.com/80/v2-4489f7267d3b9420243ea3a02adbba80_720w.webp" alt=""></p><p>在管理日志通道上的流量时，有许多有趣的实现细节。在我们的实现中，管理程序为主备 VM 的日志记录条目维持了一个大的 <strong>缓冲区</strong> 。当主 VM 执行时，它生成日志条目到缓冲区中，类似地，备份VM从它的日志缓冲区中消耗日志条目。主日志缓冲区的内容会被尽快刷新到日志记录通道，这些日志条目一到日志通道，就会被读取到备份的日志缓冲区。备份每次从网络上读取一些日志条目到它的日志缓冲区时，都会发送确认返回给主VM。这些确认允许 VMware FT 确定一个被输入规则延迟的输出何时可以被发送。图3说明了这个过程。</p><p>如果备份 VM 在需要读取下一个日志条目时，遇到空的日志缓冲区，它将停止执行直到有新的日志条目可用。由于备份 VM 是不与外部通信的，此暂停不会影响任何VM 的客户端。同样地，当主VM需要写入一个日志条目时，如果主VM遇到一个完整的日志缓冲区，它必须停止执行，直到可以刷新日志条目。这种执行的停止是一种自然的流控制机制，当主VM生产日志条目太快了，它会减慢主VM。但是，此暂停可能会影响VM的客户端，因为主 VM 将完全停止并且无响应，直到它可以记录其条目并继续执行。因此，我们的实现必须设计为尽量减少主日志缓冲区填满的可能性。</p><p>主日志缓冲区可能填满的原因之一是备份 VM 执行速度太慢，因此消耗日志条目太慢。 <strong>一般来说，备份VM必须能够以与正在记录执行的主VM大致相同的速度重放执行</strong> 。幸运的是，在 VMware 确定性重放中，记录和重放的开销大致相同。然而，如果由于其他VMs，托管备份 VM 的服务器负载很重（因此过度使用资源），备份VM 可能无法获得足够的 CPU 和内存资源，来与主 VM 一样快地执行，尽管备份管理程序的VM调度器已经尽了最大努力。</p><p>如果日志缓冲区填满，除了避免意外暂停，还有另一个原因是我们不希望滞后变得太大。如果主VM出现故障，备份VM必须通过重放它在上线和开始与外部世界交流之前已经确认的所有日志条目来“赶上”。完成重放的时间基本上是失败点的执行延迟时间，所以 <strong>备份上线的时间大约等于故障检测时间加上当前执行时差</strong> 。因此，我们不希望执行滞后时间太大（超过一秒），因为这将显著地增加故障转移时间。</p><p>因此，我们有一个额外的机制减慢主VM，以防止备份 VM 获取太滞后了。在我们的发送和确认日志条目的协议中，我们发送附加信息来确定主备VM之间的实时执行滞后。通常执行滞后小于 100 毫秒。 <strong>如果备份 VM 有一个显著的执行滞后（例如，超过 1 秒），VMware FT 通过通知调度程序给它稍微少一点的CPU（最初只是百分之几）来减慢主 VM</strong> 。我们使用一个缓慢的反馈循环，这将尝试逐步确定适当的 CPU 限制，将允许主备 VM同步执行。如果备份 VM 继续滞后，我们继续逐步降低主VM的 CPU 限制。反之，如果备份VM赶上，我们逐渐增加主VM的 CPU 限制，直到备份虚拟机恢复轻微的滞后。</p><p>请注意，主VM的这种减速很少见，通常只在系统处于低压力时发生。第 5 节的所有性能编号包括任何此类放缓的成本。</p><h3 id="3-3-FT-VMs上的操作">3.3 FT VMs上的操作</h3><p>另一个实际问题是处理各种控制操作，它们可以应用于主 VM 。例如，如果主VM明确关闭电源，备份 VM 也应该停止，而不是尝试上线。 再举一个例子，任何主VM上的资源管理更改（例如增加 CPU 份额）应该 也适用于备份。 对于此类操作，为了影响备份进行合适的操作，特殊的控制条目通过日志通道从主发送到备份。</p><p>一般来说，VM 上的大部分操作都应该仅在主 VM 上初始化。 VMware FT 然后发送任何必要的控制条目以造成备份VM上适当的更改。 唯一可以独立在主VM和备份VM上完成的操作是 VMotion。 那即，主VM和备份VM可以独立被 VMotioned到其他主机。 请注意，VMware FT 确保两个 VM 都不会移动到另一个 VM 所在的服务器，因为这种场景将不再提供故障容忍。</p><p>主VM的VMotion增加了比普通VM更多的复杂性，因为备份VM一定会与源主VM失去连接以及在适当的时间重连。备份VM的VMotion有一个相似的问题，但是只增加了一个额外的复杂性。对于一个正常的VMotion而言，我们需要当VMotion上最后的切换发生时，所有的磁盘IO停止（或完成）。对于一个主VM而言，这种停顿是容易应付的，通过等待直到物理IO完成并将这些完成信息发送给VM。然而，对于一个备份VM而言，没有容易的方式来使得所有IO在任何需要的时刻完成，因为备用VM必须重放主VM的执行过程，并在相同的执行点完成IO。主VM可能正运行在一个工作负载上，在正常执行过程中总是有磁盘IO。VMware FT有一个独一无二的方法来解决这个问题。当一个备份VM是在VMotion最后的切换点时，它需要通过日志通道来告知主VM临时停止所有IO。备份VM的IO将自然地被停止在一个单独的执行点，因为它需要重放主VM的停止操作的过程。</p><h3 id="3-4-磁盘IO的实现问题">3.4 磁盘IO的实现问题</h3><p>有许多与磁盘IO相关的微小的实现问题。首先，假设磁盘操作是非阻塞的，因此访问相同磁盘位置的并行、同时执行的磁盘操作将引起非确定性。此外，我们的磁盘 IO 实现使用DMA 直接from/to虚拟机的内存，所以同时访问相同内存页的磁盘操作也可能导致不确定性。我们的解决方案是 <strong>经常检测任何此类 IO 竞争</strong> （很少见），以及强制此类竞争磁盘操作在主备VM上按顺序执行。</p><p>第二，通过 VM 中的应用程序（或操作系统）时，<strong>磁盘操作与内存访问</strong>也会存在竞争，因为磁盘操作通过 DMA 直接访问 VM 的内存。例如，如果一个VM 中的应用程序/操作系统正在读取内存块，同时对该块进行磁盘读取。（ <em>Hades注：这里的意思应该是，该块内存作为DMA操作的目的地址。</em> ）这个情况也不太可能发生，但如果它发生，我们必须检测它并处理它。一种解决方案是临时设置页保护，在作为磁盘操作目标的页面上。如果VM 碰巧访问一个页，同时该页面也是磁盘操作的目标，页保护将导致一个陷阱（ <em>Hades注：trap，陷入系统调用</em> ），VM将暂停直到磁盘操作完成。 <strong>因为改变页上的MMU 保护是一项昂贵的操作，所以我们选择使用 <em>弹跳缓冲区（Bounce Buffer）</em> 代替</strong> 。bounce buffer是临时缓冲区，与正在被磁盘操作访问的内存大小相同。磁盘读取操作被修改为读取指定数据到bounce buffer，并在在IO完成时将数据复制到内存中。相似地，对于磁盘写操作，首先将要发送的数据复制到bounce buffer，磁盘写入修改为向bounce buffer写入数据。bounce buffer的使用会减慢磁盘操作，但我们还没有看到它会导致任何明显的性能损失。（ <em>Hades注：bounce buffer存在的意义是在内存访问这个操作之前加了一个拦截器，其最本质的意义是为了supervisor监控DMA操作，使得数据从bounce buffer拷贝到到内存和系统中断这两个步骤，能够同时在backup VM上被复制， <strong>否则网卡直接将网络数据包DMA到Primary虚机中这个操作是无法通过log channel进行复制的</strong> 。</em> ）</p><p>第三，有一些与故障发生并且备份VM接管时，主VM未完成的磁盘 IO 相关的问题。对于新上线的主VM，没有办法确定磁盘IO是有问题的还是成功完成了。另外，由于磁盘IO没有从外部发布到备用VM上，而是通过主备传递，因此对于继续运行的新上任的主VM来说，将没有明确的IO完成信息，最终将导致VM上的操作系统开始中止或者重调度程序。我们能够发送一个错误完成，表示每个IO失败，因为即使IO成功完成了，它可以接受返回一个错误。然而，操作系统可能不能对这些来自本地磁盘的错误有很好的响应。反之，我们在备份VM上线的过程中，重新发送这些悬挂着的IO。因为我们已经限制了所有的竞争和所有的直接指定内存和磁盘的IO，这些磁盘操作可以被重新发送，即使它们已经成功完成了（即他们是<strong>幂等的</strong>）。</p><h3 id="3-5-网络IO的实现问题">3.5 网络IO的实现问题</h3><p>VMware vSphere针对VM网络提供了很多性能优化。一些优化是基于管理程序（supervisor） <strong>异步更新虚拟机的网络设备状态</strong> 。例如，当VM正在执行时，接收缓冲区可以由管理程序直接更新。不幸的是这些对 VM 状态的 <strong>异步更新会增加不确定性</strong> 。除非我们可以保证所有更新都发生在主备指令流上的同一点，否则备份VM的执行可能与主VM的执行不同。</p><p>对于FT而言，网络仿真代码的最大变化是禁用异步网络优化。异步更新带有传入数据包的VM环形缓冲区的代码已被修改，以强制管理程序捕获到操作系统，它可以在其中记录更新然后将它们应用到 VM。同样，异步地将数据包从传输队列中拉出也被修改了，取而代之的是通过管理程序traps来完成传输（如下所述）。</p><p>网络设备异步更新的消除结合第 2.2 节中描述的发送数据包的延迟带来了一些网络性能的挑战。我们采取了两种方法在运行 FT 时提高 VM 的网络性能。第一，我们实施了集群优化以减少 VM 的陷阱和中断。当 VM 以足够的比特率流式传输数据时，管理程序可以对每组数据包做一个传输trap，在最好的情况下零trap，因为它可以传输所接收新数据包的一部分数据包。同样地，通过仅对于一组数据包发布中断，管理程序可以将接收包的中断数量减少。</p><p>我们对网络的第二个性能优化涉及 <strong>减少传输数据包的延迟</strong> 。如前所述，管理程序必须延迟所有发送的包直到它得到备份VM对于某些日志条目的确认。减少发送延迟的关键在于减少发送/接收备份VM信息的所需时间。我们的主要优化包括 <strong>保证收发信息在无需任何线程上下文切换的情形下就可以被执行</strong> 。VMware vSphere管理程序允许函数被注册到TCP栈中，只要TCP数据被接收到了，函数就会被一个延期执行的上下文调用（和Linux中的tasklet类似）。这允许我们快速处理备份VM上任何即将到来的日志消息，以及主VM接收的任何确认消息，而不需要任何线程上下文的切换。另外，当主VM有一个包要寄出去时，我们强制一次相关输出日志条目的日志刷出（正如2.2节中所描述的），通过调度一个延迟执行的上下文来执行这次刷出。</p><h2 id="4-替代设计">4. 替代设计</h2><p>在我们VMware FT的实现中，我们已经探索了许多有趣的替代设计。在这节中，我们探索一些替代设计。</p><h3 id="4-1-共享-vs-非共享磁盘">4.1 共享 vs. 非共享磁盘</h3><p>在我们默认的设计中，主备VM共享相同的虚拟磁盘。因此，如果一次故障转移发生，共享磁盘的内容自然是正确、可接受的。必要地，对于主备VM来说，共享磁盘被认为是外部的，因此任何共享磁盘的写入被认为是一次与外部世界的沟通。因此，只有主VM做这种实际的磁盘写入，并且为了遵循输出规则，这种写入必须被延迟。</p><p><img src="https://pic4.zhimg.com/80/v2-8ff15ec8bcc0154d88fda55c68e0a3f7_720w.webp" alt=""></p><p>对于主备VM而言，一种可替代的选择是分隔的虚拟磁盘。在这种设计中，备份VM要执行所有虚拟磁盘的写入操作。而且这样做的话自然要保持它的虚拟磁盘内容与主VM虚拟磁盘内容一致。图4阐述了这种配置。在非共享磁盘的情况下，虚拟磁盘必须被认为是每个VM的内部状态。因此，依据输出规则， <strong>主VM的磁盘写入不必延迟</strong> 。在共享存储不能被主备VM接受的情况下，非共享的设计是相当有用的。这种情况可能是由于共享存储不可接受或者太昂贵，或者由于运行主备VM的服务器相隔太远（“长距离FT”）。非共享设计的一个缺点是在首次启动故障容错时，虚拟磁盘的两个复制必须以相同的方式进行显示同步。另外，发生故障后磁盘 <strong>可能会不同步</strong> ，因此当在一次失败后备份VM重启的时候，他们必须再显式地同步。FT VMotion必须不止同步主备VM的运行状态，还要同步他们的磁盘状态。</p><p>在这种非共享磁盘的配置中，他们也能应付脑裂场景。在这种场景中，系统能够 <strong>使用一些其他的外部决策者</strong> ，例如所有服务器可以沟通的一个第三方服务。如果服务器是超过两个节点的集群的一部分，这个系统能够基于集群关系使用一种majority算法。在这个例子中，一个VM能够被允许上线，如果它正在一个服务器上运行，这个服务器是包含大多数原始节点的正在通信的子集群的一部分。</p><h3 id="4-2-在备份VM上执行磁盘读">4.2 在备份VM上执行磁盘读</h3><p>在我们默认的设计中，备份的VM从不会从它自己的虚拟磁盘上读取（无论共享还是非共享）。 <strong>因为磁盘读取被认为是一个输入</strong> ，它是自然地通过日志通道将磁盘读取的结果发送到备份VM上。</p><p>一种替代的设计是 <strong>让备份VM执行磁盘读取</strong> ，因此消除了磁盘读取的日志。对于大多数时候都做磁盘读取的工作负载而言，这种方法可以很好地降低日志通道上的流量。然而，这种方法有很多小问题。它可能会减慢备份VM的执行速度，因为备份VM必须执行所有的磁盘读取，当到达VM执行中主VM已经完成的位置时，如果备份上的磁盘读取还没完成就必须等待。</p><p>同样地， <strong>为了处理失败的磁盘读取操作，必须做一些额外的工作</strong> 。如果一个主VM的磁盘读取成功了，但是相应的备份VM磁盘读取失败了，备份VM的磁盘读取必须重试直到成功。因为备份VM必须获得和主VM一样的数据到内存中。相反地，如果一个主VM的磁盘读取失败了，目标内存的内容必须通过日志通道发送给备份服务器，因此内存的内容将被破坏，不能被备份VM成功的磁盘读取复制。</p><p>最后，如果这种磁盘读取被用于共享磁盘配置的话，还有一个小问题。如果主VM做了一次对具体磁盘位置的读取，然后紧跟相同磁盘位置的写入，然后这个磁盘写必须被延迟到备份VM已经执行了第一次磁盘读取。这种依赖可以被检测和正确处理，但是需要增加实现上额外的复杂性。</p><p>在5.1节中，对于实际的应用而言，我们给出一些性能结果以表示在备份VM上执行磁盘读取会造成一些轻微的吞吐量减少(1-4%)，因此在日志通道的带宽被限制的情况下，在备份VM上执行磁盘读取可能是有用的。</p><h2 id="5-性能评估">5. 性能评估</h2><p>在这节中，我们做了一次VMware FT性能的基础评估，针对许多应用负载以及网络基准。为了得到这些结果，我们在一样的服务器上运行主备VM，每个都带9个Intel Xeon 2.8Ghz CPUs and 8Gbytes of RAM。服务器间通过10 Gbit/s的交换机连接，但是在所有的例子中都能看到被使用的网络带宽远远少于1Gbit/s。从一个通过标准的4Gbit/s的光纤通道网络连接的EMC Clariion中，服务器可以连接他们的共享虚拟磁盘。客户端通过1 Gbit/s的网络来驱动一些连接服务器的工作负载。</p><p>我们评估性能结果的应用如下所示。SPECJbb2005是工业标准的Java应用基准，非常耗费CPU和内存，但是IO非常少。Kernel Compile是一种运行Linux核编译的工作负载。由于许多编译过程的创建和毁灭，这个工作负载做很多磁盘读取和写入，是非常耗费CPU和MMU的。Oracle Swingbench是被Swingbench OLTP工作负载（在线事务处理）驱动的一个Oracle 11g的数据库。这个工作负载做连续的磁盘和网络IO，有80个同时在线的数据库会话。MS-SQL DVD Store是一种工作负载，运行了一个Microsoft SQL Server 2005的数据库，有60个同时在线的客户端。</p><h3 id="5-1-基本性能结果（Basic-Performance-Results）">5.1 基本性能结果（Basic Performance Results）</h3><p><img src="https://pic2.zhimg.com/80/v2-fb282163e7fc26950e1c12883cd6b159_720w.webp" alt=""></p><p>表 1 列出了基本的性能结果。对于每个应用程序，第二列给出了应用程序的性能比例，运行服务器工作负载的虚拟机上启用和未启用FT的情况。性能比小于 1 表示带FT的工作负载更慢。显然，这些有代表性的工作负载上启用FT 的开销小于10%。 SPECJbb2005 完全受计算限制，没有空闲时间，但其表现性能良好，因为它具有最小的除定时器中断以外的不确定性事件。另一个工作负载做磁盘 IO 有一些空闲时间，所以一些FT 开销可能被 FT虚拟机的空闲时间更少的真实情况隐藏。然而，一般的结论是VMware FT 能够支持故障容忍VM，并且具备相当低的性能开销。</p><p>在表的第三列中，我们给出了当应用程序正在运行时，在日志通道上发送数据的平均带宽。对于这些应用程序，日志带宽相当合理，1 Gbit/s的网络就能满足 。事实上，低带宽要求表明多个 FT 工作负载可以共享相同的 1 Gbit/s网络，同时没有任何负面的性能影响。</p><p>对于运行常见操作系统的 VM，例如Linux 和 Windows，我们发现当操作系统空闲时，通常的日志记录带宽为 0.5-1.5 Mbits/sec。&quot;空闲&quot;带宽主要是记录定时器中断发送的结果。对于具有活动中工作负载的 VM而言，日志带宽由网络和必须发送到备份的磁盘输入主导—网络收到的数据包和从磁盘读取的磁盘块。因此，对于非常高的网络接收或者磁盘读取带宽的应用而言，日志带宽高于表1中的测量值。对于这类应用而言，日志通道的带宽可能是瓶颈，特别是日志通道还有其他使用时。</p><p>对于许多实际应用程序而言， <strong>日志记录所需的带宽相对较低，这使得基于重放的故障容忍对于使用非共享磁盘的长距离配置非常有吸引力</strong> 。对于远距离配置而言，其主备VM可能相隔1-100公里，光纤可以轻松地支持延迟小于 10 毫秒的100-1000 Mbit/s带宽。对于表 1 中的应用而言，主备之间的额外往返延迟，可能会导致网络和磁盘输出最多延迟 20 毫秒。远距离配置仅适用于这类应用程序：他的客户端可以容忍每个请求的额外延迟。</p><p>对于两个最占用磁盘空间的应用程序，我们测量了在备份 VM上执行磁盘读取（如第 4.2 节所述）与通过日志记录通道发送磁盘读取数据相比，对于性能的影响。对于 Oracle Swingbench来说，在备份VM上执行磁盘读取时的吞吐量降低约 4%；对于 MS-SQL DVD 存储，吞吐量约降低 1%。同时，Oracle Swingbench的日志带宽从 12 Mbits/sec 降低到 3 Mbits/sec，MS-SQL DVD 存储从 18 Mbits/sec 降低到 8 Mbits/sec。显然，对于具有更大磁盘读取带宽的应用程序，带宽可能会节省很多。如第 4.2 节所述，预计在备份 VM 上执行磁盘读取时，性能可能会更差。但是，对于日志通道的带宽是有限的（例如，远程配置）情况下，在备份 VM 上执行磁盘读取可能有用。</p><h3 id="5-2-网络基准测试（Network-Benchmarks）">5.2 网络基准测试（Network Benchmarks）</h3><p>出于多种原因。网络基准测试对我们的系统来说非常具有挑战性。第一，高速网络会有一个非常高的中断率，这需要以非常高的速度记录和重放异步事件。 第二，以高速率接收数据包的基准将导致高速率的日志流量，因为所有这些数据包必须通过日志通道发送到备份。第三，发送数据包的基准测试将受制于输出规则，延迟网络数据包的发送直到已收到来自备份VM的确认。 此延迟会增加对客户端测量的延迟。这种延迟还可能会降低到客户端的网络带宽，因为网络协议（如 TCP）由于往返延迟增加，可能不得不降低网络传输速率。</p><p><img src="https://pic3.zhimg.com/80/v2-5c0dc395147124b9d6aeaa915c356282_720w.webp" alt=""></p><p>表 2 给出了我们通过标准的netperf 基准测试，多次测量的结果。在所有这些测量中，客户端 VM 和主 VM 通过 1 Gbit/s 网络连接。前两行给出了主备主机间通过1 Gbit/s 的日志通道连接时，发送和接收的性能。第三行和第四行给出当主备服务器通过10 Gbit/s的日志通道连接时，发送和接收的性能，不仅带宽更高，延迟也低于 1 Gbit/s。作为一个粗略的测量，在1 Gbit/s 网络连接的管理程序之间， ping 时间约为 150 微秒，而对于 10 Gbit/s 连接，ping时间大约需要 90 微秒。</p><p>未启用 FT 时，主 VM 对于接收和发送，可以实现接近 (940 Mbit/s) 1 Gbit/s 的线路传输速率。当为接收工作负载启用 FT 时，日志记录带宽非常大，因为所有传入的网络数据包必须在日志通道上发送。因此，日志记录通道可能成为瓶颈，正如1 Gbit/s 日志网络的结果。对于 10 Gbit/s 的日志网络，影响则小了很多。当为上传工作负载启用 FT 时，上传数据包的数据不会记录，但仍必须记录网络中断。日志带宽要低得多，因此可实现的网络上传带宽高于网络接收带宽。 <strong>总的来说，我们看到 FT 在非常高的上传和接收速率情况下，可以显著地限制网络带宽，但仍然可以实现很高的速率</strong> 。</p><h2 id="7-结论与今后的工作">7. 结论与今后的工作</h2><p>我们在VMware vSphere 中设计并实施了一个高效完整的系统(FT) ，用于为服务器上运行的虚拟机提供容错。我们的设计基于复制主VM中的执行，再通过另一台主机上的备份VM执行VMware确定性重放。如果运行主 VM的服务器出现故障，备份 VM 能立即接管且不会中断或丢失数据。</p><p>总体而言，在商业硬件上运行VMware FT时，故障容错VM的性能非常出色，并且对于某些典型应用程序，其开销低于 10%。大多数 VMware FT 的性能成本来自于使用 VMware 确定性重放来保持主备VM同步。因此，VMware FT 的低开销源自 VMware 确定性重放的效率。此外，保持主备同步所需的日志带宽非常小，通常小于 20 Mbit/s。因为日志带宽在大多数情况下很小，主备相隔很长的距离（1-100公里）似乎也是可行的实施配置。因此，VMware FT 可用于这种场景：可以防止整个站点发生故障的灾难。值得注意的是，日志流通常是可压缩的，因此简单的压缩技术可以显著地减少日志带宽，虽然有少量额外的 CPU 开销。</p><p>我们对 VMware FT 的结果表明， <strong>一个高效的故障容错VM的实现可以建立在确定性重放的基础上</strong> 。 <strong>这样的系统可以透明地为运行任何操作系统和应用的虚拟机提供容错能力，仅会带来极小的开销</strong> 。然而，对客户有用的故障容错VM系统而言，它必须还具有强大、易于使用和高度自动化的特点。一个可用的系统除了复制虚拟机执行之外，还需要许多其他组件。特别是VMware FT 故障后自动地恢复冗余，通过在本地集群中找到合适的服务器并在其上创建一个新的备份VM。通过解决所有必要的问题，我们已经展示了一个在客户的数据中心可用于实际应用的系统。</p><p>通过确定性重放实现容错的权衡之一是当前确定性重放仅针对单处理器VM 。然而，单处理器虚拟机足够应付各种各样的工作负载，特别是因为物理处理器不断变得更加强大。此外，许多工作负载可以通过使用许多单处理器的虚拟机来扩展，而不是通过使用一个更大的多处理器虚拟机来扩展。多处理器 VM 的高性能重放是一种活跃的研究领域，并且可以潜在地被微处理器中的一些额外硬件支持。一个有趣的方向可能是扩展事务内存模型以促进多处理器重放。</p><p>将来，我们也有兴趣扩展我们的系统处理部分硬件故障。通过部分硬件故障，我们的意思是服务器上功能或冗余的部分丢失，不会导致损坏或丢失数据。一个例子是到 VM所有网络连接的丢失，或在物理服务器中备用电源丢失。如果在运行主 VM 的服务器上发生部分硬件故障，在许多情况下（但不是all) 故障转移到备份 VM 将是有利的。这样的故障转移对于关键VM而言，可以立即恢复完整服务，并确保虚拟机从可能不可靠的服务器上快速地移走。</p><h1>LEC 4</h1><h2 id="故障">故障</h2><p>我们希望复制方案可以处理的故障：</p><ol><li>只处理Fail-Stop类型的故障，也就是基础设施的故障导致计算机不能正常运行的类型的失败。因此失败是一瞬间发生的，这样的失败也不会产生一些奇怪的结果。<ol><li>排除了逻辑错误（也就是代码错误）</li><li>排除了配置错误</li><li>排除了恶意错误（不能处理黑客、攻击者模拟出来的错误等）</li></ol></li><li>可能处理的：比如地震等，但是我们不关注，因为主从机器都在一个机房中</li></ol><h2 id="挑战">挑战</h2><p>如果发生了故障，主机器真的挂掉了吗？</p><p>在分布式系统中，没有办法区分网络分区和机器故障的区别，因此很有可能主机器并没有挂掉，有一些客户端还能访问主机器，但是从机器和主机器之间的网络有问题，无法互相访问到，所以从机器认为主机器已经挂掉了。因此不能有两个主机器同时存在的情况，也就是脑裂问题。</p><p>如何保持主从同步？</p><p>如果主机器挂了，从机器要从主机器挂掉的地方直接开始，这就意味着从机器的状态与主机器的状态相同，都是最新的。从客户端的角度感知不到这种变化。</p><p>非常困难：</p><ul><li>我们在主机器上的所有改变都要按照相同的顺序应用到从机器上</li><li>解决非确定性问题，也就是相同的更改在两台机器上作的改变必须相同</li><li>故障转移：要弄明白主机器在挂掉之前有没有发送过数据包，再发送一次是否可行（或者是如果所有机器都挂掉了，回来之后哪个机器上有最新的状态呢？）</li></ul><h2 id="两种主从复制方法">两种主从复制方法</h2><ul><li>状态转移：客户端与主机器进行交互，主机器更新状态，每隔一段时间有一个检查点，将状态传给从机器。因此一旦主机器有了状态的改变，这个状态就要马上传递给从机器。</li><li>状态机复制：不发送状态给从机器，而是将对主机器进行更改的操作发送给从机器。</li></ul><p>两种方法都是目前流行的方法，状态转移的缺点是如果一个操作生成了很多状态，这个传输的数据量非常大，因此如果只发送操作过去就很轻松。</p><h2 id="复制操作的级别">复制操作的级别</h2><p>应用级别：文件追加写入，需要在应用程序上进行修改</p><p>机器级别：寄存器指令级别的复制，只有x86指令，不涉及应用程序方面的更改，可以使用虚拟机实现，从而不用再硬件级别上实现。</p><h2 id="VM-FT">VM-FT</h2><p>利用虚拟化技术，使得复制操作对应用程序是透明的，应用程序认为仅有一台服务器，并且也同时提供了很强的一致性。</p><h3 id="概览">概览</h3><p>虚拟机监控器（hypervisor）：在实际硬件上运行，虚拟出多个虚拟的硬件</p><p>任何我们看到的外部事件实际上都经过了hypervisor，例如一个外部中断，hypervisor会先观察到并决定什么时候传递给虚拟机</p><p>多个hypervisor之间通过logging channel进行通信，从而进行操作的精确复制</p><p><a href="https://imgse.com/i/pSnSrQO"><img src="https://s1.ax1x.com/2023/01/11/pSnSrQO.md.png" alt="pSnSrQO.md.png"></a></p><p>storage server可以对谁当主机器进行仲裁</p><p>如果主机器和从机器不能相互通信，但是都能看到storage server，两台机器都会进行test-and-set操作，比较早的那一个就会成为主机器。</p><h3 id="设计">设计</h3><p>目标：多台虚拟机对外表现为单一的机器</p><p>问题：差异来源导致两台机器表现不一样</p><p>非确定性指令：</p><ul><li>获取时间的指令</li><li>数据的输入顺序需要相同</li><li>中断指令的顺序需要相同</li><li>多核——这篇论文中不允许</li></ul><h4 id="中断">中断</h4><p>确定性指令不需要通过logging channel进行通信</p><p>中断发生后，会传递给从机器中断发生的前一个指令号，但是从机器并不会马上去执行，而是缓存下来，等到下一条中断指令传递过来之后，再执行前一条指令。这样会落后一条指令</p><h4 id="非确定性指令">非确定性指令</h4><p>在机器启动之前会遍历全部的指令，确保浏览到全部的非确定性指令，不会直接执行，而会交给hypervisor进行控制。hypervisor执行的时候会额外记录下这些指令操作后的对应结果。传递的时候会同时对结果进行传递，这样从机器不需要真正去执行，直接修改结果就可以。</p><h2 id="性能">性能</h2><p>指令级别的复制会付出性能的代价</p><p>论文的实验表明带宽会降低大概30%左右，由于主机器接收来自客户端的输入，然后传递给从机器，这个过程中主机器必须等待，才能将响应传递给客户端。</p><p>因此状态机复制的方法并不常用的原因之一是性能会下降。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Distributed Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824 Distributed Systems-LEC 3 GFS</title>
    <link href="/2022/12/17/6.824/Distributed-Systems-MIT-6.824-LEC-3/"/>
    <url>/2022/12/17/6.824/Distributed-Systems-MIT-6.824-LEC-3/</url>
    
    <content type="html"><![CDATA[<p>MIT-6.824（Spring 2022）LEC 3 GFS</p><span id="more"></span><h1>GFS论文阅读</h1><p><a href="https://cloud.tencent.com/developer/article/1981238">参考资料</a>（感谢Alex！这篇论文翻译得非常有质量！）</p><div class="row">    <embed src="https://zhangzhao219.github.io/file/6.824/gfs.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="摘要">摘要</h2><p>Google GFS文件系统是一个面向大规模数据密集型应用的、可伸缩的分布式文件系统。GFS运行在廉价的普遍硬件设备上，但是依然了提供容错机制，为大量客户提供了高性能的服务。</p><p>GFS的设计目标与许多传统的分布式文件系统有很多相同之处，不过还是以我们对自己的应用的负载情况和技术环境的分析为基础进行设计，和早期的分布式文件系统有明显的不同。</p><p>GFS完全满足了我们对存储的需求。GFS作为存储平台已经被广泛的部署在Google内部，存储我们的服务产生和处理的数据，同时还用于那些需要大规模数据集的研究和开发工作。目前为止，最大的一个集群利用数千台机器的数千个硬盘，提供了数百TB的存储空间，同时为数百个客户机服务。</p><p>在本论文中，我们展示能够支持分布式应用的文件系统接口扩展，讨论我们设计的许多方面，最后列出了小规模性能测试以及真实生产系统中性能的相关数据。</p><h2 id="1-简介">1. 简介</h2><p>GFS与传统的分布式文件系统有着很多相同的设计目标，比如，性能、可伸缩性、可靠性以及可用性。但是，我们的设计还基于我们对我们自己的应用的负载情况和技术环境的观察的影响，和早期文件系统的假设都有明显的不同。</p><p>所以我们重新审视了传统文件系统在设计上的折衷选择，衍生出了完全不同的设计思路。</p><p>首先，<strong>组件失效被认为是常态事件，而不是意外事件</strong>。GFS组件的数量和质量导致在任何给定时间内都有可能发生某些组件无法工作，且某些组件无法从它们目前的失效状态中恢复。因此，持续的监控、错误侦测、容错以及自动恢复的机制必须集成在GFS中。</p><p>其次，<strong>我们的文件非常巨大</strong>，GB的文件非常普遍。当我们经常需要处理快速增长的、并且由数亿个对象构成的、数以TB的数据集时，采用管理数亿个KB大小的小文件的方式是非常不明智的。因此，设计的假设条件和参数，比如I/O操作和Block的尺寸等都需要重新考虑。</p><p>第三，<strong>绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式</strong>。一旦写完之后，对文件的操作就只有读，而且通常是按顺序读。对于这种针对海量文件的访问模式，客户端对数据块缓存是没有意义的，数据的追加操作是性能优化和原子性保证的主要考量因素。</p><p>第四，<strong>应用程序和文件系统API的协同设计提高了整个系统的灵活性</strong>。比如，我们放松了对GFS一致性模型的要求，这样就减轻了文件系统对应用程序的苛刻要求，大大简化了GFS的设计。我们引入了原子性的记录追加操作，从而保证多个客户端能够同时进行追加操作，不需要额外的同步操作来保证数据的一致性。</p><h2 id="2-设计概述">2. 设计概述</h2><h3 id="2-1-设计预期">2.1 设计预期</h3><ul><li>系统的组件失效是一种常态。系统必须持续监控自身的状态，迅速侦测、容忍并恢复失效的组件。</li><li>系统要能存储一定数量的大文件。系统也必须支持小文件，但是不需要针对小文件做专门的优化。</li><li>系统的工作负载主要由两种读操作组成：大规模的流式读取和小规模的随机读取。<ul><li>大规模的流式读取通常一次读取1MB甚至更多的数据。来自同一个客户机的连续操作通常是读取同一个文件中连续的一个区域。</li><li>小规模的随机读取通常是在文件某个随机的位置读取几个KB数据。通常的做法是把小规模的随机读取操作合并并排序，之后按顺序批量读取。</li></ul></li><li>系统的工作负载还包括许多大规模的、顺序的、数据追加方式的写操作。每次写入的数据的大小和大规模读类似。数据一旦被写入后，文件就很少会被修改了。</li><li>系统必须高效的、行为定义明确的。实现多客户端并行追加数据到同一个文件里的功能。</li><li>高性能的稳定网络带宽远比低延迟重要。我们的目标程序绝大部分要求能够高速率的、大批量的处理数据，极少有程序对单一的读写操作有严格的响应时间要求。</li></ul><h3 id="2-2-接口">2.2 接口</h3><p><strong>GFS提供了一套类似传统文件系统的API接口函数</strong>，虽然并不是严格按照POSIX等标准API的形式实现的。文件以分层目录的形式组织，用路径名来标识。支持常用的操作如创建新文件、删除文件、打开文件、关闭文件、读和写文件。</p><p>另外，GFS提供了<strong>快照</strong>和<strong>记录追加</strong>操作。快照以很低的成本创建一个文件或者目录树的拷贝。记录追加操作允许多个客户端同时对一个文件进行数据追加操作，同时保证每个客户端的追加操作都是原子性的。多个客户端可以在不需要额外的同步锁定的情况下，同时对一个文件追加数据。这些类型的文件对于构建大型分布应用是非常重要的。</p><h3 id="2-3-架构">2.3 架构</h3><p><a href="https://imgse.com/i/zbm43T"><img src="https://s1.ax1x.com/2022/12/17/zbm43T.md.png" alt="zbm43T.md.png"></a></p><p>一个GFS集群包含一个单独的Master节点   <em>（alex注：这里的一个单独的Master节点的含义是GFS系统中只存在一个逻辑上的Master组件。后面还会提到Master节点复制，因此，为了理解方便，我们把Master节点视为一个逻辑上的概念，一个逻辑的Master节点包括两台物理主机，即两台Master服务器）、</em> 和多台Chunk服务器，并且同时被多个客户端访问。Chunk服务器和客户端也可以放在同一台机器上。</p><p>GFS存储的文件都被分割成固定大小的Chunk。在Chunk创建的时候，Master服务器会给每个Chunk分配一个唯一不变的64位的Chunk标识。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据指定的Chunk标识和字节范围来读写块数据。出于可靠性的考虑，每个块都会复制到多个块服务器上，默认是3份。</p><p><strong>Master节点管理所有的文件系统元数据</strong>。这些元数据包括名字空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息。Master节点还管理着系统范围内的活动，比如，Chunk租用管理、孤儿Chunk的回收、以及Chunk在Chunk服务器之间的迁移。Master节点使用心跳信息周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。</p><p>GFS客户端代码以库的形式链接到客户程序里。客户端代码实现了GFS文件系统的API接口函数、应用程序与Master节点和Chunk服务器通讯、以及对数据进行读写操作。客户端和Master节点的通信只获取元数据，所有的数据操作都是由客户端直接和Chunk服务器进行交互的。</p><p><strong>无论是客户端还是Chunk服务器都不需要缓存文件数据</strong>。客户端缓存数据几乎没有什么用处，因为大部分程序要么以流的方式读取一个巨大文件，要么工作集太大根本无法被缓存。无需考虑缓存相关的问题也简化了客户端和整个系统的设计和实现。（不过，客户端会缓存元数据。）Chunk服务器不需要缓存文件数据的原因是，Chunk以本地文件的方式保存，Linux操作系统的文件系统缓存会把经常访问的数据缓存在内存中。</p><h3 id="2-4-单一Master节点">2.4 单一Master节点</h3><p>单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。不过我们必须减少对Master节点的读写，避免Master节点成为系统的瓶颈。<strong>客户端并不通过Master节点读写文件数据。而是向Master节点询问它应该联系的Chunk服务器</strong>。客户端将这些元数据信息缓存一段时间，后续的操作将直接和Chunk服务器进行数据读写操作。</p><p>一次简单读取的流程：首先，客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索引。然后，它把文件名和Chunk索引发送给Master节点。Master节点将相应的Chunk标识和副本的位置信息发还给客户端。客户端用文件名和Chunk索引作为key缓存这些信息。之后客户端发送请求到其中的一个（一般是最近的）副本处。请求信息包含了Chunk的标识和字节范围。在对这个Chunk的后续读取操作中，客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。实际上，客户端通常会在一次请求中查询多个Chunk信息，Master节点的回应也可能包含了紧跟着这些被请求的Chunk后面的Chunk的信息。在实际应用中，这些额外的信息避免了客户端和Master节点未来可能会发生的几次通讯。</p><h3 id="2-5-Chunk尺寸">2.5 Chunk尺寸</h3><p>Chunk的大小是关键的设计参数之一。我们选择了64MB，远远大于一般文件系统的Block size。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。惰性空间分配策略避免了因内部碎片造成的空间浪费，内部碎片或许是对选择这么大的Chunk尺寸最具争议的一点。</p><p>选择较大的Chunk尺寸有几个重要的优点。首先，它减少了客户端和Master节点通讯的需求，一次和Master节点的通信就可以获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作。即使是小规模的随机读取，客户端可以轻松的缓存一个数TB的工作数据集所有的Chunk位置信息。其次，采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。第三，选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量。</p><p>另一方面，即使配合惰性空间分配，采用较大的Chunk尺寸也有其缺陷。小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。在实际应用中，热点不是主要问题。</p><p>然而，当我们第一次把GFS用于批处理队列系统的时候，热点的问题还是产生了：一个可执行文件在GFS上保存为single-chunk文件，之后这个可执行文件在数百台机器上同时启动。存放这个可执行文件的几个Chunk服务器被数百个客户端的并发请求访问导致系统局部过载。<strong>我们通过将这个文件复制更多份，并错开批处理队列系统程序的启动时间的方法解决了这个问题</strong>。一个可能的长效解决方案是，在这种的情况下，允许客户端从其它客户端读取数据。</p><h3 id="2-6-元数据">2.6 元数据</h3><p>Master服务器（<em>alex注：注意逻辑的Master节点和物理的Master服务器的区别。后续我们谈的是每个Master服务器的行为，如存储、内存等等，因此我们将全部使用物理名称</em>）存储3种主要类型的元数据，包括：<strong>文件和Chunk的命名空间、文件和Chunk的对应关系、每个Chunk副本的存放地点</strong>。所有的元数据都保存在Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以记录变更日志的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被复制到其它的远程Master服务器上。采用保存变更日志的方式，我们能够简单可靠的更新Master服务器的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。Master服务器不会持久保存Chunk位置信息。Master服务器在启动时，或者有新的Chunk服务器加入时，向各个Chunk服务器轮询它们所存储的Chunk的信息。</p><h4 id="2-6-1-内存中的数据结构">2.6.1 内存中的数据结构</h4><p>因为元数据保存在内存中，所以Master服务器可以在后台简单而高效的周期性扫描自己保存的全部状态信息。这种周期性的状态扫描也用于实现Chunk垃圾收集、在Chunk服务器失效的时重新复制数据、通过Chunk的迁移实现跨Chunk服务器的负载均衡以及磁盘使用状况统计等功能。</p><p>将元数据全部保存在内存中的方法的问题：Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。但是在实际应用中，这并不是一个严重的问题。Master服务器只需要不到64个字节的元数据就能够管理一个64MB的Chunk。每个文件的在命名空间中的数据大小通常在64字节以下，因为保存的文件名是用前缀压缩算法压缩过的。</p><p>即便是需要支持更大的文件系统，为Master服务器增加额外内存的费用是很少的，增强了系统的简洁性、可靠性、高性能和灵活性。</p><h4 id="2-6-2-Chunk位置信息">2.6.2 Chunk位置信息</h4><p>Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。Master服务器只是在启动的时候轮询Chunk服务器以获取这些信息。Master服务器能够保证它持有的信息始终是最新的，因为它控制了所有的Chunk位置的分配，而且通过周期性的心跳信息监控Chunk服务器的状态。</p><p>最初设计时，我们试图把Chunk的位置信息持久的保存在Master服务器上，但是后来我们发现在启动的时候轮询Chunk服务器，之后定期轮询更新的方式更简单。这种设计简化了在有Chunk服务器加入集群、离开集群、更名、失效、以及重启的时候，Master服务器和Chunk服务器数据同步的问题。</p><p>可以从另外一个角度去理解这个设计决策：<strong>只有Chunk服务器才能最终确定一个Chunk是否在它的硬盘上</strong>。我们从没有考虑过在Master服务器上维护一个这些信息的全局视图，因为Chunk服务器的错误可能会导致Chunk自动消失(比如，硬盘损坏了或者无法访问了)，亦或者操作人员可能会重命名一个Chunk服务器。</p><h4 id="2-6-3-操作日志">2.6.3 操作日志</h4><p>操作日志包含了关键的元数据变更历史记录。这对GFS非常重要。这不仅仅是因为操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线 <em>（alex注：也就是通过逻辑日志的序号作为操作发生的逻辑时间，类似于事务系统中的LSN）</em> 。文件和Chunk，连同它们的版本，都由它们创建的逻辑时间唯一的、永久的标识。</p><p>操作日志非常重要，我们必须确保日志文件的完整，确保只有在元数据的变化被持久化后，日志才对客户端是可见的。否则，即使Chunk本身没有出现任何问题，我们仍有可能丢失整个文件系统，或者丢失客户端最近的操作。所以，<strong>我们会把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求</strong>。Master服务器会收集多个日志记录后批量处理，以减少写入磁盘和复制对系统整体性能的影响。</p><p>Master服务器在恢复时，通过重演操作日志把文件系统恢复到最近的状态。为了缩短Master启动的时间，我们必须使日志足够小   <em>（alex注：即重演系统操作的日志量尽量的少）。</em> Master服务器在日志增长到一定量时对系统状态做一次Checkpoint  <em>(alex注：Checkpoint是一种行为，一种对数据库状态作一次快照的行为)，</em> 将所有的状态数据写入一个Checkpoint文件  <em>（alex注：并删除之前的日志文件）。</em> 在灾难恢复的时候，Master服务器就通过从磁盘上读取这个Checkpoint文件，以及重演Checkpoint之后的有限个日志文件就能够恢复系统。Checkpoint文件以压缩B-树形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。</p><p>由于创建一个Checkpoint文件需要一定的时间，所以Master服务器的内部状态被组织为一种格式，这种格式要确保在Checkpoint过程中不会阻塞正在进行的修改操作。Master服务器使用独立的线程切换到新的日志文件和创建新的Checkpoint文件。新的Checkpoint文件包括切换前所有的修改。对于一个包含数百万个文件的集群，创建一个Checkpoint文件需要1分钟左右的时间。创建完成后，Checkpoint文件会被写入在本地和远程的硬盘里。</p><p>Master服务器恢复只需要最新的Checkpoint文件和后续的日志文件。旧的Checkpoint文件和日志文件可以被删除，但是为了应对灾难性的故障 <em>（alex注：catastrophes，数据备份相关文档中经常会遇到这个词，表示一种超出预期范围的灾难性事件），</em> 我们通常会多保存一些历史文件。Checkpoint失败不会对正确性产生任何影响，因为恢复功能的代码可以检测并跳过没有完成的Checkpoint文件。</p><h3 id="2-7-一致性模型">2.7 一致性模型</h3><p>GFS支持一个宽松的一致性模型，这个模型能够很好的支撑我们的高度分布的应用，同时还保持了相对简单且容易实现的优点。本节我们讨论GFS的一致性的保障机制，以及对应用程序的意义。我们也着重描述了GFS如何管理这些一致性保障机制。</p><h4 id="2-7-1-GFS一致性保障机制">2.7.1 GFS一致性保障机制</h4><p>文件命名空间的修改（例如，文件创建）是原子性的。它们仅由Master节点的控制：命名空间锁提供了原子性和正确性的保障；Master节点的操作日志定义了这些操作在全局的顺序。</p><p>数据修改后文件region <em>（alex注：region这个词用中文非常难以表达，我认为应该是修改操作所涉及的文件中的某个范围）</em> 的状态取决于操作的类型、成功与否、以及是否同步修改。如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件region是“一致的”；如果对文件的数据修改之后，region是一致的，并且客户端能够看到写入操作全部的内容，那么这个region是“已定义的”。当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰，那么影响的region就是已定义的（隐含了一致性）：所有的客户端都可以看到写入的内容。并行修改操作成功完成之后，region处于一致的、未定义的状态：所有的客户端看到同样的数据，但是无法读到任何一次写入操作写入的数据。通常情况下，文件region内包含了来自多个修改操作的、混杂的数据片段。失败的修改操作导致一个region处于不一致状态（同时也是未定义的）：不同的客户在不同的时间会看到不同的数据。</p><p>数据修改操作分为写入或者记录追加两种。写入操作把数据写在应用程序指定的文件偏移位置上。即使有多个修改操作并行执行时，记录追加操作至少可以把数据原子性的追加到文件中一次，但是偏移位置是由GFS选择的 <em>（alex注：这句话有点费解，其含义是所有的追加写入都会成功，但是有可能被执行了多次，而且每次追加的文件偏移量由GFS自己计算）</em> 。（相比而言，通常说的追加操作写的偏移位置是文件的尾部。）GFS返回给客户端一个偏移量，表示了包含了写入记录的、已定义的region的起点。另外，GFS可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件region被认定是不一致的，这些数据通常比用户数据小的多。</p><p>经过了一系列的成功的修改操作之后，GFS确保被修改的文件region是已定义的，并且包含最后一次修改操作写入的数据。GFS通过以下措施确保上述行为：（a） 对Chunk的所有副本的修改操作顺序一致（3.1章），（b）使用Chunk的版本号来检测副本是否因为它所在的Chunk服务器宕机（4.5章）而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master服务器也不再返回这个Chunk副本的位置信息给客户端。它们会被垃圾收集系统尽快回收。</p><p>由于Chunk位置信息会被客户端缓存，所以在信息刷新前，客户端有可能从一个失效的副本读取了数据。在缓存的超时时间和文件下一次被打开的时间之间存在一个时间窗，文件再次被打开后会清除缓存中与该文件有关的所有Chunk位置信息。而且，由于我们的文件大多数都是只进行追加操作的，所以，一个失效的副本通常返回一个提前结束的Chunk而不是过期的数据。当一个Reader   <em>（alex注：本文中将用到两个专有名词，Reader和Writer，分别表示执行GFS读取和写入操作的程序）</em> 重新尝试并联络Master服务器时，它就会立刻得到最新的Chunk位置信息。</p><p>即使在修改操作成功执行很长时间之后，组件的失效也可能损坏或者删除数据。GFS通过Master服务器和所有Chunk服务器的定期“握手”来找到失效的Chunk服务器，并且使用Checksum来校验数据是否损坏（5.2章）。一旦发现问题，数据要尽快利用有效的副本进行恢复（4.3章）。只有当一个Chunk的所有副本在GFS检测到错误并采取应对措施之前全部丢失，这个Chunk才会不可逆转的丢失。在一般情况下GFS的反应时间   <em>（alex注：指Master节点检测到错误并采取应对措施）</em> 是几分钟。即使在这种情况下，Chunk也只是不可用了，而不是损坏了：应用程序会收到明确的错误信息而不是损坏的数据。</p><h4 id="2-7-2-程序的实现">2.7.2 程序的实现</h4><p>使用GFS的应用程序可以利用一些简单技术实现这个宽松的一致性模型，这些技术也用来实现一些其它的目标功能，包括：尽量采用追加写入而不是覆盖，Checkpoint，自验证的写入操作，自标识的记录。</p><p>在实际应用中，我们所有的应用程序对文件的写入操作都是尽量采用数据追加方式，而不是覆盖方式。一种典型的应用，应用程序从头到尾写入数据，生成了一个文件。写入所有数据之后，应用程序自动将文件改名为一个永久保存的文件名，或者周期性的作Checkpoint，记录成功写入了多少数据。Checkpoint文件可以包含程序级别的校验和。Readers仅校验并处理上个Checkpoint之后产生的文件region，这些文件region的状态一定是已定义的。这个方法满足了我们一致性和并发处理的要求。追加写入比随机位置写入更加有效率，对应用程序的失败处理更具有弹性。Checkpoint可以让Writer以渐进的方式重新开始，并且可以防止Reader处理已经被成功写入，但是从应用程序的角度来看还并未完成的数据。</p><p>我们再来分析另一种典型的应用。许多应用程序并行的追加数据到同一个文件，比如进行结果的合并或者是一个生产者-消费者队列。记录追加方式的“至少一次追加”的特性保证了Writer的输出。Readers使用下面的方法来处理偶然性的填充数据和重复内容。Writers在每条写入的记录中都包含了额外的信息，例如Checksum，用来验证它的有效性。Reader可以利用Checksum识别和抛弃额外的填充数据和记录片段。如果应用不能容忍偶尔的重复内容(比如，如果这些重复数据触发了非幂等操作)，可以用记录的唯一标识符来过滤它们，这些唯一标识符通常用于命名程序中处理的实体对象，例如web文档。这些记录I/O功能   <em>（alex注：These functionalities for record I/O）</em> （除了剔除重复数据）都包含在我们的程序共享的库中，并且适用于Google内部的其它的文件接口实现。所以，相同序列的记录，加上一些偶尔出现的重复数据，都被分发到Reader了。</p><h2 id="3-系统交互">3. 系统交互</h2><p>我们在设计这个系统时，一个重要的原则是最小化所有操作和Master节点的交互。带着这样的设计理念，我们现在描述一下客户机、Master服务器和Chunk服务器如何进行交互，以实现数据修改操作、原子的记录追加操作以及快照功能。</p><h3 id="3-1-租约（lease）和变更顺序">3.1 租约（lease）和变更顺序</h3><p><em>（alex注：lease是数据库中的一个术语）</em></p><p>变更是一个会改变Chunk内容或者元数据的操作，比如写入操作或者记录追加操作。变更操作会在Chunk的所有副本上执行。我们使用租约（lease）机制来保持多个副本间变更顺序的一致性。Master节点为Chunk的一个副本建立一个租约，我们把这个副本叫做主Chunk。主Chunk对Chunk的所有更改操作进行序列化。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序首先由Master节点选择的租约的顺序决定，然后由租约中主Chunk分配的序列号决定。</p><p>设计租约机制的目的是为了最小化Master节点的管理负担。租约的初始超时设置为60秒。不过，只要Chunk被修改了，主Chunk就可以申请更长的租期，通常会得到Master节点的确认并收到租约延长的时间。这些租约延长请求和批准的信息通常都是附加在Master节点和Chunk服务器之间的心跳消息中来传递。有时Master节点会试图提前取消租约（例如，Master节点想取消在一个已经被改名的文件上的修改操作）。即使Master节点和主Chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个Chunk副本签订新的租约。</p><p>在图中，依据步骤编号，展现写入操作的控制流程。</p><p><a href="https://imgse.com/i/zbbzEn"><img src="https://s1.ax1x.com/2022/12/18/zbbzEn.png" alt="zbbzEn.png"></a></p><ol><li>客户机向Master节点询问哪一个Chunk服务器持有当前的租约，以及其它副本的位置。如果没有一个Chunk持有租约，Master节点就选择其中一个副本建立一个租约（这个步骤在图上没有显示）。</li><li>Master节点将主Chunk的标识符以及其它副本（又称为secondary副本、二级副本）的位置返回给客户机。客户机缓存这些数据以便后续的操作。只有在主Chunk不可用，或者主Chunk回复信息表明它已不再持有租约的时候，客户机才需要重新跟Master节点联系。</li><li>客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk服务器接收到数据并保存在它的内部LRU缓存中，一直到数据被使用或者过期交换出去。由于数据流的网络传输负载非常高，通过分离数据流和控制流，我们可以基于网络拓扑情况对数据流进行规划，提高系统性能，而不用去理会哪个Chunk服务器保存了主Chunk。3.2章节会进一步讨论这点。</li><li>当所有的副本都确认接收到了数据，客户机发送写请求到主Chunk服务器。这个请求标识了早前推送到所有副本的数据。主Chunk为接收到的所有操作分配连续的序列号，这些操作可能来自不同的客户机，序列号保证了操作顺序执行。它以序列号的顺序把操作应用到它自己的本地状态中     <em>（alex注：也就是在本地执行这些操作，这句话按字面翻译有点费解，也许应该翻译为“它顺序执行这些操作，并更新自己的状态”）</em> 。</li><li>主Chunk把写请求传递到所有的二级副本。每个二级副本依照主Chunk分配的序列号以相同的顺序执行这些操作。</li><li>所有的二级副本回复主Chunk，它们已经完成了操作。</li><li>主Chunk服务器     <em>（alex注：即主Chunk所在的Chunk服务器）</em> 回复客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写入操作可能在主Chunk和一些二级副本执行成功。（如果操作在主Chunk上失败了，操作就不会被分配序列号，也不会被传递。）客户端的请求被确认为失败，被修改的region处于不一致的状态。我们的客户机代码通过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤（3）到步骤（7）做几次尝试。</li></ol><p>如果应用程序一次写入的数据量很大，或者数据跨越了多个Chunk，GFS客户机代码会把它们分成多个写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。因此，共享的文件region的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分解后的写入操作在所有的副本上都以相同的顺序执行完成，Chunk的所有副本都是一致的。这使文件region处于2.7节描述的一致的、但是未定义的状态。</p><h3 id="3-2-数据流">3.2 数据流</h3><p>为了提高网络效率，我们采取了把数据流和控制流分开的措施。在控制流从客户机到主Chunk、然后再到所有二级副本的同时，数据以管道的方式，顺序的沿着一个精心选择的Chunk服务器链推送。我们的目标是充分利用每台机器的带宽，避免网络瓶颈和高延时的连接，最小化推送所有数据的延时。</p><p>为了充分利用每台机器的带宽，数据沿着一个Chunk服务器链顺序的推送，而不是以其它拓扑形式分散推送（例如，树型拓扑结构）。线性推送模式下，每台机器所有的出口带宽都用于以最快的速度传输数据，而不是在多个接受者之间分配带宽。</p><p>为了尽可能的避免出现网络瓶颈和高延迟的链接（eg，inter-switch最有可能出现类似问题），每台机器都尽量的在网络拓扑中选择一台还没有接收到数据的、离自己最近的机器作为目标推送数据。假设客户机把数据从Chunk服务器S1推送到S4。它把数据推送到最近的Chunk服务器S1。S1把数据推送到S2，因为S2和S4中最接近的机器是S2。同样的，S2把数据传递给S3和S4之间更近的机器，依次类推推送下去。我们的网络拓扑非常简单，通过IP地址就可以计算出节点的“距离”。</p><p>最后，我们利用基于TCP连接的、管道式数据推送方式来最小化延迟。Chunk服务器接收到数据后，马上开始向前推送。管道方式的数据推送对我们帮助很大，因为我们采用全双工的交换网络。接收到数据后立刻向前推送不会降低接收的速度。在没有网络拥塞的情况下，传送B字节的数据到R个副本的理想时间是 B/T+RL ，T是网络的吞吐量，L是在两台机器数据传输的延迟。通常情况下，我们的网络连接速度是100Mbps（T），L将远小于1ms。因此，1MB的数据在理想情况下80ms左右就能分发出去。</p><h3 id="3-3-原子的记录追加">3.3 原子的记录追加</h3><p>GFS提供了一种原子的数据追加操作–记录追加。传统方式的写入操作，客户程序会指定数据写入的偏移量。对同一个region的并行写入操作不是串行的：region尾部可能会包含多个不同客户机写入的数据片段。使用记录追加，客户机只需要指定要写入的数据。GFS保证至少有一次原子的写入操作成功执行（即写入一个顺序的byte流），写入的数据追加到GFS指定的偏移位置上，之后GFS返回这个偏移量给客户机。这类似于在Unix操作系统编程环境中，对以O_APPEND模式打开的文件，多个并发写操作在没有竞态条件时的行为。</p><p>记录追加在我们的分布应用中非常频繁的使用，在这些分布式应用中，通常有很多的客户机并行地对同一个文件追加写入数据。如果我们采用传统方式的文件写入操作，客户机需要额外的复杂、昂贵的同步机制，例如使用一个分布式的锁管理器。在我们的工作中，这样的文件通常用于多个生产者/单一消费者的队列系统，或者是合并了来自多个客户机的数据的结果文件。</p><p>记录追加是一种修改操作，它也遵循3.1节描述的控制流程，除了在主Chunk有些额外的控制逻辑。客户机把数据推送给文件最后一个Chunk的所有副本，之后发送请求给主Chunk。主Chunk会检查这次记录追加操作是否会使Chunk超过最大尺寸（64MB）。如果超过了最大尺寸，主Chunk首先将当前Chunk填充到最大尺寸，之后通知所有二级副本做同样的操作，然后回复客户机要求其对下一个Chunk重新进行记录追加操作。（记录追加的数据大小严格控制在Chunk最大尺寸的1/4，这样即使在最坏情况下，数据碎片的数量仍然在可控的范围。）通常情况下追加的记录不超过Chunk的最大尺寸，主Chunk把数据追加到自己的副本内，然后通知二级副本把数据写在跟主Chunk一样的位置上，最后回复客户机操作成功。</p><p>如果记录追加操作在任何一个副本上失败了，客户端就需要重新进行操作。重新进行记录追加的结果是，同一个Chunk的不同副本可能包含不同的数据–重复包含一个记录全部或者部分的数据。GFS并不保证Chunk的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子的被至少写入一次。这个特性可以通过简单观察推导出来：如果操作成功执行，数据一定已经写入到Chunk的所有副本的相同偏移位置上。这之后，所有的副本至少都到了记录尾部的长度，任何后续的记录都会追加到更大的偏移地址，或者是不同的Chunk上，即使其它的Chunk副本被Master节点选为了主Chunk。就我们的一致性保障模型而言，记录追加操作成功写入数据的region是已定义的（因此也是一致的），反之则是不一致的（因此也就是未定义的）。正如我们在2.7.2节讨论的，我们的程序可以处理不一致的区域。</p><h3 id="3-4-快照">3.4 快照</h3><p><em>(alex注：这一节非常难以理解，总的来说依次讲述了什么是快照、快照使用的COW技术、快照如何不干扰当前操作)</em></p><p>快照操作几乎可以瞬间完成对一个文件或者目录树（“源”）做一个拷贝，并且几乎不会对正在进行的其它操作造成任何干扰。我们的用户可以使用快照迅速的创建一个巨大的数据集的分支拷贝（而且经常是递归的拷贝拷贝），或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的提交或者回滚到备份时的状态。</p><p>就像AFS   <em>（alex注：AFS，即Andrew File System，一种分布式文件系统），</em> 我们用标准的copy-on-write技术实现快照。当Master节点收到一个快照请求，它首先取消作快照的文件的所有Chunk的租约。这个措施保证了后续对这些Chunk的写操作都必须与Master交互交互以找到租约持有者。这就给Master节点一个率先创建Chunk的新拷贝的机会。</p><p>租约取消或者过期之后，Master节点把这个操作以日志的方式记录到硬盘上。然后，Master节点通过复制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件和源文件指向完全相同的Chunk地址。</p><p>在快照操作之后，当客户机第一次想写入数据到Chunk C，它首先会发送一个请求到Master节点查询当前的租约持有者。Master节点注意到Chunke C的引用计数超过了1   <em>(alex注：不太明白为什么会大于1.难道是Snapshot没有释放引用计数？)</em> 。Master节点不会马上回复客户机的请求，而是选择一个新的Chunk句柄C 。之后，Master节点要求每个拥有Chunk C当前副本的Chunk服务器创建一个叫做C的新Chunk。通过在源Chunk所在Chunk服务器上创建新的Chunk，我们确保数据在本地而不是通过网络复制（我们的硬盘比我们的100Mb以太网大约快3倍）。从这点来讲，请求的处理方式和任何其它Chunk没什么不同：Master节点确保新Chunk C`的一个副本拥有租约，之后回复客户机，客户机得到回复后就可以正常的写这个Chunk，而不必理会它是从一个已存在的Chunk克隆出来的。</p><h2 id="4-Master节点的操作">4. Master节点的操作</h2><p>Master节点执行所有的名称空间操作。此外，它还管理着整个系统里所有Chunk的副本：它决定Chunk的存储位置，创建新Chunk和它的副本，协调各种各样的系统活动以保证Chunk被完全复制，在所有的Chunk服务器之间的进行负载均衡，回收不再使用的存储空间。</p><h3 id="4-1-名称空间管理和锁">4.1 名称空间管理和锁</h3><p>Master节点的很多操作会花费很长的时间：比如，快照操作必须取消Chunk服务器上快照所涉及的所有的Chunk的租约。我们不希望在这些操作的运行时，延缓了其它的Master节点的操作。因此，我们允许多个操作同时进行，使用名称空间的region上的锁来保证执行的正确顺序。</p><p>不同于许多传统文件系统，GFS没有针对每个目录实现能够列出目录下所有文件的数据结构。GFS也不支持文件或者目录的链接（即Unix术语中的硬链接或者符号链接）。在逻辑上，GFS的名称空间就是一个全路径和元数据映射关系的查找表。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型结构上，每个节点（绝对路径的文件名或绝对路径的目录名）都有一个关联的读写锁。</p><p>每个Master节点的操作在开始之前都要获得一系列的锁。通常情况下，如果一个操作涉及/d1/d2/…/dn/leaf，那么操作首先要获得目录/d1，/d1/d2，…，/d1/d2/…/dn的读锁，以及/d1/d2/…/dn/leaf的读写锁。注意，根据操作的不同，leaf可以是一个文件，也可以是一个目录。</p><p>我们演示一下在/home/user被快照到/save/user的时候，锁机制如何防止创建文件/home/user/foo。快照操作获取/home和/save的读取锁，以及/home/user和/save/user的写入锁。文件创建操作获得/home和/home/user的读取锁，以及/home/user/foo的写入锁。这两个操作要顺序执行，因为它们试图获取的/home/user的锁是相互冲突。文件创建操作不需要获取父目录的写入锁，因为这里没有”目录”，或者类似inode等用来禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。</p><p>采用这种锁方案的优点是支持对同一目录的并行操作。比如，可以在同一个目录下同时创建多个文件：每一个操作都获取一个目录名的上的读取锁和文件名上的写入锁。目录名的读取锁足以的防止目录被删除、改名以及被快照。文件名的写入锁序列化文件创建操作，确保不会多次创建同名的文件。</p><p>因为名称空间可能有很多节点，读写锁采用惰性分配策略，在不再使用的时候立刻被删除。同样，锁的获取也要依据一个全局一致的顺序来避免死锁：首先按名称空间的层次排序，在同一个层次内按字典顺序排序。</p><h3 id="4-2-副本的位置">4.2 副本的位置</h3><p>GFS集群是高度分布的多层布局结构，而不是平面结构。典型的拓扑结构是有数百个Chunk服务器安装在许多机架上。Chunk服务器被来自同一或者不同机架上的数百个客户机轮流访问。不同机架上的两台机器间的通讯可能跨越一个或多个网络交换机。另外，机架的出入带宽可能比机架内所有机器加和在一起的带宽要小。多层分布架构对数据的灵活性、可靠性以及可用性方面提出特有的挑战。</p><p>Chunk副本位置选择的策略服务两大目标：最大化数据可靠性和可用性，最大化网络带宽利用率。为了实现这两个目的，仅仅是在多台机器上分别存储这些副本是不够的，这只能预防硬盘损坏或者机器失效带来的影响，以及最大化每台机器的网络带宽利用率。我们必须在多个机架间分布储存Chunk的副本。这保证Chunk的一些副本在整个机架被破坏或掉线（比如，共享资源，如电源或者网络交换机造成的问题）的情况下依然存在且保持可用状态。这还意味着在网络流量方面，尤其是针对Chunk的读操作，能够有效利用多个机架的整合带宽。另一方面，写操作必须和多个机架上的设备进行网络通信，但是这个代价是我们愿意付出的。</p><h3 id="4-3-创建，重新复制，重新负载均衡">4.3 创建，重新复制，重新负载均衡</h3><p>Chunk的副本有三个用途：Chunk创建，重新复制和重新负载均衡。</p><p>当Master节点创建一个Chunk时，它会选择在哪里放置初始的空的副本。Master节点会考虑几个因素。（1）我们希望在低于平均硬盘使用率的Chunk服务器上存储新的副本。这样的做法最终能够平衡Chunk服务器之间的硬盘使用率。（2）我们希望限制在每个Chunk服务器上”最近”的Chunk创建操作的次数。虽然创建操作本身是廉价的，但是创建操作也意味着随之会有大量的写入数据的操作，因为Chunk在Writer真正写入数据的时候才被创建，而在我们的”追加一次，读取多次”的工作模式下，Chunk一旦写入成功之后就会变为只读的了。（3）如上所述，我们希望把Chunk的副本分布在多个机架之间。</p><p>当Chunk的有效副本数量少于用户指定的复制因数的时候，Master节点会重新复制它。这可能是由几个原因引起的：一个Chunk服务器不可用了，Chunk服务器报告它所存储的一个副本损坏了，Chunk服务器的一个磁盘因为错误不可用了，或者Chunk副本的复制因数提高了。每个需要被重新复制的Chunk都会根据几个因素进行排序。一个因素是Chunk现有副本数量和复制因数相差多少。例如，丢失两个副本的Chunk比丢失一个副本的Chunk有更高的优先级。另外，我们优先重新复制活跃（live）文件的Chunk而不是最近刚被删除的文件的Chunk（查看4.4节）。最后，为了最小化失效的Chunk对正在运行的应用程序的影响，我们提高会阻塞客户机程序处理流程的Chunk的优先级。</p><p>Master节点选择优先级最高的Chunk，然后命令某个Chunk服务器直接从可用的副本”克隆”一个副本出来。选择新副本的位置的策略和创建时类似：平衡硬盘使用率、限制同一台Chunk服务器上的正在进行的克隆操作的数量、在机架间分布副本。为了防止克隆产生的网络流量大大超过客户机的流量，Master节点对整个集群和每个Chunk服务器上的同时进行的克隆操作的数量都进行了限制。另外，Chunk服务器通过调节它对源Chunk服务器读请求的频率来限制它用于克隆操作的带宽。</p><p>最后，Master服务器周期性地对副本进行重新负载均衡：它检查当前的副本分布情况，然后移动副本以便更好的利用硬盘空间、更有效的进行负载均衡。而且在这个过程中，Master服务器逐渐的填满一个新的Chunk服务器，而不是在短时间内用新的Chunk填满它，以至于过载。新副本的存储位置选择策略和上面讨论的相同。另外，Master节点必须选择哪个副本要被移走。通常情况，Master节点移走那些剩余空间低于平均值的Chunk服务器上的副本，从而平衡系统整体的硬盘使用率。</p><h3 id="4-4-垃圾回收">4.4 垃圾回收</h3><p>GFS在文件删除后不会立刻回收可用的物理空间。GFS空间回收采用惰性的策略，只在文件和Chunk级的常规垃圾收集时进行。我们发现这个方法使系统更简单、更可靠。</p><h4 id="4-4-1-机制">4.4.1 机制</h4><p>当一个文件被应用程序删除时，Master节点像对待其它修改操作一样，立刻把删除操作以日志的方式记录下来。但是，Master节点并不马上回收资源，而是把文件名改为一个包含删除时间戳的、隐藏的名字。当Master节点对文件系统命名空间做常规扫描的时候，它会删除所有三天前的隐藏文件（这个时间间隔是可以设置的）。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。当隐藏文件被从名称空间中删除，Master服务器内存中保存的这个文件的相关元数据才会被删除。这也有效的切断了文件和它包含的所有Chunk的连接   <em>（alex注：原文是This effectively severs its links to all its chunks）</em> 。</p><p>在对Chunk名字空间做类似的常规扫描时，Master节点找到孤儿Chunk（不被任何文件包含的Chunk）并删除它们的元数据。Chunk服务器在和Master节点交互的心跳信息中，报告它拥有的Chunk子集的信息，Master节点回复Chunk服务器哪些Chunk在Master节点保存的元数据中已经不存在了。Chunk服务器可以任意删除这些Chunk的副本。</p><h4 id="4-4-2-讨论">4.4.2 讨论</h4><p>虽然分布式垃圾回收在编程语言领域是一个需要复杂的方案才能解决的难题，但是在GFS系统中是非常简单的。我们可以轻易的得到Chunk的所有引用：它们都只存储在Master服务器上的文件到块的映射表中。我们也可以很轻易的得到所有Chunk的副本：它们都以Linux文件的形式存储在Chunk服务器的指定目录下。所有Master节点不能识别的副本都是”垃圾”。</p><p>垃圾回收在空间回收方面相比直接删除有几个优势。首先，对于组件失效是常态的大规模分布式系统，垃圾回收方式简单可靠。Chunk可能在某些Chunk服务器创建成功，某些Chunk服务器上创建失败，失败的副本处于无法被Master节点识别的状态。副本删除消息可能丢失，Master节点必须重新发送失败的删除消息，包括自身的和Chunk服务器的   <em>（alex注：自身的指删除metadata的消息）</em> 。垃圾回收提供了一致的、可靠的清除无用副本的方法。第二，垃圾回收把存储空间的回收操作合并到Master节点规律性的后台活动中，比如，例行扫描和与Chunk服务器握手等。因此，操作被批量的执行，开销会被分散。另外，垃圾回收在Master节点相对空闲的时候完成。这样Master节点就可以给那些需要快速反应的客户机请求提供更快捷的响应。第三，延缓存储空间回收为意外的、不可逆转的删除操作提供了安全保障。</p><p>根据我们的使用经验，延迟回收空间的主要问题是，延迟回收会阻碍用户调优存储空间的使用，特别是当存储空间比较紧缺的时候。当应用程序重复创建和删除临时文件时，释放的存储空间不能马上重用。我们通过显式的再次删除一个已经被删除的文件的方式加速空间回收的速度。我们允许用户为命名空间的不同部分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的、不可恢复的从文件系统移除。</p><h3 id="4-5-过期失效的副本检测">4.5 过期失效的副本检测</h3><p>当Chunk服务器失效时，Chunk的副本有可能因错失了一些修改操作而过期失效。Master节点保存了每个Chunk的版本号，用来区分当前的副本和过期副本。</p><p>无论何时，只要Master节点和Chunk签订一个新的租约，它就增加Chunk的版本号，然后通知最新的副本。Master节点和这些副本都把新的版本号记录在它们持久化存储的状态信息中。这个动作发生在任何客户机得到通知以前，因此也是对这个Chunk开始写之前。如果某个副本所在的Chunk服务器正好处于失效状态，那么副本的版本号就不会被增加。Master节点在这个Chunk服务器重新启动，并且向Master节点报告它拥有的Chunk的集合以及相应的版本号的时候，就会检测出它包含过期的Chunk。如果Master节点看到一个比它记录的版本号更高的版本号，Master节点会认为它和Chunk服务器签订租约的操作失败了，因此会选择更高的版本号作为当前的版本号。</p><p>Master节点在例行的垃圾回收过程中移除所有的过期失效副本。在此之前，Master节点在回复客户机的Chunk信息请求的时候，简单的认为那些过期的块根本就不存在。另外一重保障措施是，Master节点在通知客户机哪个Chunk服务器持有租约、或者指示Chunk服务器从哪个Chunk服务器进行克隆时，消息中都附带了Chunk的版本号。客户机或者Chunk服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。</p><h2 id="5-容错和诊断">5. 容错和诊断</h2><p>我们在设计GFS时遇到的最大挑战之一是如何处理频繁发生的组件失效。组件的数量和质量让这些问题出现的频率远远超过一般系统意外发生的频率：我们不能完全依赖机器的稳定性，也不能完全相信硬盘的可靠性。组件的失效可能造成系统不可用，更糟糕的是，还可能产生不完整的数据。我们讨论我们如何面对这些挑战，以及当组件失效不可避免的发生时，用GFS自带工具诊断系统故障。</p><h3 id="5-1-高可用性">5.1 高可用性</h3><p>在GFS集群的数百个服务器之中，在任何给定的时间必定会有些服务器是不可用的。我们使用两条简单但是有效的策略保证整个系统的高可用性：快速恢复和复制。</p><h4 id="5-1-1-快速恢复">5.1.1 快速恢复</h4><p>不管Master服务器和Chunk服务器是如何关闭的，它们都被设计为可以在数秒钟内恢复它们的状态并重新启动。事实上，我们并不区分正常关闭和异常关闭；通常，我们通过直接kill掉进程来关闭服务器。客户机和其它的服务器会感觉到系统有点颠簸    <em>(alex注：a minor hiccup)</em> ，正在发出的请求会超时，需要重新连接到重启后的服务器，然后重试这个请求。</p><h4 id="5-1-2-Chunk复制">5.1.2 Chunk复制</h4><p>正如之前讨论的，每个Chunk都被复制到不同机架上的不同的Chunk服务器上。用户可以为文件命名空间的不同部分设定不同的复制级别。缺省是3。当有Chunk服务器离线了，或者通过Chksum校验（参考5.2节）发现了已经损坏的数据，Master节点通过克隆已有的副本保证每个Chunk都被完整复制 <em>（alex注：即每个Chunk都有复制因子制定的个数个副本，缺省是3）。</em> 虽然Chunk复制策略对我们非常有效，但是我们也在寻找其它形式的跨服务器的冗余解决方案，比如使用奇偶校验、或者Erasure codes <em>（alex注：Erasure codes用来解决链接层中不相关的错误，以及网络拥塞和buffer限制造成的丢包错误）</em> 来解决我们日益增长的只读存储需求。我们的系统主要的工作负载是追加方式的写入和读取操作，很少有随机的写入操作，因此，我们认为在我们这个高度解耦合的系统架构下实现这些复杂的冗余方案很有挑战性，但并非不可实现。</p><h4 id="5-1-3-Master服务器的复制">5.1.3 Master服务器的复制</h4><p>为了保证Master服务器的可靠性，Master服务器的状态也要复制。Master服务器所有的操作日志和checkpoint文件都被复制到多台机器上。对Master服务器状态的修改操作能够提交成功的前提是，操作日志写入到Master服务器的备节点和本机的磁盘。简单说来，一个Master服务进程负责所有的修改操作，包括后台的服务，比如垃圾回收等改变系统内部状态活动。当它失效的时候，几乎可以立刻重新启动。如果Master进程所在的机器或者磁盘失效了，处于GFS系统外部的监控进程会在其它的存有完整操作日志的机器上启动一个新的Master进程。客户端使用规范的名字访问Master（比如gfs-test）节点，这个名字类似DNS别名，因此也就可以在Master进程转到别的机器上执行时，通过更改别名的实际指向访问新的Master节点。</p><p>此外，GFS中还有些“影子”Master服务器，这些“影子”服务器在“主”Master服务器宕机的时候提供文件系统的只读访问。它们是影子，而不是镜像，所以它们的数据可能比“主”Master服务器更新要慢，通常是不到1秒。对于那些不经常改变的文件、或者那些允许获取的数据有少量过期的应用程序，“影子”Master服务器能够提高读取的效率。事实上，因为文件内容是从Chunk服务器上读取的，因此，应用程序不会发现过期的文件内容。在这个短暂的时间窗内，过期的可能是文件的元数据，比如目录的内容或者访问控制信息。</p><p>“影子”Master服务器为了保持自身状态是最新的，它会读取一份当前正在进行的操作的日志副本，并且依照和主Master服务器完全相同的顺序来更改内部的数据结构。和主Master服务器一样，“影子”Master服务器在启动的时候也会从Chunk服务器轮询数据（之后定期拉数据），数据中包括了Chunk副本的位置信息；“影子”Master服务器也会定期和Chunk服务器“握手”来确定它们的状态。在主Master服务器因创建和删除副本导致副本位置信息更新时，“影子”Master服务器才和主Master服务器通信来更新自身状态。</p><h3 id="5-2-数据完整性">5.2 数据完整性</h3><p>每个Chunk服务器都使用Checksum来检查保存的数据是否损坏。考虑到一个GFS集群通常都有好几百台机器、几千块硬盘，磁盘损坏导致数据在读写过程中损坏或者丢失是非常常见的（第7节讲了一个原因）。我们可以通过别的Chunk副本来解决数据损坏问题，但是跨越Chunk服务器比较副本来检查数据是否损坏很不实际。另外，GFS允许有歧义的副本存在：GFS修改操作的语义，特别是早先讨论过的原子纪录追加的操作，并不保证副本完全相同 <em>(alex注：副本不是byte-wise完全一致的)</em> 。因此，每个Chunk服务器必须独立维护Checksum来校验自己的副本的完整性。</p><p>我们把每个Chunk都分成64KB大小的块。每个块都对应一个32位的Checksum。和其它元数据一样，Checksum与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。</p><p>对于读操作来说，在把数据返回给客户端或者其它的Chunk服务器之前，Chunk服务器会校验读取操作涉及的范围内的块的Checksum。因此Chunk服务器不会把错误数据传递到其它的机器上。如果发生某个块的Checksum不正确，Chunk服务器返回给请求者一个错误信息，并且通知Master服务器这个错误。作为回应，请求者应当从其它副本读取数据，Master服务器也会从其它副本克隆数据进行恢复。当一个新的副本就绪后，Master服务器通知副本错误的Chunk服务器删掉错误的副本。</p><p>Checksum对读操作的性能影响很小，可以基于几个原因来分析一下。因为大部分的读操作都至少要读取几个块，而我们只需要读取一小部分额外的相关数据进行校验。GFS客户端代码通过每次把读取操作都对齐在Checksum block的边界上，进一步减少了这些额外的读取操作的负面影响。另外，在Chunk服务器上，Chunksum的查找和比较不需要I/O操作，Checksum的计算可以和I/O操作同时进行。</p><p>Checksum的计算针对在Chunk尾部的追加写入操作作了高度优化（与之对应的是覆盖现有数据的写入操作），因为这类操作在我们的工作中占了很大比例。我们只增量更新最后一个不完整的块的Checksum，并且用所有的追加来的新Checksum块来计算新的Checksum。即使是最后一个不完整的Checksum块已经损坏了，而且我们不能够马上检查出来，由于新的Checksum和已有数据不吻合，在下次对这个块进行读取操作的时候，会检查出数据已经损坏了。</p><p>相比之下，如果写操作覆盖已经存在的一个范围内的Chunk，我们必须读取和校验被覆盖的第一个和最后一个块，然后再执行写操作；操作完成之后再重新计算和写入新的Checksum。如果我们不校验第一个和最后一个被写的块，那么新的Checksum可能会隐藏没有被覆盖区域内的数据错误。</p><p>在Chunk服务器空闲的时候，它会扫描和校验每个不活动的Chunk的内容。这使得我们能够发现很少被读取的Chunk是否完整。一旦发现有Chunk的数据损坏，Master可以创建一个新的、正确的副本，然后把损坏的副本删除掉。这个机制也避免了非活动的、已损坏的Chunk欺骗Master节点，使Master节点认为它们已经有了足够多的副本了。</p><h3 id="5-3-诊断工具">5.3 诊断工具</h3><p>详尽的、深入细节的诊断日志，在问题隔离、调试、以及性能分析等方面给我们带来无法估量的帮助，同时也只需要很小的开销。没有日志的帮助，我们很难理解短暂的、不重复的机器之间的消息交互。GFS的服务器会产生大量的日志，记录了大量关键的事件（比如，Chunk服务器启动和关闭）以及所有的RPC的请求和回复。这些诊断日志可以随意删除，对系统的正确运行不造成任何影响。然而，我们在存储空间允许的情况下会尽量的保存这些日志。</p><p>RPC日志包含了网络上发生的所有请求和响应的详细记录，但是不包括读写的文件数据。通过匹配请求与回应，以及收集不同机器上的RPC日志记录，我们可以重演所有的消息交互来诊断问题。日志还用来跟踪负载测试和性能分析。</p><p>日志对性能的影响很小（远小于它带来的好处），因为这些日志的写入方式是顺序的、异步的。最近发生的事件日志保存在内存中，可用于持续不断的在线监控。</p><h2 id="7-经验">7. 经验</h2><p>在建造和部署GFS的过程中，我们经历了各种各样的问题，有些是操作上的，有些是技术上的。</p><p>起初，GFS被设想为我们的生产系统的后端文件系统。随着时间推移，在GFS的使用中逐步的增加了对研究和开发任务的支持。我们开始增加一些小的功能，比如权限和配额，到了现在，GFS已经初步支持了这些功能。虽然我们生产系统是严格受控的，但是用户层却不总是这样的。需要更多的基础架构来防止用户间的相互干扰。</p><p>我们最大的问题是磁盘以及和Linux相关的问题。很多磁盘都声称它们支持某个范围内的Linux IDE硬盘驱动程序，但是实际应用中反映出来的情况却不是这样，它们只支持最新的驱动。因为协议版本很接近，所以大部分磁盘都可以用，但是偶尔也会有由于协议不匹配，导致驱动和内核对于驱动器的状态判断失误。这会导致数据因为内核中的问题意外的被破坏了。这个问题促使我们使用Checksum来校验数据，同时我们也修改内核来处理这些因为协议不匹配带来的问题。</p><p>较早的时候，我们在使用Linux 2.2内核时遇到了些问题，主要是fsync()的效率问题。它的效率与文件的大小而不是文件修改部分的大小有关。这在我们的操作日志文件过大时给出了难题，尤其是在我们尚未实现Checkpoint的时候。我们费了很大的力气用同步写来解决这个问题，但是最后还是移植到了Linux2.4内核上。</p><p>另一个和Linux相关的问题是单个读写锁的问题，也就是说，在某一个地址空间的任意一个线程都必须在从磁盘page in（读锁）的时候先hold住，或者在mmap()调用（写锁）的时候改写地址空间。我们发现即使我们的系统负载很轻的情况下也会有偶尔的超时，我们花费了很多的精力去查找资源的瓶颈或者硬件的问题。最后我们终于发现这个单个锁在磁盘线程交换以前映射的数据到磁盘的时候，锁住了当前的网络线程，阻止它把新数据映射到内存。由于我们的性能主要受限于网络接口，而不是内存copy的带宽，因此，我们用pread()替代mmap()，用了一个额外的copy动作来解决这个问题。</p><p>尽管偶尔还是有其它的问题，Linux的开放源代码还是使我们能够快速探究和理解系统的行为。在适当的时候，我们会改进内核并且和公开源码组织共享这些改动。</p><h2 id="9-结束语">9. 结束语</h2><p>Google文件系统展示了一个使用普通硬件支持大规模数据处理的系统的特质。虽然一些设计要点都是针对我们的特殊的需要定制的，但是还是有很多特性适用于类似规模的和成本的数据处理任务。</p><p>首先，我们根据我们当前的和可预期的将来的应用规模和技术环境来评估传统的文件系统的特性。我们的评估结果将我们引导到一个使用完全不同于传统的设计思路上。根据我们的设计思路，我们认为组件失效是常态而不是异常，针对采用追加方式（有可能是并发追加）写入、然后再读取（通常序列化读取）的大文件进行优化，以及扩展标准文件系统接口、放松接口限制来改进整个系统。</p><p>我们系统通过持续监控，复制关键数据，快速和自动恢复提供灾难冗余。Chunk复制使得我们可以对Chunk服务器的失效进行容错。高频率的组件失效要求系统具备在线修复机制，能够周期性的、透明的修复损坏的数据，也能够第一时间重新建立丢失的副本。此外，我们使用Checksum在磁盘或者IDE子系统级别检测数据损坏，在这样磁盘数量惊人的大系统中，损坏率是相当高的。</p><p>我们的设计保证了在有大量的并发读写操作时能够提供很高的合计吞吐量。我们通过分离控制流和数据流来实现这个目标，控制流在Master服务器处理，而数据流在Chunk服务器和客户端处理。当一般的操作涉及到Master服务器时，由于GFS选择的Chunk尺寸较大 <em>(alex注：从而减小了元数据的大小)，</em> 以及通过Chunk Lease将控制权限移交给主副本，这些措施将Master服务器的负担降到最低。这使得一个简单、中心的Master不会成为成为瓶颈。我们相信我们对网络协议栈的优化可以提升当前对于每客户端的写入吞吐量限制。</p><p>GFS成功的实现了我们对存储的需求，在Google内部，无论是作为研究和开发的存储平台，还是作为生产系统的数据处理平台，都得到了广泛的应用。它是我们持续创新和处理整个WEB范围内的难题的一个重要工具。</p><h1>LEC 3</h1><h1>存储系统</h1><p>存储系统是容错系统的基础构件</p><p>如果可以建立一个持久的存储系统，应用程序不需要特殊对自己的状态进行保存，因为存储系统已经存好了，从而简化了应用程序的设计。</p><p>因此存储系统本身必须有很高的容错性能，设计这个并不容易。</p><ul><li>高性能：需要跨服务器对数据分片</li><li>多服务器：出错概率非常大</li><li>容错机制：复制数据到其他的机器上</li><li>多份数据：带来数据的不一致性</li><li>强一致性：持久性协议，写入存储系统会降低性能</li></ul><p>因此形成了一个环，主要矛盾是一致性和性能之间的矛盾</p><h1>一致性</h1><p>理想情况下的一致性：分布式系统与单机系统在表现上完全相同</p><p>然而在实际情况下很难实现</p><ol><li>并发问题：</li></ol><p>两个线程<img src="https://math.now.sh?inline=C_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=C_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为同一个变量写入了不同的值，此时有两个线程<img src="https://math.now.sh?inline=C_3" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=C_4" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>读取。</p><p>此时<img src="https://math.now.sh?inline=C_3" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>读取的值应该是<img src="https://math.now.sh?inline=C_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>或<img src="https://math.now.sh?inline=C_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中的任意一个，而<img src="https://math.now.sh?inline=C_4" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的值应该与<img src="https://math.now.sh?inline=C_3" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>相同，才是我们希望看到的结果。</p><ol start="2"><li>故障问题</li></ol><p>解决故障一般是通过使用复制数据到其他机器上的方式。</p><p>一个很烂的服务器之间复制数据的方案：客户端写入数据的时候，同时向两个服务器写入数据，不需要服务器之间同步。</p><p>此时两个线程<img src="https://math.now.sh?inline=C_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=C_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为同一个变量写入了不同的值，两个线程<img src="https://math.now.sh?inline=C_3" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=C_4" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>读取不一定读出什么。</p><h1>GFS</h1><p>相当于一个分布式系统的案例研究，包括了高性能、复制和容错、一致性等等主题</p><p>GFS是第一个在上千台计算机上构建的分布式系统，后续的HDFS等都受到了GFS的启发。</p><p>两个非标准做法：</p><ul><li>单一的master节点</li><li>存在不一致的地方</li></ul><p>关键属性</p><ul><li>大数据集：可能是从整个互联网上爬取的数据集</li><li>快速：自动分片到多个磁盘</li><li>全局共享：所有应用程序都看到的是相同的文件系统</li><li>容错：自动容错性（或者容错能力很强）</li></ul><h2 id="设计">设计</h2><p><a href="https://imgse.com/i/zbm43T"><img src="https://s1.ax1x.com/2022/12/17/zbm43T.md.png" alt="zbm43T.md.png"></a></p><h3 id="Master">Master</h3><ul><li>文件名到chunk的对应关系（存在日志中-持久存储）</li><li>对每一个chunk有一个版本号（持久存储，恢复时候才能找到正确的版本）和服务器列表</li><li>日志（首先的操作，建立持久存储）+checkpoints（持久存储）</li></ul><h3 id="读取文件">读取文件</h3><ol><li>客户端发送消息</li><li>master通过消息返回chunk信息等</li><li>客户端缓存信息（在一段时间内不需要再次与master进行通信）</li><li>客户端从信息中的最近的服务器中读取文件</li><li>最近的服务器检查版本号，无误后发送数据</li></ol><h3 id="写文件（追加操作）">写文件（追加操作）</h3><p><a href="https://imgse.com/i/zbbzEn"><img src="https://s1.ax1x.com/2022/12/18/zbbzEn.png" alt="zbbzEn.png"></a></p><ol><li>客户端发送消息</li><li>master增加版本号，选取primary服务器，服务器增加版本号（持久存储），发送租约，返回消息给客户端</li><li>客户端发送写数据的请求给最近的服务器，然后服务器之间通过网络传递数据</li><li>客户端给primary服务器端发送写数据的消息</li><li>primary服务器检查版本号和租约，无误后写入数据，发送写数据的信息给其他的服务器</li><li>其他服务器反馈写成功的消息给primary服务器</li><li>服务器反馈成功消息给客户端</li></ol><p>如果中间过程有错误，客户端一般会重试，希望下一次可以正常运行（也就是最少一次）</p><p>这可能会造成在一个磁盘中有两份数据的拷贝。会有id和checksum协助控制不会将相同的数据读取两次。</p><h2 id="一致性">一致性</h2><p>一个服务器暂时挂掉了，导致版本号没有更新，同时一个客户端的版本号也是一个老版本号，结果正好匹配到了这个刚刚挂掉的服务器，最终导致读取的数据和期望的不同。</p><p>通过租约机制确保只会存在一个primary服务器，不会产生“脑裂”现象</p><p>获得强一致性？更新所有的除primary外的其他服务器或者全部都不更新，GFS没有实现这个。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Distributed Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824 Distributed Systems-LEC 2 RPC and Threads</title>
    <link href="/2022/12/15/6.824/Distributed-Systems-MIT-6.824-LEC-2/"/>
    <url>/2022/12/15/6.824/Distributed-Systems-MIT-6.824-LEC-2/</url>
    
    <content type="html"><![CDATA[<p>MIT-6.824（Spring 2022）LEC 2 RPC and Threads</p><span id="more"></span><h1><a href="http://tour.golang.org/">Go快速入门</a></h1><p>How do Go channels work? How does Go make sure they are synchronized between the many possible goroutines?</p><p><a href="https://golang.org/src/runtime/chan.go">https://golang.org/src/runtime/chan.go</a></p><p>At a high level, a chan is a struct holding a buffer and a lock. Sending on a channel involves acquiring the lock, waiting (perhaps releasing the CPU) until some thread is receiving, and handing off the message. Receiving involves acquiring the lock and waiting for a sender. You could implement your own channels with Go sync.Mutex and sync.Cond.</p><h1>LEC 2</h1><h2 id="为什么使用Go？">为什么使用Go？</h2><ul><li>对线程和RPC有很好的支持（更适合分布式编程）</li><li>垃圾收集器，不需要用户自己释放内存</li><li>简单易学</li><li>自带编译器，不是 Python 那样的解释型语言</li></ul><h2 id="线程">线程</h2><p>在一个进程中并行运行多个线程</p><p>线程原语：开启线程、退出线程（隐式）、停止线程（挂在一边不懂）、恢复线程</p><h3 id="为什么需要线程？">为什么需要线程？</h3><p>支持并发</p><ul><li>输入/输出并发</li><li>多核并行</li><li>方便（例如定期执行后台活动等）</li></ul><p>数量可以不考虑，按照需求创建线程即可</p><h3 id="线程编程挑战">线程编程挑战</h3><ul><li>竞争情况（同时对某一个变量进行写操作）<ul><li>可能大多数情况运行都很好，但是确实在某些条件下得不到想要的结果</li><li>解决的两种方法<ul><li>避免共享变量（channels）go推荐使用</li><li>使用锁（mutex）</li></ul></li></ul></li><li>协调问题：一个线程必须等待另一个线程完成后才能继续进行<ul><li>channels</li><li>condition variables</li></ul></li><li>死锁问题：两边都在等待对方</li></ul><h3 id="Go应对挑战的机制">Go应对挑战的机制</h3><p>channels和condition variables</p><ul><li>如果不共享内存，只想让线程互相进行通信，则应该使用channels</li><li>如果需要共享内存，应该使用锁和condition variables</li></ul><h3 id="条件变量和channel实例">条件变量和channel实例</h3><p>分配条件变量并且和锁关联，不满足条件进入睡眠状态，并释放关联的锁。</p><p>在goroutine运行的最后唤醒睡眠状态的线程，重新进行判断</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;rand.Seed(time.Now().UnixNano())count := <span class="hljs-number">0</span>finished := <span class="hljs-number">0</span><span class="hljs-keyword">var</span> mu sync.Mutexcond := sync.NewCond(&amp;mu)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;vote := requestVote()mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()<span class="hljs-keyword">if</span> vote &#123;count++&#125;finished++cond.Broadcast()&#125;()&#125;mu.Lock()<span class="hljs-keyword">for</span> count &lt; <span class="hljs-number">5</span> &amp;&amp; finished != <span class="hljs-number">10</span> &#123;cond.Wait()&#125;<span class="hljs-keyword">if</span> count &gt;= <span class="hljs-number">5</span> &#123;<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;received 5+ votes!&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;lost&quot;</span>)&#125;mu.Unlock()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestVote</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">100</span>)) * time.Millisecond)<span class="hljs-keyword">return</span> rand.Int() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;rand.Seed(time.Now().UnixNano())count := <span class="hljs-number">0</span>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;ch &lt;- requestVote()&#125;()&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;v := &lt;-ch<span class="hljs-keyword">if</span> v &#123;count += <span class="hljs-number">1</span>&#125;&#125;<span class="hljs-keyword">if</span> count &gt;= <span class="hljs-number">5</span> &#123;<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;received 5+ votes!&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;lost&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">requestVote</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;time.Sleep(time.Duration(rand.Intn(<span class="hljs-number">100</span>)) * time.Millisecond)<span class="hljs-keyword">return</span> rand.Int()%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;</code></pre></div><h3 id="go-tour-爬虫练习">go tour 爬虫练习</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-comment">//</span><span class="hljs-comment">// Several solutions to the crawler exercise from the Go tutorial</span><span class="hljs-comment">// https://tour.golang.org/concurrency/10</span><span class="hljs-comment">//</span><span class="hljs-comment">//</span><span class="hljs-comment">// Serial crawler</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Serial</span><span class="hljs-params">(url <span class="hljs-type">string</span>, fetcher Fetcher, fetched <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)</span></span> &#123;<span class="hljs-keyword">if</span> fetched[url] &#123;<span class="hljs-keyword">return</span>&#125;fetched[url] = <span class="hljs-literal">true</span>urls, err := fetcher.Fetch(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> _, u := <span class="hljs-keyword">range</span> urls &#123;Serial(u, fetcher, fetched)&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">//</span><span class="hljs-comment">// Concurrent crawler with shared state and Mutex</span><span class="hljs-comment">//</span><span class="hljs-keyword">type</span> fetchState <span class="hljs-keyword">struct</span> &#123;mu      sync.Mutexfetched <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ConcurrentMutex</span><span class="hljs-params">(url <span class="hljs-type">string</span>, fetcher Fetcher, f *fetchState)</span></span> &#123;f.mu.Lock()already := f.fetched[url]f.fetched[url] = <span class="hljs-literal">true</span>f.mu.Unlock()<span class="hljs-keyword">if</span> already &#123;<span class="hljs-keyword">return</span>&#125;urls, err := fetcher.Fetch(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">var</span> done sync.WaitGroup<span class="hljs-keyword">for</span> _, u := <span class="hljs-keyword">range</span> urls &#123;done.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(u <span class="hljs-type">string</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> done.Done()ConcurrentMutex(u, fetcher, f)&#125;(u)&#125;done.Wait()<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeState</span><span class="hljs-params">()</span></span> *fetchState &#123;f := &amp;fetchState&#123;&#125;f.fetched = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<span class="hljs-keyword">return</span> f&#125;<span class="hljs-comment">//</span><span class="hljs-comment">// Concurrent crawler with channels</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>, fetcher Fetcher)</span></span> &#123;urls, err := fetcher.Fetch(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;ch &lt;- []<span class="hljs-type">string</span>&#123;&#125;&#125; <span class="hljs-keyword">else</span> &#123;ch &lt;- urls&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coordinator</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>, fetcher Fetcher)</span></span> &#123;n := <span class="hljs-number">1</span>fetched := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<span class="hljs-keyword">for</span> urls := <span class="hljs-keyword">range</span> ch &#123;<span class="hljs-keyword">for</span> _, u := <span class="hljs-keyword">range</span> urls &#123;<span class="hljs-keyword">if</span> fetched[u] == <span class="hljs-literal">false</span> &#123;fetched[u] = <span class="hljs-literal">true</span>n += <span class="hljs-number">1</span><span class="hljs-keyword">go</span> worker(u, ch, fetcher)&#125;&#125;n -= <span class="hljs-number">1</span><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ConcurrentChannel</span><span class="hljs-params">(url <span class="hljs-type">string</span>, fetcher Fetcher)</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;ch &lt;- []<span class="hljs-type">string</span>&#123;url&#125;&#125;()coordinator(ch, fetcher)&#125;<span class="hljs-comment">//</span><span class="hljs-comment">// main</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;=== Serial===\n&quot;</span>)Serial(<span class="hljs-string">&quot;http://golang.org/&quot;</span>, fetcher, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>))fmt.Printf(<span class="hljs-string">&quot;=== ConcurrentMutex ===\n&quot;</span>)ConcurrentMutex(<span class="hljs-string">&quot;http://golang.org/&quot;</span>, fetcher, makeState())fmt.Printf(<span class="hljs-string">&quot;=== ConcurrentChannel ===\n&quot;</span>)ConcurrentChannel(<span class="hljs-string">&quot;http://golang.org/&quot;</span>, fetcher)&#125;<span class="hljs-comment">//</span><span class="hljs-comment">// Fetcher</span><span class="hljs-comment">//</span><span class="hljs-keyword">type</span> Fetcher <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Fetch returns a slice of URLs found on the page.</span>Fetch(url <span class="hljs-type">string</span>) (urls []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>)&#125;<span class="hljs-comment">// fakeFetcher is Fetcher that returns canned results.</span><span class="hljs-keyword">type</span> fakeFetcher <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*fakeResult<span class="hljs-keyword">type</span> fakeResult <span class="hljs-keyword">struct</span> &#123;body <span class="hljs-type">string</span>urls []<span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f fakeFetcher)</span></span> Fetch(url <span class="hljs-type">string</span>) ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">if</span> res, ok := f[url]; ok &#123;fmt.Printf(<span class="hljs-string">&quot;found:   %s\n&quot;</span>, url)<span class="hljs-keyword">return</span> res.urls, <span class="hljs-literal">nil</span>&#125;fmt.Printf(<span class="hljs-string">&quot;missing: %s\n&quot;</span>, url)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;not found: %s&quot;</span>, url)&#125;<span class="hljs-comment">// fetcher is a populated fakeFetcher.</span><span class="hljs-keyword">var</span> fetcher = fakeFetcher&#123;<span class="hljs-string">&quot;http://golang.org/&quot;</span>: &amp;fakeResult&#123;<span class="hljs-string">&quot;The Go Programming Language&quot;</span>,[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;http://golang.org/pkg/&quot;</span>,<span class="hljs-string">&quot;http://golang.org/cmd/&quot;</span>,&#125;,&#125;,<span class="hljs-string">&quot;http://golang.org/pkg/&quot;</span>: &amp;fakeResult&#123;<span class="hljs-string">&quot;Packages&quot;</span>,[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;http://golang.org/&quot;</span>,<span class="hljs-string">&quot;http://golang.org/cmd/&quot;</span>,<span class="hljs-string">&quot;http://golang.org/pkg/fmt/&quot;</span>,<span class="hljs-string">&quot;http://golang.org/pkg/os/&quot;</span>,&#125;,&#125;,<span class="hljs-string">&quot;http://golang.org/pkg/fmt/&quot;</span>: &amp;fakeResult&#123;<span class="hljs-string">&quot;Package fmt&quot;</span>,[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;http://golang.org/&quot;</span>,<span class="hljs-string">&quot;http://golang.org/pkg/&quot;</span>,&#125;,&#125;,<span class="hljs-string">&quot;http://golang.org/pkg/os/&quot;</span>: &amp;fakeResult&#123;<span class="hljs-string">&quot;Package os&quot;</span>,[]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;http://golang.org/&quot;</span>,<span class="hljs-string">&quot;http://golang.org/pkg/&quot;</span>,&#125;,&#125;,&#125;</code></pre></div><h2 id="RPC-远程过程调用">RPC-远程过程调用</h2><p>RPC：在客户端上调用在服务器端实现的函数-传递参数并返回结果</p><p>实际过程：</p><ul><li>在客户端上调用stub过程：构建一个消息，包括调用哪个函数，函数的参数，参数类型等等。</li><li>通过网络发送给服务器上对应的stub</li><li>在服务器上调用函数</li><li>返回给服务器的stub</li><li>返回给客户端的stub（这个期间一直在等待）</li><li>返回结果</li></ul><h3 id="示例">示例</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net&quot;</span><span class="hljs-string">&quot;net/rpc&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-comment">//</span><span class="hljs-comment">// Common RPC request/reply definitions</span><span class="hljs-comment">//</span><span class="hljs-keyword">type</span> PutArgs <span class="hljs-keyword">struct</span> &#123;Key   <span class="hljs-type">string</span>Value <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> PutReply <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-keyword">type</span> GetArgs <span class="hljs-keyword">struct</span> &#123;Key <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> GetReply <span class="hljs-keyword">struct</span> &#123;Value <span class="hljs-type">string</span>&#125;<span class="hljs-comment">//</span><span class="hljs-comment">// Client</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span></span> *rpc.Client &#123;client, err := rpc.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(<span class="hljs-string">&quot;dialing:&quot;</span>, err)&#125;<span class="hljs-keyword">return</span> client&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;client := connect()args := GetArgs&#123;<span class="hljs-string">&quot;subject&quot;</span>&#125;reply := GetReply&#123;&#125;err := client.Call(<span class="hljs-string">&quot;KV.Get&quot;</span>, &amp;args, &amp;reply)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(<span class="hljs-string">&quot;error:&quot;</span>, err)&#125;client.Close()<span class="hljs-keyword">return</span> reply.Value&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">put</span><span class="hljs-params">(key <span class="hljs-type">string</span>, val <span class="hljs-type">string</span>)</span></span> &#123;client := connect()args := PutArgs&#123;<span class="hljs-string">&quot;subject&quot;</span>, <span class="hljs-string">&quot;6.824&quot;</span>&#125;reply := PutReply&#123;&#125;err := client.Call(<span class="hljs-string">&quot;KV.Put&quot;</span>, &amp;args, &amp;reply)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(<span class="hljs-string">&quot;error:&quot;</span>, err)&#125;client.Close()&#125;<span class="hljs-comment">//</span><span class="hljs-comment">// Server</span><span class="hljs-comment">//</span><span class="hljs-keyword">type</span> KV <span class="hljs-keyword">struct</span> &#123;mu   sync.Mutexdata <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;kv := <span class="hljs-built_in">new</span>(KV)kv.data = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;rpcs := rpc.NewServer()rpcs.Register(kv)l, e := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:1234&quot;</span>)<span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;log.Fatal(<span class="hljs-string">&quot;listen error:&quot;</span>, e)&#125;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;conn, err := l.Accept()<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">go</span> rpcs.ServeConn(conn)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;l.Close()&#125;()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kv *KV)</span></span> Get(args *GetArgs, reply *GetReply) <span class="hljs-type">error</span> &#123;kv.mu.Lock()<span class="hljs-keyword">defer</span> kv.mu.Unlock()reply.Value = kv.data[args.Key]<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(kv *KV)</span></span> Put(args *PutArgs, reply *PutReply) <span class="hljs-type">error</span> &#123;kv.mu.Lock()<span class="hljs-keyword">defer</span> kv.mu.Unlock()kv.data[args.Key] = args.Value<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">//</span><span class="hljs-comment">// main</span><span class="hljs-comment">//</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;server()put(<span class="hljs-string">&quot;subject&quot;</span>, <span class="hljs-string">&quot;6.824&quot;</span>)fmt.Printf(<span class="hljs-string">&quot;Put(subject, 6.824) done\n&quot;</span>)fmt.Printf(<span class="hljs-string">&quot;get(subject) -&gt; %s\n&quot;</span>, get(<span class="hljs-string">&quot;subject&quot;</span>))&#125;</code></pre></div><h3 id="RPC失败">RPC失败</h3><ul><li>至少一次：失败后（没有接到服务器的响应）会自动重试<ul><li>有可能多次执行</li></ul></li><li>最多一次：服务器端实现过滤重复，确保最多只能执行一次（Go的RPC实现）</li><li>正好一次：很难实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Distributed Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824 Distributed Systems-Lab 1 MapReduce</title>
    <link href="/2022/12/15/6.824/Distributed-Systems-MIT-6.824-Lab-1/"/>
    <url>/2022/12/15/6.824/Distributed-Systems-MIT-6.824-Lab-1/</url>
    
    <content type="html"><![CDATA[<p>MIT-6.824（Spring 2022）Lab 1 MapReduce</p><span id="more"></span><p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">6.824 Lab 1: MapReduce</a></p><h1>简介</h1><p>构建一个MapReduce系统</p><ol><li>实现一个worker进程，调用Map和Reduce函数、处理读写文件，</li><li>实现coordinator进程，向worker分发任务并提供容错机制。</li></ol><h1>准备开始</h1><p>在 <code>src/main/mrsequential.go</code> 中提供了串行的mapreduce程序，在单进程里面直接顺序执行Map操作和Reduce操作</p><p>同时提供了一些MapReduce的应用程序：</p><p><code>mrapps/wc.go</code>：WordCount程序</p><p><code>mrapps/indexer.go</code>：text-indexer</p><p>按照如下的方式运行串行的mapreduce程序：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> src/maingo build -race -buildmode=plugin ../mrapps/wc.go<span class="hljs-built_in">rm</span> mr-out*go run -race mrsequential.go wc.so pg*.txtmore mr-out-0</code></pre></div><p>输出的文件中是对文件的WordCount结果</p><h2 id="代码理解">代码理解</h2><h3 id="插件模式编译">插件模式编译</h3><p><a href="https://www.zhihu.com/question/51650593">参考资料</a></p><p>Go是静态编译型语言，在编译时就将所有引用的包（库）全部加载打包到最终的可执行程序（或库文件）中，因此并不能在运行时动态加载其他共享库。Go Plugin提供了这样一种方式，能够让你在运行时动态加载外部功能。</p><ul><li>可插拔：有了Plugin，我的程序可以根据需要随时替换其中某些部件而不用修改我的程序；</li><li>动态加载的需要：有些模块只有在运行时才能确定，需要动态加载外部的功能模块；</li><li>独立开发：Plugin 可以和主程序独立建设，主程序只需要制定好框架，实现默认（模版）功能。Plugin 可根据用户需求随时自行扩展开发，运行时随意替换，提高了程序的可定制性；</li></ul><p>type Plugin即Golang加载的插件，与之有关的两个方法：</p><ul><li>Open: 根据参数path提供的插件路径加载这个插件，并返回插件这个插件结构的指针*Plugin</li><li>Lookup: *Plugin的惟一方法，通过名称symName在插件中寻找对应的变量或方法，以Symbol的形式返回</li></ul><p>因此这一行命令将 <code>wc.go</code>文件编译成了一个插件 <code>wc.so</code>（默认文件名），从而可以插入到MapReduce主程序中运行。</p><h4 id="wc-go-Map函数">wc.go-Map函数</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// The map function is called once for each file of input. The first</span><span class="hljs-comment">// argument is the name of the input file, and the second is the</span><span class="hljs-comment">// file&#x27;s complete contents. You should ignore the input file name,</span><span class="hljs-comment">// and look only at the contents argument. The return value is a slice</span><span class="hljs-comment">// of key/value pairs.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span><span class="hljs-params">(filename <span class="hljs-type">string</span>, contents <span class="hljs-type">string</span>)</span></span> []mr.KeyValue &#123;<span class="hljs-comment">// function to detect word separators.</span>ff := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> !unicode.IsLetter(r) &#125;<span class="hljs-comment">// split contents into an array of words.</span>words := strings.FieldsFunc(contents, ff)kva := []mr.KeyValue&#123;&#125;<span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> words &#123;kv := mr.KeyValue&#123;w, <span class="hljs-string">&quot;1&quot;</span>&#125;kva = <span class="hljs-built_in">append</span>(kva, kv)&#125;<span class="hljs-keyword">return</span> kva&#125;</code></pre></div><p>对每一个传进来的字符串，通过 <code>strings.FieldsFunc</code>函数找到字符串的分割点，分割成单独的单词，构造成KeyValue结构体并合并成切片返回</p><h4 id="wc-go-Reduce函数">wc.go-Reduce函数</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// The reduce function is called once for each key generated by the</span><span class="hljs-comment">// map tasks, with a list of all the values created for that key by</span><span class="hljs-comment">// any map task.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reduce</span><span class="hljs-params">(key <span class="hljs-type">string</span>, values []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-comment">// return the number of occurrences of this word.</span><span class="hljs-keyword">return</span> strconv.Itoa(<span class="hljs-built_in">len</span>(values))&#125;</code></pre></div><p>直接以字符串的形式返回values的长度</p><h3 id="串行MapReduce运行">串行MapReduce运行</h3><h4 id="导入插件">导入插件</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// load the application Map and Reduce functions</span><span class="hljs-comment">// from a plugin file, e.g. ../mrapps/wc.so</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadPlugin</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> (<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []mr.KeyValue, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;p, err := plugin.Open(filename)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot load plugin %v&quot;</span>, filename)&#125;xmapf, err := p.Lookup(<span class="hljs-string">&quot;Map&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot find Map in %v&quot;</span>, filename)&#125;mapf := xmapf.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []mr.KeyValue)xreducef, err := p.Lookup(<span class="hljs-string">&quot;Reduce&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot find Reduce in %v&quot;</span>, filename)&#125;reducef := xreducef.(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>)<span class="hljs-keyword">return</span> mapf, reducef&#125;</code></pre></div><p>从编译好的*.so文件中查找Map函数和Reduce函数，通过函数的返回值类型进行类型推断，最终返回两个函数通过主函数里面的变量进行接收</p><div class="code-wrapper"><pre><code class="hljs go">mapf, reducef := loadPlugin(os.Args[<span class="hljs-number">1</span>])</code></pre></div><h4 id="打开文件，进行Map操作">打开文件，进行Map操作</h4><div class="code-wrapper"><pre><code class="hljs go">       <span class="hljs-comment">//</span><span class="hljs-comment">// read each input file,</span><span class="hljs-comment">// pass it to Map,</span><span class="hljs-comment">// accumulate the intermediate Map output.</span><span class="hljs-comment">//</span>intermediate := []mr.KeyValue&#123;&#125;<span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">2</span>:] &#123;file, err := os.Open(filename)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, filename)&#125;content, err := ioutil.ReadAll(file)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot read %v&quot;</span>, filename)&#125;file.Close()kva := mapf(filename, <span class="hljs-type">string</span>(content))intermediate = <span class="hljs-built_in">append</span>(intermediate, kva...)&#125;</code></pre></div><p>pg-*.txt会匹配到所有满足条件的文件，将文件逐个打开，读取文件内容，通过Map函数处理成中间数据格式，存入中间变量intermediate</p><h4 id="排序">排序</h4><p>对中间变量的切片按照键的字典序进行排序</p><div class="code-wrapper"><pre><code class="hljs go">sort.Sort(ByKey(intermediate))<span class="hljs-comment">// for sorting by key.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a ByKey)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(a) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a ByKey)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; a[i], a[j] = a[j], a[i] &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a ByKey)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> a[i].Key &lt; a[j].Key &#125;</code></pre></div><p>这里是通过实现Sort的接口实现了自定义排序</p><h4 id="统计Reduce">统计Reduce</h4><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//</span><span class="hljs-comment">// call Reduce on each distinct key in intermediate[],</span><span class="hljs-comment">// and print the result to mr-out-0.</span><span class="hljs-comment">//</span>i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(intermediate) &#123;j := i + <span class="hljs-number">1</span><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;j++&#125;values := []<span class="hljs-type">string</span>&#123;&#125;<span class="hljs-keyword">for</span> k := i; k &lt; j; k++ &#123;values = <span class="hljs-built_in">append</span>(values, intermediate[k].Value)&#125;output := reducef(intermediate[i].Key, values)<span class="hljs-comment">// this is the correct format for each line of Reduce output.</span>fmt.Fprintf(ofile, <span class="hljs-string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)i = j&#125;</code></pre></div><p>由于已经排好顺序了，从左到右遍历一遍就可以统计每一个键出现的数量，然后输出到文件即可。</p><h1>我的工作</h1><p>实现一个分布式MapReduce，由coordinator和worker两个程序组成。</p><p>coordinator进程只有一个，worker进程有一个或多个并行执行。</p><p>worker进程将通过RPC与coordinator进程进行通信。每个worker进程将向coordinator进程请求任务，从一个或多个文件中读取任务的输入，执行任务，并将任务的输出写入一个或更多个文件。</p><p>coordinator进程应该注意到一个worker进程是否没有在合理的时间内完成其任务（10秒），并将相同的任务交给另一个worker进程。</p><p>coordinator和worker的“main”函数在 <code>main/mrcordinator.go</code>和 <code>main/mrworker.go</code>中</p><p>实现应该在 <code>mr/coordinator.go</code>、<code>mr/worker.go</code>和 <code>mr/rpc.go</code>中。</p><p>测试运行：</p><div class="code-wrapper"><pre><code class="hljs bash">go build -race -buildmode=plugin ../mrapps/wc.go<span class="hljs-built_in">rm</span> mr-out*go run -race mrcoordinator.go pg-*.txtgo run -race mrworker.go wc.sogo run -race mrworker.go wc.so</code></pre></div><p>测试脚本：</p><div class="code-wrapper"><pre><code class="hljs bash">bash test-mr.sh</code></pre></div><h2 id="代码理解-2">代码理解</h2><p>待补充的代码提供了一个RPC的示例</p><p>启动Worker后，会调用CallExample()函数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// example function to show how to make an RPC call to the coordinator.</span><span class="hljs-comment">//</span><span class="hljs-comment">// the RPC argument and reply types are defined in rpc.go.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CallExample</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// declare an argument structure.</span>args := ExampleArgs&#123;&#125;<span class="hljs-comment">// fill in the argument(s).</span>args.X = <span class="hljs-number">99</span><span class="hljs-comment">// declare a reply structure.</span>reply := ExampleReply&#123;&#125;<span class="hljs-comment">// send the RPC request, wait for the reply.</span><span class="hljs-comment">// the &quot;Coordinator.Example&quot; tells the</span><span class="hljs-comment">// receiving server that we&#x27;d like to call</span><span class="hljs-comment">// the Example() method of struct Coordinator.</span>ok := call(<span class="hljs-string">&quot;Coordinator.Example&quot;</span>, &amp;args, &amp;reply)<span class="hljs-keyword">if</span> ok &#123;<span class="hljs-comment">// reply.Y should be 100.</span>fmt.Printf(<span class="hljs-string">&quot;reply.Y %v\n&quot;</span>, reply.Y)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;call failed!\n&quot;</span>)&#125;&#125;</code></pre></div><p>函数构建了RPC的结构体，然后调用call函数并接收响应</p><p><strong>在这里体现了RPC的核心思想：在这里看起来就是调用的本地函数call，但是实际上call内部是与coordinator进行通信，然后在远程得到返回值后返回给reply结构体，因此为“远程过程调用”</strong></p><p>call函数：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// send an RPC request to the coordinator, wait for the response.</span><span class="hljs-comment">// usually returns true.</span><span class="hljs-comment">// returns false if something goes wrong.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">call</span><span class="hljs-params">(rpcname <span class="hljs-type">string</span>, args <span class="hljs-keyword">interface</span>&#123;&#125;, reply <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-comment">// c, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1&quot;+&quot;:1234&quot;)</span>sockname := coordinatorSock()c, err := rpc.DialHTTP(<span class="hljs-string">&quot;unix&quot;</span>, sockname)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(<span class="hljs-string">&quot;dialing:&quot;</span>, err)&#125;<span class="hljs-keyword">defer</span> c.Close()err = c.Call(rpcname, args, reply)<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;fmt.Println(err)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div><p>注意coordinatorSock()方法，会获取一个临时文件，通信是通过这个临时文件进行的。</p><p>在coordinator.go内部，RPC指定的方法&quot;Coordinator.Example&quot;：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// an example RPC handler.</span><span class="hljs-comment">//</span><span class="hljs-comment">// the RPC argument and reply types are defined in rpc.go.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> Example(args *ExampleArgs, reply *ExampleReply) <span class="hljs-type">error</span> &#123;reply.Y = args.X + <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>因此返回的结构体中reply.Y的值就为100</p><p>在启动Worker前要先启动Coordinator，启动后首先创建一个Coordinator结构：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// create a Coordinator.</span><span class="hljs-comment">// main/mrcoordinator.go calls this function.</span><span class="hljs-comment">// nReduce is the number of reduce tasks to use.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCoordinator</span><span class="hljs-params">(files []<span class="hljs-type">string</span>, nReduce <span class="hljs-type">int</span>)</span></span> *Coordinator &#123;c := Coordinator&#123;&#125;<span class="hljs-comment">// Your code here.</span>c.server()<span class="hljs-keyword">return</span> &amp;c&#125;</code></pre></div><p>其中调用server方法，监听Worker的RPC：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// start a thread that listens for RPCs from worker.go</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> server() &#123;rpc.Register(c)rpc.HandleHTTP()<span class="hljs-comment">//l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)</span>sockname := coordinatorSock()os.Remove(sockname)l, e := net.Listen(<span class="hljs-string">&quot;unix&quot;</span>, sockname)<span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;log.Fatal(<span class="hljs-string">&quot;listen error:&quot;</span>, e)&#125;<span class="hljs-keyword">go</span> http.Serve(l, <span class="hljs-literal">nil</span>)&#125;</code></pre></div><p>Coordinator会不断检测Done方法的返回值，一旦为true，Coordinator就会退出：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// main/mrcoordinator.go calls Done() periodically to find out</span><span class="hljs-comment">// if the entire job has finished.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> Done() <span class="hljs-type">bool</span> &#123;ret := <span class="hljs-literal">false</span><span class="hljs-comment">// Your code here.</span><span class="hljs-keyword">return</span> ret&#125;</code></pre></div><h2 id="Map简单实现">Map简单实现</h2><p>首先考虑简单一些，不考虑并行、容错处理等，先把整个的流程跑通。</p><p>首先跑通Map流程</p><p>Coordinator的数据结构：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Coordinator <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// Your definitions here.</span>MapTask    []MapTaskInformation    <span class="hljs-comment">// Map任务列表</span>ReduceTask []ReduceTaskInformation <span class="hljs-comment">// Reduce任务列表</span>&#125;</code></pre></div><p>内部有两个切片，分别对应Map的任务列表和Reduce的任务列表。</p><p>两个任务列表是在Coordinator启动的时候就设置好：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// create a Coordinator.</span><span class="hljs-comment">// main/mrcoordinator.go calls this function.</span><span class="hljs-comment">// nReduce is the number of reduce tasks to use.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeCoordinator</span><span class="hljs-params">(files []<span class="hljs-type">string</span>, nReduce <span class="hljs-type">int</span>)</span></span> *Coordinator &#123;mapTaskSlice := []MapTaskInformation&#123;&#125;<span class="hljs-keyword">for</span> id, fileName := <span class="hljs-keyword">range</span> files &#123;mapTaskSlice = <span class="hljs-built_in">append</span>(mapTaskSlice, MapTaskInformation&#123;Id:                   id + <span class="hljs-number">1</span>,State:                <span class="hljs-number">0</span>,NReduce:              nReduce,OriginFileName:       fileName,IntermediateFileName: <span class="hljs-string">&quot;mr-&quot;</span> + strconv.Itoa(id+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;-&quot;</span>,&#125;)&#125;reduceTaskSlice := []ReduceTaskInformation&#123;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nReduce; i++ &#123;reduceTaskSlice = <span class="hljs-built_in">append</span>(reduceTaskSlice, ReduceTaskInformation&#123;Id:             i + <span class="hljs-number">1</span>,State:          <span class="hljs-number">0</span>,OriginFileName: <span class="hljs-string">&quot;mr-0-&quot;</span> + strconv.Itoa(i+<span class="hljs-number">1</span>),OutputFileName: <span class="hljs-string">&quot;mr-&quot;</span> + strconv.Itoa(i+<span class="hljs-number">1</span>),&#125;)&#125;c := Coordinator&#123;MapTask:    mapTaskSlice,ReduceTask: reduceTaskSlice,&#125;<span class="hljs-comment">// Your code here.</span>c.server()<span class="hljs-keyword">return</span> &amp;c&#125;</code></pre></div><p>其中为Map和Reduce暂时设计的数据结构：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MapTaskInformation <span class="hljs-keyword">struct</span> &#123;Id                   <span class="hljs-type">int</span>    <span class="hljs-comment">// 任务唯一编码</span>State                <span class="hljs-type">int</span>    <span class="hljs-comment">// 0表示未开始，1表示正在进行，2表示已经完成</span>NReduce              <span class="hljs-type">int</span>    <span class="hljs-comment">// 分成Reduce任务的数量</span>OriginFileName       <span class="hljs-type">string</span> <span class="hljs-comment">// 原始文件名称</span>IntermediateFileName <span class="hljs-type">string</span> <span class="hljs-comment">// Map任务完成后的文件名称（中间文件）</span>&#125;<span class="hljs-keyword">type</span> ReduceTaskInformation <span class="hljs-keyword">struct</span> &#123;Id             <span class="hljs-type">int</span>    <span class="hljs-comment">// 任务唯一编码</span>State          <span class="hljs-type">int</span>    <span class="hljs-comment">// 0表示未开始，1表示正在进行，2表示已经完成</span>OriginFileName <span class="hljs-type">string</span> <span class="hljs-comment">// Reduce的初始文件名称（中间文件）</span>OutputFileName <span class="hljs-type">string</span> <span class="hljs-comment">// Reduce任务完成后的最终文件名称</span>&#125;</code></pre></div><p>Worker启动时，通过RPC向Coordinator要一个任务</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// main/mrworker.go calls this function.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue,reducef <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;args := TaskInformation&#123;&#125;reply := TaskInformation&#123;&#125;ok := call(<span class="hljs-string">&quot;Coordinator.AsssignTask&quot;</span>, &amp;args, &amp;reply)</code></pre></div><p>Coordinator会遍历自己内部的所有任务列表，找到第一个还没有完成的任务分配给这个Worker：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 分配任务</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> AsssignTask(args *TaskInformation, reply *TaskInformation) <span class="hljs-type">error</span> &#123;isMapfinished := <span class="hljs-literal">true</span><span class="hljs-comment">//遍历所有的Map任务信息，将未开始的分配给这个节点</span><span class="hljs-keyword">for</span> i, mapTask := <span class="hljs-keyword">range</span> c.MapTask &#123;<span class="hljs-keyword">if</span> mapTask.State == <span class="hljs-number">0</span> &#123;isMapfinished = <span class="hljs-literal">false</span>reply.Id = mapTask.Idreply.TaskType = <span class="hljs-string">&quot;map&quot;</span>reply.InputFileName = mapTask.OriginFileNamereply.OutputFileName = mapTask.IntermediateFileNamereply.NReduce = mapTask.NReducec.MapTask[i].State = <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> mapTask.State == <span class="hljs-number">1</span> &#123;isMapfinished = <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-comment">// 如果所有的Map任务都完成了，就遍历Reduce任务</span><span class="hljs-keyword">if</span> isMapfinished &#123;<span class="hljs-keyword">for</span> _, reduceTask := <span class="hljs-keyword">range</span> c.ReduceTask &#123;<span class="hljs-keyword">if</span> reduceTask.State == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>Worker接收到任务后使用插件中的Map函数进行处理，并将成功完成任务的消息通过RPC的方式返回给Coordinator</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">if</span> ok &#123;fmt.Println(<span class="hljs-string">&quot;Call Success!&quot;</span>)<span class="hljs-keyword">if</span> reply.TaskType == <span class="hljs-string">&quot;map&quot;</span> &#123;fmt.Printf(<span class="hljs-string">&quot;Map Task!\n&quot;</span>)intermediate := []KeyValue&#123;&#125;file, err := os.Open(reply.InputFileName)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, reply.InputFileName)&#125;content, err := io.ReadAll(file)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot read %v&quot;</span>, reply.InputFileName)&#125;file.Close()kva := mapf(reply.InputFileName, <span class="hljs-type">string</span>(content))intermediate = <span class="hljs-built_in">append</span>(intermediate, kva...)<span class="hljs-comment">// 排序</span>sort.Sort(ByKey(intermediate))fmt.Println(intermediate)args = replycall(<span class="hljs-string">&quot;Coordinator.TaskFinish&quot;</span>, &amp;args, &amp;reply)</code></pre></div><p>Coordinator接收消息，将自己内部的任务状态修改，后续就不会再将这个任务分配给Worker了。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 接收任务已经完成的信息</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> TaskFinish(args *TaskInformation, reply *TaskInformation) <span class="hljs-type">error</span> &#123;<span class="hljs-keyword">if</span> args.TaskType == <span class="hljs-string">&quot;map&quot;</span> &#123;c.MapTask[args.Id<span class="hljs-number">-1</span>].State = <span class="hljs-number">2</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> args.TaskType == <span class="hljs-string">&quot;reduce&quot;</span> &#123;c.ReduceTask[args.Id<span class="hljs-number">-1</span>].State = <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>问题：</p><ol><li>Worker要任务的时候Coordinator去列表中遍历是不是有点太傻了，有更好的办法吗？比如Coordinator维护未完成的和已完成的任务列表，然后动态更新？</li><li>定义的struct数据结构不一定合理，还要看后面怎么用</li><li>RPC传递的数据结构不是很合理，而且有大量的冗余，比如后面的消息args和reply几乎完全相同，后面需要修改</li></ol><h2 id="Reduce简单实现">Reduce简单实现</h2><p>首先在Worker的主函数增加一层循环，从而使Worker不断请求任务，由Coordinator按需分配</p><p>首先要构造中间文件，也就是map结束后的文件需要存起来，然后才能用reduce去处理</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 循环创建NReduce个文件准备保存</span>encoderList := <span class="hljs-built_in">make</span>([]*json.Encoder, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; reply.NReduce; i++ &#123;fileName := reply.OutputFileName + strconv.FormatInt(<span class="hljs-type">int64</span>(i+<span class="hljs-number">1</span>), <span class="hljs-number">10</span>)tempFile, err := os.Create(fileName)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot create %v&quot;</span>, fileName)&#125;<span class="hljs-keyword">defer</span> tempFile.Close()encoderList = <span class="hljs-built_in">append</span>(encoderList, json.NewEncoder(tempFile))&#125;<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> intermediate &#123;encoderList[ihash(v.Key)%reply.NReduce].Encode(&amp;intermediate[i])&#125;</code></pre></div><p>map在保存的时候要直接分成NReduce的文件，文件的内容是由哈希函数对键进行映射后得到的，保证键大致平均分到NReduce个节点上</p><p>保存文件的时候使用的是json的格式，保存的过程有些慢，需要对整个map的结果全部遍历一遍，后续可以考虑并行处理？</p><p>Reduce内容：</p><div class="code-wrapper"><pre><code class="hljs go">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> reply.TaskType == <span class="hljs-string">&quot;reduce&quot;</span> &#123;ofile, _ := os.Create(reply.OutputFileName)fmt.Printf(<span class="hljs-string">&quot;Reduce Task!\n&quot;</span>)kva := <span class="hljs-built_in">make</span>([]KeyValue, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> p := <span class="hljs-number">1</span>; p &lt;= <span class="hljs-number">8</span>; p++ &#123;filename := strings.Replace(reply.InputFileName, <span class="hljs-string">&quot;*&quot;</span>, strconv.FormatInt(<span class="hljs-type">int64</span>(p), <span class="hljs-number">10</span>), <span class="hljs-number">1</span>)fmt.Println(filename)file, err := os.Open(filename)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, filename)&#125;dec := json.NewDecoder(file)<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">var</span> kv KeyValue<span class="hljs-keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">break</span>&#125;kva = <span class="hljs-built_in">append</span>(kva, kv)&#125;&#125;<span class="hljs-comment">// 排序</span>sort.Sort(ByKey(kva))<span class="hljs-comment">//</span><span class="hljs-comment">// call Reduce on each distinct key in intermediate[],</span><span class="hljs-comment">// and print the result to mr-out-0.</span><span class="hljs-comment">//</span>i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(kva) &#123;j := i + <span class="hljs-number">1</span><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(kva) &amp;&amp; kva[j].Key == kva[i].Key &#123;j++&#125;values := []<span class="hljs-type">string</span>&#123;&#125;<span class="hljs-keyword">for</span> k := i; k &lt; j; k++ &#123;values = <span class="hljs-built_in">append</span>(values, kva[k].Value)&#125;output := reducef(kva[i].Key, values)<span class="hljs-comment">// this is the correct format for each line of Reduce output.</span>fmt.Fprintf(ofile, <span class="hljs-string">&quot;%v %v\n&quot;</span>, kva[i].Key, output)i = j&#125;</code></pre></div><p>循环读取map保存下来的内容，这里写死了，后面需要调整。</p><p>读取内容后汇总并排序，排序后直接使用串行的Reduce代码即可</p><p>对于Coordinator，将Reduce的内容添加进去即可：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 如果所有的Map任务都完成了，就遍历Reduce任务</span><span class="hljs-keyword">if</span> isMapfinished &#123;<span class="hljs-keyword">for</span> i, reduceTask := <span class="hljs-keyword">range</span> c.ReduceTask &#123;<span class="hljs-keyword">if</span> reduceTask.State == <span class="hljs-number">0</span> &#123;reply.Id = reduceTask.Idreply.TaskType = <span class="hljs-string">&quot;reduce&quot;</span>reply.InputFileName = reduceTask.OriginFileNamereply.OutputFileName = reduceTask.OutputFileNamemu.Lock()c.ReduceTask[i].State = <span class="hljs-number">1</span>mu.Unlock()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;&#125;&#125;</code></pre></div><p>Reduce结束后需要告知主Coordinator在无限循环的Done()，返回True让其退出：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// main/mrcoordinator.go calls Done() periodically to find out</span><span class="hljs-comment">// if the entire job has finished.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> Done() <span class="hljs-type">bool</span> &#123;ret := <span class="hljs-literal">true</span>mu.Lock()<span class="hljs-comment">// Your code here.</span><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> c.ReduceTask &#123;<span class="hljs-keyword">if</span> v.State != <span class="hljs-number">2</span> &#123;ret = <span class="hljs-literal">false</span><span class="hljs-keyword">break</span>&#125;&#125;mu.Unlock()<span class="hljs-keyword">return</span> ret&#125;</code></pre></div><p>中间添加了锁，但是添加的有些问题，后面需要调整。</p><p>到这里的代码除了异常处理外已经都能测试通过了，只不过是有data race问题</p><p>问题：</p><ol><li>Worker的无限循环退不出去，需要Coordinator通过RPC的方式告知才可以</li><li>Reduce的遍历文件写死了，需要动态变化去判断</li><li>Coordinator存在data race问题，是循环遍历任务和对任务的完成情况进行更改后两者的锁加的不太好导致的，需要对数据结构进行修改</li><li>没有异常处理，不能处理有Worker异常退出的情况，实际测试中陷入了死循环，需要进行调整</li></ol><h2 id="问题及解决">问题及解决</h2><p>首先将Coordinator对于任务的数据结构更改，内部维护三个双向链表，分别表示未开始的任务，正在进行的任务和已经结束的任务，链表外面使用map的数据结构，从而支持快速查找。在生成任务的时候自动赋值一个全局唯一的id。</p><p>数据结构中要包括全部的信息，主要变化部分是对输入和输出的信息，将Map的输入、输出和Reduce的输出都在初始化的时候直接写在结构体中，避免后续进行多次判断和修改。</p><p>结构体：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Coordinator存储的主要信息，包括Map和Reduce两部分任务的信息以及工作节点的信息</span><span class="hljs-keyword">type</span> Coordinator <span class="hljs-keyword">struct</span> &#123;UniqueIdSlice     []*list.Element <span class="hljs-comment">// 通过任务Id找到任务信息的切片，相当于一个Map</span>MapTaskNum        <span class="hljs-type">int</span>             <span class="hljs-comment">// map任务总数量</span>ReduceTaskNum     <span class="hljs-type">int</span>             <span class="hljs-comment">// reduce任务总数量</span>WorkerNum         <span class="hljs-type">int</span>             <span class="hljs-comment">// 目前正在工作的节点数量</span>MapTask                           <span class="hljs-comment">// Map任务信息链表</span>ReduceTask                        <span class="hljs-comment">// Reduce任务信息链表</span>WorkerInformation                 <span class="hljs-comment">// Worker的信息</span>&#125;<span class="hljs-comment">// Map任务信息链表，包括三个链表，分别表示未开始、正在进行和已经完成的任务</span><span class="hljs-keyword">type</span> MapTask <span class="hljs-keyword">struct</span> &#123;MapListReady    *list.List <span class="hljs-comment">// 未开始的Map任务</span>MapListRunning  *list.List <span class="hljs-comment">// 正在进行的Map任务</span>MapListComplete *list.List <span class="hljs-comment">// 已经完成的Map任务</span>&#125;<span class="hljs-comment">// Reduce任务信息链表，包括三个链表，分别表示未开始、正在进行和已经完成的任务</span><span class="hljs-keyword">type</span> ReduceTask <span class="hljs-keyword">struct</span> &#123;ReduceListReady    *list.List <span class="hljs-comment">// 未开始的Reduce任务</span>ReduceListRunning  *list.List <span class="hljs-comment">// 正在进行的Reduce任务</span>ReduceListComplete *list.List <span class="hljs-comment">// 已经完成的Reduce任务</span>&#125;<span class="hljs-comment">// Map任务具体信息</span><span class="hljs-keyword">type</span> MapTaskInformation <span class="hljs-keyword">struct</span> &#123;Id                   <span class="hljs-type">int</span>      <span class="hljs-comment">// 任务唯一编码</span>OriginFileName       <span class="hljs-type">string</span>   <span class="hljs-comment">// 原始文件名称</span>IntermediateFileName []<span class="hljs-type">string</span> <span class="hljs-comment">// Map任务完成后中间文件列表</span>&#125;<span class="hljs-comment">// Reduce任务具体信息</span><span class="hljs-keyword">type</span> ReduceTaskInformation <span class="hljs-keyword">struct</span> &#123;Id                   <span class="hljs-type">int</span>      <span class="hljs-comment">// 任务唯一编码</span>IntermediateFileName []<span class="hljs-type">string</span> <span class="hljs-comment">// Reduce的初始中间文件列表（从Map处获得）</span>OutputFileName       <span class="hljs-type">string</span>   <span class="hljs-comment">// Reduce任务完成后的最终文件名称</span>&#125;</code></pre></div><p>Worker中分为几个步骤：</p><ol><li>告知Coordinator自己已经上线</li><li>向Coordinator请求任务</li><li>向Coordinator返回自己的Map任务已经完成</li><li>向Coordinator返回自己的Reduce任务已经完成</li><li>向Coordinator返回自己退出的消息</li></ol><p>主程序如下：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// main/mrworker.go 调用的函数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue, reducef <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) &#123;<span class="hljs-comment">// 1. 告知Coordinator自己已经上线</span>args := WorkerArgs&#123;TaskType: <span class="hljs-string">&quot;None&quot;</span>&#125;reply := WorkerReply&#123;TaskType: <span class="hljs-string">&quot;None&quot;</span>&#125;call(<span class="hljs-string">&quot;Coordinator.WorkerOnline&quot;</span>, &amp;args, &amp;reply)<span class="hljs-comment">// 无限循环向Coordinator请求任务</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-comment">// 2. 向Coordinator请求任务</span>args = WorkerArgs&#123;TaskType: <span class="hljs-string">&quot;None&quot;</span>&#125;reply = WorkerReply&#123;TaskType: <span class="hljs-string">&quot;None&quot;</span>&#125;ok := call(<span class="hljs-string">&quot;Coordinator.AsssignTask&quot;</span>, &amp;args, &amp;reply)<span class="hljs-keyword">if</span> ok &#123;fmt.Println(<span class="hljs-string">&quot;Call Success!&quot;</span>)<span class="hljs-keyword">if</span> reply.TaskType == <span class="hljs-string">&quot;map&quot;</span> &#123;fmt.Printf(<span class="hljs-string">&quot;Map Task!\n&quot;</span>)<span class="hljs-comment">// 读取文件，调用map函数进行处理</span>intermediate := []KeyValue&#123;&#125;file, err := os.Open(reply.MapInput)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, reply.MapInput)&#125;content, err := io.ReadAll(file)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot read %v&quot;</span>, reply.MapInput)&#125;file.Close()kva := mapf(reply.MapInput, <span class="hljs-type">string</span>(content))intermediate = <span class="hljs-built_in">append</span>(intermediate, kva...)<span class="hljs-comment">// 循环创建NReduce个文件准备保存</span>encoderList := <span class="hljs-built_in">make</span>([]*json.Encoder, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> _, fileName := <span class="hljs-keyword">range</span> reply.MapOutput &#123;tempFile, err := os.Create(fileName)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot create %v&quot;</span>, fileName)&#125;<span class="hljs-keyword">defer</span> tempFile.Close()encoderList = <span class="hljs-built_in">append</span>(encoderList, json.NewEncoder(tempFile))&#125;<span class="hljs-comment">// 将map后的结果存入文件中（最费时间）</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> intermediate &#123;encoderList[ihash(v.Key)%<span class="hljs-built_in">len</span>(reply.MapOutput)].Encode(&amp;intermediate[i])&#125;<span class="hljs-comment">// 3. 向Coordinator返回自己的Map任务已经完成</span>args.TaskType = <span class="hljs-string">&quot;map&quot;</span>args.Taskid = reply.Idcall(<span class="hljs-string">&quot;Coordinator.TaskFinish&quot;</span>, &amp;args, &amp;reply)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> reply.TaskType == <span class="hljs-string">&quot;reduce&quot;</span> &#123;fmt.Printf(<span class="hljs-string">&quot;Reduce Task!\n&quot;</span>)<span class="hljs-comment">// 创建输出文件</span>ofile, _ := os.Create(reply.ReduceOutput)<span class="hljs-comment">// 遍历输入文件，汇总Map产生的所有结果</span>kva := <span class="hljs-built_in">make</span>([]KeyValue, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> reply.ReduceInput &#123;<span class="hljs-comment">// fmt.Println(filename)</span>file, err := os.Open(filename)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, filename)&#125;dec := json.NewDecoder(file)<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">var</span> kv KeyValue<span class="hljs-keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">break</span>&#125;kva = <span class="hljs-built_in">append</span>(kva, kv)&#125;&#125;<span class="hljs-comment">// 排序</span>sort.Sort(ByKey(kva))<span class="hljs-comment">// 在已经排好序的键值对上进行统计，并写入到文件中</span>i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(kva) &#123;j := i + <span class="hljs-number">1</span><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(kva) &amp;&amp; kva[j].Key == kva[i].Key &#123;j++&#125;values := []<span class="hljs-type">string</span>&#123;&#125;<span class="hljs-keyword">for</span> k := i; k &lt; j; k++ &#123;values = <span class="hljs-built_in">append</span>(values, kva[k].Value)&#125;output := reducef(kva[i].Key, values)fmt.Fprintf(ofile, <span class="hljs-string">&quot;%v %v\n&quot;</span>, kva[i].Key, output)i = j&#125;<span class="hljs-comment">// 4. 向Coordinator返回自己的Reduce任务已经完成</span>args.Taskid = reply.Idargs.TaskType = <span class="hljs-string">&quot;reduce&quot;</span>call(<span class="hljs-string">&quot;Coordinator.TaskFinish&quot;</span>, &amp;args, &amp;reply)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> reply.TaskType == <span class="hljs-string">&quot;finish&quot;</span> &#123;<span class="hljs-comment">// 5. 向Coordinator返回自己退出的消息</span>call(<span class="hljs-string">&quot;Coordinator.WorkerFinish&quot;</span>, &amp;args, &amp;reply)fmt.Printf(<span class="hljs-string">&quot;Bye!\n&quot;</span>)<span class="hljs-keyword">return</span>&#125;&#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;Call failed!\n&quot;</span>)&#125;<span class="hljs-comment">// 间隔1秒请求一次</span>time.Sleep(time.Second)&#125;&#125;</code></pre></div><p>其中将RPC的发送和接收的结构体更改的更为合理：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Worker向Coordinator传递的信息</span><span class="hljs-keyword">type</span> WorkerArgs <span class="hljs-keyword">struct</span> &#123;Id       <span class="hljs-type">int</span>    <span class="hljs-comment">// Worker的唯一ID</span>Taskid   <span class="hljs-type">int</span>    <span class="hljs-comment">// 任务全局唯一ID</span>TaskType <span class="hljs-type">string</span> <span class="hljs-comment">// 任务类型</span>&#125;<span class="hljs-comment">// Coordinator向Worker传递的信息</span><span class="hljs-keyword">type</span> WorkerReply <span class="hljs-keyword">struct</span> &#123;Id           <span class="hljs-type">int</span>      <span class="hljs-comment">// 任务id</span>TaskType     <span class="hljs-type">string</span>   <span class="hljs-comment">// 任务类型</span>MapInput     <span class="hljs-type">string</span>   <span class="hljs-comment">// Map任务的输入</span>MapOutput    []<span class="hljs-type">string</span> <span class="hljs-comment">// Map任务的输出</span>ReduceInput  []<span class="hljs-type">string</span> <span class="hljs-comment">// Reduce任务的输入</span>ReduceOutput <span class="hljs-type">string</span>   <span class="hljs-comment">// Reduce任务的输出</span>&#125;</code></pre></div><ul><li>告知Coordinator自己已经上线：</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Worker告知Coordinator自己上线了</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> WorkerOnline(args *WorkerArgs, reply *WorkerReply) <span class="hljs-type">error</span> &#123;mu.Lock()<span class="hljs-keyword">if</span> c.WorkerNum == <span class="hljs-number">-1</span> &#123;c.WorkerNum = <span class="hljs-number">0</span>&#125;c.WorkerNum += <span class="hljs-number">1</span>mu.Unlock()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>这里暂时比较简单，后续需要进行处理，以进行异常处理</p><ul><li>向Coordinator请求任务：</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Worker向Coordinator请求任务</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> AsssignTask(args *WorkerArgs, reply *WorkerReply) <span class="hljs-type">error</span> &#123;mu.Lock()<span class="hljs-comment">// 首先查看map任务是否已经全部完成，如果全部完成了就去完成Reduce任务，如果也全部完成了就发送Worker可以退出的消息</span><span class="hljs-comment">// 判断方式：通过完成链表的节点数量与初始化时侯计算的数量是否相同</span><span class="hljs-keyword">if</span> c.MapListComplete.Len() != c.MapTaskNum &#123;<span class="hljs-comment">// 分配map任务</span><span class="hljs-keyword">if</span> c.MapListReady.Len() == <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// 没有没开始的Map任务</span>reply.TaskType = <span class="hljs-string">&quot;waiting&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 将一个未完成的任务从未开始的链表中取出，插入到正在进行的链表里面</span>e := c.MapListReady.Front()c.MapListReady.Remove(e)c.MapListRunning.PushBack(e)<span class="hljs-comment">// 构建返回消息，告知Worker这个任务的信息</span>reply.TaskType = <span class="hljs-string">&quot;map&quot;</span>value := e.Value.(MapTaskInformation)reply.Id = value.Idreply.MapInput = value.OriginFileNamereply.MapOutput = value.IntermediateFileName&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c.ReduceListComplete.Len() != c.ReduceTaskNum &#123;<span class="hljs-comment">// 分配reduce任务</span><span class="hljs-keyword">if</span> c.ReduceListReady.Len() == <span class="hljs-number">0</span> &#123;<span class="hljs-comment">// 没有没开始的Reduce任务</span>reply.TaskType = <span class="hljs-string">&quot;waiting&quot;</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 将一个未完成的任务从未开始的链表中取出，插入到正在进行的链表里面</span>e := c.ReduceListReady.Front()c.ReduceListReady.Remove(e)c.ReduceListRunning.PushBack(e)<span class="hljs-comment">// 构建返回消息，告知Worker这个任务的信息</span>reply.TaskType = <span class="hljs-string">&quot;reduce&quot;</span>value := e.Value.(ReduceTaskInformation)reply.Id = value.Idreply.ReduceInput = value.IntermediateFileNamereply.ReduceOutput = value.OutputFileName&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//告知Worker已经没有任务了，可以退出了</span>reply.TaskType = <span class="hljs-string">&quot;finish&quot;</span>&#125;mu.Unlock()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>收到请求后操作全局链表，构建消息并返回即可</p><ul><li>向Coordinator返回自己的任务已经完成</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Worker告知Coordinator刚才分配的任务已经完成</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> TaskFinish(args *WorkerArgs, reply *WorkerReply) <span class="hljs-type">error</span> &#123;mu.Lock()<span class="hljs-comment">// 将节点从正在进行的链表中取出，插入到已经完成的链表中</span><span class="hljs-keyword">if</span> args.TaskType == <span class="hljs-string">&quot;map&quot;</span> &#123;<span class="hljs-comment">// 操作节点</span>e := c.UniqueIdSlice[args.Taskid]c.MapListRunning.Remove(e)c.MapListComplete.PushBack(e)<span class="hljs-comment">// 如果是Map任务，需要将产生的nReduce个中间文件分配给Reduce节点</span><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> e.Value.(MapTaskInformation).IntermediateFileName &#123;<span class="hljs-comment">// 计算是哪个Reduce节点</span>reduceTaskNum, err := strconv.Atoi(strings.Split(file, <span class="hljs-string">&quot;-&quot;</span>)[<span class="hljs-number">2</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;cannot parseInt %v&quot;</span>, file)&#125;<span class="hljs-comment">// 将产生的nReduce个中间文件分配给Reduce节点（需要重新构建节点）</span>value := c.UniqueIdSlice[reduceTaskNum].ValuetempSlice := <span class="hljs-built_in">append</span>(value.(ReduceTaskInformation).IntermediateFileName, file)c.UniqueIdSlice[reduceTaskNum].Value = ReduceTaskInformation&#123;Id:                   value.(ReduceTaskInformation).Id,IntermediateFileName: tempSlice,OutputFileName:       value.(ReduceTaskInformation).OutputFileName,&#125;&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> args.TaskType == <span class="hljs-string">&quot;reduce&quot;</span> &#123;<span class="hljs-comment">// 操作节点</span>e := c.ReduceListRunning.Remove(c.UniqueIdSlice[args.Taskid])c.ReduceListComplete.PushBack(e)&#125;mu.Unlock()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>对于Map任务需要传递Map输出，Reduce输入的文件信息，将结构体填充完整</p><ul><li>向Coordinator返回自己退出的消息</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Worker告知Coordinator自己退出了</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> WorkerFinish(args *WorkerArgs, reply *WorkerReply) <span class="hljs-type">error</span> &#123;mu.Lock()<span class="hljs-comment">// 退出时将Coordinator内部存储的Worker数量-1</span>c.WorkerNum -= <span class="hljs-number">1</span>mu.Unlock()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>将全局的WorkerNum减去1，后续需要进行处理。</p><p>经测试，除异常检测完已经都能顺利pass，多次运行的结果也完全相同</p><p>有一个小问题是它的脚本给的超时时间不够，调大一些后才能顺利运行，后续可以进行更改。</p><h2 id="异常处理">异常处理</h2><p>原文与异常处理相关的部分：</p><p>The coordinator should notice if a worker hasn’t completed its task in a reasonable amount of time (for this lab, use ten seconds), and give the same task to a different worker.</p><p>The best you can do is have the coordinator wait for some amount of time, and then give up and re-issue the task to a different worker. For this lab, have the coordinator wait for ten seconds; after that the coordinator should assume the worker has died (of course, it might not have).</p><p>To test crash recovery, you can use the mrapps/crash.go application plugin. It randomly exits in the Map and Reduce functions.</p><p>可以先查看crash.go，看看是如何模拟线程崩溃的：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maybeCrash</span><span class="hljs-params">()</span></span> &#123;max := big.NewInt(<span class="hljs-number">1000</span>)rr, _ := crand.Int(crand.Reader, max)<span class="hljs-keyword">if</span> rr.Int64() &lt; <span class="hljs-number">330</span> &#123;<span class="hljs-comment">// crash!</span>os.Exit(<span class="hljs-number">1</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> rr.Int64() &lt; <span class="hljs-number">660</span> &#123;<span class="hljs-comment">// delay for a while.</span>maxms := big.NewInt(<span class="hljs-number">10</span> * <span class="hljs-number">1000</span>)ms, _ := crand.Int(crand.Reader, maxms)time.Sleep(time.Duration(ms.Int64()) * time.Millisecond)&#125;&#125;</code></pre></div><p>阅读代码，可以发现这个设置是有1/3的概率直接崩溃掉，有2/3的概率线程睡眠不到10s，模拟的环境还是比较简单的。</p><p>实现：</p><p>Worker部分：</p><p>Worker上线后，由Coordinator为其分配一个ID，随后在Worker的每一个rpc请求中都带有这个ID</p><div class="code-wrapper"><pre><code class="hljs go">WorkerID := reply.WorkerID</code></pre></div><p>Worker上线后每5秒发送心跳信号给Coordinator，表明自己在线</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 心跳信号</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;args := WorkerArgs&#123;TaskType: <span class="hljs-string">&quot;None&quot;</span>&#125;args.Id = WorkerIDreply := WorkerReply&#123;TaskType: <span class="hljs-string">&quot;None&quot;</span>&#125;time.Sleep(time.Second * <span class="hljs-number">5</span>)call(<span class="hljs-string">&quot;Coordinator.WorkerAlive&quot;</span>, &amp;args, &amp;reply)&#125;&#125;()</code></pre></div><p>Coordinator部分：</p><p>维护一个切片结构体，索引表示Worker的ID，结构体内部包括任务ID和上一次心跳信号的时间</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HeartBeat <span class="hljs-keyword">struct</span> &#123;WorkID <span class="hljs-type">int</span>Time   <span class="hljs-type">int64</span>&#125;<span class="hljs-keyword">var</span> WorkerList []HeartBeat</code></pre></div><p>接收到Worker上线的RPC后，记录当前的时间戳，记录任务ID为-1，即表示这个索引ID已经分配给Worker了</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 分配任务ID并记录时间</span>WorkerList = <span class="hljs-built_in">append</span>(WorkerList, HeartBeat&#123;WorkID: <span class="hljs-number">-1</span>,Time:   time.Now().Unix(),&#125;)reply.WorkerID = <span class="hljs-built_in">len</span>(WorkerList)</code></pre></div><p>接收心跳信号后更新切片结构体</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Coordinator接收心跳信号</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Coordinator)</span></span> WorkerAlive(args *WorkerArgs, reply *WorkerReply) <span class="hljs-type">error</span> &#123;mu.Lock()WorkerList[args.Id<span class="hljs-number">-1</span>].Time = time.Now().Unix()fmt.Printf(<span class="hljs-string">&quot;接收到%d心跳信号\n&quot;</span>, args.Id<span class="hljs-number">-1</span>)mu.Unlock()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>分配任务后在切片结构体内更新任务ID信息</p><div class="code-wrapper"><pre><code class="hljs go">WorkerList[args.Id<span class="hljs-number">-1</span>].WorkID = value.Id</code></pre></div><p>开启协程每10秒检查切片结构体的时间戳，如果时间戳与当前时间间隔大于10秒，将任务的状态更改为未完成，重新分配。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Worker信息存储</span>WorkerList = <span class="hljs-built_in">make</span>([]HeartBeat, <span class="hljs-number">0</span>)<span class="hljs-comment">// 每间隔10秒进行验证</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;time.Sleep(<span class="hljs-number">10</span> * time.Second)mu.Lock()<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(WorkerList); i++ &#123;<span class="hljs-keyword">if</span> WorkerList[i].WorkID != <span class="hljs-number">-1</span> &amp;&amp; time.Now().Unix()-WorkerList[i].Time &gt; <span class="hljs-number">10</span> &#123;fmt.Printf(<span class="hljs-string">&quot;%d心跳信号过期\n&quot;</span>, i)e2 := *(c.UniqueIdSlice[WorkerList[i].WorkID])<span class="hljs-comment">// 这里不太懂为什么要这样写</span><span class="hljs-keyword">if</span> WorkerList[i].WorkID &lt; c.MapTaskNum &#123;c.MapListRunning.Remove(&amp;e2)c.MapListReady.PushBack(e2.Value)&#125; <span class="hljs-keyword">else</span> &#123;c.ReduceListRunning.Remove(&amp;e2)c.ReduceListReady.PushBack(e2.Value)&#125;c.WorkerNum -= <span class="hljs-number">1</span>WorkerList[i].WorkID = <span class="hljs-number">-1</span>&#125;&#125;mu.Unlock()&#125;&#125;()</code></pre></div><h1>结束</h1><p>至此，可以单独通过全部的test，但是仍然存在一些问题</p><ul><li>代码可读性不高，不够规范，自己都看不太明白</li><li>第一个wc的test和第二个index的test结合在一起通不过，但是可以单独通过两个test</li><li>最后异常检测的时候会有worker退不出去</li><li>代码运行时间整体比较长，不能满足脚本的运行时间</li><li>加锁的地方考虑的比较少，有点过于简单粗暴了</li></ul><p>总之基本功能已经没有什么问题了，以后有时间再进行重构。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Distributed Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.824 Distributed Systems-LEC 1 Introduction</title>
    <link href="/2022/12/13/6.824/Distributed-Systems-MIT-6.824-LEC-1/"/>
    <url>/2022/12/13/6.824/Distributed-Systems-MIT-6.824-LEC-1/</url>
    
    <content type="html"><![CDATA[<p>MIT-6.824（Spring 2022）LEC 1 Introduction</p><span id="more"></span><h1>MapReduce论文阅读</h1><p><a href="https://zhuanlan.zhihu.com/p/141657364">参考翻译</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/6.824/mapreduce.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="方法提出">方法提出</h2><ul><li>大量的数据分布在不同的机器上，为了能让某些算法在可以接受的时间内完成，需要将算法分配到不同的机器上一起并行运行</li><li>受Lisp的启发，我们发现大多数的操作都可以分为两个部分，map和reduce<ul><li>首先将输入中的逻辑记录应用map操作转化为过渡的键值对</li><li>然后将相同的键对应的值应用reduce操作，从而合并上一步产生的过渡数据</li></ul></li></ul><h2 id="编程模型">编程模型</h2><p>（WordCount）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-built_in">map</span>(String key, String value):<span class="hljs-comment">// key: document name</span><span class="hljs-comment">// value: document contents</span>    <span class="hljs-keyword">for</span> each word w in value:        <span class="hljs-built_in">EmitIntermediate</span>(w, <span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-built_in">reduce</span>(String key, Iterator values):<span class="hljs-comment">// key: a word</span><span class="hljs-comment">// values: a list of counts</span>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> each v in values:        result += <span class="hljs-built_in">ParseInt</span>(v);    <span class="hljs-built_in">Emit</span>(<span class="hljs-built_in">AsString</span>(result));</code></pre></div><p>map函数输出每个单词和计数的数量，reduce汇总其中某个特定单词的数量并输出。</p><ul><li>分布式查找：map函数匹配到了就直接输出，reduce函数不发挥作用</li><li>计数URL访问频率：map函数对网页的日志进行处理并输出中间键值对，reduce函数再进行汇总处理</li><li>反转网页-链接图：map函数在source网页中寻找target URL，输出 <code>&lt;target, source&gt;</code>键值对，reduce函数对目标URL汇总source并输出</li><li>节点的主干词向量</li><li>倒排索引</li><li>分布式排序：map从每一条记录中提取键，reduce输出所有的键值对（后面详细说明）</li></ul><h2 id="Google对MapReduce的一种实现">Google对MapReduce的一种实现</h2><p><a href="https://imgse.com/i/zIslPU"><img src="https://s1.ax1x.com/2022/12/14/zIslPU.md.png" alt="zIslPU.md.png"></a></p><p>如上图所示，map的过程是在多机器上调用的，其中分配的过程是自动化的，共分配了<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个节点进行。reduce过程是通过用户指定的节点数量，通过某种方法（如计算哈希值等）分配<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>台机器进行。</p><p>其中有一个master节点，这个节点负责将任务进行分配，有些机器进行map操作，有些机器进行reduce操作等。</p><p>被分配到map任务的节点读取输入，将处理好的内容写入缓存，周期性的存入硬盘。存入时直接分为<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>部分，并将数据存放的位置告知master</p><p>当一个节点被master通知要进行reduce时，通过RPC的方式从硬盘中读取数据到缓存中，进行处理并排序，保证相同的key出现在相同的位置</p><p>最终输出的时<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的文件，但是并不需要用户进行手动合并，因为这些文件通常是作为下一阶段的输入。</p><h3 id="Master数据结构">Master数据结构</h3><p>对于每一个map任务或者reduce任务，都要保存任务的状态（已经完成或者未完成）以及工作节点的信息</p><p>对于每一个完成后的map任务，还要保存完成后的中间数据的位置和大小等信息</p><h3 id="容错机制">容错机制</h3><p>机器太多了肯定有的机器会失效</p><p>Worker失效：Master会定期ping每一个Worker，如果没有得到响应，将这个节点标记为失效</p><ul><li>如果节点的任务正在进行，将分配给它的任务还原到初始状态，给没有失效的节点去完成</li><li>如果节点的任务已经完成，对于map任务要重做，因为无法访问这个节点的存储。对于reduce来说不需要，因为已经输出到文件了</li><li>map任务重做时会通知所有的reduce任务的节点</li></ul><p>Master失效：Master的数据要经常备份，且由于只有一个Master，不太可能失效（因为被保护好了？），因此如果Master失效了会终止整个任务</p><p>故障时处理的机制：用户提供的Map和Reduce操作是输入确定性函数时，分布式的计算要保证任何情况下的输出都要一致没有错误.</p><p>使用map和reduce的原子提交特点来实现。map和reduce操作都写入临时文件中，完成操作后通知Master节点。如果Master节点被通知了另外一次，则直接忽略掉。reduce操作结束后将临时文件重命名为最终输出的文件，重命名操作也是原子性，最终只会有一个符合条件的文件名。</p><h3 id="存储位置">存储位置</h3><p>尽量存储在本地的硬盘中，通过GFS把每个文件按64MB一个块，并在不同的机器上存储三份冗余的数据。</p><h3 id="任务粒度">任务粒度</h3><p>理想情况下<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>都应该比物理节点数量大得多，在每台机器都执行大量的不同任务能够提高集群的动态的负载均衡能力，并且能够加快故障恢复的速度。</p><p>在我们的具体实现中对<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的取值有一定的限制，因为master必须执行<img src="https://math.now.sh?inline=O%28M%2BR" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>)次调度，并且在内存中保存<img src="https://math.now.sh?inline=O%28M*R%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个状态（一个字节一个状态）</p><p><img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>值通常由用户指定，实际使用中选择合适的<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>值，以使得每一个独立任务都是处理大约<img src="https://math.now.sh?inline=16M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到<img src="https://math.now.sh?inline=64M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的输入数据</p><p>MapReduce的合适执行比例：<img src="https://math.now.sh?inline=M%3D200000" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=R%3D5000" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，使用<img src="https://math.now.sh?inline=2000" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>台机器节点</p><h3 id="备份任务">备份任务</h3><p>在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，会导致MapReduce操作总的执行时间超过预期。</p><p>当一个MapReduce操作接近完成的时候，master会调度备用任务进程来一起执行最后的任务，谁完成了整个任务都算完成。</p><h2 id="任务细节">任务细节</h2><p>在具体的实现上，对上面描述的简单mapreduce过程可以进行优化</p><ol><li>reduce前需要先分配map的结果，使用哈希函数的方式分配的比较均衡，但是可能有一些场景下需要将特定的键值对分配到一起，因此用户可以传入自定义的类似于哈希的函数进行分配</li><li>确保在给定的分区中，键值对数据的处理顺序是按照键进行排序后的。排序后对后面的任务都有利</li><li>Map函数产生的中间key值的重复数据会占很大的比重（成千上万个&lt;the,1&gt;），因此允许用户指定一个可选的combiner函数，combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。一般情况下，Combiner和Reduce函数相同。区别在于输出到最终文件还是中间文件。</li><li>MapReduce支持不同的格式的输入数据，如文本或者键值对等，同时提供Reader接口使用户可以自定义输出，只要保证输入是可以分割的就可以</li><li>某些情况下，在Map或Reduce操作过程中增加辅助的输出文件会比较省事。（但是这里不支持？）</li><li>用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候会崩溃掉。这个bug可能很难找。因此提供了一种执行模式，在这种模式下，为了保证保证整个处理能继续进行，MapReduce会检测哪些记录导致确定性的crash，并且跳过这些记录不处理。</li><li>在远程分布式节点上调试程序非常困难，因此开发了一套MapReduce库的本地实现版本，可以调试使用</li><li>master使用嵌入式的HTTP服务器（如Jetty）显示一组状态信息页面，用户可以监控各种执行状态</li><li>MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。可以用于MapReduce操作的完整性检查。</li></ol><h2 id="实验表现">实验表现</h2><ul><li>在大约1TB的数据中进行特定的模式匹配（从海量数据中抽取感兴趣的数据）</li><li>对大约1TB的数据进行排序（对数据的形式进行转换）</li></ul><h2 id="应用">应用</h2><ol><li>大规模机器学习问题</li><li>Google News和Froogle产品的集群问题</li><li>从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。</li><li>从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。</li><li>大规模的图形计算。</li></ol><p>MapReduce的成功取决于采用MapReduce库能够在不到半个小时时间内写出一个简单的程序，这个简单的程序能够在上千台机器的组成的集群上做大规模并发处理，极大的加快了开发和原形设计的周期。另外，采用MapReduce库，可以让完全没有分布式和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。</p><h2 id="结论">结论</h2><p>MapReduce的成功有几个方面：</p><ol><li>MapReduce封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节，使得MapReduce库易于使用。</li><li>大量不同类型的问题都可以通过MapReduce简单解决。</li><li>实现了在数千台计算机组成的大型集群上灵活部署运行的MapReduce，使得有效利用这些计算资源变得非常简单，适合用来解决其他需要大量计算的问题。</li></ol><p>从MapReduce开发过程中也学到了不少东西。</p><ol><li>使用固定的编程模式使得并行和分布式计算非常容易，也易于构造容错的计算环境；</li><li>网络带宽是稀有资源。大量的系统优化是针对减少网络传输量为目的的：本地优化策略使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络带宽</li><li>备份服务器执行相同的任务可以减少性能缓慢的机器带来的负面影响（硬件配置的不平衡），同时解决了由于机器失效导致的数据丢失问题。</li></ol><h1>LEC 1</h1><h2 id="什么是分布式系统">什么是分布式系统</h2><ul><li>多个计算机通过网络连接，因此只能通过发送和接收数据包的形式进行交互，不能共享内存等等。</li><li>支持应用程序的基础设施主干架构</li></ul><h2 id="分布式系统的作用">分布式系统的作用</h2><ul><li>连接物理上分离的机器-允许用户之间的数据共享</li><li>通过并行提升性能</li><li>容错机制-挂掉的机器不能影响服务</li><li>通过将程序分布在不同的机器上获得安全性（例如一台机器只用于登录服务的验证）</li></ul><h2 id="分布式系统的发展历程">分布式系统的发展历程</h2><ul><li>起始于局域网出现（AFS）-DNS、Email</li><li>数据中心（大量数据）和大型网站（大量用户）</li><li>云计算</li><li>很难跟上时代发展节奏，一直在不断努力</li></ul><h2 id="分布式系统的挑战">分布式系统的挑战</h2><ul><li>很多并行的部分</li><li>容错机制</li><li>很难实现分布式的性能优势</li></ul><p>判断系统是否正常工作非常困难，例如两台机器间的网络挂掉，两边都认为对方挂掉了，因此对外提供了两份服务。</p><h2 id="课程关注的内容">课程关注的内容</h2><p>课程不关注应用程序，只关注基础设施，也就是支撑这些应用程序正确工作的部分。</p><p>关注的三个方面：存储、计算和通信</p><p>抽象：分布式系统的抽象与单机系统的抽象基本相同</p><h2 id="重点内容">重点内容</h2><p>容错机制</p><ul><li>可用性：使系统高可用的技术，某个节点挂掉仍然可以正常工作<ul><li>关键：复制</li></ul></li><li>可恢复性：挂掉的机器重启后还能回到分布式系统中继续工作<ul><li>关键：日志或事务</li></ul></li></ul><p>一致性：分布式系统与单机的行为相同</p><p>性能：不同类型的一致性和容错机制与性能相关</p><ul><li>吞吐量</li><li>低延迟：某些很慢的机器会拖慢整个程序的运行过程</li></ul><p>实现细节：如何实现并发、远程过程调用等等</p><h2 id="MapReduce">MapReduce</h2><h3 id="背景">背景</h3><p>在Google早期的数据中心，有一个搜索引擎，需要构建万维网的倒排索引，允许用户上网查询。</p><p>在这个过程中处理TB级别的数据需要耗费几个小时。</p><p>为每一个应用都编写一个这种系统很困难，因此提出了MapReduce，使得构建不同应用的分布式程序比较轻松</p><p>不过这些应用必须要能分成map和reduce两个部分，然后放到MapReduce框架下运行，不需要再关注其他细节（如容错机制等等）</p><h3 id="框架图">框架图</h3><p><a href="https://imgse.com/i/zIslPU"><img src="https://s1.ax1x.com/2022/12/14/zIslPU.md.png" alt="zIslPU.md.png"></a></p><ol><li>Map操作统计所有的输入文件，不同机器节点之间没有通信</li><li>Shuffle：从每个Map获取输出，按照键进行排序（最难的操作）</li><li>在键相同的字段上运行Reduce</li></ol><p>主要的网络通信在于传输map产生的中间文件给reduce使用</p><h3 id="容错机制-2">容错机制</h3><p>如果一个机器在一定的时间内没有对Coordinator作出响应，就认为这个机器已经挂掉了，因此Coordinator会重新安排其他机器重启它的任务。</p><p>map和reduce任务可能会运行两次，例如Coordinator认为这个机器挂掉了，把它的任务分配给别人了，但是实际上这个机器并没有挂掉。最终使用重命名操作的原子性确保只存储一个结果。</p><p>Coordinator会挂掉吗？挂掉了整个任务就都要重新跑了，一般不会挂掉。</p><p>一些机器可能会运行很慢从而拖累整个任务的进程。当整个任务快要结束的时候，会复制任务到其他的空闲节点上一起做，谁先做完取谁的。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Distributed Systems</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-期末复习</title>
    <link href="/2022/12/11/UCAS/machine-learning/machine-learning-final/"/>
    <url>/2022/12/11/UCAS/machine-learning/machine-learning-final/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》期末复习</p><span id="more"></span><h1>选择题</h1><h2 id="各种分类">各种分类</h2><p>监督学习：贝叶斯分类器、支持向量机、Logistic回归、决策树、线性回归、最大熵、CRF</p><p>无监督学习：主成分分析、K-Means、高斯混合聚类、层次聚类</p><p>线性分类方法：感知机、线性鉴别分析、最小距离分类器</p><p>非线性分类方法：决策树、最近邻、集成学习、核SVM</p><p>线性分类器最佳准则：感知准则函数、支持向量机、Fisher准则</p><p>生成式模型：朴素贝叶斯、隐马尔可夫模型、高斯混合模型</p><p>判别式模型：支持向量机、线性分类器、神经网络、线性判别分析</p><h2 id="回归">回归</h2><p>Logistic回归使用最大似然估计</p><p>回归问题和分类问题的区别：前者预测函数值为连续值，后者为离散值</p><p>最小二乘回归方法的等效回归方法：线性均值和正态误差的最大似然回归</p><p>正则化的回归分析，可以避免过拟合</p><p>假如使用一个较复杂的回归模型来拟合样本数据，使用岭回归，调试正则化参数λ，来降低模型复杂度。若λ较大时，偏差增大，方差减小</p><p>在线性回归中使用正则项，你发现解的不少coefficient都是0，这个正则项可能是L0-norm或L1-norm</p><p>LR模型的损失函数是交叉熵</p><p>在Logistic Regression 中,如果同时加入L1和L2范数，可以做特征选择，并在一定程度上防止过拟合</p><p>逻辑斯蒂回归没有利用回归的思想</p><h2 id="共轭分布">共轭分布</h2><p>二项式分布的共轭分布是Beta分布</p><p>多项式分布的共轭分布是Dirichlet分布</p><h2 id="贝叶斯">贝叶斯</h2><ul><li>以贝叶斯定理为基础</li><li>可以解决有监督学习的问题</li><li>可以用极大似然估计法解贝叶斯分类器</li></ul><p>朴素贝叶斯分类器的特点是假设样本各维属性独立</p><p>最大似然估计没有考虑先验分布</p><p>对于正态密度的贝叶斯分类器，各类协方差矩阵相同时，决策函数为线性决策函数</p><p>下面关于贝叶斯分类器描述错误：是基于后验概率，推导出先验概率</p><p>朴素贝叶斯模型属于生成式模型</p><p>贝叶斯分类器参数估计的准则：最大高斯后验、最大beta后验、极大似然</p><p>错误：以贝叶斯估计的角度来看朴素贝叶斯时，其没有估计联合概率</p><p>以下模型中属于贝叶斯网络的有( BD )</p><p>A.马尔可夫随机场</p><p>B.隐马尔可夫模型</p><p>C.条件随机场</p><p>D.朴素贝叶斯分类器</p><h2 id="SVM">SVM</h2><p>支持向量机属于判别式模型</p><p>SVM的原理：最大间隔分类</p><p>SVM的算法性能取决于：核函数的选择、核函数的参数、软间隔参数C</p><p>支持向量机的对偶问题是凸二次优化</p><p>支撑向量：最大间隔支撑面上的向量</p><p>避免直接的复杂非线性变换，采用线性手段实现非线性学习的方法是：核函数方法</p><p>软间隔SVM的阈值趋于无穷：只要最佳分类超平面存在，它就能将所有数据全部正确分类</p><p>核函数并不是把特征映射到的空间维度越高越好</p><p>如果SVM模型欠拟合, 以下方法哪些可以改进模型：增大惩罚参数C的值，增大核系数(gamma参数)</p><h2 id="聚类">聚类</h2><p>密度聚类方法充分考虑了样本间的密度可达关系</p><p>混合高斯聚类使用了EM算法</p><p>k-means算法初始值不同，最终结果可能不同</p><p>k-means不适合处理非凸型数据</p><p>以下可用于聚类性能测量的评估方法：Jaccard系数、FM指数、Rand指数、DB指数</p><h2 id="降维">降维</h2><p>主成分分析方法是一种降维方法</p><p>PCA在做降维处理时，优先选取中心化样本的协方差矩阵的最大特征值对应特征向量</p><p>可以用于特征降维的：SVD、PCA和LDA</p><p>不可以用于特征降维的：蒙特卡洛方法</p><p>特征降维带来的好处：节省数据通信开销、节省数据存储资源、加快模型计算速度</p><h2 id="决策树">决策树</h2><p>关于决策树节点划分指标描述正确的是信息增益越大越好</p><p>决策树不受数据归一化影响，SVM、神经网络、Logistic回归都会受影响</p><p>增加决策树的深度可能导致随机森林模型过拟合数据</p><p>我们想在大数据集上训练决策树, 为了使用较少时间, 我们可以减少树的深度，减少树的数量</p><h2 id="集成学习">集成学习</h2><p>Bootstrap数据：有放回地从总共N个样本中抽样n个样本</p><p>集成学习中基分类器多样，差异大，学习效率通常越好，每个基分类器的正确率的最低要求50%以上</p><p>Bagging方法的特点：构造训练集时采用Bootstraping的方式</p><p>Boosting方法的特点：预测结果时，分类器的比重不同</p><p>随机森林方法属于Bagging方法</p><p>Adaboost算法：</p><ul><li>是弱分类器的线性组合</li><li>提升树是以分类树或者回归树为基本分类器的提升办法</li><li>该算法实际上是前向分步算法的一个实现，在这个方法里，模型是加法模型，损失函数是指数损失，算法是前向分步算法。</li></ul><p>Adaboost方法中，需要迭代调整的两个重要参数是：样本权重和分类器权重</p><h2 id="深度学习">深度学习</h2><p>以下关于深度网络训练的说法正确的：</p><ul><li>训练过程需要用到梯度，梯度衡量了损失函数相对于模型参数的变化率</li><li>损失函数衡量了模型预测结果与真实值之间的差异</li><li>训练过程基于一种叫做反向传播的技术</li></ul><p>在训练神经网络时，如果出现训练error过高，增加训练数据不能大幅度降低训练error</p><p>Tanh可以导致梯度消失</p><p>ReLU在神经网络中引入了非线性</p><p>关于CNN，Pooling层用于减少图片的空间分辨率</p><p>卷积神经网络可以有多个卷积核，可以不同大小</p><p>GRU和LSTM的说法正确的是：GRU的参数比LSTM的参数少</p><p>与普通反向传播不同的是，BPTT会在每个时间步长内叠加所有对应权重的梯度</p><p>在RNN中，梯度裁剪可以较好地处理梯度爆炸问题</p><p>循环神经网络有反馈连接并常被用来处理序列数据</p><h2 id="过拟合和欠拟合">过拟合和欠拟合</h2><p>数据增强会增加模型的欠拟合风险</p><p>过拟合现象中训练样本的测试误差最小，测试样本的正确识别率却很低</p><p>过拟合：训练误差小，测试误差大</p><p>容易引起过拟合：SVM算法中使用高斯核代替线性核</p><p>不容易引起过拟合：增加训练集量、减少神经网络隐藏层节点数、删除稀疏的特征</p><p>神经网络处理过拟合：Dropout、Batch Normalization、regularization</p><h2 id="概率图模型">概率图模型</h2><p>在HMM中,如果已知观察序列和产生观察序列的状态序列,那么可用极大似然估计直接进行参数估计</p><p>解决隐马模型中预测问题的算法是维特比算法</p><h2 id="其他">其他</h2><p>K-NN最近邻方法在什么情况下效果好：样本较少但典型性较好</p><p>以下可行的最近邻分类的加速方案：分层搜索和训练样本缩减</p><p>线性鉴别分析：找到一个投影方向，使得类内距离最小，类间距离最大</p><p>KL散度是根据类概率密度构造的可分性判据</p><p>最大似然估计没有考虑先验分布</p><p>多层感知机方法中，可用作神经元的非线性激活函数：logistic 函数</p><p>在有限支撑集上，均匀分布的熵最大</p><p>已知均值和方差，高斯分布的熵最大</p><p>受限玻尔兹曼机属于概率图模型</p><p>余弦距离会侧重考虑向量的方向</p><p>除了EM算法，梯度下降也可求混合高斯模型的参数</p><p>下列哪个不属于常用的文本分类的特征选择算法（D）</p><p>A. 卡方检验值</p><p>B. 互信息</p><p>C. 信息增益</p><p>D. 主成分分析</p><p>解决样本类别不平衡的手段：欠采样、过采样、使用focal loss</p><p>对于k折交叉验证, 以下对k的说法正确的是：</p><p>A.k越大, 不一定越好, 选择大的k会加大评估时间</p><p>B.选择更大的k, 就会有更小的bias ，因为训练集更加接近总数据集</p><p>C.在选择k时, 要最小化数据集之间的方差</p><p>下列选项中，关于KNN算法说法不正确的是（D）</p><p>A.能找出与待测样本相近的K个样本</p><p>B.可以使用欧氏距离度量相似度</p><p>C.实现过程相对简单，但是可解释性不强</p><p>D.效率很高</p><p>73.关于特征预处理，下列说法中错误的是（B ）</p><p>A.包含标准化和归一化</p><p>B.标准化在任何场景下受异常值的影响都很小</p><p>C.归一化利用了样本中的最大值和最小值</p><p>D.标准化实际上是将数据在样本的标准差上做了等比例的缩放操作</p><p>交叉验证不能够提升模型的准确率</p><p>76.EM算法（Expectation Maximization Algorithm）是机器学习领域的一个经典算法，下面关于EM算法的说法中不正确的有：（A）</p><p>A.EM算法属于一种分类算法</p><p>B.EM算法可用于隐马尔科夫模型的参数估计</p><p>C.EM算法可以分为E-step和M-step两步</p><p>D.EM算法可用于从不完整的数据中计算最大似然估计</p><p>将一个k分类问题分解成一对一问题时总共需要k(k-1)/2个分类器</p><p>在有限支撑集上，下面分布中熵最大的是均匀分布</p><p>在机器学习中，当模型的参数量大于样本量时参数估计使用梯度下降法</p><ol start="62"><li>GRU和LSTM的说法正确的是（D）</li></ol><p>A.  GRU通过output gate控制memory；</p><p>B.  LSTM对memory不做控制，直接传递给下一个unit</p><p>C.  GRU不对上一时刻的信息做任何控制；</p><p>D.  GRU的参数比LSTM的参数少；</p><p>以下哪些算法, 可以用神经网络去构造( BD )</p><p>A.KNN</p><p>B.Logistic回归</p><p>C.决策树</p><p>D.最小二乘估计</p><h1>简答题</h1><h2 id="原题目">原题目</h2><h3 id="试阐述LDA（线性鉴别分析）的分类思想">试阐述LDA（线性鉴别分析）的分类思想</h3><p>给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近，异类样例的投影点尽可能远离；</p><p>在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来判断新样本的类别。</p><h3 id="请简要介绍SVM的设计思想">请简要介绍SVM的设计思想</h3><p>答案：SVM是一个分类算法，它的目标为确定一个分类超平面，从而将不同类别的数据分隔开达到分类的目标。</p><p>当训练数据线性可分时，通过硬间隔最大化，学习一个线性的分类器，即线性可分支持向量机，又称为硬间隔支持向量机；</p><p>当训练数据近似线性可分时，通过软间隔最大化，也学习一个线性的分类器，即线性支持向量机，又称为软间隔支持向量机；</p><p>当训练数据线性不可分时，通过使用核技巧及软间隔最大化，学习非线性支持向量机。</p><h3 id="试分析SVM对噪声敏感的原因">试分析SVM对噪声敏感的原因</h3><p>给定训练集，SVM最优决策边界由支持向量决定。</p><p>当增加噪声时，那么该噪声有极高的可能是含噪声训练集的一个支持向量，这意味着决策边界需要变。</p><h3 id="简要介绍在深度神经网络中引入非线性激活函数的作用">简要介绍在深度神经网络中引入非线性激活函数的作用</h3><p>不引入非线性激活函数的情况下，不管神经网络有多少层其输出都是输入的线性组合，与没有隐藏层的效果相当</p><h3 id="在数据处理时，为什么通常要进行标准化处理">在数据处理时，为什么通常要进行标准化处理</h3><p>在实际问题中，我们使用的样本通常是多维数据，每一维对应一个特征，这些特征的量纲和数量级都是不一样的</p><p>这时需要对数据进行标准化处理，试所有的特征具有同样的尺度</p><h3 id="试述将线性函数用作神经元激活函数的缺陷">试述将线性函数用作神经元激活函数的缺陷</h3><p>如果单用线性函数作为激活函数，无论多少层的神经网络会退化成一个线性回归，不能处理非线性分类任务。</p><h3 id="试述学习率的取值对神经网络训练的影响">试述学习率的取值对神经网络训练的影响</h3><p>如果学习率太低，每次下降的很慢，使得迭代次数非常多。</p><p>如果学习率太高，在后面迭代时会出现震荡现象，在最小值附近来回波动。</p><h3 id="神经网络为什么会产生梯度消失，有什么解决方案">神经网络为什么会产生梯度消失，有什么解决方案</h3><p>前面层上的梯度是来自于后面层上梯度的乘积。当存在过多的层次时，且激活函数的梯度小于1时，就会使前面层的梯度变得很小，更新速度过慢，导致梯度消失。</p><p>一种解决方案是使用Relu激活函数替换sigmoid，relu函数的梯度不会随着x的增大而变小，sigmoid在x取值较大时梯度趋近于0。</p><h3 id="卷积核尺度和参数的计算">卷积核尺度和参数的计算</h3><p>对3个32×32的特征图进行卷积层操作，卷积核10个5×5，Stride是1，pad为2，输出特征图的尺度是多少？卷积层的参数是多少？写出公式和结果。</p><p>输出尺度：(N+2P-F)/stride+1</p><p>卷积层的参数：(F×F×n+1)×N</p><p>答案：输出尺度（ 32+2×2-5）/1+1 = 32</p><p>卷积层的参数 （5×5×3+1）×10=760</p><h3 id="试析随机森林为何比决策树Bagging集成的训练速度更快">试析随机森林为何比决策树Bagging集成的训练速度更快</h3><p>随机森林是Bagging算法的一个扩展变体，以决策树为基学习器构建Bagging集成，</p><p>Bagging在选择划分属性时需要考察结点的所有属性，而随机森林只需随机地考察一个属性子集</p><p>所以随机森林比决策树Bagging训练速度更快，泛化能力越强。</p><h3 id="请给出L1范数和L2范数的计算方法及他们的使用场景。">请给出L1范数和L2范数的计算方法及他们的使用场景。</h3><p>L1范数为向量各个元素绝对值之和可以使权值稀疏，方便特征提取。</p><p>L2 范数为向量各个元素平方和的1/2次方可以防止过拟合，提升模型的泛化能力。</p><h3 id="试述为什么基于L1范数可以进行特征选择。">试述为什么基于L1范数可以进行特征选择。</h3><p>基于L1范数的特征选择：不能直接设置最终选择特征的个数k；通过设置正则化系数λ来隐式控制k；</p><p>λ值越大，模型越关注稀疏性，得到的非零系数个数越少；</p><p>反之，非零稀疏个数越多；</p><p>可以设置一个选择特征个数的上限，通过设置不同λ值，得到满足要求的特征。</p><p>从有条件极值问题的角度来看，L1范数相当于将模型界空间限制在了L1-ball上，目标函数的等高线有很大的概率与坐标轴和边相交，这样的解具有稀疏性。</p><h3 id="请指出数据聚类存在哪些挑战性问题">请指出数据聚类存在哪些挑战性问题</h3><ul><li>能够处理高维数据：在高维空间聚类更具挑战性，随着维数的增加，具有相同距离的两个样本其相似程度可以相差很远。对于高维稀疏数据，这一点更突出。</li><li>对噪声鲁棒：在实际中，绝大多数样本集都包含噪声、空缺、部分未知属性、孤立点、甚至错误数据。</li><li>具有约束的聚类：在实际应用中，通常需要在某种约束条件下进行聚类，既满足约束条件，以希望有高聚类精度，是一个挑战性问题。</li><li>对初始输入参数鲁棒：具有自适应的簇数判定能力，对初始聚类中心鲁棒。</li><li>能够解决用户的问题：聚类结果能被用户所理解，并能带来经济效益，特别是在数据挖掘领域。</li></ul><h3 id="描述主成分分析的主要步骤">描述主成分分析的主要步骤</h3><ol><li>数据标准化</li><li>计算协方差矩阵，求协方差的特征值和特征向量。</li><li>将特征值按照从大到小的顺序排序，选择其中最大的k个，然后将其对应的k个特征向量分别作为列向量组成特征向量矩阵。</li><li>将样本点投影到选取的特征向量上。</li></ol><h3 id="请描述机器学习中的分类任务">请描述机器学习中的分类任务</h3><p>根据给定的训练集<img src="https://math.now.sh?inline=T%3D%5C%7B%28%5Cmathbf%7Bx%7D_%7B1%7D%2C%20y_%7B1%7D%29%2C%20%5Ccdots%2C(%5Cmathbf%7Bx%7D_%7Bl%7D%2C%20y_%7Bl%7D)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_%7Bi%7D%20%5Cin%20C%3DR%5E%7Bn%7D%20%2C%20%20y_%7Bi%7D%20%5Cin%20%5Cmathrm%7BY%7D%3D%5C%7B1%2C2%2C%20%5Cldots%2C%20m%5C%7D%2C%20i%3D1%2C2%2C%20%5Cldots%2C%20l" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，要求寻找<img src="https://math.now.sh?inline=%5Cmathrm%7BC%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的决策函数  <img src="https://math.now.sh?inline=g%28%5Cmathbf%7Bx%7D%29%3A%20%5Cmathrm%7BC%7D%20%5Crightarrow%20%5Cmathrm%7BY%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><h3 id="请给出你对泛化误差的理解">请给出你对泛化误差的理解</h3><p>泛化误差 = 偏差+方差+噪声</p><p>偏差：度量了学习算法的期望预测与真实结果的偏离程度，刻画了学习算法本身的拟合能力</p><p>方差：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响</p><p>噪声：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度</p><h3 id="模型评估过程中，欠拟合和过拟合现象是什么。">模型评估过程中，欠拟合和过拟合现象是什么。</h3><p>过拟合是指模型对于训练数据拟合呈过当的情况，反映到评估指标上，就是模型在训练集上的表现很好，但在测试集和新数据上的表现较差。</p><p>欠拟合是模型在训练和预测时表现都不好的情况。</p><h3 id="说出几种降低过拟合和欠拟合的方法。">说出几种降低过拟合和欠拟合的方法。</h3><p>降低过拟合：</p><ol><li>从数据入手，获得更多的训练数据。使用更多的训练数据是解决过拟合问题最高效的手段，因为更多的样本能够让模型学习到更多更高效的特征。当然，直接增加实验数据一般是很困难的，但是可以通过一定的规则来扩充训练数据。比如在图像分类的问题上，可以通过图像的平移、旋转、缩放等方式扩充数据，更进一步地，可以使用生成式对抗网络来合成大量的新训练数据。</li><li>降低模型复杂度。在数据较少时，模型过于复杂是产生过拟合的主要因素，适当降低模型复杂度可以避免模型拟合过多的采样噪声。例如，在神经网络模型中减少网络层数、神经元个数等;在决策树模型中降低树的深度、进行剪枝等。</li><li>正则化方法。给模型的参数加上一定的正则约束，比如将权值的大小加入到损失函数中。</li><li>集成学习方法。集成学习是把多个模型集成在一起，来降低单一模型的过拟合风险，如Bagging方法。</li></ol><p>降低欠拟合：</p><ol><li>添加新特征。当特征不足或者现特征与样本标签的相关性不强时，模型容易出现欠拟合。通过挖掘“上下文特征”“ ID 类特征”“组合特征”等新的特征，往往能够取得更好的效果。</li><li>增加模型复杂度。简单模型的学习能力较差，通过增加模型的复杂度可以便模型拥高更强的拟合能力。例如，在线性模型中添加高次项，在神经网络模型中增加网络层数或神经元个数等。</li><li>减小正则化系数。正则化是用来防止过拟合的，但当模型出现欠拟合现象时，则需要针对性地减小正则化系数。</li></ol><h3 id="K均值算法的优缺点是什么，如何对其调优。">K均值算法的优缺点是什么，如何对其调优。</h3><p>K均值算法缺点：例如受初值和离群点的影响每次的结果不稳定、结果通常不是全局最优而是局部最优解、无法很好地解决数据簇分布差别比较大的情况、不太适用于离散分类等。</p><p>K均值聚类的优点：主要体现在对于大数据集，K均值聚类算法相对是高效的，计算复杂度是 O(NKt) 接近于线性，其中N是数据对象的数目，K是聚类的簇数，t 是迭代的轮数。</p><p>调优方法：数据归一化，离群点预处理，采用核函数，合理选择K值。</p><h3 id="请简述relu激活函数的优缺点">请简述relu激活函数的优缺点</h3><p>优点：</p><ol><li>从计算的角度上，Sigmoid与Tanh激活函数均需要计算指数，复杂度高。而ReLU 只需要一个阈值即可得到激活值。</li><li>ReLU的非饱和性可以有效地解决梯度消失的问题。</li><li>ReLU的单侧抑制提供了网络的稀疏表达能力。</li></ol><p>缺点：</p><p>在较大学习率设置下Relu可能会出现大量神经元死亡问题。后面神经元方向传播梯度为正，且学习率较大，Relu的梯度为1，梯度下降此时会导致该神经元的参数为负值，可能之后不会再被激活，造成神经元死亡。</p><h2 id="补充题目">补充题目</h2><h3 id="生成式模型和判别式模型的区别">生成式模型和判别式模型的区别</h3><p>生成模型估计的是联合概率分布，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：P(Y|X)= P(X,Y)/ P(X)。</p><p>生成方法关心的是给定输入x产生输出y的生成关系。</p><p>判别模型估计的是条件概率分布，有数据直接学得决策函数P(X)或者条件概率分布P(Y|X)作为预测的模型。</p><p>判别式方法关心的是给定输入X，应该预测什么样的输出Y</p><h3 id="逻辑回归和线性回归的异同">逻辑回归和线性回归的异同</h3><p>不同之处：</p><ol><li>逻辑回归解决的是分类问题，因此因变量是离散的；而线性回归解决的是回归问题，因此因变量是连续的。这是两者最本质的区别</li><li>在自变量和超参数确定的情况下逻辑回归可看作广义的线性模型在因变量下服从二元分布的一个特殊情况</li><li>使用最小二乘法求解线性回归时我们认为因变量服从正态分布</li></ol><p>相同之处：</p><ol><li>二者在求解超参数的过程中都使用梯度下降的方法</li><li>二者都使用了极大似然估计对训练样本进行建模</li></ol><h3 id="距离函数的四个基本性质">距离函数的四个基本性质</h3><ol><li>非负性:  <img src="https://math.now.sh?inline=%5Coperatorname%7Bdist%7D%5Cleft%28x_%7Bi%7D%2C%20x_%7Bj%7D%5Cright%29%20%5Cgeq%200" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>同一性:  <img src="https://math.now.sh?inline=%5Coperatorname%7Bdist%7D%5Cleft%28x_%7Bi%7D%2C%20x_%7Bj%7D%5Cright%29%3D0%20%20%E5%BD%93%E4%B8%94%E4%BB%85%E5%BD%93%20%20x_%7Bi%7D%3Dx_%7Bj%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>对称性:  <img src="https://math.now.sh?inline=%5Coperatorname%7Bdist%7D%5Cleft%28x_%7Bi%7D%2C%20x_%7Bj%7D%5Cright%29%3D%5Coperatorname%7Bdist%7D%5Cleft(x_%7Bj%7D%2C%20x_%7Bi%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>直递性:  <img src="https://math.now.sh?inline=%5Coperatorname%7Bdist%7D%5Cleft%28x_%7Bi%7D%2C%20x_%7Bj%7D%5Cright%29%20%5Cleq%20%5Coperatorname%7Bdist%7D%5Cleft(x_%7Bi%7D%2C%20x_%7Bk%7D%5Cright)%2B%5Coperatorname%7Bdist%7D%5Cleft(x_%7Bk%7D%2C%20x_%7Bj%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><h3 id="随机变量x的支撑集（也就是非零值域）定义为-a，b-，没有别的限制加在x上，该随机变量的最大熵分布是什么">随机变量x的支撑集（也就是非零值域）定义为[a，b]，没有别的限制加在x上，该随机变量的最大熵分布是什么</h3><p>根据最大熵模型， 推导出x概率密度函数是一个常函数，所以最大熵分布为均匀分布。</p><h3 id="随机变量x的给定均值和方差限制在x上，该随机变量的最大熵分布是什么">随机变量x的给定均值和方差限制在x上，该随机变量的最大熵分布是什么</h3><p>根据最大熵模型推导出x概率密度函数是一个高斯分布 。</p><h1>计算题</h1><h2 id="概率图">概率图</h2><p>写出概率图模型联合分布的因子分解式</p><p>无向图看团，有向图看条件概率</p><p>贝叶斯网络计算概率</p><h2 id="HMM">HMM</h2><p>前向算法</p><p>后向算法</p><p>维特比解码</p><h2 id="聚类-2">聚类</h2><p>Kmeans：</p><ul><li>确定初始中心点</li><li>计算聚类结果</li><li>根据结果更新中心点</li></ul><p>层次聚类自底向上：初始每一个点为一类，逐步合并更新中心即可，注意更新的时候要使用原始的点重新进行计算</p><h2 id="贝叶斯-2">贝叶斯</h2><p>贝叶斯最小错误分类</p><p>贝叶斯最小风险</p><h2 id="决策树-2">决策树</h2><ul><li>ID3：最大信息增益：根据类别计算经验熵，然后按照特征对类别算条件熵，两者相减，取比较大的特征作为划分的节点</li><li>C4.5：最大信息增益比：在ID3计算后的基础上除以每一个特征的经验熵</li><li>CART：最小基尼指数：外层是特征比例，内层是特征内部的类别比例</li></ul><h2 id="Maximum-Likelihood">Maximum Likelihood</h2><p>抛一枚硬币问题，观察数据情况是：一枚硬币包括正反两面，共抛了30次，其中12次是正面，18次是反面。采用Maximum Likelihood方法，估计正面出<br>现的概率和反面出现的概率。</p><p><a href="https://imgse.com/i/pS96XQO"><img src="https://s1.ax1x.com/2022/12/31/pS96XQO.md.png" alt="pS96XQO.md.png"></a></p><h2 id="Fisher">Fisher</h2><h1>设计题</h1><h2 id="10万张图片分类，说明模型结构和训练方法">10万张图片分类，说明模型结构和训练方法</h2><p>在机器学习中常常采用基于数据驱动的方法进行图像分类。所谓基于数据驱动的方法，就是给计算机很多数据，然后实现学习算法，让计算机学习到每个类的外形的方法。基于这种方法的完整流程如下</p><ol><li>输入：输入是包含 N 个图像的集合，每个图像的标签是 K 种分类标签中的一种。这个集合称为训练集。</li><li>学习：这一步的任务是使用训练集来学习每个类到底长什么样。一般该步骤叫做训练分类器或者学习一个模型。</li><li>评价：让分类器来预测它未曾见过的图像的分类标签，并以此来评价分类器的质量。我们会把分类器预测的标签和图像真正的分类标签对比。毫无疑问，分类器预测的分类标签和图像真正的分类标签如果一致，那就是好事，这样的情况越多越好。</li></ol><p>[<img src="https://img-blog.csdnimg.cn/72bc54765e58432bb4f437c753288655.jpeg" alt="pS.md.png"></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-期末复习</title>
    <link href="/2022/12/11/UCAS/advanced-ai/advanced-ai-final/"/>
    <url>/2022/12/11/UCAS/advanced-ai/advanced-ai-final/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》期末复习</p><span id="more"></span><h1>概述部分</h1><p>人工智能的三大主义：行为主义、联结主义、符号主义</p><p><a href="https://imgse.com/i/pSpBeD1"><img src="https://s1.ax1x.com/2022/12/30/pSpBeD1.md.png" alt="pSpBeD1.md.png"></a></p><p>图灵测试是做什么的？给几个论断，哪些是哪些不是？</p><p>图灵测试：一个人（C）在完全不接触对方（A和B）的情况下，和对方进行一系列的问答，如果在相当长时间内，他无法根据这些问题判断对方是人（B）还是计算机（A），那么，就认为该计算机具有同人相当的智能（即计算机是能思维的）。</p><p><a href="https://imgse.com/i/pSpBZuR"><img src="https://s1.ax1x.com/2022/12/30/pSpBZuR.md.png" alt="pSpBZuR.md.png"></a></p><h1>搜索和优化部分</h1><h2 id="选择题">选择题</h2><p>g(x)为从根节点到x节点的代价总和</p><p>h(x)为从x节点到目标节点的估计代价总和</p><p>代价一致搜索 f(x) = g(x)</p><ul><li>完备性：肯定能找到最优解</li><li>最优性：找到的解花费最小</li><li>比A*慢一些</li><li>广度优先搜索是代价一致搜索的特例</li></ul><p>贪婪搜索 f(x) = h(x)</p><ul><li>不完备</li><li>不保证能找到最优解</li><li>深度优先搜索是贪婪搜索的特例</li></ul><p>A*搜索 f(x) = g(x) + h(x)</p><ul><li>启发函数<img src="https://math.now.sh?inline=h" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<strong>可采纳的</strong>，那么<img src="https://math.now.sh?inline=0%E2%89%A4h%28n%29%E2%89%A4h%5E*(n)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=h%5E*%28n%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是到最近目标的真实耗散。</li><li>启发函数<img src="https://math.now.sh?inline=h" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<strong>可采纳的</strong>，那么A* 树搜索是最优的</li><li>A*图搜索与树搜索的区别在于图搜索不允许访问相同结点</li><li>一致的：启发函数不仅仅要是可采纳的，沿路径的节点估计耗散值单调递增。<img src="https://math.now.sh?inline=h%28A%29%20%E2%80%93%20h(C)%20%E2%89%A4%20cost(A%20to%20C)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>图搜索中，如果启发函数是一致的，A* 搜索是最优的。</li></ul><p><a href="https://imgse.com/i/pSpsd56"><img src="https://s1.ax1x.com/2022/12/30/pSpsd56.md.png" alt="pSpsd56.md.png"></a></p><h3 id="遗传算法">遗传算法</h3><p><a href="https://imgse.com/i/pSpy9sJ"><img src="https://s1.ax1x.com/2022/12/30/pSpy9sJ.md.png" alt="pSpy9sJ.md.png"></a></p><h2 id="简答题">简答题</h2><p>蚁群优化算法和粒子群优化算法是群体智能优化算法的两个代表，请从蚁群优化算法和粒子群优化算法中任选一个阐述其基本原理、算法过程及适用范围。</p><h3 id="粒子群优化算法">粒子群优化算法</h3><p>基本原理：</p><p>粒子群优化算法中的每个粒子模拟一只鸟，代表待求解问题搜索解空间中的一个潜在解，“飞行信息”包括粒子当前的位置和速度两个状态量。每个粒子都可以获得其邻域内其它个体的信息，对所经过的位置进行评价，并根据这些信息和位置速度更新规则，改变自身的两个状态量，随着这一过程的不断进行，粒子群最终能够找到问题的近似最优解。</p><p>算法过程：</p><ul><li>初始化<ul><li>初始化粒子群：每个粒子的位置和速度，即<img src="https://math.now.sh?inline=%F0%9D%91%A5_0%5E%7B%28%F0%9D%91%96%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%F0%9D%91%A3_0%5E%7B%28%F0%9D%91%96%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=%F0%9D%91%9D_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D%5E%7B%28%F0%9D%91%96%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=g_%7Bbest%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul></li><li>循环执行如下三步直至满足结束条件<ul><li>计算每个粒子的适应度：<img src="https://math.now.sh?inline=%F0%9D%91%93%28%F0%9D%91%A5_%F0%9D%91%9B%5E%7B(%F0%9D%91%96%29%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>更新每个粒子历史最好适应度及其相应的位置，更新当前全局最好适应度及其相应的位置</li><li>更新每个粒子的速度和位置<ul><li><img src="https://math.now.sh?inline=%F0%9D%91%A3_%7B%F0%9D%91%9B%2B1%7D%5E%7B%28%F0%9D%91%96%29%7D%3D%F0%9D%91%A3_%F0%9D%91%9B%5E%7B(%F0%9D%91%96)%7D%2B%F0%9D%91%90_1%E2%88%97%F0%9D%91%9F_1%E2%88%97(%F0%9D%91%9D_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D%5E%7B%F0%9D%91%96%7D%E2%88%92%F0%9D%91%A5_%F0%9D%91%9B%5E%F0%9D%91%96)%2B%F0%9D%91%90_2%E2%88%97%F0%9D%91%9F_2%E2%88%97(%F0%9D%91%94_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D%E2%88%92%F0%9D%91%A5_%F0%9D%91%9B%5E%7B(%F0%9D%91%96)%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=%F0%9D%91%A5_%7B%F0%9D%91%9B%2B1%7D%5E%7B%28%F0%9D%91%96%29%7D%3D%F0%9D%91%A5_%F0%9D%91%9B%5E%7B(%F0%9D%91%96)%7D%2B%F0%9D%91%A3_%7B%F0%9D%91%9B%2B1%7D%5E%7B(i)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul></li></ul></li></ul><p>适用范围：适用于求解连续解空间的优化问题</p><h3 id="蚁群优化算法">蚁群优化算法</h3><p>基本原理：</p><p>蚁群算法是一种用来寻找优化路径的概率型算法。用蚂蚁的行走路径表示待优化问题的可行解，整个蚂蚁群体的所有路径构成待优化问题的解空间。路径较短的蚂蚁释放的信息素量较多，随着时间的推进，较短的路径上累积的信息素浓度逐渐增高，选择该路径的蚂蚁个数也愈来愈多。最终，整个蚂蚁会在正反馈的作用下集中到最佳的路径上，此时对应的便是待优化问题的最优解。</p><p>算法过程：</p><ul><li>首先将<img src="https://math.now.sh?inline=%F0%9D%91%9A" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>只蚂蚁随机放置在<img src="https://math.now.sh?inline=%F0%9D%91%9B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个城市，位于城市<img src="https://math.now.sh?inline=%F0%9D%91%96" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的第<img src="https://math.now.sh?inline=%F0%9D%91%98" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>只蚂蚁选择下一个城市<img src="https://math.now.sh?inline=%F0%9D%91%97" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的概率为：</li></ul><p><img src="https://math.now.sh?inline=p_%7Bi%20j%7D%5Ek%28t%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D%5Cfrac%7B%5Cleft(%5Ctau_%7Bi%20j%7D(t)%5Cright)%5E%5Calpha%5Cleft(%5Ceta_%7Bi%20j%7D(t)%5Cright)%5E%5Cbeta%7D%7B%5Csum_%7Bk%20%5Cin%20%5Ctext%20%7B%20allowed%20%7D%7D%5Cleft(%5Ctau_%7Bi%20k%7D(t)%5Cright)%5E%5Calpha%5Cleft(%5Ceta_%7Bi%20k%7D(t)%5Cright)%5E%5Cbeta%7D%20%26%20j%20%5Cin%20%5Ctext%20%7B%20allowed%20%7D%20%5C%5C%200%2C%20%26%20%5Ctext%20%7B%20otherwise%20%7D%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中<img src="https://math.now.sh?inline=%5Ctau_%7Bi%20j%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示边<img src="https://math.now.sh?inline=%28i%2Cj%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的信息素浓度，<img src="https://math.now.sh?inline=%5Ceta_%7Bi%2C%20j%7D%28t%29%3D1%20%2F%20d_%7Bi%20j%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是根据距离定义的启发信息，<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5Cbeta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>反映了信息素与启发信息的相对重要性</p><ul><li>当所有蚂蚁完成周游后，按以下公式进行信息素更新：</li></ul><p><img src="https://math.now.sh?inline=%5CDelta%20%5Ctau_%7Bi%20j%7D%5Ek%3Df%28x%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcc%7D%5Cfrac%7BQ%7D%7BL_k%7D%2C%20%26%20(i%2C%20j)%20%5Cin%20w_k%20%5C%5C%200%2C%20%26%20%5Ctext%20%7B%20otherwise%20%7D%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Ctau_%7Bi%20j%7D%28t%2B1%29%3D%5Crho%20%5Ccdot%20%5Ctau_%7Bi%20j%7D(t%2B1)%2B%5CDelta%20%5Ctau_%7Bi%20j%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5CDelta%20%5Ctau_%7Bi%20j%7D%3D%5Csum_%7Bk%3D1%7D%5Em%20%5CDelta%20%5Ctau_%7Bi%20j%7D%5Ek" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中: <img src="https://math.now.sh?inline=Q" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为常数, <img src="https://math.now.sh?inline=w_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 表示第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>只蚂蚁在本轮迭代中走过的路径，<img src="https://math.now.sh?inline=L_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为路径长度，<img src="https://math.now.sh?inline=%5Crho" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为小于1的常数，反映信息素挥发速度</p><p>适用范围：适用于求解离散解空间的优化问题，适用于在图上寻找最优路径</p><h2 id="应用题">应用题</h2><p>A*树搜索的最优性条件</p><ul><li>启发函数<img src="https://math.now.sh?inline=h" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<strong>可采纳的</strong>，那么<img src="https://math.now.sh?inline=0%E2%89%A4h%28n%29%E2%89%A4h%5E*(n)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=h%5E*%28n%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是到最近目标的真实耗散。</li><li>启发函数<img src="https://math.now.sh?inline=h" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<strong>可采纳的</strong>，那么A* 树搜索是最优的</li></ul><p>A*图搜索的最优性条件</p><ul><li>一致的：启发函数不仅仅要是可采纳的，沿路径的节点估计耗散值单调递增。<img src="https://math.now.sh?inline=h%28A%29%20%E2%80%93%20h(C)%20%E2%89%A4%20cost(A%20to%20C)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>图搜索中，如果启发函数是一致的，A* 搜索是最优的。</li></ul><p><a href="https://imgse.com/i/pSPRY7D"><img src="https://s1.ax1x.com/2023/01/02/pSPRY7D.md.jpg" alt="pSPRY7D.md.jpg"></a></p><p>传教士和野人问题通常描述如下：三个传教士和三个野人在河的一边，还有一条能载一个人或者两个人的船，找到一个方法让所有的人都渡到河的另一岸，要求在任何地方野人数都不能多于传教士的人数（可以只有野人没有传教士）。</p><p>(1) 精确地形式化该问题，只描述确保该问题有解所必须的特性，画出该问题的完全状态图</p><p><a href="https://imgse.com/i/pSPRNAe"><img src="https://s1.ax1x.com/2023/01/02/pSPRNAe.md.jpg" alt="pSPRNAe.md.jpg"></a></p><p>(2) 用一个合适的算法实现和最优地求解该问题，检查重复状态是个好主意吗?</p><p>采用先深搜索、先广搜索以及图搜索都可以，注意检查重复状态，重复状态的检测避免程序陷入死循环。</p><p>(3) 这个问题的状态空间如此简单，你认为为什么人们求解他却很困难?</p><p>虽然状态空间比较简单，但是要检测重复状态是一个困难：另外，在当前状态选取下一个合法状态，要能够不漏举所有合法状态也存在困难，当在某个状态无下一个合法状态时，需要回溯，这些都使得人为求解它变得困难</p><h1>逻辑部分</h1><h2 id="选择题-2">选择题</h2><p><a href="https://imgse.com/i/pSpsjiV"><img src="https://s1.ax1x.com/2022/12/30/pSpsjiV.md.png" alt="pSpsjiV.md.png"></a><a href="https://imgse.com/i/pSpyldI"><img src="https://s1.ax1x.com/2022/12/30/pSpyldI.md.png" alt="pSpyldI.md.png"></a><a href="https://imgse.com/i/pSpyGJf"><img src="https://s1.ax1x.com/2022/12/30/pSpyGJf.md.png" alt="pSpyGJf.md.png"></a></p><h2 id="简答题-2">简答题</h2><h3 id="命题逻辑">命题逻辑</h3><p>已知知识库里包含如下的句子：</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=A%5CLeftrightarrow%28B%20%5Clor%20E%29%2CE%20%5CRightarrow%20D%2CC%20%5Cland%20F%20%5CRightarrow%20%5Cneg%20B%2C%20E%5CRightarrow%20B%2C%20B%5CRightarrow%20F%2CB%5CRightarrow%20C%0A" /></p><p>请用归结原理证明该知识库蕴含如下的句子：$\neg A \land \neg B $</p><p>Forward chain 证明7&lt;3+9</p><p><a href="https://imgse.com/i/pSPdsmR"><img src="https://s1.ax1x.com/2023/01/02/pSPdsmR.md.jpg" alt="pSPdsmR.md.jpg"></a></p><p>kb中所有句子都为definite子句，请构造一种真值指派使得kb中所有子句为真</p><p>将所有的原子命题指派为True即可。</p><ol><li>由于是definite子句，不可能包含负文字，只能包含正文字，因此单独的文字一定为正文字，也就一定为True</li><li>由于是definite子句，每一个非文字的子句中一定有一个文字是正文字，且子句内部一定使用析取符号连接，因此正文字一定为True，子句也一定为True</li><li>综上，所有子句都为True</li></ol><p><a href="https://imgse.com/i/pSPdafU"><img src="https://s1.ax1x.com/2023/01/02/pSPdafU.md.jpg" alt="pSPdafU.md.jpg"></a></p><p>归结原理及证明：</p><p><a href="https://imgse.com/i/pSPdwpF"><img src="https://s1.ax1x.com/2023/01/02/pSPdwpF.md.jpg" alt="pSPdwpF.md.jpg"></a><a href="https://imgse.com/i/pSPdB6J"><img src="https://s1.ax1x.com/2023/01/02/pSPdB6J.md.jpg" alt="pSPdB6J.md.jpg"></a></p><p>设计一个可靠但不完备的规则</p><ul><li>知识库中是全部有理数的集合</li><li>算法：<img src="https://math.now.sh?inline=%5Calpha_i%3Di" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，为全部自然数的集合</li><li>因此算法是可靠的，但是并不完备，因为算法无法计算出任何的小数</li></ul><p>描述语义蕴含、<img src="https://math.now.sh?inline=%5CRightarrow" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的作用</p><ul><li>语义蕴含指的是有了知识表示后，额外推出其他的知识</li><li><img src="https://math.now.sh?inline=%5CRightarrow" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是命题逻辑里面的连接词，用于知识表示（实际上是可以替代的，但是引入这个符号进行知识表示比较方便）</li></ul><p>设计A*启发式函数来使归结次数最少</p><p>构想一个A启发式函数，使得A归结结果为最优，并证明</p><p>h(n)为集合中的最短子句的长度</p><h3 id="一阶谓词逻辑">一阶谓词逻辑</h3><p>胜者为王，败者为寇</p><p>不到长城非好汉，到了长城就是好汉；两个句子是否语义等价，并证明</p><p>成绩好的人都很刻苦，刻苦的人，一定成绩好；两个句子是否语义等价，并证明</p><p>理发师只给不给自己理发的人理发</p><p><a href="https://imgse.com/i/pSPd0l4"><img src="https://s1.ax1x.com/2023/01/02/pSPd0l4.md.jpg" alt="pSPd0l4.md.jpg"></a></p><p>将如下的一阶谓词逻辑的句子转化为合取范式：（不需要包含存在量词）</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=%5Cforall%20x%5B%5Cforall%20y%5C%2CAnimal%28y%29%5CRightarrow%5C%2CLoves(x%2Cy)%5D%5CRightarrow%20%5B%5Cexists%20y%5C%2CLoves(y%2Cx)%5D%0A" /></p><p>构造一个一阶谓词逻辑的知识库<img src="https://math.now.sh?inline=KB" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和句子<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，使得<img src="https://math.now.sh?inline=KB%5Cvdash%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的归结过程永远不会停止。</p><p><a href="https://imgse.com/i/pSPdUYT"><img src="https://s1.ax1x.com/2023/01/02/pSPdUYT.md.jpg" alt="pSPdUYT.md.jpg"></a></p><h3 id="模糊逻辑">模糊逻辑</h3><p>（刻画模糊量词、模糊修饰词等）</p><p>很少有成绩好的学生特别贪玩</p><ul><li>模糊谓词：贪玩、成绩好</li><li>模糊修饰词：很、特别</li><li>模糊量词：很少</li></ul><p>很少有成绩好的学生特别喜欢玩游戏</p><ul><li>模糊谓词：贪玩、喜欢玩游戏</li><li>模糊修饰词：很、特别</li><li>模糊量词：很少</li></ul><h3 id="Prolog">Prolog</h3><p>普通编程的步骤：了解问题-收集条件-寻找解决方法-编程解决-将问题数据化-用程序运行数据-debug</p><p>逻辑编程的步骤：了解问题-收集条件-不寻找解决方法-将条件写进KB-将问题转换为fact-问query-寻找错误的事实</p><p>C :- A,B 如果AB，则implyC（definite 子句）</p><p>[E | L]：将list拆解成第一个是E，后面的剩下</p><p>trace 和 notrace是debug的过程</p><p>DFS+backward chaining</p><p>不教程序怎么算，只列出事实</p><p>Prolog缺点：</p><ul><li>不做occur check，因此有些事实是错的但是也可能推导出来，也就是不sound</li><li>DFS可能造成无穷递归，对的也导不出来，不complete。与语句编写的顺序也有关系</li></ul><h1>深度学习部分</h1><h2 id="选择题-3">选择题</h2><p><a href="https://imgse.com/i/pSpsvGT"><img src="https://s1.ax1x.com/2022/12/30/pSpsvGT.md.png" alt="pSpsvGT.md.png"></a><a href="https://imgse.com/i/pSpsxRU"><img src="https://s1.ax1x.com/2022/12/30/pSpsxRU.png" alt="pSpsxRU.png"></a><a href="https://imgse.com/i/pSpyEi6"><img src="https://s1.ax1x.com/2022/12/30/pSpyEi6.md.png" alt="pSpyEi6.md.png"></a></p><h3 id="GNN">GNN</h3><p>谱方法：在谱空间中定义卷积：</p><ul><li>通过图傅里叶变换和卷积原理定义卷积<ul><li>图数据符合幂律分布，造成了极大的挑战</li></ul></li><li>主要挑战是在谱空间定义的卷积在结点空间并没有局部化</li></ul><p>空间方法：在向量空间中定义卷积</p><ul><li>卷积被定义为目标结点到它的所有邻居的一个加权平均函数</li><li>主要挑战是邻域的大小在结点之间差异很大，可能服从幂律分布</li></ul><p>谱方法是空间方法的特例</p><ul><li>谱方法通过特别的空间变换定义核函数</li><li>空间方法直接定义核函数</li></ul><p>聚合，更新是什么？</p><p>图神经网络的框架：聚合邻居节点的信息从而更新中心节点的表示</p><p>GraphSAGE：从每个结点开始随机游走，采样<img src="https://math.now.sh?inline=K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个结点，不用临近度指标判断。然后通过聚合函数进行参数共享</p><p>图卷积网络（GCN）：通过归一化的拉普拉斯矩阵从不固定数量的邻居结点中聚合信息，通过特征变换共享参数</p><h2 id="应用题-2">应用题</h2><p>证明感知机不能表示异或逻辑</p><p>异或的逻辑为：</p><table><thead><tr><th style="text-align:center"><img src="https://math.now.sh?inline=x_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th><th style="text-align:center"><img src="https://math.now.sh?inline=x_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th><th style="text-align:center"><img src="https://math.now.sh?inline=x_1%20%5Coplus%20x_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table><p>两个变量的感知机模型为<img src="https://math.now.sh?inline=f%28x%29%3Dsign(w_1x_1%2Bw_2x_2%2Bb)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>代入上面的异或逻辑：</p><ol><li><img src="https://math.now.sh?inline=w_1%5Ccdot%200%2Bw_2%20%5Ccdot%200%20%2Bb%20%3C%200" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=b%3C0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=w_1%5Ccdot%201%2Bw_2%20%5Ccdot%200%20%2Bb%20%3E%200" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=w_1%3E-b%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=w_1%5Ccdot%200%2Bw_2%20%5Ccdot%201%20%2Bb%20%3E%200" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=w_2%3E-b%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=w_1%5Ccdot%201%2Bw_2%20%5Ccdot%201%20%2Bb%20%3C%200" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，根据上面三个式子是明显不可满足的</li></ol><p>因此感知机不能表示异或逻辑</p><p>设计用于异或问题的二层感知机</p><p><a href="https://imgse.com/i/z4tj3V"><img src="https://s1.ax1x.com/2022/12/12/z4tj3V.md.jpg" alt="z4tj3V.md.jpg"></a></p><p>（以下简答题目答案来源于<a href="https://github.com/Ming-er">shmily</a>）</p><p>描述BP算法</p><p>BP算法由正向传播与反向传播两个过程组成。正向传播时，输入由输入层经过隐藏层到输出层；反向传播时，输出结果与真实结果通过损失函数计算误差，误差信号再沿相反方向传播至输入层，获得各层各单元的误差信号（梯度），并将其作为修正权值的依据。通过梯度下降算法更新权值，使得网络的整体误差迭代减小。</p><p>试论述在深度神经网络中BP算法遇到的困难，并说明为什么会出现“梯度消失”问题</p><p>当网络变深时，BP算法会遇到梯度消失或者梯度爆炸的现象，此时浅层的神经元几乎接受不到来自输出层的误差信号或者误差太大，无法更新其参数或参数剧烈波动。</p><p>根据链式求导法则，浅层参数的梯度来源于深层参数梯度的乘积。由于中间梯度矩阵的范数可能远小于1，再加上许多激活函数的导数小于1，随着传播层数的增多，误差信号反向传播的过程中以指数形式衰减，当传播到浅层时便出现了梯度消失现象。</p><p>简述对抗式生成网络（GAN）的基本原理及其学习算法</p><p>GAN的思想来源于博弈论当中的均衡理论，其由生成器G与判别器D构成。生成器G希望生成更接近于真实分布的数据，判别器则希望尽可能分辨所给数据是由生成器生成的还是从真实分布中采样的。</p><p>GAN的学习算法交替地更新判别器D与生成器G：</p><p>首先训练判别器D，</p><ol><li>从真实分布采样数据<img src="https://math.now.sh?inline=x_1%2C%20x_2%2C%20%5Ccdots%2C%20x_N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</li><li>从高斯分布采样数据<img src="https://math.now.sh?inline=z_1%2C%20z_2%2C%20%5Ccdots%2C%20z_N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，送入生成器G生成数据<img src="https://math.now.sh?inline=%5Chat%7Bx_1%7D%EF%BC%8C%5Chat%7Bx_2%7D%EF%BC%8C%5Ccdots%2C%20%5Chat%7Bx_N%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</li><li>最小化损失函数<img src="https://math.now.sh?inline=V%20%28G%2C%20D%29%20%3D%20-%5Csum_%7Bi%3D1%7D%5E%7BN%7D%5Clog%20D(x_i)%20-%5Csum_%7Bi%3D1%7D%5E%7BN%7D%5Clog%20D(1%20-%20%5Chat%7Bx_i%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</li></ol><p>接着训练生成器G，</p><ol><li>从高斯分布采样数据<img src="https://math.now.sh?inline=z_1%2C%20z_2%2C%20%5Ccdots%2C%20z_N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，送入生成器G生成数据<img src="https://math.now.sh?inline=%5Chat%7Bx_1%7D%2C%20%5Chat%7Bx_2%7D%2C%20%5Ccdots%2C%20%5Chat%7Bx_N%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</li><li>最小化损失函数<img src="https://math.now.sh?inline=V%20%28G%2C%20D%29%20%3D%20-%5Csum_%7Bi%3D1%7D%5E%7BN%7D%5Clog%20D(%5Chat%7Bx_i%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</li></ol><p>重复进行以上各步骤直至收敛。</p><p>描述ResNet（ResNet的原理和结构图）</p><p>ResNet由如下多个Residual Block堆叠构成</p><p><a href="https://imgse.com/i/pSPRJ0O"><img src="https://s1.ax1x.com/2023/01/02/pSPRJ0O.png" alt="pSPRJ0O.png"></a></p><p>残差网络容易优化恒等式函数，学习优化残差映射比原始映射更加容易，随着网络加深，网络至少不会变得更差，有效地缓解了梯度消失等现象；此外，残差连接隐式地扩展了模型的特征空间，可以看作一种模型集成。</p><p>利用RNN构建一个翻译器</p><p>采用编码器-解码器结构，二者都是RNN网络，示意图如下：</p><p><a href="https://imgse.com/i/pSPRGnK"><img src="https://s1.ax1x.com/2023/01/02/pSPRGnK.png" alt="pSPRGnK.png"></a></p><p>其中，编码器RNN接受输入(原文token) <img src="https://math.now.sh?inline=x_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，并通过RNN结构编码隐藏状态<img src="https://math.now.sh?inline=h_t%20%3D%20%28W_%7Bhh%7Dh_%7Bt%20-%201%7D%20%2B%20W_%7Bxh%7Dx_t%20%2B%20b%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。编码器编码完成后所有隐藏状态聚合为背景向量<img src="https://math.now.sh?inline=c%20%3D%20Mean%20%28h_1%2C%20h_2%2C%20%5Ccdots%2C%20h_T%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>解码器的RNN同样编码隐藏状态<img src="https://math.now.sh?inline=s_t%20%3D%20%28W_%7Bss%7Ds_%7Bt%20-%201%7D%20%2B%20W_%7Bys%7D%5Ctext%7BCAT%7D(y_t%2C%20c%29)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，并将编码的隐藏状态<img src="https://math.now.sh?inline=s_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>映射到预测结果<img src="https://math.now.sh?inline=%5Chat%7By_t%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，计算<img src="https://math.now.sh?inline=y_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=%5Chat%7By_t%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>间的损失来完成模型的训练</p><p>预测时，通过自回归与束搜索的方式得到翻译序列。</p><h1>强化学习部分</h1><h2 id="选择题-4">选择题</h2><h3 id="强化学习基础">强化学习基础</h3><p>多臂赌博机：</p><p>一台赌博机有多个摇臂，每个摇臂摇出的奖励大小不确定，玩家希望<strong>摇固定次数的臂所获得的期望累积奖励最大</strong></p><p>优化目标：期望累计奖励最大化</p><p>探索和利用的关系：</p><ul><li>利用：按照贪心策略进行选择，最大化即时奖励</li><li>探索：选择贪心策略之外的行为，短期奖励会比较低，长期奖励会比较高</li></ul><p>策略：</p><ul><li>贪心策略</li><li><img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>贪心策略<ul><li>以概率<img src="https://math.now.sh?inline=1%E2%88%92%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>按照贪心策略进行行为选择（利用）</li><li>以概率<img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在所有行为中随机选择一个（探索）</li></ul></li><li>乐观初值法：未发生之前，保持乐观的心态。每次摇完臂都会失望，所以下次会换个臂摇，鼓励探索</li><li>UCB行为选择策略：对Qt(a)做估计，但因为估不准（估不准与之前尝试的次数有关，尝试次数越多估的越准），所以对它做一个上界</li></ul><p><a href="https://imgse.com/i/pSpWfmD"><img src="https://s1.ax1x.com/2022/12/30/pSpWfmD.md.png" alt="pSpWfmD.md.png"></a></p><p>马尔可夫状态过程的要素：</p><ul><li>智能体（Agent）和环境（Environment）按照离散的时间步进行交互</li><li>智能体的状态S、智能体采取的行为A、获得的奖励R</li></ul><p><a href="https://imgse.com/i/pSpfnhR"><img src="https://s1.ax1x.com/2022/12/30/pSpfnhR.md.png" alt="pSpfnhR.md.png"></a></p><p>奖励假设：最终目标是通过最大化累积的Reward实现的</p><p>策略学习方法：</p><ul><li>动态规划<ul><li>策略迭代：从初始策略开始，迭代进行策略估值和策略提升，最终得到最优策略<ul><li>策略估值：解给定的策略下的值函数，也就是预测当前策略下所能拿到的值函数问题。</li><li>策略提升：根据当前策略的估值函数，寻找更优的策略（如果存在）</li></ul></li><li>估值迭代：值迭代算法是策略评估过程只进行一次迭代的策略迭代算法，从初始状态估值开始，进行估值迭代，找到最优状态估值，按照贪心方式得到最优策略</li><li>从运算量角度看，值迭代方法中策略评估只需要一次迭代，需要的运算量更小，应该比策略迭代更快收敛。但是，通常在策略提升中间插入需要多次迭代的策略评估的算法，收敛的更快！这可能与值迭代算法的终止条件有关。值迭代算法的终止条件对象为值函数，策略迭代算法的终止条件对象为策略，结合之前gridworld中观察的现象（策略可能比值函数收敛的更快），所以策略迭代可能比值迭代更快收敛。</li></ul></li><li>蒙特卡洛：（通过采样的方式，最后用样本的平均值作估值，是一种从经验中获得的方法）<ul><li>从真实或者模拟的经验中计算状态（行动估值函数）不需要关于环境的完整模型</li><li>直接根据真实经验或模拟经验计算状态估值函数</li><li>不同状态的估值在计算时是独立的，不依赖于“自举”方法</li></ul></li><li>时序差分：非平稳情形下的蒙特卡洛方法（恒定步长）</li><li>参数近似</li></ul><p><a href="https://imgse.com/i/pSpyJW8"><img src="https://s1.ax1x.com/2022/12/30/pSpyJW8.md.png" alt="pSpyJW8.md.png"></a></p><h3 id="博弈部分">博弈部分</h3><p>博弈的要素</p><ul><li>局中人：在博弈中有权决定自己行动方案的博弈参加者</li><li>重要假设：局中人是自私的理性人</li><li>策略：博弈中可供局中人选择的行动方案</li><li>效用函数：对每个参与博弈的局中人，都有一个相应的效用函数，每个局中人的目的都是最大化自己的效用</li></ul><p>剪刀石头布：所有玩家的收益之和为0-零和博弈</p><p>最佳应对：针对局中人2的策略t，若局中人1用策略s产生的收益大于或等于其任何其他策略，则称策略s是局中人1对局中人2的策略t的最佳应对</p><p>纳什均衡：如果一个局势下，每个局中人的策略都是相对其他局中人当前策略的最佳应对，则称该局势是一个纳什均衡</p><p>帕累托最优：对于一组策略选择（局势）若不存在其他策略选择使所有参与者得到至少和目前一样高的回报，且至少一个参与者会得到严格较高的回报，则这组策略选择为帕累托最优。（“不可能再改善某些人的境况，而不使任何其他人受损。”）</p><p>社会最优：使参与者的回报之和最大的策略选择，社会最优的结果一定也是帕累托最优的结果</p><p><a href="https://imgse.com/i/pSpytSS"><img src="https://s1.ax1x.com/2022/12/30/pSpytSS.md.png" alt="pSpytSS.md.png"></a></p><p>应用案例：</p><ul><li>首价密封报价拍卖<ul><li>纳什均衡：每个竞拍者的报价低于其对商品的估价</li><li>最优报价低于估价，竞拍者越多，报价越接近于估价</li></ul></li><li>次价密封报价拍卖<ul><li>纳什均衡：每个竞拍者会倾向于采用其对商品的估价进行报价</li></ul></li></ul><p>讨价的对象是双方对商品估价之差</p><p><a href="https://imgse.com/i/pSpyFd1"><img src="https://s1.ax1x.com/2022/12/30/pSpyFd1.md.png" alt="pSpyFd1.md.png"></a></p><p>maxmin策略：最大化自己最坏情况时的效用</p><ul><li>最小化损失，控制风险</li><li>预防其它局中人的不理性给自己带来损失</li></ul><p>minmax策略：最小化对手的最大效用</p><p>零和博弈情况下：</p><ul><li>minmax和maxmin是对偶的</li><li>minmax策略和maxmin策略等价于纳什均衡策略</li></ul><p><a href="https://imgse.com/i/pSpyNQg"><img src="https://s1.ax1x.com/2022/12/30/pSpyNQg.md.png" alt="pSpyNQg.md.png"></a></p><p>匹配市场：</p><ul><li>完全匹配：对于两类节点集合大小一样的二部图，选择数目和节点个数一样的边，使得每类节点中的任意一个节点在另一类节点中都有唯一的对应者</li><li>最优匹配：效用最大的匹配，最优匹配对于个体而言不一定最优，甚至是最差的</li></ul><p>市场结清价格：给定买方报价的情况下，如果卖方的某种价格使得对应的买方偏好图中存在完全匹配，则称卖方的这组价格为市场结清价格。市场结清价格总是存在，且使得买卖双方总效用最优。</p><p><a href="https://imgse.com/i/pSpyaLj"><img src="https://s1.ax1x.com/2022/12/30/pSpyaLj.md.png" alt="pSpyaLj.md.png"></a></p><p>议价权：</p><p>不稳定边：对于结局中未参与配对的边，如果边的两个端点获得的收益之和小于1，则称这条边为不稳定边，不稳定边的存在意味着其两个端点可以通过改变报价而改变结局</p><p>稳定结局：如果一个结局中不存在不稳定边，则称该结局为稳定结局</p><p>纳什议价解：</p><ul><li>A的备选项收益为<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>B的备选项收益为<img src="https://math.now.sh?inline=y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>分配剩余价值<img src="https://math.now.sh?inline=s%3D1-x-y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>纳什议价解：一人一半就好<ul><li>A的收益是<img src="https://math.now.sh?inline=x%2B%5Cfrac%7Bs%7D%7B2%7D%3D%5Cfrac%7B1%2Bx-y%7D%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>B的收益是<img src="https://math.now.sh?inline=y%2B%5Cfrac%7Bs%7D%7B2%7D%3D%5Cfrac%7B1%2By-x%7D%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul></li></ul><p>均衡结局：给定一个结局，如果结局中的任意一个参与配对的边都满足纳什议价解的条件，则称该结局是均衡结局</p><p>均衡结局一定是稳定结局</p><p><a href="https://imgse.com/i/pSpykIx"><img src="https://s1.ax1x.com/2022/12/30/pSpykIx.md.png" alt="pSpykIx.md.png"></a></p><h3 id="因果学习">因果学习</h3><p>画一个图，什么什么路径，上课那种，阻断、D分离</p><p><a href="https://imgse.com/i/pSp5cUe"><img src="https://s1.ax1x.com/2022/12/30/pSp5cUe.md.png" alt="pSp5cUe.md.png"></a></p><p>后门准则：Z满足关于(X,Y)的后门准则</p><ul><li>Z阻断了X与Y之间的每条含有指向X的路径（后门路径）</li><li>Z中没有X的后代节点</li></ul><p><a href="https://imgse.com/i/pSp5g4H"><img src="https://s1.ax1x.com/2022/12/30/pSp5g4H.md.png" alt="pSp5g4H.md.png"></a></p><h2 id="应用题：格子游戏">应用题：格子游戏</h2><p><a href="https://imgse.com/i/zf5LVA"><img src="https://s1.ax1x.com/2022/12/11/zf5LVA.md.png" alt="zf5LVA.md.png"></a></p><p><a href="https://imgse.com/i/zf71aj"><img src="https://s1.ax1x.com/2022/12/11/zf71aj.md.jpg" alt="zf71aj.md.jpg"></a></p><p><a href="https://imgse.com/i/zf7lZQ"><img src="https://s1.ax1x.com/2022/12/11/zf7lZQ.md.jpg" alt="zf7lZQ.md.jpg"></a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：模式识别与机器学习-期末复习</title>
    <link href="/2022/12/11/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-final/"/>
    <url>/2022/12/11/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-final/</url>
    
    <content type="html"><![CDATA[<p>《模式识别与机器学习》期末复习</p><span id="more"></span><h1>第1章 引言</h1><p>模式识别：利用计算机对物理对象进行分类，在错误概率最小的条件下，使识别的结果尽量与客观物体相符合</p><p>在特征空间和解释空间之间找到一种映射关系：<img src="https://math.now.sh?inline=y%3Df%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>机器学习：利用大量的训练数据，获得产生数据的模式或预测</p><h1>第2章 统计判别</h1><h2 id="贝叶斯">贝叶斯</h2><p><a href="https://imgse.com/i/pSirOKS"><img src="https://s1.ax1x.com/2023/01/03/pSirOKS.md.png" alt="pSirOKS.md.png"></a></p><h3 id="作为统计判别问题的模式分类">作为统计判别问题的模式分类</h3><p><a href="https://imgse.com/i/zIkB5j"><img src="https://s1.ax1x.com/2022/12/14/zIkB5j.md.jpg" alt="zIkB5j.md.jpg"></a><img src="https://s1.ax1x.com/2022/12/14/zIk0aQ.md.jpg" alt="zIk0aQ.md.jpg"><a href="https://imgse.com/i/zIkUr8"><img src="https://s1.ax1x.com/2022/12/14/zIkUr8.md.jpg" alt="zIkUr8.md.jpg"></a></p><h3 id="正态分布模式的贝叶斯分类器">正态分布模式的贝叶斯分类器</h3><p><a href="https://imgse.com/i/zbf478"><img src="https://s1.ax1x.com/2022/12/18/zbf478.md.jpg" alt="zbf478.md.jpg"></a><a href="https://imgse.com/i/zbfh0f"><img src="https://s1.ax1x.com/2022/12/18/zbfh0f.md.jpg" alt="zbfh0f.md.jpg"></a></p><h1>第3章 判别函数</h1><h2 id="线性判别函数">线性判别函数</h2><p>什么是线性判别函数？</p><p>统计模式识别中用以对模式进行分类的一种最简单的判别函数称为线性判别函数。线性判别函数的一般形式是<img src="https://math.now.sh?inline=y%3Dwx" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是特征向量的增广形式，<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是权重系数。根据<img src="https://math.now.sh?inline=y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的取值进行分类，这个函数在几何上一般表现为直线（高维空间的超平面），所以称之为线性判别函数。</p><p>为什么需要非线性判别函数？</p><p>对于复杂的实际应用，线性分类器往往无法满足要求，不同类别的样本之间并不总是线性可分的，比如著名的异或问题，这就需要寻找能够实现非线性分类的判别函数分类器。</p><p>多类情况：</p><ul><li>多类情况1：用M个判别函数将属于这一类的和不属于这一类的分开，也就是分类成功只能有一个大于0的</li><li>多类情况2：用M*(M-1)/2个判别函数，两两进行分类，只有这一类关于其他所有类的判别函数都大于0时才算分类成功</li><li>多类情况3：M个判别函数，没有不确定区域的多类情况2，判别函数比较大小即可</li></ul><p>权重分量数量计算：<img src="https://math.now.sh?inline=C_%7Bn%2Br%7D%5Er" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的维度，<img src="https://math.now.sh?inline=r" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为多项式次数。</p><h2 id="Fisher线性判别">Fisher线性判别</h2><p><a href="https://imgse.com/i/pSPdNkV"><img src="https://s1.ax1x.com/2023/01/02/pSPdNkV.md.jpg" alt="pSPdNkV.md.jpg"></a></p><h2 id="感知器">感知器</h2><p><a href="https://imgse.com/i/z5CLon"><img src="https://s1.ax1x.com/2022/12/13/z5CLon.md.jpg" alt="z5CLon.md.jpg"></a><a href="https://imgse.com/i/zIkaqS"><img src="https://s1.ax1x.com/2022/12/14/zIkaqS.md.jpg" alt="zIkaqS.md.jpg"></a></p><p>多类情况增广向量不需要变为负数，要求这个类别的比其他的类别都要大，否则这个类别+样本，其他的类别-样本</p><p>H-K算法可以发现类别不可分的情况</p><h1>第4章 特征选择和提取</h1><h2 id="K-L变换">K-L变换</h2><p><a href="https://imgse.com/i/zIkwVg"><img src="https://s1.ax1x.com/2022/12/14/zIkwVg.md.jpg" alt="zIkwVg.md.jpg"></a></p><h1>第5章 统计机器学习基础</h1><p>期望风险：机器学习算法的目标就是降低式所示的期望泛化误差（这个数据量被称为风险），选择期望风险最小的模型。</p><p>经验风险：用训练集的分布代替真实情况下的数据分布，最小化训练集上的期望损失</p><p>结构风险：在经验风险最小化的基础上再引入参数的正则化来限制模型能力，使其不要过度地最小化经验风险</p><h2 id="偏差方差和噪声">偏差方差和噪声</h2><p>简述偏差方差分解及其推导过程，并说明偏差、方差和噪声三部分的内在含义</p><p><a href="https://imgse.com/i/pSpCJmD"><img src="https://s1.ax1x.com/2022/12/29/pSpCJmD.md.png" alt="pSpCJmD.md.png"></a><img src="https://s1.ax1x.com/2022/12/19/zqsmin.md.jpg" alt="zqsmin.md.jpg"></p><h2 id="过拟合和欠拟合">过拟合和欠拟合</h2><p><a href="https://imgse.com/i/pSi6VhR"><img src="https://s1.ax1x.com/2023/01/03/pSi6VhR.md.png" alt="pSi6VhR.md.png"></a><a href="https://imgse.com/i/pSi6QBD"><img src="https://s1.ax1x.com/2023/01/03/pSi6QBD.md.png" alt="pSi6QBD.md.png"></a></p><p>过拟合：当学习器把训练样本学的“太好”了的时候，很可能已经把训练样本自身的一些特点当作了所有潜在样本都会具有的一般性质，在训练集上效果好。但是在测试集上效果差，这样就会导致模型的泛化性能下降。</p><p>欠拟合：模型尚未学习到数据的真实结构。在训练集和验证集上的性能都很差。</p><p>如何判断一个模型处在过拟合状态还是欠拟合状态？</p><ul><li>欠拟合情况 ：随着训练样本数增大，训练集得分和验证集得分相差不大，并且得分都不高。</li><li>过拟合情况 ：随着训练样本数增大，训练集得分上升的同时和验证集得分下降。</li></ul><p>给出3种减轻模型过拟合的方法：</p><p>过拟合：</p><ul><li>获得更多数据</li><li>降低模型复杂度</li><li>特征选择</li><li>早停</li><li>正则化</li><li>添加噪声</li></ul><p>欠拟合：</p><ul><li>增加特征数</li><li>增加模型复杂度</li><li>减小正则化参数</li></ul><p>假设某研究者在 ImageNet 数据上使用线性支持向量机 Linear SVM 来做文本分类的任务，请说明在如下情况下分别如何操作才能得到更好的结果， 并说明原因。</p><ul><li>训练误差5％，验证误差10％，测试误差10％<ul><li>训练、验证和测试误差都很大，模型处于欠拟合状态，可以选择将正则化参数C值适当调大，增大模型的复杂度</li></ul></li><li>训练误差1％，验证误差10％，测试误差10％<ul><li>训练误差比较小，验证和测试误差比较大，模型处于过拟合状态，可以选择进行数据增强、或者将C值适当调小，增加模型泛化能力</li></ul></li><li>训练误差1％，验证误差3％，测试误差10％<ul><li>训练和验证误差比较小，测试误差比较大，说明训练数据和测试数据的分布差别比较大，可以重新采样或者shuffle数据</li></ul></li></ul><p>如果使用SVM做二分类问题得到如下结果，分别应该采取什么措施以取得更好的结果？并说明原因。</p><ul><li>训练集的分类准确率90%，验证集的分类准确率90%，测试集的分类准确率88%<ul><li>训练、验证和测试准确率都很低，模型处于欠拟合状态，可以选择将正则化参数C值适当调大，增大模型的复杂度</li></ul></li><li>训练集的分类准确率98%，验证集的分类准确率90%，测试集的分类准确率88%<ul><li>训练准确率比较高，验证和测试准确率比较低，模型处于过拟合状态，可以选择进行数据增强、或者将C值适当调小，增加模型泛化能力</li></ul></li></ul><p>如果使用逻辑回归算法做二分类问题得到如下结果，分别应该采取什么措施以取得更好的结果？并说明理由。</p><ul><li>训练集的分类准确率85%，验证集的分类准确率80%，测试集的分类准确率75%<ul><li>训练、验证和测试准确率都很低，模型处于欠拟合状态，可以选择增加训练特征，使用更多的训练参数</li></ul></li><li>训练集的分类准确率99%，验证集的分类准确率80%，测试集的分类准确率78%<ul><li>训练准确率比较高，验证和测试准确率比较低，模型处于过拟合状态，可以选择减少训练特征，添加正则项，增加数据量等等</li></ul></li></ul><h1>第6章 有监督学习方法</h1><p><a href="https://imgse.com/i/pSiybnS"><img src="https://s1.ax1x.com/2023/01/03/pSiybnS.md.png" alt="pSiybnS.md.png"></a><a href="https://imgse.com/i/pSiyXkj"><img src="https://s1.ax1x.com/2023/01/03/pSiyXkj.md.png" alt="pSiyXkj.md.png"></a><a href="https://imgse.com/i/pSiyjts"><img src="https://s1.ax1x.com/2023/01/03/pSiyjts.md.png" alt="pSiyjts.md.png"></a></p><h2 id="公式推导相关">公式推导相关</h2><p>2018-2019</p><p><a href="https://imgse.com/i/pSit5Af"><img src="https://s1.ax1x.com/2023/01/03/pSit5Af.md.png" alt="pSit5Af.md.png"></a><a href="https://imgse.com/i/pSitgcd"><img src="https://s1.ax1x.com/2023/01/03/pSitgcd.md.jpg" alt="pSitgcd.md.jpg"></a><img src="https://s1.ax1x.com/2023/01/01/pSCUIW4.md.png" alt="pSCUIW4.md.png"><a href="https://imgse.com/i/pSiNZE6"><img src="https://s1.ax1x.com/2023/01/03/pSiNZE6.md.png" alt="pSiNZE6.md.png"></a><a href="https://imgse.com/i/pSiNm4O"><img src="https://s1.ax1x.com/2023/01/03/pSiNm4O.md.png" alt="pSiNm4O.md.png"></a><a href="https://imgse.com/i/pSiN1KA"><img src="https://s1.ax1x.com/2023/01/03/pSiN1KA.md.png" alt="pSiN1KA.md.png"></a><a href="https://imgse.com/i/pSiNUPS"><img src="https://s1.ax1x.com/2023/01/03/pSiNUPS.md.png" alt="pSiNUPS.md.png"></a></p><p>2021-2022</p><p><a href="https://imgse.com/i/pSCdBvj"><img src="https://s1.ax1x.com/2023/01/01/pSCdBvj.md.png" alt="pSCdBvj.md.png"></a></p><p><a href="https://imgse.com/i/pSitc1H"><img src="https://s1.ax1x.com/2023/01/03/pSitc1H.md.jpg" alt="pSitc1H.md.jpg"></a></p><h1>第7章 支持向量机</h1><p><a href="https://imgse.com/i/pSi6S10"><img src="https://s1.ax1x.com/2023/01/03/pSi6S10.md.png" alt="pSi6S10.md.png"></a><a href="https://imgse.com/i/pSi6pcV"><img src="https://s1.ax1x.com/2023/01/03/pSi6pcV.md.png" alt="pSi6pcV.md.png"></a><a href="https://imgse.com/i/pSi6Y9I"><img src="https://s1.ax1x.com/2023/01/03/pSi6Y9I.md.png" alt="pSi6Y9I.md.png"></a></p><p>径向基函数（RBF）gamma和C的影响：</p><ul><li>参数gamma定义了单个训练样本的影响大小，值越小影响越大，值越大影响越小。参数gamma可以看作被模型选中作为支持向量的样本的影响半径的倒数。gamma越大半径越窄，因此如果欠拟合需要增大gamma，分的更准</li><li>参数C在误分类样本和分界面之间进行权衡。低的C值使分界面平滑，而高的C值通过增加模型自由度以选择更多支持向量来确保所有样本都被正确分类。因此如果欠拟合要增大C</li></ul><p>最小化VC维h等价于最大化间隔，使分类器的复杂度小！</p><p>简述SVM算法的原理</p><p><a href="https://imgse.com/i/z5CjJ0"><img src="https://s1.ax1x.com/2022/12/13/z5CjJ0.md.jpg" alt="z5CjJ0.md.jpg"></a><a href="https://imgse.com/i/z5CXiq"><img src="https://s1.ax1x.com/2022/12/13/z5CXiq.md.jpg" alt="z5CXiq.md.jpg"></a></p><h1>第8章 聚类</h1><p><a href="https://imgse.com/i/pSi6s4s"><img src="https://s1.ax1x.com/2023/01/03/pSi6s4s.md.png" alt="pSi6s4s.md.png"></a></p><p>K均值：CE</p><p>密度：AF</p><p>高斯混合：BD</p><p>Kmeans：<strong>Kmeans的判别界面应该是簇的中垂线</strong></p><ul><li>一种经典的聚类算法，简单、快速</li><li>假定簇为球形且每个簇的概率相等</li><li>能处理大规模数据，可扩展型好</li><li>当簇接近高斯分布时，效果较好</li><li>当簇具有不同的尺寸、密度、非球形，Kmeans可能得不到理想的聚类结果</li><li>硬划分数据点到簇，当数据上出现一些小的扰动，可能导致一个点划分到另外的簇</li></ul><p>K-Means与GMM</p><p>K-Means</p><ul><li>损失函数:最小化平方距离的和</li><li>样本点硬划分到某个簇</li><li>假定样本属于每个簇的概率相等，且为球形簇</li></ul><p>GMM</p><ul><li>最小化负对数似然</li><li>点到簇的从属关系为软分配</li><li>可以被用于椭球形簇，且各个簇概率不同</li></ul><p>层次聚类：<strong>最小距离层次聚类可以做同心圆相关聚类</strong></p><ul><li>对噪声和离群点敏感</li><li>比较难处理不同尺寸的簇和凸的簇</li><li>成链,误把大簇分裂</li></ul><p>DBSCAN</p><ul><li>各种大小、各种形状的簇，不需要明确簇的数量</li><li>具有一定的抗噪音特性</li><li>参数选择比较困难</li><li>不适合密度差异较大的数据集</li><li>时间慢</li></ul><p><a href="https://imgse.com/i/pSCaYhF"><img src="https://s1.ax1x.com/2023/01/01/pSCaYhF.md.png" alt="pSCaYhF.md.png"></a></p><h1>第9章 降维</h1><p>PCA的优化目标：</p><ul><li>最大化映射后的样本方差角度</li><li>最小重建误差角度</li></ul><h1>第10章 半监督学习</h1><h2 id="基本假设">基本假设</h2><p>平滑假设：如果高密度区域中两个点<img src="https://math.now.sh?inline=x_1%2Cx_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>距离较近, 那么对应的输出<img src="https://math.now.sh?inline=y_1%2Cy_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>也应该接近</p><p>聚类假设：如果两个点在同一个簇，那么它们很有可能属于同一个类别</p><ul><li>等价形式：低密度分割（决策边界应该在低密度区域）</li></ul><p>流形假设：输入空间由所有数据点所在的多个低维流形构成，位于同一流形上的数据点具有相同的标签，流形上距离近的点的标签相似</p><h2 id="具体算法">具体算法</h2><p>自我训练算法：假设输出的高度置信的预测是正确的</p><p>协同训练：假设特征可分裂<img src="https://math.now.sh?inline=x%3D%5Bx_1%2Cx_2%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=x_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>或<img src="https://math.now.sh?inline=x_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>单独对于训练一个好的分类器是充分的，<img src="https://math.now.sh?inline=x_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=x_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在给定类别后是条件独立的</p><p>生成式模型：假设所有数据（带标签&amp;不带标签）都由一个潜在的模型生成（GMM，HMM，朴素贝叶斯）</p><p>半监督支持向量机：假设来自不同类别的无标记数据之间会被较大的间隔隔开</p><ul><li>C2很小表达对未标注样本错分的容忍度比较大，很大表示不容忍错分，每一个未标注样本也要分对</li></ul><p>基于干扰的半监督：基于连续性假设：考虑对输入<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>稍加改变，得到其增广表示<img src="https://math.now.sh?inline=A%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，模型对<img src="https://math.now.sh?inline=A%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的预测和对原始数据点的预测<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>相似。</p><p>基于图的半监督学习：假设在所有数据点（标注数据和无标注数据）定义一个相似性图，相似的数据点之间存在边，边的权重表示两个数据点之间的相似程度，相似图中“紧密”连接的点趋向于有相同的标签</p><h1>第11章 概率图模型</h1><p>贝叶斯球：</p><p><a href="https://imgse.com/i/pSSLlbq"><img src="https://s1.ax1x.com/2022/12/29/pSSLlbq.md.png" alt="pSSLlbq.md.png"></a></p><p><a href="https://imgse.com/i/z7Vp0P"><img src="https://s1.ax1x.com/2022/12/16/z7Vp0P.md.jpg" alt="z7Vp0P.md.jpg"></a><br><a href="https://imgse.com/i/z7VSmt"><img src="https://s1.ax1x.com/2022/12/16/z7VSmt.md.jpg" alt="z7VSmt.md.jpg"></a></p><h2 id="HMM">HMM</h2><p><a href="https://imgse.com/i/zoUqK0"><img src="https://s1.ax1x.com/2022/12/15/zoUqK0.md.jpg" alt="zoUqK0.md.jpg"></a></p><h3 id="前向算法">前向算法</h3><p><a href="https://imgse.com/i/zoUjVU"><img src="https://s1.ax1x.com/2022/12/15/zoUjVU.md.jpg" alt="zoUjVU.md.jpg"></a><br><a href="https://imgse.com/i/zoUObT"><img src="https://s1.ax1x.com/2022/12/15/zoUObT.md.jpg" alt="zoUObT.md.jpg"></a></p><h3 id="维特比算法">维特比算法</h3><p><a href="https://imgse.com/i/zoULrV"><img src="https://s1.ax1x.com/2022/12/15/zoULrV.md.jpg" alt="zoULrV.md.jpg"></a><a href="https://imgse.com/i/zoUvaF"><img src="https://s1.ax1x.com/2022/12/15/zoUvaF.md.jpg" alt="zoUvaF.md.jpg"></a></p><h1>第12章 集成学习</h1><h2 id="bagging">bagging</h2><p>降低模型的方差，偏差不变</p><p>原理：通过对训练样本进行bootstrap采样（有放回的随机采样），然后训练多个模型，最后对多个模型作平均，得到最后的融合模型。</p><p>Bagging适合对偏差低、方差高的模型进行融合，如决策树、神经网络等</p><h2 id="boosting">boosting</h2><p>降低模型的偏差，方差不变</p><p>原理：每次迭代顺序的把一些模型加进去，最后一些子模型的加权平均是我们最后的集成模型</p><h3 id="Adaboost">Adaboost</h3><p>Adaboost：在弱学习器失败的样本上，学习第二个弱学习器</p><p>开始初始化的时候每个样本的权重相同</p><p>分对的样本，其权重除以<img src="https://math.now.sh?inline=d_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，权重减小</p><p>分错的样本，其权重乘以<img src="https://math.now.sh?inline=d_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，权重增大</p><p>最后对模型进行加权融合</p><p>Adaboost 原理：先从初始训练集训练出一个学习器，再根据基学习器的表现来对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续得到更多的关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直到基学习器达到事先指定的值T，最终将这T个基学习器进行加权结合。</p><p>Adaboost 损失函数：使用指数损失函数<img src="https://math.now.sh?inline=L%28y%2Cf(x%29)%3Dexp(-yf(x))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>Adaboost算法流程：</p><p><a href="https://imgse.com/i/pSigIpR"><img src="https://s1.ax1x.com/2023/01/03/pSigIpR.md.png" alt="pSigIpR.md.png"></a></p><p>为什么AdaBoost经常可以在训练误差为0后继续训练还可能带来测试误差的持续下降？</p><p>在训练误差下降到接近0的时候，更多的训练，会增加分类器的分类margin，这个过程也能够防止测试误差的上升，随着Margin的变大，测试误差会逐渐收敛。</p><p>AdaBoost优缺点：</p><p>优点：实现快速简单、灵活、通用性高</p><p>缺点：AdaBoost性能取决于数据和弱学习器，如果弱分类器过于复杂，可能会产生过拟合情况，如果弱分类器太弱有可能造成欠拟合，还容易收到均匀噪声的影响。</p><h1>第13章 深度学习</h1><h2 id="神经元的结构">神经元的结构</h2><p><a href="https://imgse.com/i/pSpSD6U"><img src="https://s1.ax1x.com/2022/12/29/pSpSD6U.md.png" alt="pSpSD6U.md.png"></a></p><h2 id="激活函数">激活函数</h2><p>Sigmoid函数：</p><p>在早期的神经网络中较为普遍，逐渐被更简单的ReLU函数取代</p><p>容易导致梯度消失问题：</p><ul><li>导数最大值为0.25：反向传播时，返回网络的误差将会在每一层收缩至少75%</li><li>尾部是饱和的，对应的梯度接近0，导致消失梯度问题</li></ul><p>Tanh函数：形状和sigmoid函数的形状很像，但tanh函数在坐标系的原点上对称：使用tanh激活函数收敛会更快，减轻消失梯度的现象</p><p>ReLU函数：</p><ul><li>计算量小，不涉及除法</li><li>一部分神经元的输出为0：网络稀疏，减少了参数的相互依存关系，缓解过拟合</li><li>当<img src="https://math.now.sh?inline=x%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，导数为<img src="https://math.now.sh?inline=1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，解决了梯度消失问题，收敛速度更快</li><li>当<img src="https://math.now.sh?inline=x%3C0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，导数为<img src="https://math.now.sh?inline=0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，无法更新权重</li></ul><h2 id="神经网络">神经网络</h2><p><a href="https://imgse.com/i/pSpSLtI"><img src="https://s1.ax1x.com/2022/12/29/pSpSLtI.md.png" alt="pSpSLtI.md.png"></a><a href="https://imgse.com/i/pSpSOht"><img src="https://s1.ax1x.com/2022/12/29/pSpSOht.md.png" alt="pSpSOht.md.png"></a></p><h2 id="梯度消失和梯度爆炸">梯度消失和梯度爆炸</h2><p>梯度爆炸：梯度值超出范围：无穷大值</p><p>对学习率敏感</p><ul><li>学习率较大-更大的权重-更大的梯度</li><li>学习率太小-模型训练没有进展</li><li>可能需要在训练期间大幅改变学习率</li></ul><p>梯度消失：梯度值趋近0</p><p>无论如何选择学习率，训练都没有进展</p><p>只有顶层训练有效，底层训练基本无效，使网络更深可能并没有更好</p><p>模型的深度增加，梯度会逐渐消失：</p><ul><li>将sigmoid激活函数换成其他的激活函数</li><li>Resnet：通过跳接的方式，优化残差映射比直接优化原始映射更容易，带有集成学习的思想</li><li>Batch normalization，还能带来正则化的效果</li></ul><p>其他技巧：</p><ul><li>batch normalization 会使得我们的训练对好多因素（学习率、初始化）的要求没有那么高</li><li>参数初始化，或者采用预训练网络作初始化或者核初始化</li><li>mini-batch的梯度下降</li><li>动量法梯度下降：移动量不仅与梯度有关，还与前一时刻的移动量有关。</li><li>Adam：同时利用一阶动量和二阶动量进行优化</li></ul><h2 id="过拟合">过拟合</h2><ul><li>早停</li><li>正则：L1正则能让系数=0，L2可以让参数趋向于变小，对整体的影响就变小了，相当于参数变简单了</li><li>Dropout：随机删除一部分神经元（可视为一种集成学习）</li><li>数据增强：增加训练样本集尽可能让他多样化，也可以增加模型的泛化能力</li></ul><h2 id="卷积神经网络">卷积神经网络</h2><ul><li>局部连接：我们认为是一个模式在一个比较小的范围内，而不是要看全局，有些模式比整个图像小得多，神经元不需要看整幅图像就能发现模式，与一个小区域连接所需的参数更少</li><li>权值共享：同一个模式会在图像中不同的区域出现，不同位置可能都有这样的模式，这样做可以使得模型的参数变少</li><li>池化：对像素进行下采样不影响目标，通过下采样可以让图像更小，网络处理图像需要的参数更少</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Pattern Recognition and Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go项目-分布式缓存GeeCache</title>
    <link href="/2022/12/05/Go/Go-Project-Geecache/"/>
    <url>/2022/12/05/Go/Go-Project-Geecache/</url>
    
    <content type="html"><![CDATA[<p>Go项目-分布式缓存GeeCache</p><span id="more"></span><h1>GeeCache</h1><h2 id="完成的功能">完成的功能</h2><ul><li>单机缓存和基于 HTTP 的分布式缓存</li><li>最近最少访问(Least Recently Used, LRU) 缓存策略</li><li>使用 Go 锁机制防止缓存击穿</li><li>使用一致性哈希选择节点，实现负载均衡</li></ul><h2 id="LRU-缓存淘汰策略">LRU 缓存淘汰策略</h2><p>FIFO：先淘汰缓存中最早添加的记录</p><p>LFU：淘汰缓存中访问频率最低的记录，需要维护一个访问频率的表</p><p>LRU：最近最少使用，认为如果数据最近被访问过，那么将来被访问的概率也会更高。维护一个队列，如果一条记录被访问，则移动到队列尾端，这样保证队首一定是最近最少访问的数据</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> lru<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;container/list&quot;</span><span class="hljs-comment">// LRU cache 结构体</span><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;maxBytes  <span class="hljs-type">int64</span>                         <span class="hljs-comment">// 允许使用的最大内存</span>nbytes    <span class="hljs-type">int64</span>                         <span class="hljs-comment">// 当前已使用的内存</span>ll        *list.List                    <span class="hljs-comment">// cache链表</span>cache     <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element      <span class="hljs-comment">// 查找键值对的字典</span>OnEvicted <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>, value Value)</span></span> <span class="hljs-comment">// 某条记录被移除时的回调函数</span>&#125;<span class="hljs-comment">// 双向链表节点的数据类型</span><span class="hljs-comment">// 主要目的是为了删除节点后能从字典中删除该键值对</span><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;key   <span class="hljs-type">string</span>value Value&#125;<span class="hljs-comment">// 值的类型可以是任意的，定义一个空接口，实现Len()方法返回值的占用空间大小</span><span class="hljs-comment">// Len the number of cache entries</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Len() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> c.ll.Len()&#125;<span class="hljs-keyword">type</span> Value <span class="hljs-keyword">interface</span> &#123;Len() <span class="hljs-type">int</span> <span class="hljs-comment">// 包含一个方法返回值占用的内存大小</span>&#125;<span class="hljs-comment">// 工厂模式，返回实例化的cache</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(maxBytes <span class="hljs-type">int64</span>, onEvicted <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, Value)</span></span>) *Cache &#123;<span class="hljs-keyword">return</span> &amp;Cache&#123;maxBytes:  maxBytes,ll:        list.New(),cache:     <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*list.Element),OnEvicted: onEvicted,&#125;&#125;<span class="hljs-comment">// 查找功能，在字典中进行查找，然后移动到队尾（Front）</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Get(key <span class="hljs-type">string</span>) (value Value, ok <span class="hljs-type">bool</span>) &#123;<span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;c.ll.MoveToFront(ele)kv := ele.Value.(*entry)<span class="hljs-keyword">return</span> kv.value, <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// LRU删除策略：从队首（Back）拿到节点，然后将其删除</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> RemoveOldest() &#123;ele := c.ll.Back()<span class="hljs-keyword">if</span> ele != <span class="hljs-literal">nil</span> &#123;c.ll.Remove(ele)kv := ele.Value.(*entry)<span class="hljs-built_in">delete</span>(c.cache, kv.key)c.nbytes -= <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(kv.key)) + <span class="hljs-type">int64</span>(kv.value.Len()) <span class="hljs-comment">// 更新当前已经使用的内存</span><span class="hljs-keyword">if</span> c.OnEvicted != <span class="hljs-literal">nil</span> &#123;c.OnEvicted(kv.key, kv.value)&#125;&#125;&#125;<span class="hljs-comment">// 新增节点/修改节点</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> Add(key <span class="hljs-type">string</span>, value Value) &#123;<span class="hljs-comment">// 如果在链表中找到则将其更新，同时更新占用的空间大小等，并移动到队列尾端</span><span class="hljs-keyword">if</span> ele, ok := c.cache[key]; ok &#123;c.ll.MoveToFront(ele)kv := ele.Value.(*entry)c.nbytes += <span class="hljs-type">int64</span>(value.Len()) - <span class="hljs-type">int64</span>(kv.value.Len())kv.value = value&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果找不到则直接插入</span>ele := c.ll.PushFront(&amp;entry&#123;key, value&#125;)c.cache[key] = elec.nbytes += <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(key)) + <span class="hljs-type">int64</span>(value.Len())&#125;<span class="hljs-comment">// 如果占用空间超过了链表的最大空间，则删除掉队首的节点</span><span class="hljs-keyword">for</span> c.maxBytes != <span class="hljs-number">0</span> &amp;&amp; c.maxBytes &lt; c.nbytes &#123;c.RemoveOldest()&#125;&#125;</code></pre></div><h2 id="单机并发缓存">单机并发缓存</h2><p>多个协程(goroutine)同时读写同一个变量，在并发度较高的情况下，会发生冲突。确保一次只有一个协程(goroutine)可以访问该变量以避免冲突，这称之为 <code>互斥</code>，互斥锁可以解决这个问题。</p><p>当一个协程调用了 <code>Lock()</code> 方法时，其他协程被阻塞了，直到 <code>Unlock()</code>调用将锁释放。因此被包裹部分的代码就能够避免冲突，实现互斥。</p><p>抽象了一个只读数据结构 <code>ByteView</code> 用来表示缓存值：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<span class="hljs-comment">// 只读数据结构用来表示缓存值</span><span class="hljs-keyword">type</span> ByteView <span class="hljs-keyword">struct</span> &#123;b []<span class="hljs-type">byte</span>&#125;<span class="hljs-comment">// 返回缓存值的长度</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v ByteView)</span></span> Len() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(v.b)&#125;<span class="hljs-comment">// 返回拷贝从而防止这个值被外部操作修改</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v ByteView)</span></span> ByteSlice() []<span class="hljs-type">byte</span> &#123;<span class="hljs-keyword">return</span> cloneBytes(v.b)&#125;<span class="hljs-comment">// 将数据作为一个字符串进行返回</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v ByteView)</span></span> String() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(v.b)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cloneBytes</span><span class="hljs-params">(b []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span> &#123;c := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-built_in">len</span>(b))<span class="hljs-built_in">copy</span>(c, b)<span class="hljs-keyword">return</span> c&#125;</code></pre></div><p>为 lru.Cache 添加并发特性（加锁）：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/GeeCache/lru&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">type</span> cache <span class="hljs-keyword">struct</span> &#123;mu         sync.Mutexlru        *lru.CachecacheBytes <span class="hljs-type">int64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cache)</span></span> add(key <span class="hljs-type">string</span>, value ByteView) &#123;c.mu.Lock()<span class="hljs-keyword">defer</span> c.mu.Unlock()<span class="hljs-comment">// 延迟初始化</span><span class="hljs-keyword">if</span> c.lru == <span class="hljs-literal">nil</span> &#123;c.lru = lru.New(c.cacheBytes, <span class="hljs-literal">nil</span>)&#125;c.lru.Add(key, value)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *cache)</span></span> get(key <span class="hljs-type">string</span>) (value ByteView, ok <span class="hljs-type">bool</span>) &#123;c.mu.Lock()<span class="hljs-keyword">defer</span> c.mu.Unlock()<span class="hljs-keyword">if</span> c.lru == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> v, ok := c.lru.Get(key); ok &#123;<span class="hljs-keyword">return</span> v.(ByteView), ok&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>Group 是 GeeCache 最核心的数据结构，负责与用户的交互，并且控制缓存值存储和获取的流程。</p><p>在缓存不存在时，调用这个函数，得到源数据：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Getter <span class="hljs-keyword">interface</span> &#123;Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)&#125;<span class="hljs-comment">// 定义函数类型 GetterFunc，并实现 Getter 接口的 Get 方法</span><span class="hljs-keyword">type</span> GetterFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f GetterFunc)</span></span> Get(key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">return</span> f(key)&#125;</code></pre></div><p>核心Group：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 缓存的命名空间</span><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;name      <span class="hljs-type">string</span> <span class="hljs-comment">// 每个Group拥有一个唯一的名称</span>getter    Getter <span class="hljs-comment">// 缓存未命中时的回溯</span>mainCache cache  <span class="hljs-comment">// 并发缓存</span>&#125;<span class="hljs-keyword">var</span> (mu     sync.RWMutexgroups = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*Group))<span class="hljs-comment">// 创建Group实例，并且将group的名称存在全局变量中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>, cacheBytes <span class="hljs-type">int64</span>, getter Getter)</span></span> *Group &#123;<span class="hljs-keyword">if</span> getter == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;nil Getter&quot;</span>)&#125;mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()g := &amp;Group&#123;name:      name,getter:    getter,mainCache: cache&#123;cacheBytes: cacheBytes&#125;,&#125;groups[name] = g<span class="hljs-keyword">return</span> g&#125;<span class="hljs-comment">// 获取指定的group</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetGroup</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *Group &#123;mu.RLock()g := groups[name]mu.RUnlock()<span class="hljs-keyword">return</span> g&#125;</code></pre></div><p>Group的Get方法，完成对缓存的查找以及未命中后的回调操作</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 找到缓存值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Get(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;<span class="hljs-comment">// 如果没有键则报错</span><span class="hljs-keyword">if</span> key == <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> ByteView&#123;&#125;, fmt.Errorf(<span class="hljs-string">&quot;key is required&quot;</span>)&#125;<span class="hljs-comment">// 从 mainCache 中查找缓存，如果存在则返回缓存值</span><span class="hljs-keyword">if</span> v, ok := g.mainCache.get(key); ok &#123;log.Println(<span class="hljs-string">&quot;[GeeCache] hit&quot;</span>)<span class="hljs-keyword">return</span> v, <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> g.load(key)&#125;<span class="hljs-comment">// 缓存不存在，则调用 load 方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> load(key <span class="hljs-type">string</span>) (value ByteView, err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">return</span> g.getLocally(key)&#125;<span class="hljs-comment">// getLocally 调用用户回调函数 g.getter.Get() 获取源数据，并且将源数据添加到缓存 mainCache 中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getLocally(key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;bytes, err := g.getter.Get(key)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> ByteView&#123;&#125;, err&#125;value := ByteView&#123;b: cloneBytes(bytes)&#125;g.populateCache(key, value)<span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> populateCache(key <span class="hljs-type">string</span>, value ByteView) &#123;g.mainCache.add(key, value)&#125;</code></pre></div><h2 id="HTTP-服务端">HTTP 服务端</h2><p>分布式缓存需要实现节点间通信，建立基于 HTTP 的通信机制是比较常见和简单的做法。如果一个节点启动了 HTTP 服务，那么这个节点就可以被其他节点访问。</p><p>承载节点间 HTTP 通信的核心数据结构：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<span class="hljs-keyword">const</span> defaultBasePath = <span class="hljs-string">&quot;/_geecache/&quot;</span><span class="hljs-keyword">type</span> HTTPPool <span class="hljs-keyword">struct</span> &#123;self     <span class="hljs-type">string</span> <span class="hljs-comment">// 记录自己的地址，包括主机名/IP 和端口</span>basePath <span class="hljs-type">string</span> <span class="hljs-comment">// 节点间通讯地址的前缀</span>&#125;<span class="hljs-comment">// 返回HTTP实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewHTTPPool</span><span class="hljs-params">(self <span class="hljs-type">string</span>)</span></span> *HTTPPool &#123;<span class="hljs-keyword">return</span> &amp;HTTPPool&#123;self:     self,basePath: defaultBasePath,&#125;&#125;</code></pre></div><p>实现最为核心的 <code>ServeHTTP</code> 方法：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 使用服务器登录</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HTTPPool)</span></span> Log(format <span class="hljs-type">string</span>, v ...<span class="hljs-keyword">interface</span>&#123;&#125;) &#123;log.Printf(<span class="hljs-string">&quot;[Server %s] %s&quot;</span>, p.self, fmt.Sprintf(format, v...))&#125;<span class="hljs-comment">// 处理HTTP请求</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HTTPPool)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<span class="hljs-comment">// 判断访问路径的前缀是否是 basePath，不是返回错误</span><span class="hljs-keyword">if</span> !strings.HasPrefix(r.URL.Path, p.basePath) &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;HTTPPool serving unexpected path: &quot;</span> + r.URL.Path)&#125;p.Log(<span class="hljs-string">&quot;%s %s&quot;</span>, r.Method, r.URL.Path)<span class="hljs-comment">// /&lt;basepath&gt;/&lt;groupname&gt;/&lt;key&gt; required</span>parts := strings.SplitN(r.URL.Path[<span class="hljs-built_in">len</span>(p.basePath):], <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">2</span>)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) != <span class="hljs-number">2</span> &#123;http.Error(w, <span class="hljs-string">&quot;bad request&quot;</span>, http.StatusBadRequest)<span class="hljs-keyword">return</span>&#125;groupName := parts[<span class="hljs-number">0</span>]key := parts[<span class="hljs-number">1</span>]<span class="hljs-comment">// 通过 groupname 得到 group 实例，再使用 group.Get(key) 获取缓存数据</span>group := GetGroup(groupName)<span class="hljs-keyword">if</span> group == <span class="hljs-literal">nil</span> &#123;http.Error(w, <span class="hljs-string">&quot;no such group: &quot;</span>+groupName, http.StatusNotFound)<span class="hljs-keyword">return</span>&#125;view, err := group.Get(key)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;http.Error(w, err.Error(), http.StatusInternalServerError)<span class="hljs-keyword">return</span>&#125;w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/octet-stream&quot;</span>)<span class="hljs-comment">// 将缓存值作为 httpResponse 的 body 返回</span>w.Write(view.ByteSlice())&#125;</code></pre></div><h2 id="一致性哈希">一致性哈希</h2><p>一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> consistenthash<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;hash/crc32&quot;</span><span class="hljs-string">&quot;sort&quot;</span><span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-comment">// 定义了函数类型 Hash，采取依赖注入的方式，允许用于替换成自定义的 Hash 函数</span><span class="hljs-keyword">type</span> Hash <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">uint32</span><span class="hljs-comment">// 一致性哈希算法的主数据结构</span><span class="hljs-keyword">type</span> Map <span class="hljs-keyword">struct</span> &#123;hash     Hashreplicas <span class="hljs-type">int</span>            <span class="hljs-comment">// 虚拟节点倍数</span>keys     []<span class="hljs-type">int</span>          <span class="hljs-comment">// 哈希环</span>hashMap  <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span> <span class="hljs-comment">// 虚拟节点与真实节点的映射表</span>&#125;<span class="hljs-comment">// 允许自定义虚拟节点倍数和 Hash 函数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(replicas <span class="hljs-type">int</span>, fn Hash)</span></span> *Map &#123;m := &amp;Map&#123;replicas: replicas,hash:     fn,hashMap:  <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>),&#125;<span class="hljs-keyword">if</span> m.hash == <span class="hljs-literal">nil</span> &#123;m.hash = crc32.ChecksumIEEE&#125;<span class="hljs-keyword">return</span> m&#125;<span class="hljs-comment">// 实现添加真实节点/机器的 Add() 方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Add(keys ...<span class="hljs-type">string</span>) &#123;<span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keys &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m.replicas; i++ &#123;hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(strconv.Itoa(i) + key)))m.keys = <span class="hljs-built_in">append</span>(m.keys, hash)m.hashMap[hash] = key&#125;&#125;sort.Ints(m.keys)&#125;<span class="hljs-comment">// 实现选择节点的 Get() 方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Map)</span></span> Get(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(m.keys) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125;hash := <span class="hljs-type">int</span>(m.hash([]<span class="hljs-type">byte</span>(key))) <span class="hljs-comment">// 计算 key 的哈希值</span><span class="hljs-comment">// 顺时针找到第一个匹配的虚拟节点的下标 idx</span>idx := sort.Search(<span class="hljs-built_in">len</span>(m.keys), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">return</span> m.keys[i] &gt;= hash&#125;)<span class="hljs-keyword">return</span> m.hashMap[m.keys[idx%<span class="hljs-built_in">len</span>(m.keys)]]&#125;</code></pre></div><h2 id="分布式节点">分布式节点</h2><p>抽象 PeerPicker</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geecache<span class="hljs-comment">// PeerPicker 的 PickPeer() 方法用于根据传入的 key 选择相应节点 PeerGetter</span><span class="hljs-keyword">type</span> PeerPicker <span class="hljs-keyword">interface</span> &#123;PickPeer(key <span class="hljs-type">string</span>) (peer PeerGetter, ok <span class="hljs-type">bool</span>)&#125;<span class="hljs-comment">// 接口 PeerGetter 的 Get() 方法用于从对应 group 查找缓存值</span><span class="hljs-keyword">type</span> PeerGetter <span class="hljs-keyword">interface</span> &#123;Get(group <span class="hljs-type">string</span>, key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)&#125;</code></pre></div><p>节点选择与 HTTP 客户端</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (defaultBasePath = <span class="hljs-string">&quot;/_geecache/&quot;</span>defaultReplicas = <span class="hljs-number">50</span>)<span class="hljs-keyword">type</span> HTTPPool <span class="hljs-keyword">struct</span> &#123;self        <span class="hljs-type">string</span>                 <span class="hljs-comment">// 记录自己的地址，包括主机名/IP 和端口</span>basePath    <span class="hljs-type">string</span>                 <span class="hljs-comment">// 节点间通讯地址的前缀</span>mu          sync.Mutex             <span class="hljs-comment">// 锁</span>peers       *consistenthash.Map    <span class="hljs-comment">// 新增成员变量 peers，类型是一致性哈希算法的 Map，用来根据具体的 key 选择节点</span>httpGetters <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*httpGetter <span class="hljs-comment">// 映射远程节点与对应的 httpGetter</span>&#125;<span class="hljs-comment">// 实现 PeerGetter 接口</span><span class="hljs-keyword">type</span> httpGetter <span class="hljs-keyword">struct</span> &#123;baseURL <span class="hljs-type">string</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 使用 http.Get() 方式获取返回值，并转换为 []bytes 类型</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *httpGetter)</span></span> Get(group <span class="hljs-type">string</span>, key <span class="hljs-type">string</span>) ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;u := fmt.Sprintf(<span class="hljs-string">&quot;%v%v/%v&quot;</span>,h.baseURL,url.QueryEscape(group),url.QueryEscape(key),)res, err := http.Get(u)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">defer</span> res.Body.Close()<span class="hljs-keyword">if</span> res.StatusCode != http.StatusOK &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;server returned: %v&quot;</span>, res.Status)&#125;bytes, err := ioutil.ReadAll(res.Body)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;reading response body: %v&quot;</span>, err)&#125;<span class="hljs-keyword">return</span> bytes, <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>实现 PeerPicker 接口</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Set() 方法实例化了一致性哈希算法，并且添加了传入的节点，为每一个节点创建了一个 HTTP 客户端 httpGetter</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HTTPPool)</span></span> Set(peers ...<span class="hljs-type">string</span>) &#123;p.mu.Lock()<span class="hljs-keyword">defer</span> p.mu.Unlock()p.peers = consistenthash.New(defaultReplicas, <span class="hljs-literal">nil</span>)p.peers.Add(peers...)p.httpGetters = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*httpGetter, <span class="hljs-built_in">len</span>(peers))<span class="hljs-keyword">for</span> _, peer := <span class="hljs-keyword">range</span> peers &#123;p.httpGetters[peer] = &amp;httpGetter&#123;baseURL: peer + p.basePath&#125;&#125;&#125;<span class="hljs-comment">// PickerPeer() 包装了一致性哈希算法的 Get() 方法，根据具体的 key，选择节点，返回节点对应的 HTTP 客户端</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HTTPPool)</span></span> PickPeer(key <span class="hljs-type">string</span>) (PeerGetter, <span class="hljs-type">bool</span>) &#123;p.mu.Lock()<span class="hljs-keyword">defer</span> p.mu.Unlock()<span class="hljs-keyword">if</span> peer := p.peers.Get(key); peer != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; peer != p.self &#123;p.Log(<span class="hljs-string">&quot;Pick peer %s&quot;</span>, peer)<span class="hljs-keyword">return</span> p.httpGetters[peer], <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>&#125;</code></pre></div><p>修改主方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 将 实现了 PeerPicker 接口的 HTTPPool 注入到 Group 中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> RegisterPeers(peers PeerPicker) &#123;<span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;RegisterPeerPicker called more than once&quot;</span>)&#125;g.peers = peers&#125;<span class="hljs-comment">// 使用实现了 PeerGetter 接口的 httpGetter 从访问远程节点，获取缓存值</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> getFromPeer(peer PeerGetter, key <span class="hljs-type">string</span>) (ByteView, <span class="hljs-type">error</span>) &#123;bytes, err := peer.Get(g.name, key)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> ByteView&#123;&#125;, err&#125;<span class="hljs-keyword">return</span> ByteView&#123;b: bytes&#125;, <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// 缓存不存在，则调用 load 方法</span><span class="hljs-comment">// 若非本机节点，则调用 getFromPeer() 从远程获取。若是本机节点或失败，则回退到 getLocally()</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> load(key <span class="hljs-type">string</span>) (value ByteView, err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">if</span> g.peers != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> peer, ok := g.peers.PickPeer(key); ok &#123;<span class="hljs-keyword">if</span> value, err = g.getFromPeer(peer, key); err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span>&#125;log.Println(<span class="hljs-string">&quot;[GeeCache] Failed to get from peer&quot;</span>, err)&#125;&#125;<span class="hljs-keyword">return</span> g.getLocally(key)&#125;</code></pre></div><h2 id="防止缓存击穿">防止缓存击穿</h2><p>并发了 N 个请求，假设对数据库的访问没有做任何限制的，很可能向数据库也发起 N 次请求，容易导致缓存击穿和穿透。针对相同的 key，如何做到只向远端节点发起一次请求呢？</p><p>实现了一个名为 singleflight 的 package 来解决这个问题</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleflight<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><span class="hljs-comment">// call 代表正在进行中，或已经结束的请求。使用 sync.WaitGroup 锁避免重入</span><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;wg  sync.WaitGroupval <span class="hljs-keyword">interface</span>&#123;&#125;err <span class="hljs-type">error</span>&#125;<span class="hljs-comment">// Group 是 singleflight 的主数据结构，管理不同 key 的请求(call)</span><span class="hljs-keyword">type</span> Group <span class="hljs-keyword">struct</span> &#123;mu sync.Mutex <span class="hljs-comment">// protects m</span>m  <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*call&#125;</code></pre></div><p>实现 <code>Do</code> 方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 针对相同的 key，无论 Do 被调用多少次，函数 fn 都只会被调用一次，等待 fn 调用结束了，返回返回值或错误。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Do(key <span class="hljs-type">string</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;g.mu.Lock()<span class="hljs-keyword">if</span> g.m == <span class="hljs-literal">nil</span> &#123;g.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*call)&#125;<span class="hljs-keyword">if</span> c, ok := g.m[key]; ok &#123;g.mu.Unlock()c.wg.Wait()         <span class="hljs-comment">// 如果请求正在进行中，则等待</span><span class="hljs-keyword">return</span> c.val, c.err <span class="hljs-comment">// 请求结束，返回结果</span>&#125;c := <span class="hljs-built_in">new</span>(call)c.wg.Add(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 发起请求前加锁</span>g.m[key] = c <span class="hljs-comment">// 添加到 g.m，表明 key 已经有对应的请求在处理</span>g.mu.Unlock()c.val, c.err = fn() <span class="hljs-comment">// 调用 fn，发起请求</span>c.wg.Done()         <span class="hljs-comment">// 请求结束</span>g.mu.Lock()<span class="hljs-built_in">delete</span>(g.m, key) <span class="hljs-comment">// 更新 g.m</span>g.mu.Unlock()<span class="hljs-keyword">return</span> c.val, c.err <span class="hljs-comment">// 返回结果</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
      <tag>Project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第14讲 强化学习</title>
    <link href="/2022/12/01/UCAS/advanced-ai/advanced-ai-14/"/>
    <url>/2022/12/01/UCAS/advanced-ai/advanced-ai-14/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第14讲 强化学习</p><span id="more"></span><h1>第14讲 强化学习</h1><h2 id="强化学习">强化学习</h2><p>目标：学习<strong>从环境状态到行为的映射（即策略）</strong>，智能体选择能够获得环境<strong>最大奖赏</strong>的行为，使得外部环境对学习系统在某种意义下的评价为最佳。</p><p>区别于监督学习：监督学习是从标注中学习；强化学习是从交互中学习</p><h3 id="两种反馈">两种反馈</h3><p>评价性反馈</p><ul><li>当智能体采取某个行为时，对该行为给出一个评价，但并不知道哪个行为是最好的</li><li>强化学习经常面临的是评价性反馈</li></ul><p>指导性反馈</p><ul><li>直接给出某个状态下的正确或最好行为</li><li>独立于智能体当前采取的行为</li><li>监督学习使用的是指导性反馈</li></ul><h3 id="强化学习的两大特性">强化学习的两大特性</h3><p>试错搜索和延迟奖励，用于判断某一问题是否适用于强化学习求解。</p><h3 id="强化学习需要应对的挑战">强化学习需要应对的挑战</h3><p>利用和探索之间的矛盾</p><h3 id="强化学习的要素">强化学习的要素</h3><p>主体：智能体和环境-状态、行为和奖励</p><p>要素：</p><ul><li>策略：状态到行为的映射，包括确定策略和随机策略两种</li><li>奖励：关于状态和行为的函数，通常具有一定的不确定性</li><li>价值：累积奖励或长期目标</li><li>环境模型：刻画环境对行为的反馈</li></ul><h3 id="强化学习发展历程">强化学习发展历程</h3><ul><li>1911年，Thorndike 提出效果律（Law of effect），从心理学的角度探讨了强化思想：动物感到舒服的行为会被强化，动物感到不舒服的行为会被弱化</li><li>1954年，马文 · 明斯基（Marvin Minsky）在其博士论文中实现了计算上的试错学习</li><li>1957年，Bellman提出求解最优控制问题的动态规划方法，并提出了最优控制问题的随机离散版本，即著名的马尔科夫决策过程</li><li>1960年，Howard提出马尔科夫决策过程的策略迭代方法</li><li>1961年，明斯基在其论文“Steps toward artificial intelligence”中首次使用“Reinforcement learning”一词</li><li>1989年，Watkins提出了Q-learning，将动态规划、时序差分、蒙特卡洛模拟三条线结合在了一起</li><li>1992年，Tesauro 将强化学习成功应用到西洋双陆棋</li><li>2015年，强化学习和深度学习结合： AlphaGo</li><li>2017年，AlphaGo Zero</li></ul><h2 id="多臂赌博机">多臂赌博机</h2><p>一台赌博机有多个摇臂 ，每个摇臂摇出的奖励（reward）大小不确定 ，玩家希望摇固定次数的臂所获得的期望累积奖励最大</p><h3 id="问题形式化">问题形式化</h3><p>行为：摇哪个臂</p><p>奖励：每次摇臂获得的奖金</p><p><img src="https://math.now.sh?inline=%F0%9D%90%B4_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示第<img src="https://math.now.sh?inline=%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>轮的行为，<img src="https://math.now.sh?inline=%F0%9D%91%85_%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示第<img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>轮获得的奖励</p><p>第<img src="https://math.now.sh?inline=%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>轮采取行为<img src="https://math.now.sh?inline=%F0%9D%91%8E" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的期望奖励为：<img src="https://math.now.sh?inline=q_*%28a%29%20%5Cdoteq%20%5Cmathbb%7BE%7D%5Cleft%5BR_t%20%5Cmid%20A_t%3Da%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>假如摇臂<img src="https://math.now.sh?inline=%F0%9D%91%87" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次， 那么按照什么策略摇臂，才能使期望累积奖励最大呢？</p><p>当<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>已知时， 每次都选择<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最大的<img src="https://math.now.sh?inline=%F0%9D%91%8E" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（贪心策略）</p><p>但是一般情况下，<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对于玩家而言是未知的或具有不确定性，玩家在第<img src="https://math.now.sh?inline=%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>轮时只能依赖于当时对<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的估值<img src="https://math.now.sh?inline=%F0%9D%91%84_%F0%9D%91%A1%28%F0%9D%91%8E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>进行选择，此时，贪心策略是在第<img src="https://math.now.sh?inline=%F0%9D%91%A1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>轮 选择<img src="https://math.now.sh?inline=%F0%9D%91%84_%F0%9D%91%A1%28%F0%9D%91%8E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最大的<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="利用和探索">利用和探索</h3><p>利用：</p><ul><li>按照贪心策略进行选择，即选择<img src="https://math.now.sh?inline=%F0%9D%91%84_%F0%9D%91%A1%28%F0%9D%91%8E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最大的行为<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>优点：最大化即时奖励</li><li>缺点：由于<img src="https://math.now.sh?inline=%F0%9D%91%84_%F0%9D%91%A1%28%F0%9D%91%8E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>只是对<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的估计，估计的不确定性导致按照贪心策略选择的行为不一定是<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最大的行为</li></ul><p>探索：</p><ul><li>选择贪心策略之外的行为</li><li>缺点：短期奖励会比较低</li><li>优点：长期奖励会比较高 ，通过探索可以找出奖励更大的行为，供后续选择</li></ul><p>每步选择在“利用”和“探索”中二选一</p><p>如何平衡“利用”和“探索” 是关键</p><p>贪心策略形式化地表示为：<img src="https://math.now.sh?inline=A_t%20%5Cdoteq%20argmax_aQ_t%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，当有多个行为的<img src="https://math.now.sh?inline=Q_t%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>同时为最大时，随机选择一个</p><p><img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>贪心策略：</p><ul><li>以概率<img src="https://math.now.sh?inline=1%E2%88%92%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>按照贪心策略进行行为选择（Exploitation）</li><li>以概率<img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在所有行为中随机选择一个（Exploration）</li><li><img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的取值取决于<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的方差，方差越大<img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>取值应越大</li></ul><h3 id="行为估值方法">行为估值方法</h3><p>根据历史观测样本的均值对<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>进行估计</p><p>约定：</p><ul><li>当分母等于0时，<img src="https://math.now.sh?inline=%F0%9D%91%84_%F0%9D%91%A1%28%F0%9D%91%8E%29%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>当分母趋于无穷大时，<img src="https://math.now.sh?inline=%F0%9D%91%84_%F0%9D%91%A1%28%F0%9D%91%8E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>收敛到<img src="https://math.now.sh?inline=q_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>行为估值时，一个行为被选择了<img src="https://math.now.sh?inline=%F0%9D%91%9B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次后的估值记为<img src="https://math.now.sh?inline=Q_n%20%5Cdoteq%20%5Cfrac%7BR_1%2BR_2%2B%5Ccdots%2BR_n%7D%7Bn-1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，该估值方式需要记录<img src="https://math.now.sh?inline=%F0%9D%91%9B%E2%88%921" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个奖励值</p><h3 id="乐观初值法">乐观初值法</h3><p>行为的初始估值</p><ul><li>前述贪心策略中，每个行为的初始估值为0</li><li>每个行为的初始估值可以帮助我们引入先验知识</li><li>初始估值还可以帮助我们平衡exploitation 和 exploration</li></ul><p>乐观初值法：Optimistic Initial Values</p><ul><li>为每个行为赋一个高的初始估值</li><li>好处：初期每个行为都有较大机会被explore</li></ul><h3 id="小结">小结</h3><ul><li>多臂赌博机是强化学习的一个简化场景，行为和状态之间没有关联关系</li><li>扩展情形<ul><li>有上下文的多臂赌博机<ul><li>存在多个多臂赌博机，状态表示赌博机</li><li>学习状态到行为的映射</li><li>但行为不改变状态</li></ul></li></ul></li><li>更一般的情形<ul><li>马尔科夫决策过程</li></ul></li></ul><h2 id="马尔科夫决策过程">马尔科夫决策过程</h2><ul><li>常用于建模序列化决策过程</li><li>行为不仅获得即时奖励，还能改变状态，从而影响长期奖励</li><li>学习状态到行为的映射-策略<ul><li>多臂赌博机学习<img src="https://math.now.sh?inline=%F0%9D%91%9E_*%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>MDP学习<img src="https://math.now.sh?inline=%F0%9D%91%9E_%E2%88%97%28%F0%9D%91%A0%2C%F0%9D%91%8E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>或<img src="https://math.now.sh?inline=v_%E2%88%97%28%F0%9D%91%A0%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul></li></ul><h2 id="奖励设置">奖励设置</h2><ul><li>设置奖励是希望智能体能达到我们期望的目标<ul><li>下围棋<ul><li>目标：赢棋</li><li>奖励需要是能够实现赢棋这一目标才合适<ul><li>吃子多少？占领棋盘的中心？</li></ul></li></ul></li><li>迷宫<ul><li>目标：尽快走出去</li><li>奖励：每走一步，奖励为-1（相当于惩罚）</li></ul></li><li>垃圾回收机器人<ul><li>目标：在尽可能少的人工干预的情况下回收尽可能多的垃圾</li><li>奖励：回收一个垃圾奖励+1 （等待和主动寻找获得奖励的概率不同），人工干预一次奖励-3</li></ul></li></ul></li></ul><h3 id="贝尔曼方程的作用">贝尔曼方程的作用</h3><p>贝尔曼方程定义了状态估值函数的依赖关系</p><ul><li>给定策略下，每个状态的估值视为一个变量</li><li>所有状态（假如有<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个）的估值根据贝尔曼方程形成了一个具有<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个方程和<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个变量的线性方程组</li><li>求解该方程组即可得到该策略下每个状态的估值</li></ul><h3 id="寻找最优策略">寻找最优策略</h3><ul><li>基于状态估值函数的贝尔曼最优性方程<ul><li>第一步：求解状态估值函数的贝尔曼最优性方程得到最优策略对应的状态估值函数</li><li>第二步：根据状态估值函数的贝尔曼最优性方程，进行一步搜索找到每个状态下的最优行为<ul><li>注意：最优策略可以存在多个</li><li>贝尔曼最优性方程的优势，可以采用贪心局部搜索即可得到全局最优解</li></ul></li></ul></li><li>基于行为估值函数的贝尔曼最优性方程<ul><li>直接得到最优策略</li></ul></li></ul><h3 id="寻找最优策略小结">寻找最优策略小结</h3><p>求解贝尔曼最优性方程寻找最优策略的局限性</p><ul><li>需要知道环境模型<img src="https://math.now.sh?inline=p%28s'%2Cr%7Cs%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>需要高昂的计算代价和内存（存放估值函数）</li><li>依赖于马尔科夫性</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第13讲 群体智能</title>
    <link href="/2022/11/24/UCAS/advanced-ai/advanced-ai-13/"/>
    <url>/2022/11/24/UCAS/advanced-ai/advanced-ai-13/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第13讲 群体智能</p><span id="more"></span><h1>第13讲 群体智能</h1><h2 id="群体智能">群体智能</h2><ul><li>群体智能指的是无智能或者仅具有相对简单智能的主体通过合作涌现出更高智能行为的特性<ul><li>其中的个体并非绝对的无智能或只具有简单智能，而是相对于群体表现出来的智能而言是简单的。</li></ul></li><li>单个复杂个体可以实现的功能，同样可以由大量简单的个体通过群体合作实现，后者的优势在于它更健壮、灵活和经济。</li><li>群体智能利用群体优势，在没有中心控制的条件下，寻找解决复杂问题的新思路</li></ul><p>集群智能：众多无智能的个体，通过相互之间的简单合作所表现出来的智能行为</p><p>博弈：具备一定智能的理性个体，按照某种机制行动，在群体层面体现出的智能</p><p>众包：设计合适的机制，激励个体参与，从而实现单个个体不具备的社会智能</p><h2 id="集群智能">集群智能</h2><p>分布式 、 自组织的（自然/人造）系统表现出的一种群体智能</p><p>集群智能系统一般由一群简单的智能体构成，智能体按照简单的规则彼此进行局部交互，智能体也可以环境交互</p><p>灵感通常来自生物系统（蚁群、鸟群、兽群、粒子群）</p><p>特点：</p><ul><li>分布式：无中心控制</li><li>随机性：非确定性</li><li>自适应：个体根据环境进行策略调整</li><li>正反馈：个体好的尝试会对个体产生正反馈</li><li>自发涌现：会在群体层面涌现出一种智能</li></ul><h3 id="蚁群优化算法">蚁群优化算法</h3><p>一种解空间搜索方法，适用于在图上寻找最优路径</p><p>算法形式化：</p><ul><li>每个蚂蚁对应一个计算智能体</li><li>蚂蚁依概率选择候选位置进行移动</li><li>在经过的路径上留下“信息素”</li><li>“信息素”随时间挥发</li><li>“信息素”浓度大的路径在后续的选择中会以更高的概率被选取</li></ul><p><strong>TSP问题蚁群算法流程</strong></p><p>蚁群大小：一般情况下，蚁群中的蚂蚁个数不超过TSP图中节点的个数</p><p>终止条件：</p><ul><li>设定迭代轮数</li><li>设定最优解连续保持不变的迭代轮数</li></ul><p>思想：局部随机搜索+自增强</p><p>缺点：</p><ul><li>收敛速度慢</li><li>易于陷入局部最优</li><li>对于解空间为连续的优化问题不适用</li></ul><h3 id="粒子群优化算法">粒子群优化算法</h3><ul><li>粒子群优化算法是一种基于种群寻优的启发式搜索算法 。在 1995年由Kennedy和Eberhart首先提出来的。</li><li>它的主要启发来源于对鸟群群体运动行为的研究。我们经常可以观察到鸟群表现出来的同步性，虽然每只鸟的运动行为都是互相独立的，但是在整个鸟群的飞行过程中却表现出了高度一致性的复杂行为，并且可以自适应的调整飞行的状态和轨迹。</li><li>鸟群具有这样的复杂飞行行为的原因，可能是因为每只鸟在飞行过程中都遵循了一定的行为规则，并能够掌握邻域内其它鸟的飞行信息。</li><li>粒子群优化算法借鉴了这样的思想，每个粒子代表待求解问题搜索解空间中的一个潜在解，它相当于一只鸟，“飞行信息”包括粒子当前的位置和速度两个状态量。</li><li>每个粒子都可以获得其邻域内其它个体的信息，对所经过的位置进行评价，并根据这些信息和位置速度更新规则，改变自身的两个状态量，在“飞行”过程中传递信息和互相学习，去更好地适应环境。</li><li>随着这一过程的不断进行，粒子群最终能够找到问题的近似最优解。</li></ul><p><strong>是一种随机优化方法，通过粒子群在解空间中进行搜索，寻找最优解（适应度最大的解）</strong></p><h3 id="构成要素">构成要素</h3><ul><li>粒子群：<ul><li>每个粒子对应所求解问题的一个可行解</li><li>粒子通过其位置和速度表示<ul><li>粒子<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在第<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>轮的位置：<img src="https://math.now.sh?inline=x_n%5E%7B%28i%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>粒子<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在第<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>轮的速度：<img src="https://math.now.sh?inline=v_n%5E%7B%28i%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul></li></ul></li><li>记录：<ul><li><img src="https://math.now.sh?inline=%F0%9D%91%9D_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D%5E%7B%28%F0%9D%91%96%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：粒子<img src="https://math.now.sh?inline=%F0%9D%91%96" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的历史最好位置</li><li><img src="https://math.now.sh?inline=g_%7Bbest%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：全局历史最好位置</li></ul></li><li>计算适应度的函数-适应度：<img src="https://math.now.sh?inline=f%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><h3 id="算法过程描述">算法过程描述</h3><ul><li>初始化<ul><li>初始化粒子群：每个粒子的位置和速度，即<img src="https://math.now.sh?inline=%F0%9D%91%A5_0%5E%7B%28%F0%9D%91%96%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%F0%9D%91%A3_0%5E%7B%28%F0%9D%91%96%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=%F0%9D%91%9D_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D%5E%7B%28%F0%9D%91%96%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=g_%7Bbest%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul></li><li>循环执行如下三步直至满足结束条件<ul><li>计算每个粒子的适应度：<img src="https://math.now.sh?inline=%F0%9D%91%93%28%F0%9D%91%A5_%F0%9D%91%9B%5E%7B(%F0%9D%91%96%29%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>更新每个粒子历史最好适应度及其相应的位置，更新当前全局最好适应度及其相应的位置</li><li>更新每个粒子的速度和位置<ul><li><img src="https://math.now.sh?inline=%F0%9D%91%A3_%7B%F0%9D%91%9B%2B1%7D%5E%7B%28%F0%9D%91%96%29%7D%3D%F0%9D%91%A3_%F0%9D%91%9B%5E%7B(%F0%9D%91%96)%7D%2B%F0%9D%91%90_1%E2%88%97%F0%9D%91%9F_1%E2%88%97(%F0%9D%91%9D_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D%5E%7B%F0%9D%91%96%7D%E2%88%92%F0%9D%91%A5_%F0%9D%91%9B%5E%F0%9D%91%96)%2B%F0%9D%91%90_2%E2%88%97%F0%9D%91%9F_2%E2%88%97(%F0%9D%91%94_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D%E2%88%92%F0%9D%91%A5_%F0%9D%91%9B%5E%7B(%F0%9D%91%96)%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=%F0%9D%91%A5_%7B%F0%9D%91%9B%2B1%7D%5E%7B%28%F0%9D%91%96%29%7D%3D%F0%9D%91%A5_%F0%9D%91%9B%5E%7B(%F0%9D%91%96)%7D%2B%F0%9D%91%A3_%7B%F0%9D%91%9B%2B1%7D%5E%7B(i)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul></li></ul></li></ul><p>粒子速度更新公式：</p><ol><li>惯性项：保持原速度不变的倾向</li><li>记忆项：回到历史最好位置的倾向</li><li>社会项：走向粒子群全局最好位置的倾向</li><li><img src="https://math.now.sh?inline=c_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>权重参数：一般取值为2</li><li><img src="https://math.now.sh?inline=r_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>随机参数：0和1之间的随机数</li></ol><p>算法终止条件：</p><ul><li>迭代的轮数</li><li>最佳位置连续未更新的轮数</li><li>适应度函数的值到达预期要求</li></ul><p>速度更新参数：又称加速度参数，用来控制粒子当前最优位置<img src="https://math.now.sh?inline=%F0%9D%91%9D_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D%5E%7B%28%F0%9D%91%96%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和粒子群当前最优位置<img src="https://math.now.sh?inline=%F0%9D%91%94_%7B%F0%9D%91%8F%F0%9D%91%92%F0%9D%91%A0%F0%9D%91%A1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对粒子飞行速度的影响</p><ul><li><img src="https://math.now.sh?inline=c_1%3E0%2C%20c_2%20%3D%200" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：每个微粒执行局部搜索；</li><li><img src="https://math.now.sh?inline=c_1%3D0%2C%20c_2%20%3E%200" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：微粒群转化为一个随机爬山法</li><li><img src="https://math.now.sh?inline=c_1%3Dc_2%20%3E%200" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：微粒逐渐移向<img src="https://math.now.sh?inline=%5Cvec%7Bp_g%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5Cvec%7Bp_i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的加权均值</li><li><img src="https://math.now.sh?inline=c_2%3Ec_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：算法比较适合于单峰优化问题</li><li><img src="https://math.now.sh?inline=c_1%3E%20c_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：算法比较适合于多峰优化问题</li></ul><p>惯性权重：速度冲量导致微粒按照先前速度方向继续移动。提出一个惯性权重<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来控制先前微粒速度的影响</p><h3 id="粒子群优化算法和遗传算法相比">粒子群优化算法和遗传算法相比</h3><ul><li>遗传算法强调“适者生存”，不好的个体在竞争中被淘汰； PSO 强调“协同合作”，不好的个体通过学习向好的方向转变。</li><li>遗传算法中最好的个体通过产生更多的后代来传播基因；PSO 中的最好个体通过吸引其它个体向它靠近来施加影响。</li><li>遗传算法的选择概率只与上一代群体相关，而与历史无关，群体的信息变化过程是一个Markov链过程；而PSO中的个体除了有位置和速度外，还有着过去的历史信息（pBest, gBest）。</li></ul><p>优点：</p><ul><li>易于实现</li><li>可调参数较少</li><li>所需种群或微粒群规模较小</li><li>计算效率高，收敛速度快</li></ul><p>缺点：和其它演化计算算法类似，不保证收敛到全局最优解</p><h3 id="粒子群优化算法代码">粒子群优化算法代码</h3><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">def</span> <span class="hljs-title function_">cal</span>(<span class="hljs-params">x</span>):    <span class="hljs-keyword">return</span> x*x*x-<span class="hljs-number">5</span>*x*x-<span class="hljs-number">2</span>*x+<span class="hljs-number">3</span>x_min = -<span class="hljs-number">2</span>x_max = <span class="hljs-number">5</span>p_num = <span class="hljs-number">1000</span>g_best_max = <span class="hljs-number">1</span>g_best_max_i = <span class="hljs-number">0</span>g_best_min = <span class="hljs-number">1</span>g_best_min_i = <span class="hljs-number">0</span>x_MAX = (x_max - x_min) * np.random.random_sample((p_num,)) + x_minv_MAX = (x_max - x_min) * np.random.random_sample((p_num,)) + x_minx_MIN = (x_max - x_min) * np.random.random_sample((p_num,)) + x_minv_MIN = (x_max - x_min) * np.random.random_sample((p_num,)) + x_minp_best_max = np.ones_like(x_MAX)p_best_min = np.ones_like(x_MAX)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10000</span>):    f_max = cal(x_MAX)    f_min = cal(x_MIN)    t_max = cal(p_best_max)    t_min = cal(p_best_min)    p_best_max = np.where(t_max &gt; f_max, p_best_max, x_MAX)    p_best_min = np.where(t_min &lt; f_min, p_best_min, x_MIN)    <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">max</span>(f_max) &gt; g_best_max:        g_best_max = np.<span class="hljs-built_in">max</span>(f_max)        g_best_max_i = x_MAX[np.argmax(f_max)]    <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">min</span>(f_min) &lt; g_best_min:        g_best_min = np.<span class="hljs-built_in">min</span>(f_min)        g_best_min_i = x_MIN[np.argmin(f_min)]    v_MAX = v_MAX + (p_best_max - x_MAX) + (g_best_max - x_MAX)    x_MAX = x_MAX + v_MAX    x_MAX = np.where(x_MAX &gt; x_max,x_max,x_MAX)    x_MAX = np.where(x_MAX &lt; x_min,x_min,x_MAX)    v_MIN = v_MIN + (p_best_min - x_MIN) + (g_best_min - x_MIN)    x_MIN = x_MIN + v_MIN    x_MIN = np.where(x_MIN &gt; x_max,x_max,x_MIN)    x_MIN = np.where(x_MIN &lt; x_min,x_min,x_MIN)<span class="hljs-built_in">print</span>(g_best_max_i)<span class="hljs-built_in">print</span>(g_best_min_i)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go项目-Gee Web框架</title>
    <link href="/2022/11/21/Go/Go-Project-Gee/"/>
    <url>/2022/11/21/Go/Go-Project-Gee/</url>
    
    <content type="html"><![CDATA[<p>Go项目-Gee Web框架</p><span id="more"></span><h1>完成的功能</h1><ul><li>简单介绍 <code>net/http</code>库以及 <code>http.Handler</code>接口</li><li>将 <code>路由(router)</code>独立出来，方便之后增强。</li><li>设计 <code>上下文(Context)</code>，封装 Request 和 Response ，提供对 JSON、HTML 等返回类型的支持。</li><li>使用 Trie 树实现动态路由(dynamic route)解析。</li><li>实现路由分组控制(Route Group Control)</li><li>设计并实现 Web 框架的中间件(Middlewares)机制。</li><li>实现通用的 <code>Logger</code>中间件，能够记录请求到响应所花费的时间，</li><li>实现静态资源服务(Static Resource)。</li><li>支持HTML模板渲染。</li><li>实现错误处理机制。</li></ul><h1>http.Handler</h1><p>Go语言内置了 <code>net/http</code>库，封装了HTTP网络编程的基础的接口，使用这个库：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 设置两个路由</span>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, indexHandler)http.HandleFunc(<span class="hljs-string">&quot;/hello&quot;</span>, helloHandler)<span class="hljs-comment">// 启动Web服务，在9999端口进行监听，处理所有的HTTP请求的实例</span>http.ListenAndServe(<span class="hljs-string">&quot;localhost:9999&quot;</span>, <span class="hljs-literal">nil</span>)<span class="hljs-comment">// 最后的nil即为实现框架的入口</span>&#125;<span class="hljs-comment">// 根路由</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path=%q\n&quot;</span>, req.URL.Path)&#125;<span class="hljs-comment">// hello路由</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helloHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q] = %q\n&quot;</span>, k, v)&#125;&#125;</code></pre></div><p>使用curl进行测试：</p><div class="code-wrapper"><pre><code class="hljs bash">&gt; curl http://localhost:9999/URL.Path=<span class="hljs-string">&quot;/&quot;</span>&gt; curl http://localhost:9999/helloHeader[<span class="hljs-string">&quot;User-Agent&quot;</span>] = [<span class="hljs-string">&quot;curl/7.68.0&quot;</span>]Header[<span class="hljs-string">&quot;Accept&quot;</span>] = [<span class="hljs-string">&quot;*/*&quot;</span>]</code></pre></div><p>其中代码的nil就是一个接口，需要实现方法 ServeHTTP ，也就是说，只要传入任何实现了 ServerHTTP 接口的实例，所有的HTTP请求，就都交给了该实例处理了。</p><p>拦截一下请求进行尝试</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-comment">// 定义一个空结构体，因为后面实现的是一个方法，比如在一个结构体的基础上进行实现</span><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-comment">// 实现ServeHTTP方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<span class="hljs-keyword">switch</span> req.URL.Path &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span>:fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path=%q\n&quot;</span>, req.URL.Path)<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/hello&quot;</span>:<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q] = %q\n&quot;</span>, k, v)&#125;<span class="hljs-keyword">default</span>:fmt.Fprintf(w, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;engine := &amp;Engine&#123;&#125;<span class="hljs-comment">// 多设置一个路由</span>http.HandleFunc(<span class="hljs-string">&quot;/hi&quot;</span>, indexHandler)<span class="hljs-comment">// 启动Web服务，在9999端口进行监听，处理所有的HTTP请求的实例</span>http.ListenAndServe(<span class="hljs-string">&quot;localhost:9999&quot;</span>, engine)<span class="hljs-comment">// 最后的nil即为实现框架的入口</span>&#125;<span class="hljs-comment">// 根路由</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">indexHandler</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path=%q\n&quot;</span>, req.URL.Path)&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs bash">&gt; curl http://localhost:9999/helloHeader[<span class="hljs-string">&quot;User-Agent&quot;</span>] = [<span class="hljs-string">&quot;curl/7.68.0&quot;</span>]Header[<span class="hljs-string">&quot;Accept&quot;</span>] = [<span class="hljs-string">&quot;*/*&quot;</span>]&gt; curl http://localhost:9999/URL.Path=<span class="hljs-string">&quot;/&quot;</span>&gt; curl http://localhost:9999/hi404 NOT FOUND: /hi</code></pre></div><p>因此就将所有的HTTP请求转向了自己的处理逻辑，代码的运行结果与之前的是一致的。</p><p>我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等。</p><p>因此就可以从这里入手完成这个Web框架，最终的代码结构是这样的</p><div class="code-wrapper"><pre><code class="hljs bash">.├── gee│   └── gee.go└── main.go</code></pre></div><p>main.go：</p><p>使用 <code>New()</code>创建 gee 的实例，使用 <code>GET()</code>方法添加路由，最后使用 <code>Run()</code>启动Web服务。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Gee/gee&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gee.New()r.Get(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path=%q\n&quot;</span>, req.URL.Path)&#125;)r.Get(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> req.Header &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q] = %q\n&quot;</span>, k, v)&#125;&#125;)r.Run(<span class="hljs-string">&quot;localhost:9999&quot;</span>)&#125;</code></pre></div><p>gee.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-comment">// 定义一个普遍使用的函数类型，避免后面再次定义</span><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(http.ResponseWriter, *http.Request)</span></span><span class="hljs-comment">// 定义路由表</span><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;router <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc&#125;<span class="hljs-comment">// 工厂模式的构造方法，返回一个实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<span class="hljs-keyword">return</span> &amp;Engine&#123;router: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),&#125;&#125;<span class="hljs-comment">// 将路由添加到路由表中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> addRoute(method, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;key := method + <span class="hljs-string">&quot;-&quot;</span> + patternengine.router[key] = handler&#125;<span class="hljs-comment">// 实现GET方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;engine.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)&#125;<span class="hljs-comment">// 实现POST方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;engine.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)&#125;<span class="hljs-comment">// 实现Run方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)&#125;<span class="hljs-comment">// 完成统一的控制入口方法ServeHTTP</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;key := req.Method + <span class="hljs-string">&quot;-&quot;</span> + req.URL.Path<span class="hljs-keyword">if</span> handler, ok := engine.router[key]; ok &#123;handler(w, req)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, req.URL)&#125;&#125;</code></pre></div><p>测试后的效果和之前完全相同。</p><p>整个 <code>Gee</code>框架的原型已经出来了。实现了路由映射表，提供了用户注册静态路由的方法，包装了启动服务的函数。</p><h1>上下文Context</h1><p>最终调用的效果：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Gee/gee&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gee.New()r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;c.HTML(http.StatusOK, <span class="hljs-string">&quot;&lt;h1&gt;Hello Gee&lt;/h1&gt;&quot;</span>)&#125;)r.GET(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;c.String(http.StatusOK, <span class="hljs-string">&quot;hello %s, you&#x27;re at %s\n&quot;</span>, c.Query(<span class="hljs-string">&quot;name&quot;</span>), c.Path)&#125;)r.POST(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;c.JSON(http.StatusOK, gee.H&#123;<span class="hljs-string">&quot;username&quot;</span>: c.PostForm(<span class="hljs-string">&quot;username&quot;</span>),<span class="hljs-string">&quot;password&quot;</span>: c.PostForm(<span class="hljs-string">&quot;password&quot;</span>),&#125;)&#125;)r.Run(<span class="hljs-string">&quot;localhost:9999&quot;</span>)&#125;</code></pre></div><ul><li><code>Handler</code>的参数变成成了 <code>gee.Context</code>，提供了查询Query/PostForm参数的功能。</li><li><code>gee.Context</code>封装了 <code>HTML/String/JSON</code>函数，能够快速构造HTTP响应。</li></ul><ol><li>对Web服务来说，无非是根据请求 <code>*http.Request</code>，构造响应 <code>http.ResponseWriter</code>。但是这两个对象提供的接口粒度太细，比如我们要构造一个完整的响应，需要考虑消息头(Header)和消息体(Body)，而 Header 包含了状态码(StatusCode)，消息类型(ContentType)等几乎每次请求都需要设置的信息。因此，如果不进行有效的封装，那么框架的用户将需要写大量重复，繁杂的代码，而且容易出错。针对常用场景，能够高效地构造出 HTTP 响应是一个好的框架必须考虑的点。</li><li>针对使用场景，封装 <code>*http.Request</code>和 <code>http.ResponseWriter</code>的方法，简化相关接口的调用，只是设计 Context 的原因之一。对于框架来说，还需要支撑额外的功能。例如，将来解析动态路由 <code>/hello/:name</code>，参数 <code>:name</code>的值放在哪呢？再比如，框架需要支持中间件，那中间件产生的信息放在哪呢？Context 随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载。因此，设计 Context 结构，扩展性和复杂性留在了内部，而对外简化了接口。路由的处理函数，以及将要实现的中间件，参数都统一使用 Context 实例， Context 就像一次会话的百宝箱，可以找到任何东西。</li></ol><p>context.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-comment">// 给map[string]interface&#123;&#125;起了一个别名gee.H，构建JSON数据时，显得更简洁。</span><span class="hljs-keyword">type</span> H <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 原始的两个参数</span>Writer http.ResponseWriterReq    *http.Request<span class="hljs-comment">// 请求信息</span>Path   <span class="hljs-type">string</span>Method <span class="hljs-type">string</span><span class="hljs-comment">// 响应信息</span>StatusCode <span class="hljs-type">int</span>&#125;<span class="hljs-comment">// 创建一个Context实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newContext</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> *Context &#123;<span class="hljs-keyword">return</span> &amp;Context&#123;Writer: w,Req:    req,Path:   req.URL.Path,Method: req.Method,&#125;&#125;<span class="hljs-comment">// 根据key返回用户输入的value,属于POST方法的工具</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> PostForm(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> c.Req.FormValue(key)&#125;<span class="hljs-comment">// 根据key返回用户输入的value,属于GET方法的工具</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Query(key <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> c.Req.URL.Query().Get(key)&#125;<span class="hljs-comment">// 写入状态码并更改Context的状态码</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Status(code <span class="hljs-type">int</span>) &#123;c.StatusCode = codec.Writer.WriteHeader(code)&#125;<span class="hljs-comment">// 帮助下面的方法快速构造响应</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> SetHeader(key, value <span class="hljs-type">string</span>) &#123;c.Writer.Header().Set(key, value)&#125;<span class="hljs-comment">// 构造字符串类型的响应</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> String(code <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, values ...<span class="hljs-keyword">interface</span>&#123;&#125;) &#123;c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/plain&quot;</span>)c.Status(code)c.Writer.Write([]<span class="hljs-type">byte</span>(fmt.Sprintf(format, values...)))&#125;<span class="hljs-comment">// 构造JSON类型的响应</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> JSON(code <span class="hljs-type">int</span>, obj <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)c.Status(code)encoder := json.NewEncoder(c.Writer) <span class="hljs-comment">// 流数据构造json</span><span class="hljs-keyword">if</span> err := encoder.Encode(obj); err != <span class="hljs-literal">nil</span> &#123;http.Error(c.Writer, err.Error(), <span class="hljs-number">500</span>)&#125;&#125;<span class="hljs-comment">// 构造data类型的响应</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Data(code <span class="hljs-type">int</span>, data []<span class="hljs-type">byte</span>) &#123;c.Status(code)c.Writer.Write(data)&#125;<span class="hljs-comment">// 构造HTML类型的响应</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, html <span class="hljs-type">string</span>) &#123;c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)c.Status(code)c.Writer.Write([]<span class="hljs-type">byte</span>(html))&#125;</code></pre></div><p>将和路由相关的方法和结构提取出来，放到了一个新的文件中 <code>router.go</code>，方便我下一次对 router 的功能进行增强，</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-keyword">type</span> router <span class="hljs-keyword">struct</span> &#123;handlers <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newRouter</span><span class="hljs-params">()</span></span> *router &#123;<span class="hljs-keyword">return</span> &amp;router&#123;handlers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]HandlerFunc),&#125;&#125;<span class="hljs-comment">// 将路由添加到路由表中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;log.Printf(<span class="hljs-string">&quot;Route %4s - %s&quot;</span>, method, pattern)key := method + <span class="hljs-string">&quot;-&quot;</span> + patternr.handlers[key] = handler&#125;<span class="hljs-comment">// 路由处理</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + c.Path<span class="hljs-keyword">if</span> handler, ok := r.handlers[key]; ok &#123;handler(c)&#125; <span class="hljs-keyword">else</span> &#123;c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)&#125;&#125;</code></pre></div><p>调整主框架入口gee.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-comment">// 定义一个普遍使用的函数类型，避免后面再次定义</span><span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*Context)</span></span><span class="hljs-comment">// 定义路由表</span><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;router *router&#125;<span class="hljs-comment">// 工厂模式的构造方法，返回一个实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;<span class="hljs-keyword">return</span> &amp;Engine&#123;router: newRouter(),&#125;&#125;<span class="hljs-comment">// 实现GET方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> GET(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;engine.router.addRoute(<span class="hljs-string">&quot;GET&quot;</span>, pattern, handler)&#125;<span class="hljs-comment">// 实现POST方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> POST(pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;engine.router.addRoute(<span class="hljs-string">&quot;POST&quot;</span>, pattern, handler)&#125;<span class="hljs-comment">// 实现Run方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> Run(addr <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">return</span> http.ListenAndServe(addr, engine)&#125;<span class="hljs-comment">// 完成统一的控制入口方法ServeHTTP</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;c := newContext(w, req)engine.router.handle(c)&#125;</code></pre></div><p>测试代码</p><p>启动程序后：</p><div class="code-wrapper"><pre><code class="hljs bash">2022/11/21 21:05:40 Route  GET - /2022/11/21 21:05:40 Route  GET - /hello2022/11/21 21:05:40 Route POST - /login</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">&gt; curl -i http://localhost:9999/HTTP/1.1 200 OKContent-Type: text/htmlDate: Mon, 21 Nov 2022 13:05:47 GMTContent-Length: 19&lt;h1&gt;Hello Gee&lt;/h1&gt;&gt; curl <span class="hljs-string">&quot;http://localhost:9999/hello?name=geektutu&quot;</span>hello geektutu, you<span class="hljs-string">&#x27;re at /hello</span><span class="hljs-string">&gt; curl &quot;http://localhost:9999/login&quot; -X POST -d &#x27;</span>username=geektutu&amp;password=1234<span class="hljs-string">&#x27;</span><span class="hljs-string">&#123;&quot;password&quot;:&quot;1234&quot;,&quot;username&quot;:&quot;geektutu&quot;&#125;</span><span class="hljs-string">&gt; curl &quot;http://localhost:9999/xxx&quot;</span><span class="hljs-string">404 NOT FOUND: /xxx</span></code></pre></div><h1>前缀树路由</h1><p>之前，我们用了一个非常简单的 <code>map</code>结构存储了路由表，使用 <code>map</code>存储键值对，索引非常高效，但是有一个弊端，键值对的存储的方式，只能用来索引静态路由。那如果我们想支持类似于 <code>/hello/:name</code>这样的动态路由怎么办呢？</p><p>实现动态路由最常用的数据结构，被称为前缀树(Trie树)，每一个节点的所有的子节点都拥有相同的前缀。这种结构非常适用于路由匹配。</p><p>首先设计树节点上应该存储哪些信息</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> node <span class="hljs-keyword">struct</span> &#123;pattern  <span class="hljs-type">string</span>  <span class="hljs-comment">// 待匹配路由，例如 /p/:lang</span>part     <span class="hljs-type">string</span>  <span class="hljs-comment">// 路由中的一部分，例如 :lang</span>children []*node <span class="hljs-comment">// 子节点，例如 [doc, tutorial, intro]</span>isWild   <span class="hljs-type">bool</span>    <span class="hljs-comment">// 是否精确匹配，part 含有 : 或 * 时为true</span>&#125;</code></pre></div><p>将匹配的逻辑，包装为一个辅助函数：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 查找第一个匹配的节点，用于插入</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> matchChild(part <span class="hljs-type">string</span>) *node &#123;<span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children &#123;<span class="hljs-keyword">if</span> child.part == part || n.isWild &#123;<span class="hljs-keyword">return</span> child&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-comment">// 查找全部匹配的节点，用于查找</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> matchChildren(part <span class="hljs-type">string</span>) []*node &#123;nodes := <span class="hljs-built_in">make</span>([]*node, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> n.children &#123;<span class="hljs-keyword">if</span> child.part == part || n.isWild &#123;nodes = <span class="hljs-built_in">append</span>(nodes, child)&#125;&#125;<span class="hljs-keyword">return</span> nodes&#125;</code></pre></div><p>实现节点的递归插入和查找</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 插入节点</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> insert(pattern <span class="hljs-type">string</span>, parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) &#123;<span class="hljs-comment">// 到达高度了就停止</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height &#123;n.pattern = pattern<span class="hljs-keyword">return</span>&#125;part := parts[height]       <span class="hljs-comment">// 获取当前的规则</span>child := n.matchChild(part) <span class="hljs-comment">// 尝试用当前的规则进行匹配</span><span class="hljs-comment">// 如果没有匹配成功，就新建一个节点，并加入到当前节点的孩子们中去</span><span class="hljs-keyword">if</span> child == <span class="hljs-literal">nil</span> &#123;child = &amp;node&#123;part:   part,isWild: part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> || part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span>,&#125;n.children = <span class="hljs-built_in">append</span>(n.children, child)&#125;<span class="hljs-comment">// 递归进行插入</span>child.insert(pattern, parts, height+<span class="hljs-number">1</span>)&#125;<span class="hljs-comment">// 查询节点</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> search(parts []<span class="hljs-type">string</span>, height <span class="hljs-type">int</span>) *node &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(parts) == height || strings.HasPrefix(n.part, <span class="hljs-string">&quot;*&quot;</span>) &#123;<span class="hljs-keyword">if</span> n.pattern == <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> n&#125;part := parts[height]             <span class="hljs-comment">// 获取当前的规则</span>children := n.matchChildren(part) <span class="hljs-comment">// 尝试用当前的规则进行匹配</span><span class="hljs-comment">// 遍历所有当前匹配的节点进行递归匹配</span><span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> children &#123;result := child.search(parts, height+<span class="hljs-number">1</span>)<span class="hljs-keyword">if</span> result != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> result&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>使用 roots 来存储每种请求方式的Trie 树根节点。使用 handlers 存储每种请求方式的 HandlerFunc 。getRoute 函数中解析了 <code>:</code>和 <code>*</code>两种匹配符的参数，返回一个 map 。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 将字符串解析成一个切片</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePattern</span><span class="hljs-params">(pattern <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;vs := strings.Split(pattern, <span class="hljs-string">&quot;/&quot;</span>)parts := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> vs &#123;<span class="hljs-keyword">if</span> item != <span class="hljs-string">&quot;&quot;</span> &#123;parts = <span class="hljs-built_in">append</span>(parts, item)<span class="hljs-keyword">if</span> item[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<span class="hljs-keyword">break</span>&#125;&#125;&#125;<span class="hljs-keyword">return</span> parts&#125;<span class="hljs-comment">// 将路由添加到路由表中</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> addRoute(method, pattern <span class="hljs-type">string</span>, handler HandlerFunc) &#123;parts := parsePattern(pattern)key := method + <span class="hljs-string">&quot;-&quot;</span> + pattern<span class="hljs-comment">// 先看看是不是Get或者Post方法</span>_, ok := r.roots[method]<span class="hljs-keyword">if</span> !ok &#123;r.roots[method] = &amp;node&#123;&#125;&#125;r.roots[method].insert(pattern, parts, <span class="hljs-number">0</span>)r.handlers[key] = handler&#125;<span class="hljs-comment">// 从路由表中查找路由</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> getRoute(method, path <span class="hljs-type">string</span>) (*node, <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) &#123;searchParts := parsePattern(path)params := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)root, ok := r.roots[method]<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;n := root.search(searchParts, <span class="hljs-number">0</span>)<span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;parts := parsePattern(n.pattern)<span class="hljs-keyword">for</span> index, part := <span class="hljs-keyword">range</span> parts &#123;<span class="hljs-keyword">if</span> part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;:&#x27;</span> &#123;params[part[<span class="hljs-number">1</span>:]] = searchParts[index]&#125;<span class="hljs-keyword">if</span> part[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; <span class="hljs-built_in">len</span>(part) &gt; <span class="hljs-number">1</span> &#123;params[part[<span class="hljs-number">1</span>:]] = strings.Join(searchParts[index:], <span class="hljs-string">&quot;/&quot;</span>)<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-keyword">return</span> n, params&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>对 Context 对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到 <code>Params</code>中</p><p>更改路由处理的方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 路由处理</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;n, params := r.getRoute(c.Method, c.Path)<span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;c.Params = paramskey := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.patternr.handlers[key](c)&#125; <span class="hljs-keyword">else</span> &#123;c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)&#125;&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs bash">&gt; curl <span class="hljs-string">&quot;http://localhost:9999/hello/geektutu&quot;</span>hello geektutu, you<span class="hljs-string">&#x27;re at /hello/geektutu</span><span class="hljs-string">&gt; curl &quot;http://localhost:9999/assets/css/geektutu.css&quot;</span><span class="hljs-string">&#123;&quot;filepath&quot;:&quot;css/geektutu.css&quot;&#125;</span></code></pre></div><h1>分组控制Group</h1><p>真实的业务场景中，往往某一组路由需要相似的处理。例如：</p><ul><li>以 <code>/post</code>开头的路由匿名可访问。</li><li>以 <code>/admin</code>开头的路由需要鉴权。</li><li>以 <code>/api</code>开头的路由是 RESTful 接口，可以对接第三方平台，需要三方平台鉴权。</li></ul><p>一个 Group 对象需要具备哪些属性呢？</p><p>首先是前缀(prefix)，比如 <code>/</code>，或者 <code>/api</code>；</p><p>要支持分组嵌套，那么需要知道当前分组的父亲(parent)是谁；</p><p>中间件是应用在分组上的，那还需要存储应用在该分组上的中间件(middlewares)。</p><p>还需要有访问 <code>Router</code>的能力</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 分组路由</span><span class="hljs-keyword">type</span> RouterGroup <span class="hljs-keyword">struct</span> &#123;prefix      <span class="hljs-type">string</span>middlewares []HandlerFuncparent      *RouterGroupengine      *Engine&#125;</code></pre></div><p>将 <code>Engine</code>作为最顶层的分组，也就是说 <code>Engine</code>拥有 <code>RouterGroup</code>所有的能力。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 扩展Engine</span><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;*RouterGrouprouter *routergroups []*RouterGroup&#125;</code></pre></div><p>更改下面的其他Engine方法即可</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 工厂模式的构造方法，返回一个实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> *Engine &#123;engine := &amp;Engine&#123;router: newRouter(),&#125;engine.RouterGroup = &amp;RouterGroup&#123;engine: engine,&#125;engine.groups = []*RouterGroup&#123;engine.RouterGroup&#125;<span class="hljs-keyword">return</span> engine&#125;</code></pre></div><p>增加一个Group的方法，创建一个新的RouterGroup</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 创建一个新的RouterGroup</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Group(prefix <span class="hljs-type">string</span>) *RouterGroup &#123;engine := group.enginenewGroup := &amp;RouterGroup&#123;prefix: group.prefix + prefix,parent: group,engine: engine,&#125;engine.groups = <span class="hljs-built_in">append</span>(engine.groups, newGroup)<span class="hljs-keyword">return</span> newGroup&#125;</code></pre></div><p>后面的Get方法和Post方法就都换成RouterGroup的方法就可以了</p><p>测试：</p><div class="code-wrapper"><pre><code class="hljs bash">&gt; curl <span class="hljs-string">&quot;http://localhost:9999/v1/hello?name=geektutu&quot;</span>hello geektutu, you<span class="hljs-string">&#x27;re at /v1/hello</span><span class="hljs-string">&gt; curl &quot;http://localhost:9999/v2/hello/geektutu&quot;</span><span class="hljs-string">hello geektutu, you&#x27;</span>re at /v2/hello/geektutu&gt; curl <span class="hljs-string">&quot;http://localhost:9999/index&quot;</span>&lt;h1&gt;Index Page&lt;/h1&gt;</code></pre></div><h1>中间件Middleware</h1><p>中间件(middlewares)，简单说，就是非业务的技术类组件。Web 框架本身不可能去理解所有的业务，因而不可能实现所有的功能。因此，框架需要有一个插口，允许用户自己定义功能，嵌入到框架中，仿佛这个功能是框架原生支持的一样。因此，对中间件而言，需要考虑2个比较关键的点：</p><ul><li>插入点在哪？使用框架的人并不关心底层逻辑的具体实现，如果插入点太底层，中间件逻辑就会非常复杂。如果插入点离用户太近，那和用户直接定义一组函数，每次在 Handler 中手工调用没有多大的优势了。</li><li>中间件的输入是什么？中间件的输入，决定了扩展能力。暴露的参数太少，用户发挥空间有限。</li></ul><p>Gee 的中间件的定义与路由映射的 Handler 一致，处理的输入是 <code>Context</code>对象。插入点是框架接收到请求初始化 <code>Context</code>对象后，允许用户使用自己定义的中间件做一些额外的处理，例如记录日志等，以及对 <code>Context</code>进行二次加工。另外通过调用 <code>(*Context).Next()</code>函数，中间件可等待用户自己定义的 <code>Handler</code>处理结束后，再做一些额外的操作，例如计算本次处理所用时间等。即 Gee 的中间件支持用户在请求被处理的前后，做一些额外的操作。举个例子，我们希望最终能够支持如下定义的中间件，<code>c.Next()</code>表示等待执行其他的中间件或用户的 <code>Handler</code>：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Logger</span><span class="hljs-params">()</span></span> HandlerFunc &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;t := time.Now()                                                            <span class="hljs-comment">// 开始计时</span>c.Next()                                                                   <span class="hljs-comment">// 等待用户自己的Handler处理结束</span>log.Printf(<span class="hljs-string">&quot;[%d] %s in %v&quot;</span>, c.StatusCode, c.Req.RequestURI, time.Since(t)) <span class="hljs-comment">// 打印时间</span>&#125;&#125;</code></pre></div><p>中间件是应用在 <code>RouterGroup</code>上的，应用在最顶层的 Group，相当于作用于全局，所有的请求都会被中间件处理。</p><p>给 <code>Context</code>添加了2个参数，定义了 <code>Next</code>方法：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> Next() &#123;c.index++s := <span class="hljs-built_in">len</span>(c.handlers)<span class="hljs-keyword">for</span> ; c.index &lt; s; c.index++ &#123;c.handlers[c.index](c)&#125;&#125;</code></pre></div><p><code>index</code>是记录当前执行到第几个中间件，当在中间件中调用 <code>Next</code>方法时，控制权交给了下一个中间件，直到调用到最后一个中间件，然后再从后往前，调用每个中间件在 <code>Next</code>方法之后定义的部分。</p><p>定义 <code>Use</code>函数，将中间件应用到某个 Group 。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Use(middlewares ...HandlerFunc) &#123;group.middlewares = <span class="hljs-built_in">append</span>(group.middlewares, middlewares...)&#125;</code></pre></div><p>ServeHTTP 函数也有变化，当我们接收到一个具体请求时，要判断该请求适用于哪些中间件，在这里我们简单通过 URL 的前缀来判断。得到中间件列表后，赋值给 <code>c.handlers</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 完成统一的控制入口方法ServeHTTP</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<span class="hljs-keyword">var</span> middlewares []HandlerFunc<span class="hljs-keyword">for</span> _, group := <span class="hljs-keyword">range</span> engine.groups &#123;<span class="hljs-keyword">if</span> strings.HasPrefix(req.URL.Path, group.prefix) &#123;middlewares = <span class="hljs-built_in">append</span>(middlewares, group.middlewares...)&#125;&#125;c := newContext(w, req)c.handlers = middlewaresengine.router.handle(c)&#125;</code></pre></div><p>handle 函数中，将从路由匹配得到的 Handler 添加到 <code>c.handlers</code>列表中，执行 <code>c.Next()</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 路由处理</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *router)</span></span> handle(c *Context) &#123;n, params := r.getRoute(c.Method, c.Path)<span class="hljs-keyword">if</span> n != <span class="hljs-literal">nil</span> &#123;key := c.Method + <span class="hljs-string">&quot;-&quot;</span> + n.patternc.Params = paramsc.handlers = <span class="hljs-built_in">append</span>(c.handlers, r.handlers[key])&#125; <span class="hljs-keyword">else</span> &#123;c.handlers = <span class="hljs-built_in">append</span>(c.handlers, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;c.String(http.StatusNotFound, <span class="hljs-string">&quot;404 NOT FOUND: %s\n&quot;</span>, c.Path)&#125;)&#125;c.Next()&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs bash">&gt; go run Go-Projects/Gee2022/11/22 15:45:00 Route  GET - /2022/11/22 15:45:00 Route  GET - /v2/hello/:name&gt;2022/11/22 15:45:11 [200] / <span class="hljs-keyword">in</span> 3µs&gt;2022/11/22 15:45:25 [500] /v2/hello/geektutu <span class="hljs-keyword">in</span> 39.4µs <span class="hljs-keyword">for</span> group v22022/11/22 15:45:25 [500] /v2/hello/geektutu <span class="hljs-keyword">in</span> 77.6µs</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash">&gt; curl http://localhost:9999/&lt;h1&gt;Hello Gee&lt;/h1&gt;&gt; curl http://localhost:9999/v2/hello/geektutu&#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;Internal Server Error&quot;</span>&#125;</code></pre></div><h1>模板(HTML Template)</h1><p>Web 框架如何支持服务端渲染的场景</p><p>解析请求的地址，映射到服务器上文件的真实地址：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 解析请求的地址，映射到服务器上文件的真实地址</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> createStaticHandler(relativePath <span class="hljs-type">string</span>, fs http.FileSystem) HandlerFunc &#123;absolutePath := path.Join(group.prefix, relativePath)fileServer := http.StripPrefix(absolutePath, http.FileServer(fs))<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;file := c.Param(<span class="hljs-string">&quot;filepath&quot;</span>)<span class="hljs-comment">// Check if file exists and/or if we have permission to access it</span><span class="hljs-keyword">if</span> _, err := fs.Open(file); err != <span class="hljs-literal">nil</span> &#123;c.Status(http.StatusNotFound)<span class="hljs-keyword">return</span>&#125;fileServer.ServeHTTP(c.Writer, c.Req)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(group *RouterGroup)</span></span> Static(relativePath <span class="hljs-type">string</span>, root <span class="hljs-type">string</span>) &#123;handler := group.createStaticHandler(relativePath, http.Dir(root))urlPattern := path.Join(relativePath, <span class="hljs-string">&quot;/*filepath&quot;</span>)<span class="hljs-comment">// Register GET handlers</span>group.GET(urlPattern, handler)&#125;</code></pre></div><p>HTML 模板渲染</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 扩展Engine</span><span class="hljs-keyword">type</span> Engine <span class="hljs-keyword">struct</span> &#123;*RouterGrouprouter        *routergroups        []*RouterGrouphtmlTemplates *template.Template <span class="hljs-comment">// 模板渲染</span>funcMap       template.FuncMap   <span class="hljs-comment">// 模板渲染</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> SetFuncMap(funcMap template.FuncMap) &#123;engine.funcMap = funcMap&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(engine *Engine)</span></span> LoadHTMLGlob(pattern <span class="hljs-type">string</span>) &#123;engine.htmlTemplates = template.Must(template.New(<span class="hljs-string">&quot;&quot;</span>).Funcs(engine.funcMap).ParseGlob(pattern))&#125;</code></pre></div><p>对原来的 <code>(*Context).HTML()</code>方法做了些小修改，使之支持根据模板文件名选择模板进行渲染。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 构造HTML类型的响应</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Context)</span></span> HTML(code <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>, data <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;c.SetHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;text/html&quot;</span>)c.Status(code)<span class="hljs-keyword">if</span> err := c.engine.htmlTemplates.ExecuteTemplate(c.Writer, name, data); err != <span class="hljs-literal">nil</span> &#123;c.Fail(<span class="hljs-number">500</span>, err.Error())&#125;&#125;</code></pre></div><p>进行测试：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Gee/gee&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;html/template&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-type">string</span>Age  <span class="hljs-type">int8</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FormatAsDate</span><span class="hljs-params">(t time.Time)</span></span> <span class="hljs-type">string</span> &#123;year, month, day := t.Date()<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d-%02d-%02d&quot;</span>, year, month, day)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;r := gee.New()r.Use(gee.Logger())r.SetFuncMap(template.FuncMap&#123;<span class="hljs-string">&quot;FormatAsDate&quot;</span>: FormatAsDate,&#125;)r.LoadHTMLGlob(<span class="hljs-string">&quot;Gee/templates/*&quot;</span>)r.Static(<span class="hljs-string">&quot;/assets&quot;</span>, <span class="hljs-string">&quot;./static&quot;</span>)stu1 := &amp;student&#123;Name: <span class="hljs-string">&quot;Geektutu&quot;</span>, Age: <span class="hljs-number">20</span>&#125;stu2 := &amp;student&#123;Name: <span class="hljs-string">&quot;Jack&quot;</span>, Age: <span class="hljs-number">22</span>&#125;r.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;c.HTML(http.StatusOK, <span class="hljs-string">&quot;css.tmpl&quot;</span>, <span class="hljs-literal">nil</span>)&#125;)r.GET(<span class="hljs-string">&quot;/students&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;c.HTML(http.StatusOK, <span class="hljs-string">&quot;arr.tmpl&quot;</span>, gee.H&#123;<span class="hljs-string">&quot;title&quot;</span>:  <span class="hljs-string">&quot;gee&quot;</span>,<span class="hljs-string">&quot;stuArr&quot;</span>: [<span class="hljs-number">2</span>]*student&#123;stu1, stu2&#125;,&#125;)&#125;)r.GET(<span class="hljs-string">&quot;/date&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gee.Context)</span></span> &#123;c.HTML(http.StatusOK, <span class="hljs-string">&quot;custom_func.tmpl&quot;</span>, gee.H&#123;<span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;gee&quot;</span>,<span class="hljs-string">&quot;now&quot;</span>:   time.Date(<span class="hljs-number">2019</span>, <span class="hljs-number">8</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, time.UTC),&#125;)&#125;)r.Run(<span class="hljs-string">&quot;localhost:9999&quot;</span>)&#125;</code></pre></div><h1>错误恢复(Panic Recover)</h1><p>错误处理也可以作为一个中间件，增强 gee 框架的能力</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> gee<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;runtime&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-comment">// print stack trace for debug</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(message <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">var</span> pcs [<span class="hljs-number">32</span>]<span class="hljs-type">uintptr</span>n := runtime.Callers(<span class="hljs-number">3</span>, pcs[:]) <span class="hljs-comment">// skip first 3 caller</span><span class="hljs-keyword">var</span> str strings.Builderstr.WriteString(message + <span class="hljs-string">&quot;\nTraceback:&quot;</span>)<span class="hljs-keyword">for</span> _, pc := <span class="hljs-keyword">range</span> pcs[:n] &#123;fn := runtime.FuncForPC(pc)file, line := fn.FileLine(pc)str.WriteString(fmt.Sprintf(<span class="hljs-string">&quot;\n\t%s:%d&quot;</span>, file, line))&#125;<span class="hljs-keyword">return</span> str.String()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Recovery</span><span class="hljs-params">()</span></span> HandlerFunc &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;message := fmt.Sprintf(<span class="hljs-string">&quot;%s&quot;</span>, err)log.Printf(<span class="hljs-string">&quot;%s\n\n&quot;</span>, trace(message))c.Fail(http.StatusInternalServerError, <span class="hljs-string">&quot;Internal Server Error&quot;</span>)&#125;&#125;()c.Next()&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
      <tag>Project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go项目-海量用户通讯系统</title>
    <link href="/2022/11/11/Go/Go-Project-Mass-Communication-System/"/>
    <url>/2022/11/11/Go/Go-Project-Mass-Communication-System/</url>
    
    <content type="html"><![CDATA[<p>Go项目-海量用户通讯系统</p><span id="more"></span><h1>项目开发流程</h1><ol><li>实现客户端登录菜单以及简单的用户登录逻辑</li><li>实现用户登录（与服务器端进行通信验证用户的信息）</li><li>客户端可以发送消息的长度，服务器端可以接收消息的长度</li><li>客户端可以发送消息本身，服务器端可以接收消息</li><li>改进服务器端和客户端的结构，更易读</li><li>增加数据库验证，增加一层models，同时实现用户的注册和登录</li><li>维护用户在线列表</li><li>客户端发送消息</li><li>服务器端转发消息</li></ol><h1>项目需求说明</h1><p>用户注册、用户登录、显示在线用户列表、群聊（广播）、点对点聊天、离线留言</p><h1>项目代码编写</h1><h2 id="实现客户端登录菜单以及简单的用户登录逻辑">实现客户端登录菜单以及简单的用户登录逻辑</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 定义两个变量，一个表示用户ID，一个表示用户密码</span><span class="hljs-keyword">var</span> userId <span class="hljs-type">int</span><span class="hljs-keyword">var</span> userPwd <span class="hljs-type">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 接收用户的选择</span><span class="hljs-keyword">var</span> key <span class="hljs-type">int</span><span class="hljs-comment">// 判断是否还能继续显示菜单</span><span class="hljs-keyword">var</span> loop = <span class="hljs-literal">true</span><span class="hljs-comment">// 循环展示菜单</span><span class="hljs-keyword">for</span> loop &#123;fmt.Println(<span class="hljs-string">&quot;---------------欢迎登录多人聊天系统---------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;---------------   1 登录聊天室&quot;</span>)fmt.Println(<span class="hljs-string">&quot;---------------    2 注册用户&quot;</span>)fmt.Println(<span class="hljs-string">&quot;---------------    3 退出系统&quot;</span>)fmt.Println(<span class="hljs-string">&quot;请选择（1-3）：&quot;</span>)fmt.Scanln(&amp;key)<span class="hljs-keyword">switch</span> key &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Println(<span class="hljs-string">&quot;登录聊天室&quot;</span>)loop = <span class="hljs-literal">false</span><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Println(<span class="hljs-string">&quot;注册用户&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:fmt.Println(<span class="hljs-string">&quot;退出系统&quot;</span>)loop = <span class="hljs-literal">false</span><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;输入有误，请重新输入&quot;</span>)&#125;&#125;<span class="hljs-keyword">if</span> key == <span class="hljs-number">1</span> &#123;fmt.Println(<span class="hljs-string">&quot;请输入用户ID&quot;</span>)fmt.Scanln(&amp;userId)fmt.Println(<span class="hljs-string">&quot;请输入用户密码&quot;</span>)fmt.Scanln(&amp;userPwd)<span class="hljs-comment">// 先把登录的函数写在另外一个文件</span>err := login(userId, userPwd)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;登录失败&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;登录成功&quot;</span>)&#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> key == <span class="hljs-number">2</span> &#123;fmt.Println(<span class="hljs-string">&quot;进行用户注册的逻辑&quot;</span>)&#125;&#125;</code></pre></div><p>登录逻辑的判断首先写在另外的文件中，后续再进行修改</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">login</span><span class="hljs-params">(userId <span class="hljs-type">int</span>, userPwd <span class="hljs-type">string</span>)</span></span> (err <span class="hljs-type">error</span>) &#123;fmt.Printf(<span class="hljs-string">&quot;userId=%d, userPed=%s\n&quot;</span>, userId, userPwd)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>注意这种在同一个包下引用函数的方式需要在src文件夹之外进行编译，然后手动运行</p><h2 id="实现用户登录（与服务器端进行通信验证用户的信息）">实现用户登录（与服务器端进行通信验证用户的信息）</h2><p>重点是如何发送包以及如何对包进行校验，同时要保证多线程</p><p><a href="https://imgse.com/i/zESgG6"><img src="https://s1.ax1x.com/2022/11/15/zESgG6.md.png" alt="zESgG6.md.png"></a></p><h3 id="消息长度的发送与接收">消息长度的发送与接收</h3><p>要对发送的消息进行序列化等操作，首先定义好处理这些数据的结构体</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> message<span class="hljs-comment">// 确定消息类型</span><span class="hljs-keyword">const</span> (LoginMesType    = <span class="hljs-string">&quot;LoginMes&quot;</span>LoginResMesType = <span class="hljs-string">&quot;LoginResMes&quot;</span>)<span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;Type <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;type&quot;`</span> <span class="hljs-comment">// 消息类型</span>Data <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;data&quot;`</span> <span class="hljs-comment">// 消息内容</span>&#125;<span class="hljs-comment">// 定义两个消息，后面需要再增加</span><span class="hljs-keyword">type</span> LoginMes <span class="hljs-keyword">struct</span> &#123;UserId   <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;userId&quot;`</span>   <span class="hljs-comment">// 用户Id</span>UserPwd  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;userPwd&quot;`</span>  <span class="hljs-comment">// 用户密码</span>UserName <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;userName&quot;`</span> <span class="hljs-comment">// 用户名</span>&#125;<span class="hljs-keyword">type</span> LoginResMes <span class="hljs-keyword">struct</span> &#123;Code  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;code&quot;`</span>  <span class="hljs-comment">// 返回的状态码 500 表示用户未注册，200 表示成功</span>Error <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;error&quot;`</span> <span class="hljs-comment">// 返回错误信息</span>&#125;</code></pre></div><p>客户端发送消息（消息的长度）</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Mass-Communication-System/common/message&quot;</span><span class="hljs-string">&quot;encoding/binary&quot;</span><span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">login</span><span class="hljs-params">(userId <span class="hljs-type">int</span>, userPwd <span class="hljs-type">string</span>)</span></span> (err <span class="hljs-type">error</span>) &#123;<span class="hljs-comment">// fmt.Printf(&quot;userId=%d, userPed=%s\n&quot;, userId, userPwd)</span><span class="hljs-comment">// return nil</span><span class="hljs-comment">// 连接到服务器端</span>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8889&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;net.Dial err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">defer</span> conn.Close()<span class="hljs-comment">// 准备通过conn发送消息给服务</span><span class="hljs-keyword">var</span> mes message.Messagemes.Type = message.LoginMesType<span class="hljs-comment">// 创建一个LoginMes结构体</span><span class="hljs-keyword">var</span> loginMes message.LoginMesloginMes.UserId = userIdloginMes.UserPwd = userPwd<span class="hljs-comment">// 将loginMes序列化</span>data, err := json.Marshal(loginMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json Marshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;mes.Data = <span class="hljs-type">string</span>(data)<span class="hljs-comment">// 将mes进行序列化</span>data, err = json.Marshal(mes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json Marshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// data为发送的消息</span><span class="hljs-comment">// 先把data的长度发送给服务器</span><span class="hljs-keyword">var</span> pkgLen = <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(data))<span class="hljs-keyword">var</span> buf [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>binary.BigEndian.PutUint32(buf[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>], pkgLen)<span class="hljs-comment">//  发送长度</span>n, err := conn.Write(buf[:<span class="hljs-number">4</span>])<span class="hljs-keyword">if</span> n != <span class="hljs-number">4</span> || err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;conn.Write err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;客户端发送的消息长度为&quot;</span>, <span class="hljs-built_in">len</span>(data))fmt.Println(<span class="hljs-string">&quot;客户端发送的消息内容为&quot;</span>, <span class="hljs-type">string</span>(data))<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>服务器端接收消息</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<span class="hljs-comment">// 延时关闭连接</span><span class="hljs-keyword">defer</span> conn.Close()<span class="hljs-comment">// 读取客户端发送的信息</span><span class="hljs-keyword">for</span> &#123;buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">4</span>)fmt.Println(<span class="hljs-string">&quot;等待读取客户端发送的数据.....&quot;</span>)n, err := conn.Read(buf[:<span class="hljs-number">4</span>])<span class="hljs-keyword">if</span> n != <span class="hljs-number">4</span> || err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;conn.Read err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;读到的长度为&quot;</span>, buf[:<span class="hljs-number">4</span>])&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;服务器在8889端口监听.....&quot;</span>)listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8889&quot;</span>)<span class="hljs-keyword">defer</span> listen.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;net.Listen err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 一旦监听成功，等待客户端连接服务器</span><span class="hljs-keyword">for</span> &#123;fmt.Println(<span class="hljs-string">&quot;等待客户端连接服务器.....&quot;</span>)conn, err := listen.Accept()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;listen.Accept err=&quot;</span>, err)&#125;<span class="hljs-comment">// 一旦连接成功，则启动一个协程和客户端保持通讯</span><span class="hljs-keyword">go</span> process(conn)&#125;&#125;</code></pre></div><h3 id="客户端发送消息本身，服务器端进行接收">客户端发送消息本身，服务器端进行接收</h3><p>将服务器端的消息接收封装成一个函数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readPkg</span><span class="hljs-params">(conn net.Conn)</span></span> (mes message.Message, err <span class="hljs-type">error</span>) &#123;buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">4</span>)fmt.Println(<span class="hljs-string">&quot;等待读取客户端发送的数据.....&quot;</span>)_, err = conn.Read(buf[:<span class="hljs-number">4</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;conn.Read err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// fmt.Println(&quot;读到的长度为&quot;, buf[:4])</span><span class="hljs-comment">// 转换为一个uint32类型</span><span class="hljs-keyword">var</span> pkgLen = binary.BigEndian.Uint32(buf[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])<span class="hljs-comment">//  发送长度</span>n, err := conn.Read(buf[:pkgLen])<span class="hljs-keyword">if</span> n != <span class="hljs-type">int</span>(pkgLen) || err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;conn.Read err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 把pkgLen反序列化成message</span>err = json.Unmarshal(buf[:pkgLen], &amp;mes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Unmarshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>客户端发送消息</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 发送消息本身</span>_, err = conn.Write(data)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;conn.Write err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;</code></pre></div><h3 id="完成登录的验证功能（相当于服务器发送消息-客户端接收）">完成登录的验证功能（相当于服务器发送消息,客户端接收）</h3><p>服务器端封装一个发送消息的函数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writePkg</span><span class="hljs-params">(conn net.Conn, data []<span class="hljs-type">byte</span>)</span></span> (err <span class="hljs-type">error</span>) &#123;<span class="hljs-comment">// 先发送一个长度</span><span class="hljs-keyword">var</span> pkgLen = <span class="hljs-type">uint32</span>(<span class="hljs-built_in">len</span>(data))<span class="hljs-keyword">var</span> buf [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span>binary.BigEndian.PutUint32(buf[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>], pkgLen)<span class="hljs-comment">//  发送长度</span>_, err = conn.Write(buf[:<span class="hljs-number">4</span>])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;conn.Write err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">//发送data本身</span>n, err := conn.Write(data)<span class="hljs-keyword">if</span> n != <span class="hljs-type">int</span>(pkgLen) || err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;conn.Write err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>将这种请求通用化，为后面的其他消息做准备</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 编写serverProcessLogin函数，专门处理登录的请求</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serverProcessLogin</span><span class="hljs-params">(conn net.Conn, mes *message.Message)</span></span> (err <span class="hljs-type">error</span>) &#123;<span class="hljs-comment">// 从mes中取出data，并反序列化</span><span class="hljs-keyword">var</span> loginMes message.LoginMeserr = json.Unmarshal([]<span class="hljs-type">byte</span>(mes.Data), &amp;loginMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Unmarshal error, err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 先声明一个resMes</span><span class="hljs-keyword">var</span> resMes message.MessageresMes.Type = message.LoginResMesType<span class="hljs-comment">// 声明一个LoginResMes</span><span class="hljs-keyword">var</span> loginResMes message.LoginResMes<span class="hljs-comment">// 如果用户的id为100，密码为123456，认为合法，否则不合法</span><span class="hljs-keyword">if</span> loginMes.UserId == <span class="hljs-number">100</span> &amp;&amp; loginMes.UserPwd == <span class="hljs-string">&quot;123456&quot;</span> &#123;<span class="hljs-comment">//合法</span>loginResMes.Code = <span class="hljs-number">200</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//不合法</span>loginResMes.Code = <span class="hljs-number">500</span>loginResMes.Error = <span class="hljs-string">&quot;该用户不存在，请注册再使用...&quot;</span>&#125;<span class="hljs-comment">// 将loginResMes序列化</span>data, err := json.Marshal(loginResMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal error, err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 将data赋值给resMes</span>resMes.Data = <span class="hljs-type">string</span>(data)<span class="hljs-comment">// 对resMes进行序列化，准备发送</span>data, err = json.Marshal(resMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal error, err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 发送data，封装到writePkg函数</span>err = writePkg(conn, data)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 根据客户端发送消息种类不同，决定调用哪个函数来实现</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serverProcessMes</span><span class="hljs-params">(conn net.Conn, mes *message.Message)</span></span> (err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">switch</span> mes.Type &#123;<span class="hljs-keyword">case</span> message.LoginMesType:<span class="hljs-comment">// 处理登录的逻辑</span>err = serverProcessLogin(conn, mes)<span class="hljs-keyword">case</span> message.RegisterMesType:<span class="hljs-comment">// 处理注册的逻辑</span><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;消息类型不存在，无法处理&quot;</span>)&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>客户端对消息进行处理</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 处理服务器端返回的消息</span>mes, err = readPkg(conn)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;readPkg(conn) error, err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 将mes的data部分反序列化</span><span class="hljs-keyword">var</span> loginResMes message.LoginResMeserr = json.Unmarshal([]<span class="hljs-type">byte</span>(mes.Data), &amp;loginResMes)<span class="hljs-keyword">if</span> loginResMes.Code == <span class="hljs-number">200</span> &#123;fmt.Println(<span class="hljs-string">&quot;登录成功&quot;</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> loginResMes.Code == <span class="hljs-number">500</span> &#123;fmt.Println(loginResMes.Error)&#125;</code></pre></div><h3 id="改进服务器端和客户端的结构，更易读">改进服务器端和客户端的结构，更易读</h3><p><a href="https://imgse.com/i/zEDSBt"><img src="https://s1.ax1x.com/2022/11/15/zEDSBt.png" alt="zEDSBt.png"></a></p><p>改进主要是将前面编写的函数封装进方法之中，减少不同函数之间参数的传递，通过结构体直接调用即可</p><p>客户端的改进增加了一个与服务器端保持联系的函数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 和服务器端保持通讯</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serverProcessMes</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;tf := &amp;utils.Transfer&#123;Conn: conn,&#125;<span class="hljs-keyword">for</span> &#123;fmt.Println(<span class="hljs-string">&quot;客户端正在等待读取服务器发送的消息&quot;</span>)mes, err := tf.ReadPkg()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;tf.ReadPkg err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 如果读取到消息,下一步进行处理</span>fmt.Println(mes)&#125;&#125;</code></pre></div><h3 id="增加数据库验证，增加一层models，同时实现用户的注册和登录">增加数据库验证，增加一层models，同时实现用户的注册和登录</h3><p>MVC开发模式，增加models，从而从数据库中进行读取和接收，验证用户的有效性</p><p>models层</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> model<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Mass-Communication-System/common/message&quot;</span><span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;github.com/gomodule/redigo/redis&quot;</span>)<span class="hljs-comment">// 使用工厂模式创建一个UserDao的实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUserDao</span><span class="hljs-params">(pool *redis.Pool)</span></span> (userDao *UserDao) &#123;userDao = &amp;UserDao&#123;pool: pool,&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 在服务器启动后初始化一个userDao实例</span><span class="hljs-keyword">var</span> (MyUserDao *UserDao)<span class="hljs-comment">// 定义一个userDao的结构体</span><span class="hljs-keyword">type</span> UserDao <span class="hljs-keyword">struct</span> &#123;pool *redis.Pool&#125;<span class="hljs-comment">// 根据用户id返回user实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ud *UserDao)</span></span> getUserById(conn redis.Conn, id <span class="hljs-type">int</span>) (user *User, err <span class="hljs-type">error</span>) &#123;res, err := redis.String(conn.Do(<span class="hljs-string">&quot;HGET&quot;</span>, <span class="hljs-string">&quot;users&quot;</span>, id))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err == redis.ErrNil &#123;err = ERROR_USER_NOTEXISTS&#125;<span class="hljs-keyword">return</span>&#125;user = &amp;User&#123;&#125;<span class="hljs-comment">// 把res反序列化成User实例</span>err = json.Unmarshal([]<span class="hljs-type">byte</span>(res), user)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Unmarshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 完成登录的校验</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ud *UserDao)</span></span> Login(userId <span class="hljs-type">int</span>, userPwd <span class="hljs-type">string</span>) (user *User, err <span class="hljs-type">error</span>) &#123;conn := ud.pool.Get()<span class="hljs-keyword">defer</span> conn.Close()user, err = ud.getUserById(conn, userId)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">if</span> user.UserPwd != userPwd &#123;err = ERROR_USER_PWD<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 注册</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ud *UserDao)</span></span> Register(user *message.User) (err <span class="hljs-type">error</span>) &#123;conn := ud.pool.Get()<span class="hljs-keyword">defer</span> conn.Close()_, err = ud.getUserById(conn, user.UserId)<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;err = ERROR_USER_EXISTS<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 说明该用户还没有注册过，则可以完成注册</span>data, err := json.Marshal(user)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;_, err = conn.Do(<span class="hljs-string">&quot;HSET&quot;</span>, <span class="hljs-string">&quot;users&quot;</span>, user.UserId, <span class="hljs-type">string</span>(data))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;保存注册用户错误，err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>处理注册的请求</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 编写ServerProcessRegister函数，专门处理注册的请求</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserProcess)</span></span> ServerProcessRegister(mes *message.Message) (err <span class="hljs-type">error</span>) &#123;<span class="hljs-comment">// 从mes中取出data，并反序列化</span><span class="hljs-keyword">var</span> registerMes message.RegisterMeserr = json.Unmarshal([]<span class="hljs-type">byte</span>(mes.Data), &amp;registerMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Unmarshal error, err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 先声明一个resMes</span><span class="hljs-keyword">var</span> resMes message.MessageresMes.Type = message.RegisterResMesType<span class="hljs-comment">// 声明一个RegisterResMes</span><span class="hljs-keyword">var</span> registerResMes message.RegisterResMeserr = model.MyUserDao.Register(&amp;registerMes.User)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err == model.ERROR_USER_EXISTS &#123;registerResMes.Code = <span class="hljs-number">505</span>registerResMes.Error = err.Error()&#125; <span class="hljs-keyword">else</span> &#123;registerResMes.Code = <span class="hljs-number">506</span>registerResMes.Error = <span class="hljs-string">&quot;注册发生未知错误&quot;</span>&#125;&#125; <span class="hljs-keyword">else</span> &#123;registerResMes.Code = <span class="hljs-number">200</span>&#125;<span class="hljs-comment">// 将loginResMes序列化</span>data, err := json.Marshal(registerResMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal error, err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 将data赋值给resMes</span>resMes.Data = <span class="hljs-type">string</span>(data)<span class="hljs-comment">// 对resMes进行序列化，准备发送</span>data, err = json.Marshal(resMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal error, err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// 发送data，封装到writePkg函数</span>tf := &amp;utils.Transfer&#123;Conn: u.Conn,&#125;err = tf.WritePkg(data)<span class="hljs-keyword">return</span>&#125;</code></pre></div><h3 id="维护用户在线列表">维护用户在线列表</h3><p>完成对当前在线用户的增删改查</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> process2<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 在服务器端实例只有一个，在很多的地方都会使用到</span><span class="hljs-keyword">var</span> (userMgr *UserMgr)<span class="hljs-keyword">type</span> UserMgr <span class="hljs-keyword">struct</span> &#123;onlineUsers <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*UserProcess&#125;<span class="hljs-comment">// 完成对userMgr初始化工作</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;userMgr = &amp;UserMgr&#123;onlineUsers: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*UserProcess, <span class="hljs-number">1024</span>),&#125;&#125;<span class="hljs-comment">// 完成对onlineUsers的增删改查</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(um *UserMgr)</span></span> AddOnlineUser(up *UserProcess) &#123;um.onlineUsers[up.UserId] = up&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(um *UserMgr)</span></span> DelOnlineUser(userId <span class="hljs-type">int</span>) &#123;<span class="hljs-built_in">delete</span>(um.onlineUsers, userId)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(um *UserMgr)</span></span> GetAllOnlineUser() <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*UserProcess &#123;<span class="hljs-keyword">return</span> um.onlineUsers&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(um *UserMgr)</span></span> GetOnlineUserById(userId <span class="hljs-type">int</span>) (up *UserProcess, err <span class="hljs-type">error</span>) &#123;up, ok := um.onlineUsers[userId]<span class="hljs-keyword">if</span> !ok &#123;err = fmt.Errorf(<span class="hljs-string">&quot;用户%d不存在&quot;</span>, userId)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div><p>显示当前在线用户列表</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 因为用户登录成功，要将用户放入全局变量中以返回列表</span>u.UserId = loginMes.UserIduserMgr.AddOnlineUser(u)<span class="hljs-comment">// 将当前在线用户的id放入到loginResMes.UsersIds</span><span class="hljs-keyword">for</span> id := <span class="hljs-keyword">range</span> userMgr.onlineUsers &#123;loginResMes.UsersIds = <span class="hljs-built_in">append</span>(loginResMes.UsersIds, id)&#125;fmt.Println(user, <span class="hljs-string">&quot;登录成功&quot;</span>)</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 显示当前在线用户列表</span>fmt.Println(<span class="hljs-string">&quot;当前在线用户列表如下：&quot;</span>)<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> loginResMes.UsersIds &#123;fmt.Println(<span class="hljs-string">&quot;用户id,\t&quot;</span>, v)&#125;</code></pre></div><p>服务器端对用户列表进行处理</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 通知所有用户在线</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserProcess)</span></span> NotifyOthersOnlineUser(userId <span class="hljs-type">int</span>) &#123;<span class="hljs-keyword">for</span> id, up := <span class="hljs-keyword">range</span> userMgr.onlineUsers &#123;<span class="hljs-keyword">if</span> id == userId &#123;<span class="hljs-keyword">continue</span>&#125;up.NotifyMeOnline(userId)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserProcess)</span></span> NotifyMeOnline(userId <span class="hljs-type">int</span>) &#123;<span class="hljs-keyword">var</span> mes message.Messagemes.Type = message.NotifyUserStatusMesType<span class="hljs-keyword">var</span> notifyUserStatusMes message.NotifyUserStatusMesnotifyUserStatusMes.UserId = userIdnotifyUserStatusMes.Status = message.UserOnlinedata, err := json.Marshal(notifyUserStatusMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;mes.Data = <span class="hljs-type">string</span>(data)data, err = json.Marshal(mes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;tf := &amp;utils.Transfer&#123;Conn: u.Conn,&#125;err = tf.WritePkg(data)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;NotifyMeOnline err=&quot;</span>, err)&#125;&#125;</code></pre></div><p>客户端对用户列表进行处理</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> process<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Mass-Communication-System/common/message&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-comment">// 客户端要维护的map</span><span class="hljs-keyword">var</span> onlineUsers <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*message.User = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]*message.User, <span class="hljs-number">10</span>)<span class="hljs-comment">// 在客户端显示当前在线的用户</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outputOnlineUser</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;当前在线用户列表&quot;</span>)<span class="hljs-keyword">for</span> id, user := <span class="hljs-keyword">range</span> onlineUsers &#123;fmt.Println(id, user)&#125;&#125;<span class="hljs-comment">// 处理返回的NotifyUserStatusMes</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateUserStatus</span><span class="hljs-params">(notifyUserStatusMes *message.NotifyUserStatusMes)</span></span> &#123;user, ok := onlineUsers[notifyUserStatusMes.UserId]<span class="hljs-keyword">if</span> !ok &#123;user = &amp;message.User&#123;UserId: notifyUserStatusMes.UserId,&#125;&#125;user.UserStatus = notifyUserStatusMes.StatusonlineUsers[notifyUserStatusMes.UserId] = useroutputOnlineUser()&#125;</code></pre></div><p>客户端显示用户列表</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 显示当前在线用户列表</span>fmt.Println(<span class="hljs-string">&quot;当前在线用户列表如下：&quot;</span>)<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> loginResMes.UsersIds &#123;fmt.Println(<span class="hljs-string">&quot;用户id,\t&quot;</span>, v)user := &amp;message.User&#123;UserId:     v,UserStatus: message.UserOnline,&#125;onlineUsers[v] = user&#125;</code></pre></div><h3 id="客户端发送消息">客户端发送消息</h3><p>直接调用前面写好的就行，代码很少了</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> process<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Mass-Communication-System/client/utils&quot;</span><span class="hljs-string">&quot;Go-Projects/Mass-Communication-System/common/message&quot;</span><span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> SmsProecss <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sp *SmsProecss)</span></span> SendGroupSms(content <span class="hljs-type">string</span>) (err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">var</span> mes message.Messagemes.Type = message.SmsMesType<span class="hljs-keyword">var</span> smsMes message.SmsMessmsMes.Content = contentsmsMes.UserId = CurUser.UserIdsmsMes.UserStatus = CurUser.UserStatusdata, err := json.Marshal(smsMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;mes.Data = <span class="hljs-type">string</span>(data)data, err = json.Marshal(mes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;tf := &amp;utils.Transfer&#123;Conn: CurUser.Conn,&#125;err = tf.WritePkg(data)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;tf.WritePkg err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div><h3 id="服务器端转发消息">服务器端转发消息</h3><p>也是和上面的差不多</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> process2<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Mass-Communication-System/common/message&quot;</span><span class="hljs-string">&quot;Go-Projects/Mass-Communication-System/server/utils&quot;</span><span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net&quot;</span>)<span class="hljs-keyword">type</span> SmsProecss <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sp *SmsProecss)</span></span> SendGroupSms(mes *message.Message) (err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">var</span> smsMes message.SmsMeserr = json.Unmarshal([]<span class="hljs-type">byte</span>(mes.Data), &amp;smsMes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Unmarshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;data, err := json.Marshal(mes)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;json.Marshal err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> id, up := <span class="hljs-keyword">range</span> userMgr.onlineUsers &#123;<span class="hljs-keyword">if</span> id == smsMes.UserId &#123;<span class="hljs-keyword">continue</span>&#125;sp.SendMesToEachOnlineUser(data, up.Conn)&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sp *SmsProecss)</span></span> SendMesToEachOnlineUser(data []<span class="hljs-type">byte</span>, conn net.Conn) (err <span class="hljs-type">error</span>) &#123;tf := &amp;utils.Transfer&#123;Conn: conn,&#125;err = tf.WritePkg(data)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;tf.WritePkg err=&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">return</span>&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
      <tag>Project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-期末复习</title>
    <link href="/2022/11/09/UCAS/information-retrieval/information-retrieval-final/"/>
    <url>/2022/11/09/UCAS/information-retrieval/information-retrieval-final/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》期末复习</p><span id="more"></span><p>考试主要涉及概念上的问题，可能没有特别复杂的计算的内容</p><h1>第1讲 布尔检索</h1><p>倒排索引基本结构：</p><p>对每个词项t，记录所有包含t的文档列表。每篇文档用一个唯一的docID来表示，通常是正整数，如1,2,3…</p><p>为什么要用倒排索引：</p><p>当用户发起查询时（假设查询为一个关键词），搜索引擎会扫描索引库中的所有文档，找出所有包含关键词的文档，这样依次从文档中去查找是否含有关键词的方法叫做正向索引 。</p><p>为了增加效率， 搜索引擎会把正向索引变为倒排索引即把“文档→单词”的形式变为“单词→文档”的形式 。</p><p>倒排索引是实现“单词-文档矩阵”的一种具体存储形式，通过倒排索引，可以根据单词快速获取包含这个单词的文档列表。</p><p>布尔查询的处理优化：</p><ul><li>每个布尔表达式都能转换成合取范式</li><li>获得每个词项的df</li><li>通过将词项的df相加，估计每个OR表达式对应的倒排记录表的大小</li><li>按照上述估计从小到大依次处理每个OR表达式</li></ul><p>问题：什么是倒排索引？为什么说倒排索引能加快检索的速度？假设“信息”、“检索”在倒排索引中是两个独立的term，试说明检索短语“信息检索”的基本流程。</p><p>答案：倒排索引指的是从词项到文档的一种索引结构。由于它直接可以从查询词定位到文档，所以能够大大加快检索的速度。检索短语“信息检索”的基本流程：从词典中分别查找到“信息”和“检索”这两个词，分别返回它们的倒排记录表，然后求这两个表的交集，在求交集时要考虑它们在文档中的位置相对关系。</p><p><strong>词条</strong> ：一段文本中有效词的子序列，其中每个子序列称为一个词条。</p><p><strong>词条类</strong> ：相同词条构成的集合。</p><p><strong>词项</strong> ：一个词项指的是在信息检索系统词典中所包含的某个可能经过归一化处理的词条类。（词项集合和词条集合可以完全不同，比如可以采用某一个分类体系中的类别标签作为词项。当然，在实际的信息检索系统中，词项往往和词条密切相关）</p><p><strong>注意：①文档-词项关联矩阵只包含01②要按字典序进行排序</strong></p><p><a href="https://imgse.com/i/zC3hFS"><img src="https://s1.ax1x.com/2022/11/11/zC3hFS.png" alt="zC3hFS.png"></a></p><h1>第2讲 索引构建</h1><h2 id="基于排序的索引构建方法存在的问题">基于排序的索引构建方法存在的问题</h2><p>在构建索引时，每次解析一篇文档，因此对于每个词项而言，其倒排记录表不到最后一篇文档都是不完整的。</p><p>如果每个 <code>(termID, docID)</code>对占用 <code>8</code>个字节, 那么处理大规模语料需要大量的空间。</p><p>一般内存的容量比较小，没有办法将前面产生的倒排记录表全部放在内存中，需要在磁盘上存储中间结果。</p><h2 id="BSBI算法">BSBI算法</h2><p><strong>一种减少寻道操作的排序：Blocked sort-based Indexing</strong></p><p>将所有记录划分为每个大小约为10M的块，收集每一块的倒排记录，排序，将倒排索引写入硬盘，最后将不同的分块合并为一个大的倒排索引。</p><h2 id="SPIMI算法">SPIMI算法</h2><p><strong>内存式单遍扫描索引构建算法：Single-pass in-memory indexing</strong></p><p>关键思想：</p><ul><li>对每个块都产生一个独立的词典（不需要在块之间进行 <code>term-termID</code>的映射）</li><li>对倒排记录表不排序，按照它们出现的先后顺序排列，只对词典排序（实际上由于指针的存在，倒排记录表没有排序的必要）。</li></ul><p><strong>在扫描文档的同时，直接在内存中维护一个不断更新的倒排索引</strong></p><p>因此对每个块生成一个完整的倒排索引，这些独立的索引最后合并成一个大索引</p><p>最终合并词典的过程中，需要进行词项字符串的比较，因为此时没有全局词典提供词项-整数ID的映射。</p><h2 id="BSBI算法和SPIMI算法的主要区别">BSBI算法和SPIMI算法的主要区别</h2><p>BSBI算法：在分块索引阶段，BSBI算法维护一个全局Term (String) – Termid (int) 的映射表，局部索引为Termid及其倒排记录表，仍然按词典顺序排序。</p><p>SPIMI算法：分块索引阶段与BSBI算法不同在于建立局部词典和索引，无需全局词典。在合并阶段，将局部索引两两合并，最后产生全局词典建立Term – Termid的映射。</p><p><strong>使用文本预处理步骤可以大大减小系统所需要存储的倒排记录表的数目，从而提高索引构建和检索的速度</strong></p><h1>第3讲 索引压缩</h1><p>有损压缩：丢弃一些信息-很多常用的预处理步骤可以看成是有损压缩</p><p>无损压缩：所有信息都保留-索引压缩中通常都使用无损压缩</p><h2 id="词典压缩">词典压缩</h2><p>定长数组方式下的词典存储：每个词项需要20（字符串）+4（词频）+4（指向倒排索引表的指针）=28个字节。</p><p>将整部词典看成单一字符串：4（词频）+4（指向倒排索引表的指针）+3（指向字符串的指针，按照实际大小决定，例如8*400000个位置需要$log_2(8 * 400000)&lt; 24 $位来表示）+8（每个字符串平均需要8个字节）=19个字节</p><p>按块存储，假设块大小k=4，此时每4个词项只需要保留1个词项指针，但是同时需要增加4个字节（比较短，1个字节就可以）来表示每个词项的长度，因此每4个词项需要3+4=7B，比之前的节省了12-7=5B</p><p>前端编码：每个块当中 (k = 4)会有公共前缀，可以采用前端编码方式继续压缩</p><p>如果使用词干还原，由于将同一词汇的不同形式还原到词根，因此前端编码的压缩效果有限</p><h2 id="倒排记录表压缩">倒排记录表压缩</h2><p>倒排记录表的压缩：两种经典编码VB和γ编码（<strong>注意对gap进行编码，第一个id，后面都是gap</strong>）</p><p><strong>可变字节(VB)码</strong>：设定一个专用位 (高位) c作为延续位(continuation bit)，如果间隔表示少于7比特，那么c置1，将间隔编入一个<br>字节的后7位中；否则将高7位放入当前字节中，并将c置0，剩下的位数采用同样的方法进行处理，最后一个字节的c置1（表<br>示结束）</p><p><strong><img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>编码</strong>：</p><ul><li>将G (Gap, 间隔) 表示成长度(length)和偏移(offset)两部分</li><li>偏移对应G的二进制编码，只不过将首部的1去掉（因为所有的编码第一位都是1）</li><li>长度部分给出的是偏移的位数，采用一元编码</li><li>手动计算的时候先计算偏移，再根据偏移计算长度</li></ul><p><a href="https://imgse.com/i/zC8kTK"><img src="https://s1.ax1x.com/2022/11/11/zC8kTK.png" alt="zC8kTK.png"></a></p><h1>第4讲 拼写矫正</h1><p>通道模型：</p><p>若有包含<img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个词条的大文本语料，则<img src="https://math.now.sh?inline=P%28w%29%3D%5Cfrac%7BC(w)%7D%7BT%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=C%28w%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是词频。（一元先验概率）</p><p>通道模型概率-计算错误概率<img src="https://math.now.sh?inline=P%28x%7Cw%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：混淆“矩阵”（计算一个字符变为另一个字符的概率如何）</p><p>轮排索引：<strong>（主要思想：让星号出现在词汇的末尾）</strong></p><ul><li>将每个通配查询旋转，使*出现在末尾</li><li>将每个旋转后的结果存放在词典中，即B-树中</li></ul><p>轮排索引的查找过程：</p><ul><li>将查询进行旋转，将通配符旋转到右部</li><li>同以往一样查找B-树，得到匹配的所有词项，将这些词项对应的倒排记录表取出</li></ul><p>相对于通常的B-树，轮排索引(轮排树)的空间要大4倍以上 (经验值)</p><p>k-gram索引：枚举一个词项中所有连读的k个字符构成k-gram（在首尾添加k-1个首尾符号）</p><ul><li>构建一个倒排索引，此时词典部分是所有的k-gram，倒排记录表部分是包含某个k-gram的所有词项</li><li>相当于对词项再构建一个倒排索引（二级索引）</li><li>比轮排索引空间开销要小</li><li>但是可能返回一些伪正例，需要进行后过滤</li></ul><p><a href="https://imgse.com/i/zC8KOI"><img src="https://s1.ax1x.com/2022/11/11/zC8KOI.png" alt="zC8KOI.png"></a></p><p>k-gram索引 vs. 轮排索引</p><ul><li>k-gram索引的空间消耗小</li><li>轮排索引不需要进行后过滤</li></ul><h1>第5讲 TF-IDF</h1><p>tf-idf词频及log词频</p><p>TF是词项t的词项频率，是与文档相关的一个量，可以认为是文档内代表度的一个量，也可以认为是一种局部信息。</p><p>IDF是反映词项t的信息量的一个指标，是一种全局性指标，反应的是词项在全局的区别性，可视为一种词项全局信息量的指标。</p><p>向量空间模型基本思想：把查询和文本表示成向量（早期表示成TF-IDF权重）</p><p>向量空间模型的不同实现方案（不用背表，但是有很多情况，要看好题）（比如有时候idf不用算）：</p><p><a href="https://imgse.com/i/z9prND"><img src="https://s1.ax1x.com/2022/11/10/z9prND.md.png" alt="z9prND.md.png"></a></p><p>注意：看好题目，不说对数、归一化什么的就不要做</p><p><a href="https://imgse.com/i/zC8Jfg"><img src="https://s1.ax1x.com/2022/11/11/zC8Jfg.png" alt="zC8Jfg.png"></a></p><h1>第6讲 概率检索模型</h1><p>主要是BM25模型的基本概念，IDF是怎么计算的，以及它的基本假设，伯努利分布</p><p>BIM的基本假设，BM25的二重泊松分布，考虑了哪些因素，如长度归一等等。</p><p><a href="https://www.cnblogs.com/bentuwuying/p/6730891.html">参考资料</a></p><p>以往的向量空间模型是将query和文档使用向量表示然后计算其内容相似性来进行相关性估计的，而概率检索模型是一种直接对用户需求进行相关性的建模方法，一个query进来，将所有的文档分为两类-相关文档、不相关文档，这样就转为了一个相关性的分类问题。</p><p>对于某个文档<img src="https://math.now.sh?inline=D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来说，<img src="https://math.now.sh?inline=P%28R%7CD%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示该文档属于相关文档的概率，则<img src="https://math.now.sh?inline=P%28NR%7CD%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示该文档属于不相关文档的概率，如果query属于相关文档的概率大于不相关文档<img src="https://math.now.sh?inline=P%28R%7CD%29%3EP(NR%7CD)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则认为这个文档是与用户查询相关的。</p><p>使用贝叶斯公式转换一下，则在搜索排序过程中不需要真正的分类，只需要保证相关性由高到底排序即可，所以只需要<img src="https://math.now.sh?inline=P%28D%7CR%29%20%2F%20P(D%7CNR)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>降序即可，<br>这样就最终转为计算<img src="https://math.now.sh?inline=P%28D%7CR%29%2CP(D%7CNR)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的值即可。</p><h2 id="二值独立概率模型BIM">二值独立概率模型BIM</h2><p>为了能够使得上述两个计算因子可行，二元独立模型做出了两个假设</p><ol><li>二元假设</li></ol><p>类似于布尔模型中的文档表示方法，一篇文档在由特征（或者单词）进行表示的时候，以特征（或者单词）出现和不出现两种情况来表示，不考虑词频等其他因素。</p><ol start="2"><li>词汇独立性假设</li></ol><p>指文档里出现的单词之间没有任何关联，任意一个单词在文档的分布概率不依赖于其他单词是否出现。因为词汇之间没有关联，所以可以将文档概率转换为单词概率的乘积。</p><p>上述提到的文档D表示为<img src="https://math.now.sh?inline=%5C%7B1%2C0%2C1%2C0%2C1%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，用<img src="https://math.now.sh?inline=p_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来表示第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个单词在相关文档出现的概率，则在已知相关文档集合的情况下，观察到D的概率为：</p><p><img src="https://math.now.sh?inline=P%28D%7CR%29%3Dp_1(1-p_2)p_3(1-p_4)p_5" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>同理在不相关文档中出现的概率为<img src="https://math.now.sh?inline=P%28D%7CNR%29%3Ds_1(1-s_2)s_3(1-s_4)s_5" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>可以推导出：<img src="https://math.now.sh?inline=log%5Cfrac%7BP%28D%7CR%29%7D%7BP(D%7CNR)%7D%3D%5Csum_%7Bi%3Ad_i%3D1%7Dlog%5Cfrac%7Bp_i(1-s_i)%7D%7Bs_i(1-p_i)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>设文档统计量如下：</p><table><thead><tr><th></th><th>相关文档</th><th>不相关文档</th><th>文档数量</th></tr></thead><tbody><tr><td><img src="https://math.now.sh?inline=d_i%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td><td><img src="https://math.now.sh?inline=r_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td><td><img src="https://math.now.sh?inline=n_i-r_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td><td><img src="https://math.now.sh?inline=n_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td></tr><tr><td><img src="https://math.now.sh?inline=d_i%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td><td><img src="https://math.now.sh?inline=R-r_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td><td><img src="https://math.now.sh?inline=%28N-R%29-(n_i-r_i)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td><td><img src="https://math.now.sh?inline=N-n_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td></tr><tr><td>文档数量</td><td><img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td><td><img src="https://math.now.sh?inline=N-R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td><td><img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></td></tr></tbody></table><p>则可以得出（加1平滑）：<img src="https://math.now.sh?inline=p_i%3D%5Cfrac%7Br_i%2B0.5%7D%7BR%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=s_i%3D%5Cfrac%7Bn_i-r_i%2B0.5%7D%7BN-R%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此最终的公式为：</p><p><img src="https://math.now.sh?inline=%5Csum_%7Bq_i%3Dd_i%3D1%7Dlog%5Cfrac%7B%28r_i%2B0.5%29(N-R-n_i%2Br_i%2B0.5)%7D%7B(n_i-r_i%2B0.5)(R-r_i%2B0.5)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其代表的含义是：对于同时出现在用户查询Q和文档D中的单词，累加每个单词的估值，其和就是文档D和查询的相关性度量。</p><p><strong>在不确定哪些文档是相关的，哪些文档是不相关的的时候，可以给公式的估算因子直接赋予固定值，则该公式将会退化为IDF因子。</strong></p><p>优点：BIM模型建立在数学基础上，理论性较强</p><p>缺点：</p><ul><li>需要估计参数</li><li>原始的BIM没有考虑TF、文档长度因素</li><li>BIM中同样存在词项独立性假设</li><li>BIM实质上是一个idf权重公式，仅考虑了全局信息，缺少局部信息。因此需要和TF权重配合使用</li></ul><h2 id="BM25模型">BM25模型</h2><p>BM25模型计算公式其实融合了4个考虑因素：IDF因子，文档长度因子，文档词频和查询词频。并对3个自由调节因子<img src="https://math.now.sh?inline=%28k_1%2Ck_3%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>进行权值的调整。</p><p>IDF因子：设BIM模型中的相关文档数量为0，则退化为<img src="https://math.now.sh?inline=log%5Cfrac%7BN-df%2B0.5%7D%7Bdf%2B0.5%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>查询权重：<img src="https://math.now.sh?inline=%5Cfrac%7Bqtf%7D%7Bk_3%2Bqtf%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，考虑查询词频</p><p>TF权重（基于二重泊松分布）：<img src="https://math.now.sh?inline=%5Cfrac%7Bk_1%5Ccdot%20tf%7D%7Btf%2Bk_1%281-b%2Bb%5Cfrac%7Bl_d%7D%7Bavg_l%7D%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，考虑文档中词频和文档长度</p><p>最终形式为三项相乘</p><p>例题：</p><p><a href="https://imgse.com/i/zCMO8s"><img src="https://s1.ax1x.com/2022/11/11/zCMO8s.png" alt="zCMO8s.png"></a></p><p><a href="https://imgse.com/i/zCMxK0"><img src="https://s1.ax1x.com/2022/11/11/zCMxK0.png" alt="zCMxK0.png"></a></p><p>优点：</p><ul><li>一定程度上的理论化模型</li><li>基于二重泊松假设——适用于绝大多数文本语料上的IR检索应用</li><li>实验证明有效</li></ul><p>缺点：</p><ul><li>待调参数多且参数敏感性高</li><li>必须去停用词</li></ul><p>问题：BM25和向量空间模型(VSM)为何需要长度归一？语言模型为何需要平滑处理？两个问题之间有何联系？</p><p>答案：由于长文挡中词项反复出现的可能性大，包含更多的不同词项，所以词项频率和词汇量可能更大。这显然是不公平的。长度归一化，可以使长文档和短文档的向量中的权重都处于同一数量级。平滑处理是为了解决数据稀疏引起的0概率问题。两者都是常见的数据预处理方法，提高了数据质量，为了保证模型的鲁棒性。</p><h1>第7讲 语言建模的检索模型</h1><p>流行的是基于多项式分布，对于生成模型的计算有零概率的问题，需要进行平滑，基本概念要知道</p><p><a href="https://imgse.com/i/zC8stU"><img src="https://s1.ax1x.com/2022/11/11/zC8stU.png" alt="zC8stU.png"></a></p><h1>第8讲 信息检索的评价</h1><p>指标计算，如正确率召回率等等，F1，未插值的AP</p><p>题目：什么是非插值的MAP？为什么说它在引入序的作用的同时考虑了召回率？</p><p>答案：单个查询的非插值MAP指的是所有相关文档（不论是否在结果出现，若不出现就假定出现在无穷远处）在结果出现位置上的正确率的算术平均值。系统的非插值MAP是所有查询上的非插值AP的算术平均值。从非插值AP的定义看，一方面，如果出现在结果中的相关文档越多，求和结果也越大，那么非插值AP值也越大。另一方面，如果相关文档在结果中出现位置越靠前，那么非插值AP值也越大。因此，可以认为非插值MAP同时考底了召回率和序的作用。</p><p>Bpref：在相关性判断不完全的情况下，计算在进行了相关性判断的文档集合中，在判断到相关文档前，需要判断的不相关文档的篇数。相关性判断完全的情况下，利用Bpref和MAP进行评价的结果很一致，但是相关性判断不完全的情况下，Bpref更鲁棒。</p><p>NDCG：每个文档不仅仅只有相关和不相关两种情况，而是有相关度级别，比如0,1,2,3。我们可以假设，对于返回结果：相关度级别越高的结果越多越好，相关度级别越高的结果越靠前越好</p><p>优点：</p><ul><li>图形直观，易解释</li><li>支持非二值的相关度定义，比P-R曲线更精确</li><li>能够反映用户的行为特征(如：用户的持续性persistence)</li></ul><p>缺点：</p><ul><li>相关度的定义难以一致</li><li>需要参数设定</li></ul><p><a href="https://imgse.com/i/zCKQeO"><img src="https://s1.ax1x.com/2022/11/11/zCKQeO.png" alt="zCKQeO.png"></a></p><p><a href="https://imgse.com/i/zC8476"><img src="https://s1.ax1x.com/2022/11/11/zC8476.png" alt="zC8476.png"></a></p><p><a href="https://imgse.com/i/zC8g1J"><img src="https://s1.ax1x.com/2022/11/11/zC8g1J.png" alt="zC8g1J.png"></a></p><p><a href="https://imgse.com/i/zC8fn1"><img src="https://s1.ax1x.com/2022/11/11/zC8fn1.png" alt="zC8fn1.png"></a></p><h1>第9讲 完整搜索系统中的评分计算</h1><p>考试基本不涉及</p><h1>第10讲 查询扩展</h1><p>相关反馈的本质是将检索返回的文档的相关性判定(不同的判定来源：人工或非人工)作为返回信息，希望提升检索效果（召回率和正确率）</p><p>反馈信息的来源：显式（用户点击）、隐式（用户行为等）、伪相关反馈（返回的前几个结果算相关）</p><p>Rocchio算法</p><p>查询扩展的最初含义是对查询进行扩充，近年来越来越向查询重构偏移，即现在的查询扩展是指对原有查询进行修改。</p><p>通过在查询中加入同义或者相关的词项来提高检索结果。</p><p>相关词项的来源: 人工编辑的同义词词典、自动构造的同义词词典、查询日志等等。</p><p>查询扩展和相关反馈对检索效果的提升是非常有用的经验性的方法</p><p>问题：什么是伪相关反馈？为什么说有时候伪相关反馈会降低某个查询的检索效果？</p><p>答案：伪相关反馈指的是系统对上次返回的检索结采进行“伪”判定（比如假设前几个结果是相关的)，然后根据这个结果进行反馈。伪相关反馈依赖于上次检索的结果，那么在上次检索结果不可靠情况下，假设成立的可能性很小，此时就进行伪相关反馈反而可能降低后一次检索的效果。</p><p><strong>注意：负权重要记为0，同时也要进行排序</strong></p><p><a href="https://imgse.com/i/zC8jBt"><img src="https://s1.ax1x.com/2022/11/11/zC8jBt.png" alt="zC8jBt.png"></a></p><h1>第11、12、13讲 文本分类</h1><p>问题：文本分类当中，什么是宏平均？什么是微平均？为什么说微平均计算时易受大类影响？</p><p>答案：宏平均指的是在每个类别上分类效果的平均值，也即将每个类别看成一个单位。而微平均是将所有类别看成一个类别后求到的效果值，即将每篇文档看成一个单位。由于微平均将文档看成单位，而大类文档数目较多，因此它在计算时易受大类影响。</p><h2 id="朴素贝叶斯（线性分类器）">朴素贝叶斯（线性分类器）</h2><p>使用log将乘积计算变为求和计算</p><p>最大似然估计（零概率的情况下怎么进行加一平滑）</p><h2 id="Rocchio分类（线性分类器）">Rocchio分类（线性分类器）</h2><p>计算每个类的中心向量（所有文档向量的算术平均）</p><p>将每篇测试文档分到离它最近的那个中心向量</p><p>Rocchio分类器是要训练的</p><h2 id="KNN（非线性分类器）">KNN（非线性分类器）</h2><p>kNN分类决策取决于k个邻居类中的多数类</p><p>类别之间的分类面是分段线性的</p><p>kNN分类器几乎不需要训练</p><p>但是像kNN这种非线性学习方法在某些情况下也会产生一个线性分类器</p><h2 id="SVM">SVM</h2><p>SVM分线性SVM和非线性SVM，SVM本身是一个线性决策，但是核函数可以是线性或非线性的</p><p>算法本身是转化成一个线性公式，但是最终得到的是一个非线性的决策面，只不过把样本投射到高维空间里面</p><p>问题：总结SVM中处理线性不可分数据的方法，给出其基本原理。</p><ul><li>广义最优分类面：在条件中增加一个松弛项，容纳少量线性不可分的噪声样本。</li><li>核函数：从低维空间非线性映射到线性可分的高维空间。</li></ul><p>问题：什么是核函数？它的作用是什么？为什么核函数的引入常常称为核技巧？</p><p>答案：核函数是满足若干性质的相似度计算函数。它的主要作用是计算两个对象的相似度，具体地说，它可以基于原始空间上的点来定义映射后空间上的内积函数。核函数避免知道空间映射的具体函数形式，能够直接基于核函数进行映射后的对象相似度计算，所以它的引入常常称为核技巧。</p><h2 id="偏差和方差">偏差和方差</h2><p>对于像Rocchio和NB一样的线性方法来说，对于非线性问题它们的偏差就比较大</p><p>像kNN一样的非线性方法的偏差较小，方差较大</p><p>如果拥有的训练数据非常少，而又要训练出一个基于监督学习的分类器，应该采用具有高偏差的分类器，在这种情况下NB能取得较好的结果，诸如kNN的低偏差模型大概是不可取的。</p><h2 id="分类题目">分类题目</h2><p><a href="https://imgse.com/i/zCGEBq"><img src="https://s1.ax1x.com/2022/11/11/zCGEBq.png" alt="zCGEBq.png"></a></p><p><a href="https://imgse.com/i/zCGn4U"><img src="https://s1.ax1x.com/2022/11/11/zCGn4U.png" alt="zCGn4U.png"></a></p><h1>第12讲 排序学习</h1><p>现有检索排序算法存在哪些问题，怎么改进？</p><p>很多传统的IR权重计算机制中都包含了基本指标的非线性缩放过程（比如词项频率或idf 的对数权重计算）。目前为止，机器学习非常擅长特征线性组合（或者其他类似的受限模型）中的权重优化，但是并不擅长基本指标的非线性缩放。这个领域仍然需要人工的特征工程方法。</p><h2 id="基于布尔权重的学习">基于布尔权重的学习</h2><p>给定训练样例集合，每个样例表示为三元组，相关或者不相关</p><p>从上述样例中学习权重，使得学到的评分接近训练集中的相关性判定结果。</p><h2 id="基于实数权重的学习（pointwise）">基于实数权重的学习（pointwise）</h2><p>设置评分函数是两个因子的线性组合：查询和文档的向量空间相似度评分和查询词项在文档中存在的最小窗口宽度</p><p>相关记为1，不相关记为0，我们的目标是寻找一个评分函数，该函数能够组合特征因子的值，并尽量接近0或1，希望该函数的结果尽量与训练集上的结果保持一致</p><h2 id="基于序回归的排序学习（pairwise）">基于序回归的排序学习（pairwise）</h2><p>为什么将IR排序问题看成一个序回归问题？</p><ul><li>对于同一查询，文档之间可以按照相对得分排序即可，并不一定要求每篇文档有一个全局的绝对得分</li><li>因此，只需要一个排序，而不要得到相关度的绝对得分，问题空间可以减小</li><li>pairwise 方法相对 pointwise 方法对噪声标注更敏感，即一个错误标注会引起多个 doc pair 标注错误。</li></ul><p>方法：</p><ul><li>给定一些已经判定的查询</li><li>对训练集中的每条查询<img src="https://math.now.sh?inline=q" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>, 我们都有针对该查询的一系列文档集合，这些文档已经由人工按照其与查询的相关度排序</li><li>对每个文档、查询对，构造特征向量<img src="https://math.now.sh?inline=%CF%88_j%20%3D%20%CF%88%28d_j%20%2C%20q%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，这里的特征可以采用前面的特征</li><li>对于两篇文档<img src="https://math.now.sh?inline=d_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=d_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，可以计算特征向量之间的差异向量</li><li>依据假设，<img src="https://math.now.sh?inline=d_i%2Cd_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中的一个更相关</li><li>如果<img src="https://math.now.sh?inline=d_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>比<img src="https://math.now.sh?inline=d_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>更相关，记为<img src="https://math.now.sh?inline=d_i%3Cd_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（在检索结果中，<img src="https://math.now.sh?inline=d_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>应该出现在<img src="https://math.now.sh?inline=d_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>前面）, 那么分配给<img src="https://math.now.sh?inline=%D0%A4%28d_i%2Cd_j%2Cq%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>向量的类别为<img src="https://math.now.sh?inline=y_%7Bijq%7D%3D%2B1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，否则为<img src="https://math.now.sh?inline=%E2%88%921" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>学习的目标是建立一个分类器，满足：<img src="https://math.now.sh?inline=w%5ET%D0%A4%28d_i%2Cd_j%2Cq%29%3E0%2Cif%20d_i%3Cd_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><h1>第14、15讲</h1><p>词项表示：通过分析文档集来自动生成同义词库-基于共现的同义词库</p><p>词嵌入：得到每个词的低维密集向量表示</p><p>Neural IR 模型分类</p><p><strong>Representation based（基于表示学习的模型）</strong>：学习文本的分布式表示，在高维空间匹配</p><ul><li>词表示：one hot → distributed</li><li>句子表示：bag of words → distributed</li><li>匹配能力取决于学习文本表示的算法能力</li><li>代表模型：DSSM, CDSSM</li></ul><p><strong>Matching function（基于交互匹配的模型）</strong>：文本之间先进行交互匹配，再对匹配信号进行融合</p><ul><li>输入：比较底层的输入</li><li>匹配函数：cosine, dot product → NN</li><li>优点：可以考虑更加丰富的匹配信号， 如软匹配 (soft matching)</li><li>代表模型：MatchPyramid , DRMM, K NRM, PACRR, NPRF</li></ul><p>Combination of both: 既考虑 Representation 又考虑 Matching function</p><p>BERT在检索应用中的特点：</p><ol><li>在高频查询上，BM25的偏差比BERT更大，导致BM25的效果不好</li><li>BERT可以检索到更稀有的词项</li><li>在长查询上，BERT的表现不如BM25更好</li></ol><p>问题：简述BERT的基本结构？如何预训练一个BERT（涉及什么任务）？</p><p>BERT的基本结构：</p><ol><li>词向量</li><li>多层Transformer Encoder结构：包括自注意力和Feed-Forward</li><li>任务特定的输出层</li></ol><p>BERT的训练任务有两类：</p><ol><li>masked language model 随机掩盖掉一些单词，然后通过上下文预测该单词。BERT中有15%的wordpiece token会被随机掩盖，这15%的token中80%用[MASK]这个token来代替，10%用随机的一个词来替换，10%保持这个词不变。这种设计使得模型具有捕捉上下文关系的能力，同时能够有利于token-level tasks，例如序列标注等。</li><li>next sentence prediction 语料中50%的句子，选择其相应的下一句一起形成上下句，作为正样本；其余50%的句子Embedding随机选择一句非下一句一起形成上下句，作为负样本。这种设定，有利于sentence-level tasks，例如问答，注意：作者特意说了语料的选取很关键，要选用document-level的而不是sentence-level的，这样可以具备抽象连续长序列特征的能力。</li></ol><h1>第16讲 Web搜索</h1><p>Google次高竞标价格拍卖机制：</p><p><a href="https://imgse.com/i/zS0Wkt"><img src="https://s1.ax1x.com/2022/11/09/zS0Wkt.png" alt="zS0Wkt.png"></a></p><p>bid：每个广告商为每次点击给出的最大投标价格</p><p>CTR：一旦被显示后被点击的比率</p><p>ad rank=bid × CTR：这种做法可以在广告商愿意支付的价钱和广告的相关度高低之间进行平衡。</p><p>排名第1的C，需要支付的价格是它的下一位的<img src="https://math.now.sh?inline=bid_2%20%C3%97%20CTR_2%20%2F%20CTR_1%3D3*%5Cfrac%7B0.03%7D%7B0.06%7D%2B0.01%3D1.51" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>排名第2的B，需要支付的价格是它的下一位的<img src="https://math.now.sh?inline=bid_3%20%C3%97%20CTR_3%20%2F%20CTR_2%3D1*%5Cfrac%7B0.08%7D%7B0.03%7D%2B0.01%3D2.67" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>这样做避免了“保底”行为的产生，可以使收益更大化。</p><h1>第17讲 爬虫</h1><p>采集器必须做到</p><ul><li>礼貌性<ul><li>不要高频率采集某个网站</li><li>仅仅采集robots.txt所规定的可以采集的网页<ul><li>robots.txt协议不让采集，不过写程序还是可以采集到的，但是不能这样做，一定要遵守协议</li></ul></li></ul></li><li>鲁棒性<ul><li>能够处理采集器陷阱、重复页面、超大页面、超大网站、动态页面等问题</li></ul></li></ul><h1>第18讲 链接分析</h1><p>锚文本是人为创建的超链接，可以理解为质量认证的信号。</p><h2 id="BV算法-邻接表压缩的经典算法">BV算法-邻接表压缩的经典算法</h2><p>邻接表：一个节点的邻居集合，可以视为一个结点（URL）所有指向它的页面的集合</p><p>假设每个URL由一个整数表示，对于40亿页的网站，每个结点需要32位甚至64位，存储开销非常大</p><p>BV算法可以降低到平均3位</p><p>压缩中使用到的属性：</p><ul><li>相似度（邻接表之间）</li><li>位置（一个页面中的许多链接都连接到“附近”的页面）-将所有URL按照字母顺序排序，同一个网站的页面的链接相似</li><li>在已排序的邻接表中使用间隔编码</li><li>gap value 的分布</li></ul><p>BV算法主要思想：由于模板的缘故，一个节点的邻接列表类似于字典顺序中的7个先前的URL之一，根据这7个中的之一表示邻接表，否则重新编码。</p><p>BV算法的主要优势</p><ul><li>仅依赖于位置的规范顺序-字典顺序对web十分适用</li><li>邻接查询可以被非常高效地回答</li><li>易于实现one-pass算法<ul><li>顺序读取，不需要无限缓冲。读取复杂度与网页数量是线性关系</li></ul></li></ul><h2 id="PageRank">PageRank</h2><p>起源 : 引用分析</p><p>特点：</p><ol><li>一个网页如果它的入链越多，那么它也越重要（PageRank越高）</li><li>一个网页如果被越重要的网页所指向，那么它也越重要（PageRank越高）</li></ol><p>PageRank背后的假设：</p><ol><li>Web 上的链接是网页质量的标志-链出网页的作者认为链向的网页具有很高的质量</li><li>锚文本能够描述链向网页的内容</li></ol><p>PageRank的计算：迭代法计算</p><p>如果存在循环通路，需要虚拟一个结点，或者以一定的概率选取一个其他结点到达</p><h2 id="HITS-Hub节点-Authority节点">HITS: Hub节点&amp;Authority节点</h2><p>每个网页计算两个值：</p><ul><li>Hub：目录型或导航型网页的权重</li><li>Authority：权威型网页的权重</li></ul><p>计算方法：</p><p><img src="https://math.now.sh?inline=A%28p%29%3D%5Csum%20H(q_i)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=q_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是所有链接到<img src="https://math.now.sh?inline=p" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的页面</p><p><img src="https://math.now.sh?inline=H%28p%29%3D%5Csum%20A(r_i)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=r_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是所有页面<img src="https://math.now.sh?inline=p" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>链接到的页面</p><ul><li>一个网页被越重要的导航型网页指向越多，那么它的Authority越大</li><li>一个网页指向的高重要度权威型网页越多，那么它的Hub越大</li></ul><p>实际计算过程：</p><ol><li>首先进行Web 搜索，搜索的结果称为根集（从搜索结果中选择一部分排名靠前的网页作为根集，也叫做种子集合）</li><li>将所有链向种子集合和种子集合链出的网页加入到种子集合，新的更大的集合称为基本集</li><li>最后，在基本集上计算每个网页的hub值和authority值</li></ol><h2 id="PageRank-vs-HITS">PageRank vs. HITS</h2><p>PageRank算法是Google提出的一个链接分析的算法，它可以根据节点之间的链接关系计算出每个节点的重要性，反映的是“越多越重要的节点指向该节点则该节点越重要”这个事实。</p><p>HITS是IBM提出的另一种链接分析算法，它根据节点之间的链接关系对每个节点计算出两个值：权威度(authority值)和导航度(hub值).</p><p>相同点：两者都是基于链接分析的排序算法，并且在算法中两者都利用了特征向量作为理论基础和收敛性依据。</p><p>不同点：网页的PageRank是一种静态评分，与查询主题无关，可以事先算好，因此适合于大型搜索引擎；HITS算法的计算与查询主题相关，检索之后再进行计算，因此不适合于大型搜索引擎。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go项目-客户信息管理系统</title>
    <link href="/2022/11/03/Go/Go-Project-Customer-Management-System/"/>
    <url>/2022/11/03/Go/Go-Project-Customer-Management-System/</url>
    
    <content type="html"><![CDATA[<p>Go项目-客户信息管理系统</p><span id="more"></span><h1>项目开发流程</h1><p><a href="https://imgse.com/i/xHx5Pe"><img src="https://s1.ax1x.com/2022/11/02/xHx5Pe.md.png" alt="xHx5Pe.md.png"></a></p><h1>项目需求说明</h1><ol><li>模拟实现基于文本界面的《客户信息管理软件》。</li><li>该软件能够实现对客户对象的插入、修改和删除（用切片实现），并能够打印客户明细表</li></ol><h1>项目代码编写</h1><h2 id="编写Customer-go">编写Customer.go</h2><p>主要是用于表示一个客户的信息，包含结构体以及在其他地方如果调用它的工厂模式的方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> model<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 定义Customer结构体，表示一个客户信息</span><span class="hljs-keyword">type</span> Customer <span class="hljs-keyword">struct</span> &#123;Id     <span class="hljs-type">int</span>Name   <span class="hljs-type">string</span>Gender <span class="hljs-type">string</span>Age    <span class="hljs-type">int</span>Phone  <span class="hljs-type">string</span>Email  <span class="hljs-type">string</span>&#125;<span class="hljs-comment">// 工厂模式返回Customer的结构体，在CustomerService里面使用</span><span class="hljs-comment">// 感觉就是新建一个Customer的实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCustomer</span><span class="hljs-params">(id <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>, gender <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>, phone <span class="hljs-type">string</span>, email <span class="hljs-type">string</span>)</span></span> *Customer &#123;<span class="hljs-keyword">return</span> &amp;Customer&#123;Id:     id,Name:   name,Gender: gender,Age:    age,Phone:  phone,Email:  email,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cu *Customer)</span></span> GetInfo() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%v\t%v\t%v\t%v\t%v\t%v&quot;</span>, cu.Id, cu.Name, cu.Gender, cu.Age, cu.Phone, cu.Email)&#125;</code></pre></div><p>以及如果我们要返回一个客户的信息，操作也是在Customer的实例上进行的，因此后面的方法也要写在这个结构体的下面</p><p>完成对Customer结构体的操作的代码在CustomerService里面，定义另外一个结构体，里面包含一个切片，存储全部实例化的Customer</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 完成对Customer的操作，包括增删改查</span><span class="hljs-keyword">type</span> CustomerService <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 存储当前的客户</span>Customers []model.Customer<span class="hljs-comment">// 声明一个字段，表示当前切片含有多少个客户</span>CustomerNum <span class="hljs-type">int</span>&#125;</code></pre></div><h2 id="主界面-customerView-go">主界面 customerView.go</h2><p>主菜单：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> MainMenu() &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">var</span> username, password <span class="hljs-type">string</span>fmt.Print(<span class="hljs-string">&quot;请输入用户名：&quot;</span>)fmt.Scanln(&amp;username)fmt.Print(<span class="hljs-string">&quot;请输入密码：&quot;</span>)fmt.Scanln(&amp;password)<span class="hljs-keyword">if</span> cv.login(username, password) &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;用户名或密码错误！&quot;</span>)&#125;&#125;<span class="hljs-comment">// 显示主菜单</span><span class="hljs-keyword">for</span> cv.loop &#123;fmt.Println(<span class="hljs-string">&quot;\n---------------------客户信息管理软件---------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         1 添加客户&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         2 修改客户&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         3 删除客户&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         4 客户列表&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         5 退    出&quot;</span>)fmt.Print(<span class="hljs-string">&quot;请选择(1-5)：&quot;</span>)<span class="hljs-comment">// 接收用户的输入</span>fmt.Scanln(&amp;cv.key)<span class="hljs-comment">// 对用户的输入进行判断</span><span class="hljs-keyword">switch</span> cv.key &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:cv.addCustomer()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:cv.changeCustomer()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;3&quot;</span>:cv.deleteCustomer()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;4&quot;</span>:cv.showCustomer()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;5&quot;</span>:cv.exit()<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;请输入正确的选项------&quot;</span>)&#125;&#125;&#125;</code></pre></div><p>主菜单里面有的变量是需要定义在结构体中的</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> CustomerView <span class="hljs-keyword">struct</span> &#123;key             <span class="hljs-type">string</span>                   <span class="hljs-comment">// 接收用户输入</span>loop            <span class="hljs-type">bool</span>                     <span class="hljs-comment">// 表示是否循环的显示主菜单</span>username        <span class="hljs-type">string</span>                   <span class="hljs-comment">// 用户的用户名</span>password        <span class="hljs-type">string</span>                   <span class="hljs-comment">// 用户的密码</span>customerService *service.CustomerService <span class="hljs-comment">// 获取用户服务</span>&#125;</code></pre></div><p>同时也编写一个工厂模式的方法，方便main.go文件进行调用</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCustomerView</span><span class="hljs-params">()</span></span> *CustomerView &#123;<span class="hljs-keyword">return</span> &amp;CustomerView&#123;key:             <span class="hljs-string">&quot;&quot;</span>,loop:            <span class="hljs-literal">true</span>,username:        <span class="hljs-string">&quot;admin&quot;</span>,password:        <span class="hljs-string">&quot;password&quot;</span>,customerService: service.NewCustomerService(),&#125;&#125;</code></pre></div><p>main.go：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Customer-Management-System/view&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;view.NewCustomerView().MainMenu()&#125;</code></pre></div><h2 id="完成增删改查的功能">完成增删改查的功能</h2><p>要注意，全部的功能实现细节都应该是在customerService里面进行编写的，customerView.go 文件只负责调用，并对返回的结果进行判断等。</p><p>首先要对CustomerService进行初始化，也是相当于工厂模式了</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 初始化CustomerService</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCustomerService</span><span class="hljs-params">()</span></span> *CustomerService &#123;customerService := &amp;CustomerService&#123;&#125; <span class="hljs-comment">// 初始化</span>customerService.CustomerNum = <span class="hljs-number">0</span><span class="hljs-keyword">return</span> customerService&#125;</code></pre></div><h3 id="展示客户列表">展示客户列表</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> showCustomer() &#123;<span class="hljs-keyword">if</span> cv.customerService.CustomerNum == <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;没有客户！&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;\n-------------------------客户列表-------------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;编号\t姓名\t性别\t年龄\t电话\t电子邮件&quot;</span>)<span class="hljs-keyword">for</span> _, eachCustomer := <span class="hljs-keyword">range</span> cv.customerService.ShowCustomerSlice() &#123;fmt.Println(eachCustomer.GetInfo())&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *CustomerService)</span></span> ShowCustomerSlice() []model.Customer &#123;<span class="hljs-keyword">return</span> cs.Customers&#125;</code></pre></div><h3 id="添加客户">添加客户</h3><p>对切片增加一个客户的实例，然后将记录的数量+1</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> addCustomer() &#123;id := cv.customerService.CustomerNum + <span class="hljs-number">1</span><span class="hljs-keyword">var</span> name, gender, phone, email <span class="hljs-type">string</span><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span>fmt.Print(<span class="hljs-string">&quot;请输入姓名：&quot;</span>)fmt.Scanln(&amp;name)fmt.Print(<span class="hljs-string">&quot;请输入性别：&quot;</span>)fmt.Scanln(&amp;gender)fmt.Print(<span class="hljs-string">&quot;请输入年龄：&quot;</span>)fmt.Scanln(&amp;age)fmt.Print(<span class="hljs-string">&quot;请输入电话：&quot;</span>)fmt.Scanln(&amp;phone)fmt.Print(<span class="hljs-string">&quot;请输入电子邮件：&quot;</span>)fmt.Scanln(&amp;email)<span class="hljs-keyword">if</span> cv.customerService.AddCustomer(*model.NewCustomer(id, name, gender, age, phone, email)) &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------添加成功-------------------------&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------添加失败-------------------------&quot;</span>)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *CustomerService)</span></span> AddCustomer(customer model.Customer) <span class="hljs-type">bool</span> &#123;cs.Customers = <span class="hljs-built_in">append</span>(cs.Customers, customer)cs.CustomerNum += <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></div><h3 id="删除客户">删除客户</h3><p>根据客户的ID寻找客户在切片中的位置，然后将它删除即可。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> changeCustomer() &#123;<span class="hljs-keyword">var</span> id <span class="hljs-type">int</span>fmt.Print(<span class="hljs-string">&quot;请输入修改的ID号：&quot;</span>)fmt.Scanln(&amp;id)<span class="hljs-keyword">if</span> cv.customerService.ChangeCustomer(id) &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------修改成功-------------------------&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------添加失败-------------------------&quot;</span>)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *CustomerService)</span></span> DeleteCustomer(id <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">for</span> index, cus := <span class="hljs-keyword">range</span> cs.Customers &#123;<span class="hljs-keyword">if</span> cus.Id == id &#123;cs.Customers = <span class="hljs-built_in">append</span>(cs.Customers[:index], cs.Customers[index+<span class="hljs-number">1</span>:]...)cs.CustomerNum -= <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div><h3 id="修改客户">修改客户</h3><p>根据客户的ID寻找客户在切片中的位置，然后修改需要修改的字段即可。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> changeCustomer() &#123;<span class="hljs-keyword">var</span> id <span class="hljs-type">int</span>fmt.Print(<span class="hljs-string">&quot;请输入修改的ID号：&quot;</span>)fmt.Scanln(&amp;id)<span class="hljs-keyword">if</span> cv.customerService.ChangeCustomer(id) &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------修改成功-------------------------&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------添加失败-------------------------&quot;</span>)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *CustomerService)</span></span> ChangeCustomer(id <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;reader := bufio.NewReader(os.Stdin) <span class="hljs-comment">// 标准输入输出</span><span class="hljs-keyword">for</span> index, cus := <span class="hljs-keyword">range</span> cs.Customers &#123;<span class="hljs-keyword">if</span> cus.Id == id &#123;fmt.Printf(<span class="hljs-string">&quot;请输入修改的姓名(%v)：&quot;</span>, cus.Name)name, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)name = strings.TrimSpace(name)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) != <span class="hljs-number">0</span> &#123;cs.Customers[index].Name = name&#125;fmt.Printf(<span class="hljs-string">&quot;请输入修改的性别(%v)：&quot;</span>, cus.Gender)gender, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)gender = strings.TrimSpace(gender)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(gender) != <span class="hljs-number">0</span> &#123;cs.Customers[index].Gender = gender&#125;fmt.Printf(<span class="hljs-string">&quot;请输入修改的年龄(%v)：&quot;</span>, cus.Age)age, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)age = strings.TrimSpace(age)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(age) != <span class="hljs-number">0</span> &#123;t, _ := strconv.ParseInt(age, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)cs.Customers[index].Age = <span class="hljs-type">int</span>(t)&#125;fmt.Printf(<span class="hljs-string">&quot;请输入修改的电话(%v)：&quot;</span>, cus.Phone)phone, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)phone = strings.TrimSpace(phone)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(phone) != <span class="hljs-number">0</span> &#123;cs.Customers[index].Phone = phone&#125;fmt.Printf(<span class="hljs-string">&quot;请输入修改的电子邮件(%v)：&quot;</span>, cus.Email)email, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)email = strings.TrimSpace(email)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(email) != <span class="hljs-number">0</span> &#123;cs.Customers[index].Email = email&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div><p>修改的时候回车表示对这个字段不修改，因此要调一个reader的包来完成这个工作，自己无法作出这种判断。</p><h1>完整源代码</h1><p>.<br>├── Customer-Management-System<br>│   ├── main<br>│   │   └── main.go<br>│   ├── model<br>│   │   └── customer.go<br>│   ├── service<br>│   │   └── customerService.go<br>│   └── view<br>│       └── customerView.go</p><p>main.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Customer-Management-System/view&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;view.NewCustomerView().MainMenu()&#125;</code></pre></div><p>customer.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> model<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 定义Customer结构体，表示一个客户信息</span><span class="hljs-keyword">type</span> Customer <span class="hljs-keyword">struct</span> &#123;Id     <span class="hljs-type">int</span>Name   <span class="hljs-type">string</span>Gender <span class="hljs-type">string</span>Age    <span class="hljs-type">int</span>Phone  <span class="hljs-type">string</span>Email  <span class="hljs-type">string</span>&#125;<span class="hljs-comment">// 工厂模式返回Customer的结构体，在CustomerService里面使用</span><span class="hljs-comment">// 感觉就是新建一个Customer的实例</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCustomer</span><span class="hljs-params">(id <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>, gender <span class="hljs-type">string</span>, age <span class="hljs-type">int</span>, phone <span class="hljs-type">string</span>, email <span class="hljs-type">string</span>)</span></span> *Customer &#123;<span class="hljs-keyword">return</span> &amp;Customer&#123;Id:     id,Name:   name,Gender: gender,Age:    age,Phone:  phone,Email:  email,&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cu *Customer)</span></span> GetInfo() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%v\t%v\t%v\t%v\t%v\t%v&quot;</span>, cu.Id, cu.Name, cu.Gender, cu.Age, cu.Phone, cu.Email)&#125;</code></pre></div><p>customerService.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> service<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Customer-Management-System/model&quot;</span><span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-comment">// 完成对Customer的操作，包括增删改查</span><span class="hljs-keyword">type</span> CustomerService <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 存储当前的客户</span>Customers []model.Customer<span class="hljs-comment">// 声明一个字段，表示当前切片含有多少个客户</span>CustomerNum <span class="hljs-type">int</span>&#125;<span class="hljs-comment">// 初始化CustomerService</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCustomerService</span><span class="hljs-params">()</span></span> *CustomerService &#123;customerService := &amp;CustomerService&#123;&#125; <span class="hljs-comment">// 初始化</span>customerService.CustomerNum = <span class="hljs-number">0</span><span class="hljs-keyword">return</span> customerService&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *CustomerService)</span></span> ShowCustomerSlice() []model.Customer &#123;<span class="hljs-keyword">return</span> cs.Customers&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *CustomerService)</span></span> AddCustomer(customer model.Customer) <span class="hljs-type">bool</span> &#123;cs.Customers = <span class="hljs-built_in">append</span>(cs.Customers, customer)cs.CustomerNum += <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *CustomerService)</span></span> DeleteCustomer(id <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">for</span> index, cus := <span class="hljs-keyword">range</span> cs.Customers &#123;<span class="hljs-keyword">if</span> cus.Id == id &#123;cs.Customers = <span class="hljs-built_in">append</span>(cs.Customers[:index], cs.Customers[index+<span class="hljs-number">1</span>:]...)cs.CustomerNum -= <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *CustomerService)</span></span> ChangeCustomer(id <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;reader := bufio.NewReader(os.Stdin) <span class="hljs-comment">// 标准输入输出</span><span class="hljs-keyword">for</span> index, cus := <span class="hljs-keyword">range</span> cs.Customers &#123;<span class="hljs-keyword">if</span> cus.Id == id &#123;fmt.Printf(<span class="hljs-string">&quot;请输入修改的姓名(%v)：&quot;</span>, cus.Name)name, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)name = strings.TrimSpace(name)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(name) != <span class="hljs-number">0</span> &#123;cs.Customers[index].Name = name&#125;fmt.Printf(<span class="hljs-string">&quot;请输入修改的性别(%v)：&quot;</span>, cus.Gender)gender, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)gender = strings.TrimSpace(gender)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(gender) != <span class="hljs-number">0</span> &#123;cs.Customers[index].Gender = gender&#125;fmt.Printf(<span class="hljs-string">&quot;请输入修改的年龄(%v)：&quot;</span>, cus.Age)age, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)age = strings.TrimSpace(age)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(age) != <span class="hljs-number">0</span> &#123;t, _ := strconv.ParseInt(age, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)cs.Customers[index].Age = <span class="hljs-type">int</span>(t)&#125;fmt.Printf(<span class="hljs-string">&quot;请输入修改的电话(%v)：&quot;</span>, cus.Phone)phone, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)phone = strings.TrimSpace(phone)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(phone) != <span class="hljs-number">0</span> &#123;cs.Customers[index].Phone = phone&#125;fmt.Printf(<span class="hljs-string">&quot;请输入修改的电子邮件(%v)：&quot;</span>, cus.Email)email, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)email = strings.TrimSpace(email)<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(email) != <span class="hljs-number">0</span> &#123;cs.Customers[index].Email = email&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div><p>customerView.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> view<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Customer-Management-System/model&quot;</span><span class="hljs-string">&quot;Go-Projects/Customer-Management-System/service&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> CustomerView <span class="hljs-keyword">struct</span> &#123;key             <span class="hljs-type">string</span>                   <span class="hljs-comment">// 接收用户输入</span>loop            <span class="hljs-type">bool</span>                     <span class="hljs-comment">// 表示是否循环的显示主菜单</span>username        <span class="hljs-type">string</span>                   <span class="hljs-comment">// 用户的用户名</span>password        <span class="hljs-type">string</span>                   <span class="hljs-comment">// 用户的密码</span>customerService *service.CustomerService <span class="hljs-comment">// 获取用户服务</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCustomerView</span><span class="hljs-params">()</span></span> *CustomerView &#123;<span class="hljs-keyword">return</span> &amp;CustomerView&#123;key:             <span class="hljs-string">&quot;&quot;</span>,loop:            <span class="hljs-literal">true</span>,username:        <span class="hljs-string">&quot;admin&quot;</span>,password:        <span class="hljs-string">&quot;password&quot;</span>,customerService: service.NewCustomerService(),&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> login(username, password <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">if</span> username == cv.username &amp;&amp; password == cv.password &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> addCustomer() &#123;id := cv.customerService.CustomerNum + <span class="hljs-number">1</span><span class="hljs-keyword">var</span> name, gender, phone, email <span class="hljs-type">string</span><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span>fmt.Print(<span class="hljs-string">&quot;请输入姓名：&quot;</span>)fmt.Scanln(&amp;name)fmt.Print(<span class="hljs-string">&quot;请输入性别：&quot;</span>)fmt.Scanln(&amp;gender)fmt.Print(<span class="hljs-string">&quot;请输入年龄：&quot;</span>)fmt.Scanln(&amp;age)fmt.Print(<span class="hljs-string">&quot;请输入电话：&quot;</span>)fmt.Scanln(&amp;phone)fmt.Print(<span class="hljs-string">&quot;请输入电子邮件：&quot;</span>)fmt.Scanln(&amp;email)<span class="hljs-keyword">if</span> cv.customerService.AddCustomer(*model.NewCustomer(id, name, gender, age, phone, email)) &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------添加成功-------------------------&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------添加失败-------------------------&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> changeCustomer() &#123;<span class="hljs-keyword">var</span> id <span class="hljs-type">int</span>fmt.Print(<span class="hljs-string">&quot;请输入修改的ID号：&quot;</span>)fmt.Scanln(&amp;id)<span class="hljs-keyword">if</span> cv.customerService.ChangeCustomer(id) &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------修改成功-------------------------&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------添加失败-------------------------&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> deleteCustomer() &#123;<span class="hljs-keyword">var</span> id <span class="hljs-type">int</span>fmt.Print(<span class="hljs-string">&quot;请输入删除的ID号：&quot;</span>)fmt.Scanln(&amp;id)<span class="hljs-keyword">if</span> cv.customerService.DeleteCustomer(id) &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------删除成功-------------------------&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------删除失败-------------------------&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> showCustomer() &#123;<span class="hljs-keyword">if</span> cv.customerService.CustomerNum == <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;没有客户！&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Println(<span class="hljs-string">&quot;\n-------------------------客户列表-------------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;编号\t姓名\t性别\t年龄\t电话\t电子邮件&quot;</span>)<span class="hljs-keyword">for</span> _, eachCustomer := <span class="hljs-keyword">range</span> cv.customerService.ShowCustomerSlice() &#123;fmt.Println(eachCustomer.GetInfo())&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> exit() &#123;<span class="hljs-keyword">var</span> choice <span class="hljs-type">byte</span><span class="hljs-keyword">for</span> &#123;fmt.Print(<span class="hljs-string">&quot;确定退出？(y/n)：&quot;</span>)fmt.Scanf(<span class="hljs-string">&quot;%c\n&quot;</span>, &amp;choice)<span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;y&#x27;</span> &#123;cv.loop = <span class="hljs-literal">false</span><span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;n&#x27;</span> &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误！！请重新输入&quot;</span>)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cv *CustomerView)</span></span> MainMenu() &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">var</span> username, password <span class="hljs-type">string</span>fmt.Print(<span class="hljs-string">&quot;请输入用户名：&quot;</span>)fmt.Scanln(&amp;username)fmt.Print(<span class="hljs-string">&quot;请输入密码：&quot;</span>)fmt.Scanln(&amp;password)<span class="hljs-keyword">if</span> cv.login(username, password) &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;用户名或密码错误！&quot;</span>)&#125;&#125;<span class="hljs-comment">// 显示主菜单</span><span class="hljs-keyword">for</span> cv.loop &#123;fmt.Println(<span class="hljs-string">&quot;\n---------------------客户信息管理软件---------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         1 添加客户&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         2 修改客户&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         3 删除客户&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         4 客户列表&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                         5 退    出&quot;</span>)fmt.Print(<span class="hljs-string">&quot;请选择(1-5)：&quot;</span>)<span class="hljs-comment">// 接收用户的输入</span>fmt.Scanln(&amp;cv.key)<span class="hljs-comment">// 对用户的输入进行判断</span><span class="hljs-keyword">switch</span> cv.key &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:cv.addCustomer()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:cv.changeCustomer()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;3&quot;</span>:cv.deleteCustomer()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;4&quot;</span>:cv.showCustomer()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;5&quot;</span>:cv.exit()<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;请输入正确的选项------&quot;</span>)&#125;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
      <tag>Project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go项目-家庭收支记账软件</title>
    <link href="/2022/11/02/Go/Go-Project-Family-Ledger/"/>
    <url>/2022/11/02/Go/Go-Project-Family-Ledger/</url>
    
    <content type="html"><![CDATA[<p>Go项目-家庭收支记账软件</p><span id="more"></span><h1>项目开发流程</h1><p><a href="https://imgse.com/i/xHqQNd"><img src="https://s1.ax1x.com/2022/11/02/xHqQNd.md.png" alt="xHqQNd.md.png"></a></p><h1>项目需求说明</h1><ol><li>模拟实现基于文本界面的《家庭记账软件》</li><li>软件能够记录家庭的收入、支出，并能够打印收支明细表</li></ol><h1>项目代码编写</h1><h2 id="主菜单的设计">主菜单的设计</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 声明一个变量保存用户的输入</span>key := <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">// 声明一个变量，控制是否退出for循环</span>loop := <span class="hljs-literal">true</span><span class="hljs-comment">// 显示主菜单</span><span class="hljs-keyword">for</span> loop &#123;fmt.Println(<span class="hljs-string">&quot;---------------------家庭收支记账软件---------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       1 收支明细&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       2 登记收入&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       3 登记输出&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       4 退出软件&quot;</span>)fmt.Print(<span class="hljs-string">&quot;请选择(1-4)：&quot;</span>)<span class="hljs-comment">// 接收用户的输入</span>fmt.Scanln(&amp;key)<span class="hljs-comment">// 对用户的输入进行判断</span><span class="hljs-keyword">switch</span> key &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:fmt.Println(<span class="hljs-string">&quot;---------------------当前收支明细记录---------------------&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;3&quot;</span>:fmt.Println(<span class="hljs-string">&quot;登记支出------&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;4&quot;</span>:loop = <span class="hljs-literal">false</span><span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;请输入正确的选项------&quot;</span>)&#125;&#125;fmt.Println(<span class="hljs-string">&quot;-------------------退出家庭收支记账软件-------------------&quot;</span>)&#125;</code></pre></div><p>没啥有意思的，基础编程，效果如下：</p><p><a href="https://imgse.com/i/xHOuYd"><img src="https://s1.ax1x.com/2022/11/02/xHOuYd.png" alt="xHOuYd.png"></a></p><h2 id="显示明细与登记输入">显示明细与登记输入</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:fmt.Println(<span class="hljs-string">&quot;---------------------当前收支明细记录---------------------&quot;</span>)fmt.Println(details)<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:fmt.Println(<span class="hljs-string">&quot;-------------------------登记收入-------------------------&quot;</span>)fmt.Print(<span class="hljs-string">&quot;本次收入金额：&quot;</span>)fmt.Scanln(&amp;money)fmt.Print(<span class="hljs-string">&quot;本次收入说明：&quot;</span>)fmt.Scanln(&amp;note)balance += moneydetails += fmt.Sprintf(<span class="hljs-string">&quot;收  入\t%v\t%v\t%v\n&quot;</span>, balance, money, note)fmt.Println(<span class="hljs-string">&quot;收入登记成功！&quot;</span>)</code></pre></div><p>其中明细是用字符串拼接实现的，实际中应该是要操作数据库的</p><h2 id="登记支出">登记支出</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;3&quot;</span>:fmt.Println(<span class="hljs-string">&quot;-------------------------登记支出-------------------------&quot;</span>)fmt.Print(<span class="hljs-string">&quot;本次支出金额：&quot;</span>)fmt.Scanln(&amp;money)<span class="hljs-keyword">if</span> money &gt; balance &#123;fmt.Println(<span class="hljs-string">&quot;余额的金额不足！&quot;</span>)<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> money &lt;= <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;支出金额应为正数！&quot;</span>)&#125;fmt.Print(<span class="hljs-string">&quot;本次支出说明：&quot;</span>)fmt.Scanln(&amp;note)balance -= moneydetails += fmt.Sprintf(<span class="hljs-string">&quot;收  入\t%v\t%v\t%v\t%v\n&quot;</span>, balance+money, money, balance, note)fmt.Println(<span class="hljs-string">&quot;支出登记成功！&quot;</span>)</code></pre></div><p>注意支出的金额要小于账户余额，也要注意收入和支出的时候用户输入的数字需要为正数。</p><h2 id="完善代码">完善代码</h2><h3 id="退出时增加确认条件">退出时增加确认条件</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;4&quot;</span>:<span class="hljs-keyword">var</span> choice <span class="hljs-type">byte</span><span class="hljs-keyword">for</span> &#123;fmt.Print(<span class="hljs-string">&quot;确定退出？(y/n)：&quot;</span>)fmt.Scanf(<span class="hljs-string">&quot;%c\n&quot;</span>, &amp;choice)<span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;y&#x27;</span> &#123;loop = <span class="hljs-literal">false</span><span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;n&#x27;</span> &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误！！请重新输入&quot;</span>)&#125;&#125;</code></pre></div><p>注意scanf字符的时候与C语言是差不多的，需要考虑回车符号</p><h3 id="没有记录时不输出收支详情字符串">没有记录时不输出收支详情字符串</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 判断当前是否有输入或者输出的记录</span>flag := <span class="hljs-literal">false</span></code></pre></div><p>也没啥好说的，加个标志位，有记录的时候将这个标志位改掉就可以了</p><h2 id="面向对象">面向对象</h2><p>将上面的面向过程的代码修改成面向对象的代码</p><p>主要思想：将记账软件的功能封装到结构体中，然后调用这个结构体的方法完成功能。</p><h3 id="定义结构体">定义结构体</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 定义结构体</span><span class="hljs-keyword">type</span> FamilyAccount <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 声明一个变量保存用户的输入</span>key <span class="hljs-type">string</span><span class="hljs-comment">// 声明一个变量，控制是否退出for循环</span>loop <span class="hljs-type">bool</span><span class="hljs-comment">// 定义账户的初始值</span>balance <span class="hljs-type">float64</span><span class="hljs-comment">// 定义每次收支的金额和说明</span>money <span class="hljs-type">float64</span>note  <span class="hljs-type">string</span><span class="hljs-comment">// 收支的详情使用字符串来记录</span><span class="hljs-comment">// 当有记录时对这个字符串进行拼接</span>details <span class="hljs-type">string</span><span class="hljs-comment">// 判断当前是否有输入或者输出的记录</span>flag <span class="hljs-type">bool</span>&#125;</code></pre></div><p>注意定义结构体的时候不能进行初始化</p><h3 id="工厂模式返回结构体的指针">工厂模式返回结构体的指针</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 编写一个工厂模式的构造方法，返回结构体的指针</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFamilyAcount</span><span class="hljs-params">()</span></span> *FamilyAccount &#123;<span class="hljs-keyword">return</span> &amp;FamilyAccount&#123;key:     <span class="hljs-string">&quot;&quot;</span>,loop:    <span class="hljs-literal">true</span>,balance: <span class="hljs-number">10000.0</span>,money:   <span class="hljs-number">0.0</span>,note:    <span class="hljs-string">&quot;&quot;</span>,details: <span class="hljs-string">&quot;收  支\t收支前账户余额\t收支金额\t收支后账户余额\t说  明\n&quot;</span>,flag:    <span class="hljs-literal">false</span>,&#125;&#125;</code></pre></div><p>注意如果结构体是私有的是一定要有的，公开的也可以有，以后就要记得一定要有这样的一个方法</p><h3 id="编写各种方法">编写各种方法</h3><p>简单改造一下面向过程的代码即可完成面向对象的效果</p><p>将显示明细写成一个方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> showDetails() &#123;<span class="hljs-keyword">if</span> !fa.flag &#123;fmt.Println(<span class="hljs-string">&quot;当前没有任何收支记录！&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;---------------------当前收支明细记录---------------------&quot;</span>)fmt.Println(fa.details)&#125;&#125;</code></pre></div><p>将登记收入写成一个方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> income() &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------登记收入-------------------------&quot;</span>)fmt.Print(<span class="hljs-string">&quot;本次收入金额：&quot;</span>)fmt.Scanln(&amp;fa.money)<span class="hljs-comment">// 收入金额不能是负数</span><span class="hljs-keyword">if</span> fa.money &lt;= <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;收入金额应为正数！&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Print(<span class="hljs-string">&quot;本次收入说明：&quot;</span>)fmt.Scanln(&amp;fa.note)fa.balance += fa.moneyfa.details += fmt.Sprintf(<span class="hljs-string">&quot;收  入\t%v\t%v\t%v\t%v\n&quot;</span>, fa.balance-fa.money, fa.money, fa.balance, fa.note)fmt.Println(<span class="hljs-string">&quot;收入登记成功！&quot;</span>)fa.flag = <span class="hljs-literal">true</span>&#125;</code></pre></div><p>将登记支出写成一个方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> pay() &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------登记支出-------------------------&quot;</span>)fmt.Print(<span class="hljs-string">&quot;本次支出金额：&quot;</span>)fmt.Scanln(&amp;fa.money)<span class="hljs-keyword">if</span> fa.money &gt; fa.balance &#123;fmt.Println(<span class="hljs-string">&quot;余额的金额不足！&quot;</span>)<span class="hljs-keyword">return</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> fa.money &lt;= <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;支出金额应为正数！&quot;</span>)&#125;fmt.Print(<span class="hljs-string">&quot;本次支出说明：&quot;</span>)fmt.Scanln(&amp;fa.note)fa.balance -= fa.moneyfa.details += fmt.Sprintf(<span class="hljs-string">&quot;收  入\t%v\t%v\t%v\t%v\n&quot;</span>, fa.balance+fa.money, fa.money, fa.balance, fa.note)fmt.Println(<span class="hljs-string">&quot;支出登记成功！&quot;</span>)fa.flag = <span class="hljs-literal">true</span>&#125;</code></pre></div><p>将退出系统写成一个方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> exit() &#123;<span class="hljs-keyword">var</span> choice <span class="hljs-type">byte</span><span class="hljs-keyword">for</span> &#123;fmt.Print(<span class="hljs-string">&quot;确定退出？(y/n)：&quot;</span>)fmt.Scanf(<span class="hljs-string">&quot;%c\n&quot;</span>, &amp;choice)<span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;y&#x27;</span> &#123;fa.loop = <span class="hljs-literal">false</span><span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;n&#x27;</span> &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误！！请重新输入&quot;</span>)&#125;&#125;&#125;</code></pre></div><p>显示主菜单</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> MainMenu() &#123;<span class="hljs-comment">// 显示主菜单</span><span class="hljs-keyword">for</span> fa.loop &#123;fmt.Println(<span class="hljs-string">&quot;\n---------------------家庭收支记账软件---------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       1 收支明细&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       2 登记收入&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       3 登记输出&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       4 退出软件&quot;</span>)fmt.Print(<span class="hljs-string">&quot;请选择(1-4)：&quot;</span>)<span class="hljs-comment">// 接收用户的输入</span>fmt.Scanln(&amp;fa.key)<span class="hljs-comment">// 对用户的输入进行判断</span><span class="hljs-keyword">switch</span> fa.key &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:fa.showDetails()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:fa.income()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;3&quot;</span>:fa.pay()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;4&quot;</span>:fa.exit()<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;请输入正确的选项------&quot;</span>)&#125;&#125;&#125;</code></pre></div><h3 id="主函数中进行调用">主函数中进行调用</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;utils.NewFamilyAcount().MainMenu()&#125;</code></pre></div><h2 id="增加扩展功能">增加扩展功能</h2><p>添加一个用户登录的功能，即只有将用户名和密码输入正确后才能打开软件，否则无法看到主界面</p><p>实现：在显示菜单之前增加一个无限循环要求用户输入用户名和密码，只有输入正确才能退出循环</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">var</span> username, password <span class="hljs-type">string</span>fmt.Print(<span class="hljs-string">&quot;请输入用户名：&quot;</span>)fmt.Scanln(&amp;username)fmt.Print(<span class="hljs-string">&quot;请输入密码：&quot;</span>)fmt.Scanln(&amp;password)<span class="hljs-keyword">if</span> fa.login(username, password) &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;用户名或密码错误！&quot;</span>)&#125;&#125;</code></pre></div><p>用户登录的方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> login(username <span class="hljs-type">string</span>, password <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">if</span> (username == fa.username) &amp;&amp; (password == fa.password) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></div><h1>完整源代码</h1><h2 id="面向过程的代码">面向过程的代码</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 声明一个变量保存用户的输入</span>key := <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">// 声明一个变量，控制是否退出for循环</span>loop := <span class="hljs-literal">true</span><span class="hljs-comment">// 定义账户的初始值</span>balance := <span class="hljs-number">10000.0</span><span class="hljs-comment">// 定义每次收支的金额和说明</span><span class="hljs-keyword">var</span> money <span class="hljs-type">float64</span><span class="hljs-keyword">var</span> note <span class="hljs-type">string</span><span class="hljs-comment">// 收支的详情使用字符串来记录</span><span class="hljs-comment">// 当有记录时对这个字符串进行拼接</span>details := <span class="hljs-string">&quot;收  支\t收支前账户余额\t收支金额\t收支后账户余额\t说  明\n&quot;</span><span class="hljs-comment">// 判断当前是否有输入或者输出的记录</span>flag := <span class="hljs-literal">false</span><span class="hljs-comment">// 显示主菜单</span><span class="hljs-keyword">for</span> loop &#123;fmt.Println(<span class="hljs-string">&quot;\n---------------------家庭收支记账软件---------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       1 收支明细&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       2 登记收入&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       3 登记输出&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       4 退出软件&quot;</span>)fmt.Print(<span class="hljs-string">&quot;请选择(1-4)：&quot;</span>)<span class="hljs-comment">// 接收用户的输入</span>fmt.Scanln(&amp;key)<span class="hljs-comment">// 对用户的输入进行判断</span><span class="hljs-keyword">switch</span> key &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:<span class="hljs-keyword">if</span> !flag &#123;fmt.Println(<span class="hljs-string">&quot;当前没有任何收支记录！&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;---------------------当前收支明细记录---------------------&quot;</span>)fmt.Println(details)&#125;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:fmt.Println(<span class="hljs-string">&quot;-------------------------登记收入-------------------------&quot;</span>)fmt.Print(<span class="hljs-string">&quot;本次收入金额：&quot;</span>)fmt.Scanln(&amp;money)<span class="hljs-comment">// 收入金额不能是负数</span><span class="hljs-keyword">if</span> money &lt;= <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;收入金额应为正数！&quot;</span>)<span class="hljs-keyword">break</span>&#125;fmt.Print(<span class="hljs-string">&quot;本次收入说明：&quot;</span>)fmt.Scanln(&amp;note)balance += moneydetails += fmt.Sprintf(<span class="hljs-string">&quot;收  入\t%v\t%v\t%v\t%v\n&quot;</span>, balance-money, money, balance, note)fmt.Println(<span class="hljs-string">&quot;收入登记成功！&quot;</span>)flag = <span class="hljs-literal">true</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;3&quot;</span>:fmt.Println(<span class="hljs-string">&quot;-------------------------登记支出-------------------------&quot;</span>)fmt.Print(<span class="hljs-string">&quot;本次支出金额：&quot;</span>)fmt.Scanln(&amp;money)<span class="hljs-keyword">if</span> money &gt; balance &#123;fmt.Println(<span class="hljs-string">&quot;余额的金额不足！&quot;</span>)<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> money &lt;= <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;支出金额应为正数！&quot;</span>)&#125;fmt.Print(<span class="hljs-string">&quot;本次支出说明：&quot;</span>)fmt.Scanln(&amp;note)balance -= moneydetails += fmt.Sprintf(<span class="hljs-string">&quot;收  入\t%v\t%v\t%v\t%v\n&quot;</span>, balance+money, money, balance, note)fmt.Println(<span class="hljs-string">&quot;支出登记成功！&quot;</span>)flag = <span class="hljs-literal">true</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;4&quot;</span>:<span class="hljs-keyword">var</span> choice <span class="hljs-type">byte</span><span class="hljs-keyword">for</span> &#123;fmt.Print(<span class="hljs-string">&quot;确定退出？(y/n)：&quot;</span>)fmt.Scanf(<span class="hljs-string">&quot;%c\n&quot;</span>, &amp;choice)<span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;y&#x27;</span> &#123;loop = <span class="hljs-literal">false</span><span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;n&#x27;</span> &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误！！请重新输入&quot;</span>)&#125;&#125;<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;请输入正确的选项------&quot;</span>)&#125;&#125;fmt.Println(<span class="hljs-string">&quot;-------------------退出家庭收支记账软件-------------------&quot;</span>)&#125;</code></pre></div><h2 id="面向对象的代码">面向对象的代码</h2><p>.<br>├── Family-Ledger<br>│   ├── main<br>│   │   └── main.go<br>│   └── utils<br>│       └── familyAccount.go</p><p>main.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;Go-Projects/Family-Ledger/utils&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;utils.NewFamilyAcount().MainMenu()&#125;</code></pre></div><p>familyAccount.go</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> utils<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// 定义结构体</span><span class="hljs-keyword">type</span> FamilyAccount <span class="hljs-keyword">struct</span> &#123;<span class="hljs-comment">// 用户名和密码</span>username <span class="hljs-type">string</span>password <span class="hljs-type">string</span><span class="hljs-comment">// 声明一个变量保存用户的输入</span>key <span class="hljs-type">string</span><span class="hljs-comment">// 声明一个变量，控制是否退出for循环</span>loop <span class="hljs-type">bool</span><span class="hljs-comment">// 定义账户的初始值</span>balance <span class="hljs-type">float64</span><span class="hljs-comment">// 定义每次收支的金额和说明</span>money <span class="hljs-type">float64</span>note  <span class="hljs-type">string</span><span class="hljs-comment">// 收支的详情使用字符串来记录</span><span class="hljs-comment">// 当有记录时对这个字符串进行拼接</span>details <span class="hljs-type">string</span><span class="hljs-comment">// 判断当前是否有输入或者输出的记录</span>flag <span class="hljs-type">bool</span>&#125;<span class="hljs-comment">// 编写一个工厂模式的构造方法，返回结构体的指针</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFamilyAcount</span><span class="hljs-params">()</span></span> *FamilyAccount &#123;<span class="hljs-keyword">return</span> &amp;FamilyAccount&#123;username: <span class="hljs-string">&quot;admin&quot;</span>,password: <span class="hljs-string">&quot;password&quot;</span>,key:      <span class="hljs-string">&quot;&quot;</span>,loop:     <span class="hljs-literal">true</span>,balance:  <span class="hljs-number">10000.0</span>,money:    <span class="hljs-number">0.0</span>,note:     <span class="hljs-string">&quot;&quot;</span>,details:  <span class="hljs-string">&quot;收  支\t收支前账户余额\t收支金额\t收支后账户余额\t说  明\n&quot;</span>,flag:     <span class="hljs-literal">false</span>,&#125;&#125;<span class="hljs-comment">// 给结构体绑定相应的方法</span><span class="hljs-comment">// 将显示明细写成一个方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> showDetails() &#123;<span class="hljs-keyword">if</span> !fa.flag &#123;fmt.Println(<span class="hljs-string">&quot;当前没有任何收支记录！&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;---------------------当前收支明细记录---------------------&quot;</span>)fmt.Println(fa.details)&#125;&#125;<span class="hljs-comment">// 将登记收入写成一个方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> income() &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------登记收入-------------------------&quot;</span>)fmt.Print(<span class="hljs-string">&quot;本次收入金额：&quot;</span>)fmt.Scanln(&amp;fa.money)<span class="hljs-comment">// 收入金额不能是负数</span><span class="hljs-keyword">if</span> fa.money &lt;= <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;收入金额应为正数！&quot;</span>)<span class="hljs-keyword">return</span>&#125;fmt.Print(<span class="hljs-string">&quot;本次收入说明：&quot;</span>)fmt.Scanln(&amp;fa.note)fa.balance += fa.moneyfa.details += fmt.Sprintf(<span class="hljs-string">&quot;收  入\t%v\t%v\t%v\t%v\n&quot;</span>, fa.balance-fa.money, fa.money, fa.balance, fa.note)fmt.Println(<span class="hljs-string">&quot;收入登记成功！&quot;</span>)fa.flag = <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// 将登记支出写成一个方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> pay() &#123;fmt.Println(<span class="hljs-string">&quot;-------------------------登记支出-------------------------&quot;</span>)fmt.Print(<span class="hljs-string">&quot;本次支出金额：&quot;</span>)fmt.Scanln(&amp;fa.money)<span class="hljs-keyword">if</span> fa.money &gt; fa.balance &#123;fmt.Println(<span class="hljs-string">&quot;余额的金额不足！&quot;</span>)<span class="hljs-keyword">return</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> fa.money &lt;= <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;支出金额应为正数！&quot;</span>)&#125;fmt.Print(<span class="hljs-string">&quot;本次支出说明：&quot;</span>)fmt.Scanln(&amp;fa.note)fa.balance -= fa.moneyfa.details += fmt.Sprintf(<span class="hljs-string">&quot;收  入\t%v\t%v\t%v\t%v\n&quot;</span>, fa.balance+fa.money, fa.money, fa.balance, fa.note)fmt.Println(<span class="hljs-string">&quot;支出登记成功！&quot;</span>)fa.flag = <span class="hljs-literal">true</span>&#125;<span class="hljs-comment">// 将退出系统写成一个方法</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> exit() &#123;<span class="hljs-keyword">var</span> choice <span class="hljs-type">byte</span><span class="hljs-keyword">for</span> &#123;fmt.Print(<span class="hljs-string">&quot;确定退出？(y/n)：&quot;</span>)fmt.Scanf(<span class="hljs-string">&quot;%c\n&quot;</span>, &amp;choice)<span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;y&#x27;</span> &#123;fa.loop = <span class="hljs-literal">false</span><span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> choice == <span class="hljs-string">&#x27;n&#x27;</span> &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;输入有误！！请重新输入&quot;</span>)&#125;&#125;&#125;<span class="hljs-comment">// 用户登录的功能</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> login(username <span class="hljs-type">string</span>, password <span class="hljs-type">string</span>) <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">if</span> (username == fa.username) &amp;&amp; (password == fa.password) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// 显示主菜单</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(fa *FamilyAccount)</span></span> MainMenu() &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">var</span> username, password <span class="hljs-type">string</span>fmt.Print(<span class="hljs-string">&quot;请输入用户名：&quot;</span>)fmt.Scanln(&amp;username)fmt.Print(<span class="hljs-string">&quot;请输入密码：&quot;</span>)fmt.Scanln(&amp;password)<span class="hljs-keyword">if</span> fa.login(username, password) &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;用户名或密码错误！&quot;</span>)&#125;&#125;<span class="hljs-comment">// 显示主菜单</span><span class="hljs-keyword">for</span> fa.loop &#123;fmt.Println(<span class="hljs-string">&quot;\n---------------------家庭收支记账软件---------------------&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       1 收支明细&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       2 登记收入&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       3 登记输出&quot;</span>)fmt.Println(<span class="hljs-string">&quot;                       4 退出软件&quot;</span>)fmt.Print(<span class="hljs-string">&quot;请选择(1-4)：&quot;</span>)<span class="hljs-comment">// 接收用户的输入</span>fmt.Scanln(&amp;fa.key)<span class="hljs-comment">// 对用户的输入进行判断</span><span class="hljs-keyword">switch</span> fa.key &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1&quot;</span>:fa.showDetails()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;2&quot;</span>:fa.income()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;3&quot;</span>:fa.pay()<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;4&quot;</span>:fa.exit()<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;请输入正确的选项------&quot;</span>)&#125;&#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
      <tag>Project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第18讲 链接分析</title>
    <link href="/2022/10/28/UCAS/information-retrieval/information-retrieval-18/"/>
    <url>/2022/10/28/UCAS/information-retrieval/information-retrieval-18/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第18讲 链接分析</p><span id="more"></span><h1>第18讲 链接分析</h1><p>链接无处不在</p><ul><li>真实性和权威性的有效来源<ul><li>垃圾邮件-哪些电子邮件帐户是垃圾邮件发送者？</li><li>host质量-哪些 host 质量不好？</li><li>电话呼叫记录</li></ul></li><li>好节点、坏节点和未知节点<ul><li>好节点不会指向坏节点<ul><li>如果一个节点指向了坏节点，那么这个节点是坏节点</li><li>如果一个好节点指向这个节点，那么这个节点是好节点</li></ul></li><li>所有其他貌似合理的组合</li></ul></li></ul><p>为什么我们对链接分析感兴趣？</p><p>链接分析对目前为止的完全基于文本的IR任务进行了补充</p><ul><li>（文档）评分和排序</li><li>基于链接的聚类-来自链接的主题结构</li><li>链接作为分类特征-彼此链接的文档可能是同一主题</li><li>爬虫-根据已看到的链接，我们下一步要爬取哪里？</li></ul><p>Web可以看成一个有向图</p><ul><li>假设1: 超链接代表了某种质量认可信号</li><li>假设2: 锚文本描述了文档d2 的内容</li></ul><p>对锚文本构建索引</p><ul><li>因此，锚文本往往比网页本身更能揭示网页的内容</li><li>在计算过程中，锚文本应该被赋予比文档中文本更高的权重</li></ul><p>PageRank背后的假设</p><ul><li>假设1：Web 上的链接是网页质量的标志-链出网页的作者认为链向的网页具有很高的质量</li><li>假设2：锚文本能够描述链向网页的内容</li></ul><p>Google炸弹：指由于人为恶意构造锚文本而导致的结果很差的搜索。用户群体有意创建链接误导搜索引擎</p><p>锚文本索引：将从指向文档D的链接的锚文本（也可能包含锚文本附近的文本）包含在D的索引中</p><p>有时会产生低于期望的效果，例如：垃圾邮件过滤应用全然失败</p><p>可以根据锚页面网站的权威性对锚文本进行加权</p><p>链接服务器：低成本地获取所有链接信息</p><ul><li>支持网络图上的快速查询</li><li>将映射存储在内存中</li><li>应用：链接分析、网络图分析、爬虫控制</li></ul><p>Boldi and Vigna：基本目标-维护内存中的节点邻接表</p><p>邻接表压缩中利用到的属性：</p><ul><li>相似度（邻接表之间）</li><li>位置（一个页面中的许多链接都连接到“附近”的页面）</li><li>在已排序的邻接表中使用间隔编码</li><li>gap value的分布</li></ul><p>间隔编码</p><p>给出整数x,y,z 的已排序列表，用 x y-x z-y 来对 x,y,z 进行表示</p><p>使用编码来压缩整数</p><p>BV算法的主要优势</p><ul><li>仅依赖于位置的规范顺序<ul><li>字典顺序对web十分适用</li></ul></li><li>邻接查询可以被非常高效地回答<ul><li>要获取外部邻居，需要回溯到链的原型</li><li>在实践中，这条链通常很短（因为相似性主要基于host 内部）</li><li>编码过程中也可以明确限制链的长度</li></ul></li><li>易于实现one pass 算法<ul><li>顺序读取，不需要无限缓冲。读取复杂度与网页数量是线性关系</li></ul></li></ul><h2 id="引用分析">引用分析</h2><p>引用分析：科技文献中的引用分析</p><p>另一个应用：引用频率可以用度量一篇文档的影响度</p><p>更好的度量方法：对不同网页来的引用频率进行加权</p><h2 id="PageRank">PageRank</h2><ul><li>一个网页如果它的入链越多，那么它也越重要（PageRank 越高）</li><li>一个网页如果被越重要的网页所指向，那么它也越重要（PageRank 越高 )</li></ul><p>原始PageRank的一个不足：图中存在一个循环通路，每次迭代，该循环通路中的每个节点的 PageRank不断增加，但是它们并不指出去，即不将PageRank分配给其他节点！</p><p>改进的PageRank公式：随机冲浪或随机游走(Random Walk)模型</p><h2 id="HITS-Hub节点-Authority节点">HITS: Hub节点&amp;Authority节点</h2><p>每个网页计算两个值：</p><p>Hub：作为目录型或导航型网页的权重</p><p>Authority：作为权威型网页的权重</p><p>一个网页被越重要的导航型网页指向越多，那么它的Authority越大；</p><p>一个网页指向的高重要度权威型网页越多，那么它的Hub越大。</p><p>HITS算法也是收敛的，也可以通过迭代的方式计算。</p><p>HITS算法的实际计算过程</p><ul><li>首先进行Web 搜索；</li><li>搜索的结果称为根集（从搜索结果中选择一部分排名靠前的网页作为根集，也叫做种子集合）</li><li>将所有链向种子集合和种子集合链出的网页加入到种子集合；</li><li>新的更大的集合称为基本集</li><li>最后，在基本集上计算每个网页的hub值和authority值（该基本集可以看成一个小的Web图）。</li></ul><p>PageRank vs. HITS</p><p>网页的PageRank 与查询主题无关，可以事先算好，因此适合于大型搜索引擎的应用。</p><p>HITS算法的计算与查询主题相关，检索之后再进行计算，因此，不适合于大型搜索引擎。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第17讲 信息采集</title>
    <link href="/2022/10/25/UCAS/information-retrieval/information-retrieval-17/"/>
    <url>/2022/10/25/UCAS/information-retrieval/information-retrieval-17/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第17讲 信息采集</p><span id="more"></span><h1>第17讲 信息采集</h1><h2 id="一个简单的采集器">一个简单的采集器</h2><p>基本的采集过程</p><ul><li>初始化采集URL 种子队列</li><li>重复如下过程<ul><li>从队列中取出URL</li><li>下载并分析网页</li><li>从网页中抽取更多的URL</li><li>将这些URL 放到队列中</li></ul></li></ul><p>上述简单采集器的问题：</p><ul><li>规模问题：必须要分布式处理</li><li>我们不可能索引所有网页，必须要从中选择部分网页，如何选择？</li><li>重复网页：必须要集成重复检测功能</li><li>作弊网页和采集器陷阱：必须要集成作弊网页检测功能</li><li>礼貌性问题：对同一网站的访问按遵照协议规定，并且访问的间隔必须要足够</li><li>新鲜度问题：必须要定期更新或者重采<ul><li>由于Web 的规模巨大，我们只能对一个小的网页子集频繁重采</li><li>同样，这也存在一个选择或者优先级问题</li></ul></li></ul><p>采集器必须做到</p><ul><li>礼貌性<ul><li>不要高频率采集某个网站</li><li>仅仅采集robots.txt 所规定的可以采集的网页</li></ul></li><li>鲁棒性<ul><li>能够处理采集器陷阱、重复页面、超大页面、超大网站、动态页面等问题v</li></ul></li></ul><p>任意一个采集器应该做到：</p><ul><li>能够进行分布式处理</li><li>支持规模的扩展：能够通过增加机器支持更高的采集速度</li><li>优先采集高质量网页</li><li>能够持续运行：对已采集网页进行更新</li></ul><h2 id="一个真实的采集器">一个真实的采集器</h2><p>待采集URL池：</p><ul><li>待采集URL池是一个数据结构，它存放并管理那些已经看到但是还没有采集的URL集合</li><li>可能包含来自同一主机的不同页面</li><li>必要要避免在同一时间采集这些来自同一主机的页面</li><li>必须要保证采集线程任务饱和</li></ul><p>基本的采集架构</p><p>URL规范化</p><p>内容重复判别</p><ul><li>对每个抓取的页面，判断它是否已在索引当中</li><li>可以采用文档指纹或者shingle 的方法判别</li><li>忽略那些已经在索引中的重复页面</li></ul><p>分布式采集</p><ul><li>运行多个采集线程，这些线程可以分布在不同节点上<ul><li>这些节点往往在地理上分散在不同位置</li></ul></li><li>将采集的主机分配到不同节点上</li></ul><p>分布式采集器</p><p>待采集URL池 : 主要考虑两点</p><ul><li>礼貌性: 不要非常频繁第访问某个 Web 服务器<ul><li>比如，可以在两次服务器访问之间设置一个时间间隔</li></ul></li><li>新鲜度: 对某些网站的采集频率如新闻网站要高于其他网站</li></ul><p>采集器陷阱</p><ul><li>一些恶意的服务器可以产生无穷的链接网页序列</li><li>一些复杂的采集器陷阱产生的页面不能简单地判断为动态页面</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第16讲 Web搜索</title>
    <link href="/2022/10/22/UCAS/information-retrieval/information-retrieval-16/"/>
    <url>/2022/10/22/UCAS/information-retrieval/information-retrieval-16/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第16讲 Web搜索</p><span id="more"></span><h1>第16讲 Web搜索</h1><h2 id="互联网上的搜索">互联网上的搜索</h2><p>搜索是Web上使用最多的应用之一</p><p>没有搜索引擎，Web甚至无法运转</p><ul><li>没有搜索，很难找到所需的内容</li><li>没有搜索，在Web上创建内容也就缺了动机<ul><li>如果没人看为什么要发布内容？</li><li>如果没有任何回报为什么要发布内容？</li></ul></li><li>Web运转必须要有人买单<ul><li>服务器、Web 基础设施、内容创建过程等需要费用支持</li><li>这些费用的相当大一部分都是通过搜索广告支付</li><li>可以说，搜索为Web 买单</li></ul></li></ul><p>兴趣聚合：具有相同兴趣的人，即使所处地理位置分散，也可以通过Web找到对方。</p><p>搜索引擎是实现兴趣聚合的关键事物</p><p>在Web上，搜索不仅仅是一个好的特点</p><p>Web是一个充满噪声数据且组织失调的集合体→大量的重复需要检测</p><p>用户可以（某种意义上）无控制和无限制地发布内容→大量作弊内容需要检测</p><h2 id="互联网广告">互联网广告</h2><p>传统广告：品牌广告、直接营销、</p><p>传统广告的不足：</p><ul><li>广告投放场地或媒介相对有限：报纸、电视、杂志、橱窗、公汽、电梯等</li><li>广告场地的费用一般不菲：CCTV 标王</li><li>很难进行个性化</li><li>投放效果取决于广告商的智慧</li><li>投放效果很难度量</li></ul><p>互联网广告的优点：</p><ul><li>无限机会</li><li>无限创意</li><li>完全可以个性化处理</li><li>每次点击花费的代价很低</li><li>定量度量程度高</li></ul><p>互联网广告的主要形式：图片广告、文本广告、搜索广告、网页广告、</p><p>第一代搜索广告：Goto</p><p>第二代搜索广告：Google</p><p>如何对广告排序？</p><ul><li>简单的方法：按照类似 Goto 的方式，即按照投标价格排序</li><li>替代方法：按照投标价格和相关性排序（相关度度量的关键指标：点击率）</li></ul><p>Web查询“长尾”现象：基于AOL查询频次的统计、基于查询频次的流量统计</p><p>长尾效应的解释</p><ul><li>大多数用户搜索“常见”查询；一小部分用户搜索“罕见”查询</li><li>大量用户使用“常见”查询；同时大量用户也会使用一些“罕见”查询</li></ul><h2 id="重复检测">重复检测</h2><ul><li>Web上充斥重复内容</li><li>相对其它文档集合，Web 上的重复内容更多</li><li>完全重复：易剔除，比如采用哈希指纹的方法</li><li>近似重复：Web上存在大量近似重复，很难剔除</li><li>对用户而言，如果搜索结果中存在不少几乎相同的页面，那么体验非常不好</li><li>边缘相关度（Marginal relevance) 为 0 ：如果一篇高度相关的文档出现在另一篇高度近似的文档之后，那么该文档变得不相关</li><li>必须要去除这些近似重复</li></ul><p>近似重复的检测：采用编辑距离指标计算页面之间的相似度</p><p>将每篇文档表示成一个shingle 集合</p><p>每个shingle 是一个基于词语的 n-gram</p><p>使用shingle 来计算文档之间的语法相似度</p><p>两个文档的相似度定义为它们的shingle 集合的Jaccard距离</p><p>每篇文档的shingle的个数非常大</p><p>为提高效率，接下来我们使用文档的梗概来表示文档，它由文档的shingle集合中精巧挑选出的子集构成</p><p>高效的近似重复检测：局部敏感哈希或排序</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第8讲 逻辑</title>
    <link href="/2022/10/20/UCAS/advanced-ai/advanced-ai-8/"/>
    <url>/2022/10/20/UCAS/advanced-ai/advanced-ai-8/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第8讲 逻辑</p><span id="more"></span><h1>第8讲 逻辑</h1><p>什么是“数理逻辑”？</p><ul><li>一种“算法”：输入+输出，不仅要得到算法，还要证明是正确的</li><li>一种“关于证明、推理等思考活动”的算法</li></ul><p>一个算法，以任何作为输入，输出的都是正确答案</p><p>输入：</p><ul><li>知识库：任意的问题假设，前提条件等</li><li>查询：想要解决的问题</li></ul><p>输出答案：该查询在此知识库上的正确答案</p><p>如果有上面的算法，那么所有难题都能得到解决</p><p>如果有这样的一种“终极算法”，首先要将<strong>自然语言表达的知识库和查询</strong>表示成<strong>形式语言表达的知识库和查询</strong>，然后通过<strong>自动的知识推理</strong>，得到<strong>形式语言表达的答案</strong></p><h2 id="逻辑的研究内容">逻辑的研究内容</h2><p>解决如下问题：</p><ul><li>关于逻辑的形式语言是什么</li><li>在形式语言上的自动推理的算法是什么<ul><li>该算法复杂度如何，是否可以更高效</li></ul></li><li>自动推理的算法是否正确<ul><li>算法正确性的严格证明</li></ul></li></ul><p>研究形式化定义的sentences之间的关系</p><p><a href="https://imgse.com/i/x6PrGD"><img src="https://s1.ax1x.com/2022/10/20/x6PrGD.md.png" alt="x6PrGD.md.png"></a></p><p>左侧是语义的蕴含关系（逻辑推导），<img src="https://math.now.sh?inline=%5Cmodels" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，从知识库出发一定正确的知识</p><p>右侧是语法的演绎关系（形式推演），<img src="https://math.now.sh?inline=%5Cvdash" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，通过算法可以从知识库推出的</p><p>如果左侧的是右侧的子集，说明正确的结论都在算法推导的里面，那么说明这个算法是完备的，但是有一些结论可能算法计算出来是错误的</p><p>如果右侧的是左侧的子集，说明算法推出来的结论都是正确的，因此算法是可靠的，但是有可能有一些正确的结论算法算不出来</p><p>如果兼具完备性和可靠性，那么证明这个算法是正确的。</p><h2 id="语义">语义</h2><p>如果<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件下是 <code>true</code>，那么称<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是句子<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的一个 <code>model</code>，句子<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的所有model的集合是<img src="https://math.now.sh?inline=M%28%5Calpha%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><code>KB</code>指的是一些句子的集合</p><p><img src="https://math.now.sh?inline=KB%5Cmodels%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：在任意的条件下（一个真值指派）只要<img src="https://math.now.sh?inline=KB" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>成立，<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>一定成立，称为 <code>KB</code>蕴含<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此<img src="https://math.now.sh?inline=KB%5Cmodels%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=M%28KB%29%5Csubseteq%20M(%5Calpha)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>完全等价（当且仅当）（<img src="https://math.now.sh?inline=KB%20%5CRightarrow%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=KB%20%5Cland%20%5Cneg%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是不可满足的）</p><h2 id="命题逻辑">命题逻辑</h2><h3 id="语法（逻辑推导）">语法（逻辑推导）</h3><p>命题是一种声明，要么是真的，要么是假的，不存在第三种可能</p><p>命题逻辑通常不考虑时间</p><p>原子命题指的是最小的命题，用大写字母表达</p><p>文字是原子命题，或者是原子命题的否</p><p>一个句子是一个原子句或者复杂句</p><p>一个原子句表示为：<img src="https://math.now.sh?inline=True%2CFalse%2CP%2CQ%2CR%5Ccdots" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>复杂句有五种表示形式，与复杂句之间的真值表：</p><table><thead><tr><th><img src="https://math.now.sh?inline=P" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th><th><img src="https://math.now.sh?inline=Q" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th><th><img src="https://math.now.sh?inline=%5Cneg%20P" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th><th><img src="https://math.now.sh?inline=P%5Cland%20Q" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th><th><img src="https://math.now.sh?inline=P%5Clor%20Q" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th><th><img src="https://math.now.sh?inline=P%5CRightarrow%20Q" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th><th><img src="https://math.now.sh?inline=P%5CLeftrightarrow%20Q" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></th></tr></thead><tbody><tr><td>false</td><td>false</td><td>true</td><td>false</td><td>false</td><td>true</td><td>true</td></tr><tr><td>false</td><td>true</td><td>true</td><td>false</td><td>true</td><td>true</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>true</td><td>false</td><td>true</td><td>true</td><td>true</td><td>true</td></tr></tbody></table><p>连接词和集合之间的联系：</p><p><img src="https://math.now.sh?inline=M%28P%5Cland%20Q%29%3DM(P)%5Ccap%20M(Q)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=M%28P%5Clor%20Q%29%3DM(P)%5Ccup%20M(Q)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>两个句子是逻辑等价的-两个句子的model相同：<img src="https://math.now.sh?inline=%5Calpha%20%5Cequiv%20%5Cbeta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 当且仅当 <img src="https://math.now.sh?inline=%5Calpha%20%5CvDash%20%5Cbeta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 且 <img src="https://math.now.sh?inline=%5Cbeta%20%5CvDash%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>定理：</p><p><img src="https://math.now.sh?inline=%5Cbegin%7Baligned%7D%28%5Calpha%20%5Cwedge%20%5Cbeta%29%20%26%20%5Cequiv(%5Cbeta%20%5Cwedge%20%5Calpha)%20%5Cquad%20%20%5C%5C(%5Calpha%20%5Cvee%20%5Cbeta)%20%26%20%5Cequiv(%5Cbeta%20%5Cvee%20%5Calpha)%20%5Cquad%20%20%5C%5C((%5Calpha%20%5Cwedge%20%5Cbeta)%20%5Cwedge%20%5Cgamma)%20%26%20%5Cequiv(%5Calpha%20%5Cwedge(%5Cbeta%20%5Cwedge%20%5Cgamma))%20%5Cquad%20%20%5C%5C((%5Calpha%20%5Cvee%20%5Cbeta)%20%5Cvee%20%5Cgamma)%20%26%20%5Cequiv(%5Calpha%20%5Cvee(%5Cbeta%20%5Cvee%20%5Cgamma))%20%5Cquad%20%20%5C%5C%20%5Cneg(%5Cneg%20%5Calpha)%20%26%20%5Cequiv%20%5Calpha%20%5Cquad%20%20%5C%5C(%5Calpha%20%5CRightarrow%20%5Cbeta)%20%26%20%5Cequiv(%5Cneg%20%5Cbeta%20%5CRightarrow%20%5Cneg%20%5Calpha)%20%20%5C%5C(%5Calpha%20%5CRightarrow%20%5Cbeta)%20%26%20%5Cequiv(%5Cneg%20%20%5Calpha%20%5Cvee%20%5Cbeta)%20%5Cquad%20%20%5C%5C(%5Calpha%20%5CLeftrightarrow%20%5Cbeta)%20%26%20%5Cequiv((%5Calpha%20%5CRightarrow%20%5Cbeta)%20%5Cwedge(%5Cbeta%20%5CRightarrow%20%5Calpha))%5C%5C%20%5Cneg(%5Calpha%20%5Cwedge%20%5Cbeta)%20%26%20%5Cequiv(%5Cneg%20%5Calpha%20%5Cvee%20%5Cneg%20%5Cbeta)%20%5Cquad%20%20%5C%5C%20%5Cneg(%5Calpha%20%5Cvee%20%5Cbeta)%20%26%20%5Cequiv(%5Cneg%20%5Calpha%20%5Cwedge%20%5Cneg%20%5Cbeta)%20%5Cquad%20%20%5C%5C(%5Calpha%20%5Cwedge(%5Cbeta%20%5Cvee%20%5Cgamma))%20%26%20%5Cequiv((%5Calpha%20%5Cwedge%20%5Cbeta)%20%5Cvee(%5Calpha%20%5Cwedge%20%5Cgamma))%20%5C%5C(%5Calpha%20%5Cvee(%5Cbeta%20%5Cwedge%20%5Cgamma))%20%26%20%5Cequiv((%5Calpha%20%5Cvee%20%5Cbeta)%20%5Cwedge(%5Calpha%20%5Cvee%20%5Cgamma))%20%5Cend%7Baligned%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>KB: 满足命题逻辑语法的sentence的集合</p><p>假设：这组sentence中，一共有n个原子命题</p><p>真值指派（truth assignment）：对每个原子名字赋值</p><p>一共有<img src="https://math.now.sh?inline=2%5En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>种真值指派，其中：使得KB中的每个sentence都为真的真值指派，就是KB的model</p><p>在此基础上，在命题逻辑中，我们可以明确的定义<img src="https://math.now.sh?inline=KB%5Cmodels%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li>如果一个句子在任意的model下面都为true，则这个句子是永真的</li><li>演绎定理： <img src="https://math.now.sh?inline=KB%5Cmodels%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>当且仅当<img src="https://math.now.sh?inline=KB%20%5CRightarrow%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是永真的</li><li>如果一个句子在某些model下为真，则称这个句子是可满足的</li><li>如果一个句子在任何model下都为假，则称这个句子是不可满足的</li><li><img src="https://math.now.sh?inline=KB%5Cmodels%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>当且仅当<img src="https://math.now.sh?inline=KB%20%5Cland%20%5Cneg%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是不可满足的</li></ul><p><img src="https://math.now.sh?inline=KB%5Cmodels%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>蕴含，不是连接词：描述的是蕴含的一种关系，有了知识表示后，额外推出其他的知识</p><p><img src="https://math.now.sh?inline=KB%20%5CRightarrow%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>命题逻辑里面的连接词，用于知识表示（实际上是可以替代的，但是引入这个符号进行知识表示比较方便）</p><h3 id="形式推演">形式推演</h3><p>推出：<img src="https://math.now.sh?inline=%5Cvdash" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，通过算法可以从知识库推出的</p><p>共有两套规则（11条规则和归结原理）</p><p>11条形式推演规则：（不需要背诵）</p><p>形式可推演性：A在命题逻辑中由<img src="https://math.now.sh?inline=%5CSigma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>形式可推演的，记作<img src="https://math.now.sh?inline=%5CSigma%20%5Cvdash%20A" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，当且仅当<img src="https://math.now.sh?inline=%5CSigma%20%5Cvdash%20A" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>能由（有限次使用）命题逻辑的形式推演规则生成</p><p>句子<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可以通过规则<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>从KB中得出，记作<img src="https://math.now.sh?inline=KB%20%5Cvdash_i%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>可靠性：任意时刻当<img src="https://math.now.sh?inline=KB%20%5Cvdash_i%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，<img src="https://math.now.sh?inline=KB%5Cmodels%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>同时成立，那么说<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是可靠的</strong></p><p><strong>完备性：任意时刻当<img src="https://math.now.sh?inline=KB%5Cmodels%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，<img src="https://math.now.sh?inline=KB%20%5Cvdash_i%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>同时成立，那么说<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是完备的</strong></p><h4 id="归结原理">归结原理</h4><p>合取范式：子句（文字和析取符号）的合取形式，子句内部是没有合取的（CNF）转换为合取范式是多项式时间复杂度的</p><p>归结原理：互补文字可以互相消去（但是每一次只能消去一对）</p><p><strong>归结原理是既可靠又完备的</strong></p><p>证明：若<img src="https://math.now.sh?inline=KB%5Cnvdash%5Cemptyset" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=KB%5Cvdash%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>当且仅当<img src="https://math.now.sh?inline=%5C%7BKB%2C%5Cneg%5Calpha%5C%7D%20%5Cvdash%5Cemptyset" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cvdash" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>仅使用归结法则获得新子句</p><p>使用上述证明来证明知识库可以推出某个子句</p><h4 id="证明：归结原理既可靠又完备">证明：归结原理既可靠又完备</h4><p>在研究可靠性与完备性问题时，应当把语法层面的知识理解为Groundtruth</p><p>因此可靠性可以大概表述为：语义上推演得到的知识在语法上正确。因此要证明归结原理的可靠性，即证明</p><p><a href="https://imgse.com/i/xqkuwj"><img src="https://s1.ax1x.com/2022/11/03/xqkuwj.md.png" alt="xqkuwj.md.png"></a></p><p>使用真值表进行证明即可</p><p>完备性可以大概表述为：如果语法上能够推理得到的，那么语义上正确。</p><p>即证明：如果<img src="https://math.now.sh?inline=KB%5Cmodels%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=KB%5Cvdash%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>RC(S)：对S内部的全部子句进行归结后的集合。</p><p>完备性证明</p><p><img src="https://math.now.sh?inline=KB%5Cmodels%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>等价于<img src="https://math.now.sh?inline=KB%5Cland%5Cneg%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>永假，等价于<img src="https://math.now.sh?inline=S%3D%5C%7BKB%2C%5Cneg%5Calpha%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是不可满足的。</p><p><img src="https://math.now.sh?inline=KB%5Cvdash%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>等价于<img src="https://math.now.sh?inline=KB%5Cland%5Cneg%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可以归结出空子句，即RC(S)包含空子句</p><p>则只需要证明：如果<img src="https://math.now.sh?inline=S%3D%5C%7BKB%2C%5Cneg%5Calpha%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是不可满足的，则RC(S)包含空子句</p><p>等价于证明逆否命题：如果RC(S)不包含空子句，则<img src="https://math.now.sh?inline=S%3D%5C%7BKB%2C%5Cneg%5Calpha%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是可满足的</p><p>证明：针对S中的原子命题<img src="https://math.now.sh?inline=%F0%9D%91%85_1%2C%F0%9D%91%85_2%2C%E2%8B%AF%2C%F0%9D%91%85_%F0%9D%91%99" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，我们构造如下的model：</p><p>首先，因为RC(S)中不包含空集，即RC(S)中不包含永假的子句。</p><p>从<img src="https://math.now.sh?inline=i%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到<img src="https://math.now.sh?inline=l" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> , 顺序指派<img src="https://math.now.sh?inline=%F0%9D%91%85_1%2C%F0%9D%91%85_2%2C%E2%8B%AF%2C%F0%9D%91%85_%F0%9D%91%99" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的真值：</p><p>如果RC(S)中包含一个子句，此子句包含<img src="https://math.now.sh?inline=%C2%AC%F0%9D%91%85_%F0%9D%91%96" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，且此子句的其它文字都已经被指派为False（在之前的步骤中进行的）或不包含其它文字，则把<img src="https://math.now.sh?inline=R_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>指派为False；否则，把<img src="https://math.now.sh?inline=%F0%9D%91%85_%F0%9D%91%96" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>指派为True</p><p>我们用反证法证明：<strong>这个真值指派使得RC(S)中的子句都为真</strong>。</p><p>假设，在此过程的第i步，我们这样来指派<img src="https://math.now.sh?inline=R_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>使得某个子句C为False，且假设这是首次出现False的子句；此时，子句C只能是如下两种形式之一：<img src="https://math.now.sh?inline=%F0%9D%90%B9%F0%9D%91%8E%F0%9D%91%99%F0%9D%91%A0%F0%9D%91%92%5Clor%F0%9D%90%B9%F0%9D%91%8E%F0%9D%91%99%F0%9D%91%A0%F0%9D%91%92%E2%8B%AF%5Clor%F0%9D%90%B9%F0%9D%91%8E%F0%9D%91%99%F0%9D%91%A0%F0%9D%91%92%5Clor%F0%9D%91%85_%F0%9D%91%96" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>或者 <img src="https://math.now.sh?inline=%F0%9D%90%B9%F0%9D%91%8E%F0%9D%91%99%F0%9D%91%A0%F0%9D%91%92%5Clor%F0%9D%90%B9%F0%9D%91%8E%F0%9D%91%99%F0%9D%91%A0%F0%9D%91%92%E2%8B%AF%5Clor%F0%9D%90%B9%F0%9D%91%8E%F0%9D%91%99%F0%9D%91%A0%F0%9D%91%92%5Clor%C2%AC%F0%9D%91%85_%F0%9D%91%96" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>显然，如果RC(S)中只包含以上两个子句之一，子句C是不会在此真值指派中为False的。因此， RC(S)此时应该同时包含了以上两个子句。</p><p>以上两个子句显然是满足归结条件的，也就是说，它归结后的子句也应该在RC(S)中；同时，该子句已经被指派为False了；这与我们之前的假设矛盾。</p><p>因此这个真值指派使得RC(S)中的子句都为真，进而S是可满足的。</p><p>可以转换为搜索问题，<strong>如何使用A*搜索实现呢？</strong></p><h4 id="Modus-Ponens规则">Modus Ponens规则</h4><p>以限制知识库里面的句子形式为代价，获得时间复杂度上的提升</p><p>上述提到的归结原理具有完备性，这是很好的性质，对于许多现实世界的应用，如果添加一些限制，可以实现更高效的推理。为了换取更好的inference的时间效率，缩小命题逻辑的表达范围，得到适用于Horn Form的Modus Ponens规则，是另外一种形式的归结原理。</p><p>KB为Definite clause的合取形式：</p><p><a href="https://imgse.com/i/xq1HJS"><img src="https://s1.ax1x.com/2022/11/03/xq1HJS.png" alt="xq1HJS.png"></a></p><p>Definite clause: 每一个句子有且只有一个文字是正文字的析取形式</p><p>只有两种形式：①原子命题②命题的合取<img src="https://math.now.sh?inline=%5CRightarrow" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>另外一个命题</p><p>Horn clause: 每一个句子最多一个文字是正文字的析取形式</p><p>PPT例子：KB是全部句子的情况下是否能推出Q</p><p>前向推理：从条件出发去推结论</p><p>前向推理是数据驱动的，可能推出一些结论与我们要推出的结论是无关的</p><p>后向推理：从结论返回推出条件</p><p>后向推理是目的驱动的，找为了推出这个结论所需要的条件，因此通常情况下后向推理比前向推理好，<strong>但是也存在某种情况前向推理比后向推理好</strong></p><p>（全连接神经网络）</p><h5 id="Modus-Ponens规则证明">Modus Ponens规则证明</h5><p>证明是可靠的，即证明<img src="https://math.now.sh?inline=%5Calpha_1%5Cland%5Ccdots%5Cland%5Calpha_n%5Cland%28%5Calpha_1%5Cland%5Ccdots%5Cland%5Calpha_n%5CRightarrow%5Cbeta%29%5Cmodels%5Cbeta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>通过真值表进行证明即可</p><p>证明是完备的：</p><p>若<img src="https://math.now.sh?inline=KB%5Cmodels%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=KB%5Cvdash%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。此时，<img src="https://math.now.sh?inline=KB" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中仅包含definite子句，<img src="https://math.now.sh?inline=%5Cvdash" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>仅使用Modus Ponens规则，且<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是一个正文字</p><p>证明：RC(KB)是KB中原始的句子和通过Modus Ponens推出的句子的全部集合</p><ol><li>构造如下的真值指派<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：对于任意的symbol a，a指派为True当且仅当<img src="https://math.now.sh?inline=%5Calpha%5Cin%20RC%28KB%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><p>（如果一个正文字在<img src="https://math.now.sh?inline=RC%28KB%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中，就设为True，不在就设置为False）</p><ol start="2"><li>接下来证明：在<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>下，<img src="https://math.now.sh?inline=KB" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为真。</li></ol><p>反证：若此时<img src="https://math.now.sh?inline=KB" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为False，那么：必存在一个definite子句，在<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>下为False。</p><p>若该子句为<img src="https://math.now.sh?inline=%5Calpha_1%5Cland%5Ccdots%5Cland%5Calpha_k%5CRightarrow%20b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 也就是说，在m中，<img src="https://math.now.sh?inline=%5Calpha_1%2C%5Ccdots%5Calpha_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>均为True，且<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为False。根据1中的定义， <img src="https://math.now.sh?inline=%5Calpha_i%20%5Cin%20RC%28KB%29(i%3D1%2C%5Ccdots%2Ck)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，又根据Modus Ponens规则，<img src="https://math.now.sh?inline=b%5Cin%20RC%28KB%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>根据1中的定义，在<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中， <img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为True。推出矛盾。</p><p>若该子句为<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，在<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>下为<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为False，则<img src="https://math.now.sh?inline=b%5Cnotin%20RC%28KB%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，矛盾</p><ol start="3"><li>若<img src="https://math.now.sh?inline=KB%5Cmodels%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，根据蕴含的定义：在<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中，<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为真；则根据1中的定义，<img src="https://math.now.sh?inline=%5Calpha%5Cin%20RC%28KB%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，也就是说：<img src="https://math.now.sh?inline=KB%5Cvdash%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><p><strong>命题逻辑的缺点：能表达的东西比较有限。</strong></p><h2 id="一阶谓词逻辑">一阶谓词逻辑</h2><h3 id="语法和语义">语法和语义</h3><p>命题逻辑假设世界上都是事实(fact)，一阶谓词逻辑认为世界上还包括对象、关系和函数等等。</p><p>基本元素：</p><ol><li>常量和变量</li><li>谓词（哥哥、大于等）Predicates</li><li>函数</li><li>连接词（与命题逻辑的连接词完全相同）</li><li><img src="https://math.now.sh?inline=%3D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_1%3D%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为真当且仅当<img src="https://math.now.sh?inline=%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>指向现实世界中的同一个对象</li><li>量词：全称量词<img src="https://math.now.sh?inline=%5Cforall" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和存在量词<img src="https://math.now.sh?inline=%5Cexists" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><h4 id="简单句与复杂句">简单句与复杂句</h4><p>简单句：<img src="https://math.now.sh?inline=%F0%9D%91%9D%F0%9D%91%9F%F0%9D%91%92%F0%9D%91%91%F0%9D%91%96%F0%9D%91%90%F0%9D%91%8E%F0%9D%91%A1%F0%9D%91%92%28%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_1%2C%E2%80%A6%2C%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_%F0%9D%91%9B%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>或<img src="https://math.now.sh?inline=%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_1%3D%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=Term%20%3D%F0%9D%91%93%F0%9D%91%A2%F0%9D%91%9B%F0%9D%91%90%F0%9D%91%A1%F0%9D%91%96%F0%9D%91%9C%F0%9D%91%9B%28%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_1%2C%E2%80%A6%2C%F0%9D%91%A1%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%9A_%F0%9D%91%9B%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>或常量或变量</p><p>嵌套函数会造成很大的问题。命题逻辑的算法一定会停止(decidable可判定的)，但是由于嵌套函数的存在，谓词逻辑只是半可判定的。</p><p>复杂句：使用连接词对简单句进行连接构成复杂句</p><h4 id="量词">量词</h4><p>在谓词逻辑中，要将每一个符号指派到现实世界中，将常量转化为对象、将谓词转化为关系、将函数符号转化为真正的函数</p><p>量词与变量是对应的，有变量一定要有量词来量化</p><p>全称量词：变量所有实例的合取形式</p><p><img src="https://math.now.sh?inline=%5Cforall%20x%20%28%F0%9D%90%B4%F0%9D%91%A1(%F0%9D%91%A5%2C%20%F0%9D%90%B5%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%98%F0%9D%91%92%F0%9D%91%99%F0%9D%91%92%F0%9D%91%A6%29%20%5CRightarrow%20%F0%9D%91%86%F0%9D%91%9A%F0%9D%91%8E%F0%9D%91%9F%F0%9D%91%A1(%F0%9D%91%A5))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>错误的形式：<img src="https://math.now.sh?inline=%5Cforall%20x%20%28%F0%9D%90%B4%F0%9D%91%A1(%F0%9D%91%A5%2C%20%F0%9D%90%B5%F0%9D%91%92%F0%9D%91%9F%F0%9D%91%98%F0%9D%91%92%F0%9D%91%99%F0%9D%91%92%F0%9D%91%A6%29%20%5Cland%20%F0%9D%91%86%F0%9D%91%9A%F0%9D%91%8E%F0%9D%91%9F%F0%9D%91%A1(%F0%9D%91%A5))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>存在量词：变量所有实例的析取形式</p><p><img src="https://math.now.sh?inline=%5Cexists%20x%20%28%F0%9D%90%B4%F0%9D%91%A1(%F0%9D%91%A5%2C%20%F0%9D%91%86%F0%9D%91%A1%F0%9D%91%8E%F0%9D%91%9B%F0%9D%91%93%F0%9D%91%9C%F0%9D%91%9F%F0%9D%91%91%29%20%5Cland%20%F0%9D%91%86%F0%9D%91%9A%F0%9D%91%8E%F0%9D%91%9F%F0%9D%91%A1(%F0%9D%91%A5))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>错误的形式：<img src="https://math.now.sh?inline=%5Cexists%20x%20%28%F0%9D%90%B4%F0%9D%91%A1(%F0%9D%91%A5%2C%20%F0%9D%91%86%F0%9D%91%A1%F0%9D%91%8E%F0%9D%91%9B%F0%9D%91%93%F0%9D%91%9C%F0%9D%91%9F%F0%9D%91%91%29%20%5CRightarrow%20%F0%9D%91%86%F0%9D%91%9A%F0%9D%91%8E%F0%9D%91%9F%F0%9D%91%A1(%F0%9D%91%A5))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>量词的属性关系</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=%5Cforall%20x%20%5Cforall%20y%3D%5Cforall%20y%20%5Cforall%20x%0A" /></p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=%5Cexists%20x%20%5Cexists%20y%3D%5Cexists%20y%20%5Cexists%20x%0A" /></p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=%5Cexists%20x%20%5Cforall%20y%20%5Cneq%20%5Cforall%20y%20%5Cexists%20x%0A" /></p><p>两种量词之间可以相互转换</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=%5Cforall%20x%20%28A%29%20%3D%20%5Cneg%20%5Cexists%20x%20(%5Cneg%20A)%0A" /></p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=%5Cexists%20x%20%28A%29%20%3D%20%5Cneg%20%5Cforall%20x%20(%5Cneg%20A)%0A" /></p><h3 id="一阶谓词的形式推演（命题化）">一阶谓词的形式推演（命题化）</h3><p>全称实例化：实例化全称量词蕴含的每一个实例</p><p>注意在实例化的过程中，第n次循环只能嵌套n次函数</p><p>因此算法可能不会停止，为semi-decidable的</p><p>存在实例化：赋予一个新的常量符号</p><h3 id="一阶谓词逻辑的归结原理">一阶谓词逻辑的归结原理</h3><p><strong>去掉存在量词和存在量词修饰的变量，使得句子里面的每一个变量都是全称量词修饰的变量，且为合取范式</strong></p><p>合一算子：替换后等价的替换方式（只能将常量赋值给变量）</p><p>归结原理：<img src="https://math.now.sh?inline=%5Cfrac%7Bl_1%E2%88%A8%E2%80%A6%E2%88%A8l_k%2C%20%20%20%20%20%20%20%20%20m_1%E2%88%A8%E2%80%A6%E2%88%A8m_n%7D%7B%28l_1%E2%88%A8%E2%80%A6%E2%88%A8l_%7B(i-1%29%7D%E2%88%A8l_%7B(i%2B1)%7D%E2%88%A8%E2%80%A6%E2%88%A8l_k%E2%88%A8m_1%E2%88%A8%E2%80%A6%E2%88%A8m_%7B(j-1)%7D%E2%88%A8m_%7B(j%2B1)%7D%E2%88%A8%E2%80%A6%E2%88%A8m_n)%CE%B8%7D%2CUNIFY(%F0%9D%91%99_%F0%9D%91%96%2C%5Cneg%20%F0%9D%91%9A_%F0%9D%91%97)%3D%5Ctheta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>尤其注意要赋值<img src="https://math.now.sh?inline=%5Ctheta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>归结原理既完备又可靠，证明比较复杂不讲</p><h4 id="归结策略">归结策略</h4><p>可能有很多的归结策略，选择哪种方式进行归结呢？</p><p><strong>没有一种归结策略适用于全部情况</strong></p><p>广度优先策略：扩展所有可能的情况然后归结</p><p>优点：</p><ul><li>当问题有解时保证能找到最短归结路径。</li><li>是一种完备的归结策略。</li></ul><p>缺点：</p><ul><li>归结出了许多无用的子句</li><li>既浪费时间，又浪费空间</li></ul><p>广度优先对大问题的归结容易产生组合爆炸，但对小问题却仍是一种比较好的归结策略。</p><p>常用的归结策略可分为两大类：</p><ul><li>删除策略是通过删除某些无用的子句来缩小归结范围</li><li>限制策略是通过对参加归结的子句进行某些限制，来减少归结的盲目性，以尽快得到空子句。</li></ul><h5 id="删除策略">删除策略</h5><p>删除法主要想法是：把子句集中无用的子句删除掉，这就会缩小搜索范围，减少比较次数，从而提高归结效率。</p><p>删除纯文字：</p><ul><li>如果某文字<img src="https://math.now.sh?inline=L" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在子句集中不存在可与其互补的文字<img src="https://math.now.sh?inline=%5Cneg%20L" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则称该文字为纯文字。</li><li>在归结过程中，纯文字不可能被消除，用包含纯文字的子句进行归结也不可能得到空子句</li><li>对子句集而言，删除包含纯文字的子句，是不影响其不可满足性的。</li></ul><p>重言式删除法：</p><ul><li>如果一个子句中包含有互补的文字对，则称该子句为重言式。</li><li>重言式是真值为真的子句。对一个子句集来说，不管是增加还是删除一个真值为真的子句，都不会影响该子句集的不可满足性。</li><li>因此，可从子句集中删去重言式。</li></ul><h5 id="限制策略">限制策略</h5><p>限制策略要慎重，防止可以得到空子句但是限制后就得不到空子句了</p><p>支持集策略：每一次参加归结的两个亲本子句中，至少应该有一个是由目标公式的否定所得到的子句或它们的后裔。（就是别自己本身进行归结，带上<img src="https://math.now.sh?inline=%5Cneg%20%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>一起归结）</p><p><strong>支持集策略是完备的，即当子句集为不可满足时，则由支持集策略一定能够归结出一个空子句。</strong></p><ul><li>可以把支持集策略看成是在广度优先策略中引入了某种限制条件，这种限制条件代表一种启发信息，因而有较高的效率</li><li>支持集策略限制了子句集元素的剧增，但会增加空子句所在的深度（结果可能不是最优）。</li><li>支持集策略具有逆向推理的含义，由于进行归结的亲本子句中至少有一个与目标子句有关，因此推理过程可以看作是沿目标、子目标的方向前进的。</li></ul><p>单文字子句策略：每次参加归结的两个亲本子句中至少有一个子句是单文字子句</p><p>采用单文字子句策略，归结式包含的文字数将少于其非单文字亲本子句中的文字数，这将有利于向空子句的方向发展，因此会有较高的归结效率。</p><p><strong>单文字子句策略是不完备的，即当子句集为不可满足时，用这种策略不一定能归结出空子句。原因： 没有可用的单文字字句</strong></p><p>祖先过滤策略：满足以下两个条件中的任意一个就可进行归结：</p><ul><li>两个亲本子句中至少有一个是初始子句集中的子句。</li><li>如果两个亲本子句都不是初始子句集中的子句，则一个子句应该是另一个子句的先辈子句。</li></ul><p><strong>祖先过滤策略是完备的</strong></p><h3 id="Generalized-Modus-Ponens（前见推理）">Generalized Modus Ponens（前见推理）</h3><p><img src="https://math.now.sh?inline=%5Cfrac%7Bp_1%5E%E2%80%B2%2Cp_2%5E%E2%80%B2%2C%E2%80%A6%2Cp_n%5E%E2%80%B2%2C%20%20%28p_1%E2%88%A7p_2%E2%88%A7%E2%80%A6%E2%88%A7p_n%E2%87%92q%29%7D%7Bq%CE%B8%7D%2C%5Cforall%20i%EF%BC%8C%F0%9D%91%9D_%F0%9D%91%96%5E%E2%80%B2%5Ctheta%3D%F0%9D%91%9D_%F0%9D%91%96%20%5Ctheta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>GMP的可靠性证明：将量词去掉变量替换为<img src="https://math.now.sh?inline=%5Ctheta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，使用命题逻辑的Modus Ponens证明即可</p><p>同样有前向推理和后向推理，同样是半可判定的</p><p>但是，如果仅包含一阶谓词的definite子句且没有函数，那么是decidable的（也叫Datalog）</p><h2 id="模糊计算">模糊计算</h2><p>清晰的概念：对象是否属于这个概念是明确的。</p><p>模糊性的概念：对象从属的界限是模糊的，随判断人的思维而定</p><p>取得精确数据不可能或很困难，也没有必要获取精确数据</p><p>要使计算机能够模仿人脑，对复杂系统进行识别和判断，出路何在？</p><p>1965年扎德(Zadeh)教授开创了对“模糊数学”的研究。他认为数学是可以模糊的，主张从精度方面“后退”一步。他提出用隶属函数使模糊概念数学化。</p><h3 id="模糊集的定义">模糊集的定义</h3><p>设<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是给定论域，<img src="https://math.now.sh?inline=%CE%BC_F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是把任意<img src="https://math.now.sh?inline=u%E2%88%88U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>映射为<img src="https://math.now.sh?inline=%5B0%2C1%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上某个实值的函数，即<img src="https://math.now.sh?inline=%CE%BC_F%20%20%20%EF%BC%9AU%E2%86%92%5B0%2C1%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则称<img src="https://math.now.sh?inline=%CE%BC_F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为定义在<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的一个隶属函数，由<img src="https://math.now.sh?inline=%CE%BC_F%28u%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（对所有<img src="https://math.now.sh?inline=u%E2%88%88U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>）所构成的集合<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>称为<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的一个模糊集，<img src="https://math.now.sh?inline=%CE%BC_F%28u%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>称为<img src="https://math.now.sh?inline=u" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的隶属度。</p><p>模糊集<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>完全是由隶属函数<img src="https://math.now.sh?inline=%CE%BC_F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来刻画的，<img src="https://math.now.sh?inline=%CE%BC_F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>把<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中的每一个元素<img src="https://math.now.sh?inline=u" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>都映射为<img src="https://math.now.sh?inline=%5B0%2C1%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的一个值<img src="https://math.now.sh?inline=%CE%BC_F%28u%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%CE%BC_F%28u%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的值表示<img src="https://math.now.sh?inline=u" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>隶属于<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的程度，其值越大，表示<img src="https://math.now.sh?inline=u" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>隶属于<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的程度越高。当<img src="https://math.now.sh?inline=%CE%BC_F%28u%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>仅取<img src="https://math.now.sh?inline=0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，模糊集<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>便退化为一个普通集合。</p><p>模糊性：事件发生的程度，而不是一个事件是否发生</p><p>随机性：描述事件发生的不确定性，即一个事件发生与否</p><h3 id="模糊集的表示">模糊集的表示</h3><p>离散且为有限论域的表示方法</p><p>设论域<img src="https://math.now.sh?inline=U%3D%5C%7Bu_1%2C%20u_2%2C%5Ccdots%2C%20u_n%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为离散论域，则其模糊集可表示为：<img src="https://math.now.sh?inline=F%3D%5C%7B%CE%BC_F%28u_1%29%2C%CE%BC_F(u_2)%2C%E2%80%A6%20%2C%CE%BC_F(u_n)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>为了能够表示出论域中的元素与其隶属度之间的对应关系，扎德引入了一种模糊集的表示方式：先为论域中的每个元素都标上其隶属度，然后再用“+”号把它们连接起来，即<img src="https://math.now.sh?inline=F%3D%5Csum_%7Bi%3D1%7D%5En%20%CE%BC_F%28u_i%29%2Fu_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%CE%BC_F%28u_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为<img src="https://math.now.sh?inline=u_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的隶属度；“<img src="https://math.now.sh?inline=%CE%BC_F%28u_i%29%2Fu_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>”不是相除关系，只是一个记号；“+”也不是算术意义上的加，只是一个连接符号。</p><p>连续论域的表示方法：如果论域是连续的，则其模糊集可用一个实函数来表示。</p><h3 id="模糊集的运算">模糊集的运算</h3><p>设<img src="https://math.now.sh?inline=F%2C%20G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>分别是<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的两个模糊集，对任意<img src="https://math.now.sh?inline=u%E2%88%88U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，都有<img src="https://math.now.sh?inline=%CE%BC_F%28u%29%3D%CE%BC_G%20(u)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>成立，则称<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>等于<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，记为<img src="https://math.now.sh?inline=F%3DG" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>设<img src="https://math.now.sh?inline=F%2CG" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>分别是<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的两个模糊集，对任意<img src="https://math.now.sh?inline=u%E2%88%88U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，都有<img src="https://math.now.sh?inline=%CE%BC_F%28u%29%E2%89%A4%CE%BC_G%20(u)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>成立，则称<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>包含<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，记为<img src="https://math.now.sh?inline=F%20%E2%8A%86G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>设<img src="https://math.now.sh?inline=F%2CG" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>分别是<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的两个模糊集，则<img src="https://math.now.sh?inline=F%5Ccup%20G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>、<img src="https://math.now.sh?inline=F%E2%88%A9G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>分别称为<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的并集、交集，它们的隶属函数分别为：</p><p><img src="https://math.now.sh?inline=F%E2%88%AAG%3A%CE%BC_%7BF%E2%88%AAG%7D%28u%29%3Dmax%5C%7B%CE%BC_F%20(u)%2C%CE%BC_G%20(u)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=F%E2%88%A9G%3A%CE%BC_%7BF%E2%88%A9G%7D%28u%29%3Dmin%5C%7B%CE%BC_F%20(u)%2C%CE%BC_G%20(u)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>设<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的模糊集，称<img src="https://math.now.sh?inline=%EF%B9%81F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的补集，其隶属函数为：<img src="https://math.now.sh?inline=%C2%ACF%3A%CE%BC_%7B%C2%ACF%7D%28u%29%3D1-%CE%BC_F%20(u)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>两个模糊集之间的运算实际上就是逐点对隶属函数作相应的运算</p><h3 id="模糊关系">模糊关系</h3><p>经典集合的关系：</p><p>笛卡尔积：设<img src="https://math.now.sh?inline=V" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是两个普通集合，<img src="https://math.now.sh?inline=V" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的笛卡尔乘积为<img src="https://math.now.sh?inline=V%C3%97W%3D%5C%7B%28v%2Cw%29%7C%5Cforall%20v%E2%88%88V%EF%BC%8C%5Cforall%20w%E2%88%88W%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>从<img src="https://math.now.sh?inline=V" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到<img src="https://math.now.sh?inline=W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的关系<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：<img src="https://math.now.sh?inline=V%C3%97W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的一个子集，即<img src="https://math.now.sh?inline=R%20%E2%8A%86%20V%C3%97W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，记为<img src="https://math.now.sh?inline=V%20%5Cstackrel%7BR%7D%7B%5Crightarrow%7D%20W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>对于<img src="https://math.now.sh?inline=V%C3%97W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中的元素<img src="https://math.now.sh?inline=%28v%2Cw%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，若<img src="https://math.now.sh?inline=%28v%2Cw%29%E2%88%88R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则称<img src="https://math.now.sh?inline=v" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>有关系<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；若<img src="https://math.now.sh?inline=%28v%2Cw%29%E2%88%89R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则称<img src="https://math.now.sh?inline=v" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>没有关系</p><p>模糊集合的关系：在二元关系上定义隶属度函数</p><p>设<img src="https://math.now.sh?inline=F_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<img src="https://math.now.sh?inline=U_i%28i%3D1%2C2%2C%E2%80%A6%2Cn%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的模糊集，则称</p><p><img src="https://math.now.sh?inline=F_1%20%5Ctimes%20F_2%20%5Ctimes%20%5Ccdots%20%5Ctimes%20F_n%3D%5Cint_%7Bu_1%20%5Ctimes%20u_2%20%5Ctimes%20%5Ccdots%20%5Ctimes%20u_n%7D%5Cleft%28%5Cmu_%7BF_1%7D%5Cleft(u_1%5Cright%29%20%5Cwedge%20%5Cmu_%7BF_2%7D%5Cleft(u_2%5Cright)%20%5Cwedge%20%5Ccdots%20%5Cwedge%20%5Cmu_%7BF_n%7D%5Cleft(u_n%5Cright)%5Cright)%20%2F%5Cleft(u_1%2C%20u_2%2C%20%5Ccdots%2C%20u_n%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>为<img src="https://math.now.sh?inline=F_1%2CF_2%2C%E2%80%A6%2CF_n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的笛卡尔乘积，它是<img src="https://math.now.sh?inline=U_1%C3%97U_2%C3%97%E2%80%A6%C3%97U_n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的一个模糊集</p><p>在<img src="https://math.now.sh?inline=U_1%C3%97U_2%C3%97%E2%80%A6%C3%97U_n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的一个<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>元模糊关系<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是指以<img src="https://math.now.sh?inline=U_1%C3%97U_2%C3%97%E2%80%A6%C3%97U_n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为论域的一个模糊集，记为</p><p><img src="https://math.now.sh?inline=R%3D%5Cint_%7BU_1%20%5Ctimes%20U_2%20%5Ctimes%20%5Ccdots%20%5Ctimes%20U_n%7D%20%5Cmu_R%5Cleft%28u_1%2C%20u_2%2C%20%5Ccdots%2C%20u_n%5Cright%29%20%2F%5Cleft(u_1%2C%20u_2%2C%20%5Ccdots%2C%20u_n%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>设<img src="https://math.now.sh?inline=R_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=R_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>分别是<img src="https://math.now.sh?inline=U%C3%97V" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=V%C3%97W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的两个模糊关系，则<img src="https://math.now.sh?inline=R_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=R_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的合成是从<img src="https://math.now.sh?inline=U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到<img src="https://math.now.sh?inline=W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的一个模糊关系，记为<img src="https://math.now.sh?inline=R_1%CE%BFR_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。其隶属函数为<img src="https://math.now.sh?inline=%5Cmu_%7BR_1%20%5Ccirc%20R_2%7D%28u%2C%20w%29%3D%5Cvee%5Cleft%5C%7B%5Cmu_%7BR_1%7D(u%2C%20v)%20%5Cwedge%20%5Cmu_%7BR_2%7D(v%2C%20w)%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中其中，<img src="https://math.now.sh?inline=%E2%88%A7" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%E2%88%A8" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>分别表示取最小和取最大</p><h3 id="模糊逻辑">模糊逻辑</h3><p>模糊逻辑：定义模糊谓词、模糊量词、模糊修饰语等</p><p>模糊谓词：设<img src="https://math.now.sh?inline=x%E2%88%88U" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为模糊谓词，即U中的一个模糊关系，则模糊命题可表示为<img src="https://math.now.sh?inline=x%5C%20is%5C%20%20F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中的模糊谓词<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可以是大、小、年轻、年老、冷、暖、长、短等。</p><p>模糊量词：模糊逻辑中使用的模糊量词，如极少、很少、几个、少数、多数、大多数、几乎所有等。</p><p>模糊修饰语：</p><p>设<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是模糊修饰语，<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是变量，<img src="https://math.now.sh?inline=F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是模糊谓词，则模糊命题可表示为为<img src="https://math.now.sh?inline=x%5C%20is%5C%20%20mF" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，模糊修饰语也称为程度词，常用的程度词有“很”、“非常”、“有些”、“绝对”等。</p><p>模糊修饰语的四种主要运算：</p><ol><li>求补：表示否定，如“不”、“非”等，其隶属函数的表示为：<img src="https://math.now.sh?inline=%CE%BC_%7B%E9%9D%9EF%7D%28u%29%3D1-%CE%BC_F%20(u)%2Cu%5Cin%20%5B0%2C1%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>集中：表示“很”、“非常”等，其效果是减少隶属函数的值：<img src="https://math.now.sh?inline=%CE%BC_%7B%E9%9D%9E%E5%B8%B8F%7D%28u%29%3D%CE%BC_F%5E2%20(u)%2Cu%5Cin%20%5B0%2C1%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>扩张：表示“有些”、“稍微”等，其效果是增加隶属函数的值：<img src="https://math.now.sh?inline=%CE%BC_%7B%E6%9C%89%E4%BA%9BF%7D%28u%29%3D%CE%BC_F%5E%7B%5Cfrac%7B1%7D%7B2%7D%7D%20(u)%2Cu%5Cin%20%5B0%2C1%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>加强对比：表示“明确”、“确定”等，其效果是增加0.5以上隶属函数的值，减少0.5以下隶属函数的值：<img src="https://math.now.sh?inline=%5Cmu_%7B%E7%A1%AE%E5%AE%9E%20F%7D%28u%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D2%20%5Cmu_F%5E2(u)%20%26%2C0%20%5Cleq%20%5Cmu_F(u)%20%5Cleq%200.5%20%5C%5C%201-2%5Cleft(1-%5Cmu_F(u)%5Cright)%5E2%20%26%20%2C0.5%3C%5Cmu_F(u)%20%5Cleq%201%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><h2 id="演化计算">演化计算</h2><p>演化计算（Evolutionary Computation, EC）：</p><ul><li>在基因和种群层次上模拟自然界生物进化过程与机制的问题求解技术和计算模型。</li><li>思想源于生物遗传学和适者生存的自然规律</li><li>基于达尔文（Darwin）的进化论和孟德尔（Mendel）的遗传变异理论<ul><li>达尔文的自然选择学说是一种被人们广泛接受的生物进化学说：<ul><li>生物要生存下去，就必须进行生存斗争。</li><li>具有有利变异的个体容易存活下来，并且有更多的机会将有利变异传给后代；具有不利变异的个体就容易被淘汰，产生后代的机会也少的多。</li><li>适者生存，不适者淘汰：自然选择。</li><li>遗传和变异是决定生物进化的内在因素。（相对稳定+新的物种）</li></ul></li></ul></li></ul><p>典型代表：</p><ul><li>遗传算法（Genetic Algorithm, GA）</li><li>进化策略（Evolutionary Strategy, ES）</li><li>进化规划（Evolutionary Programming, EP）</li><li>遗传规划（Genetic Programming, GP）</li></ul><p><strong>演化计算：一种模拟自然界生物进化过程与机制进行问题求解的自组织、自适应的随机搜索技术。</strong></p><p>演化规则：“物竞天择、适者生存”</p><p>演化操作：繁殖（Reproduction）、变异（Mutation）、竞争（Competition）、选择（Selection）</p><h3 id="遗传算法">遗传算法</h3><p>遗传算法的基本思想是从初始种群出发，采用优胜劣汰、适者生存的自然法则选择个体，并通过杂交、变异来产生新一代种群，如此逐代进化，直到满足目标为止</p><p>基本概念：</p><ul><li>种群（Population）：多个备选解的集合。</li><li>个体（Individual）：种群中的单个元素，通常由一个用于描述其基本遗传结构的数据结构来表示。例如，长度为L的0、1串。</li><li>适应度（Fitness）函数：用来对种群中各个个体的环境适应性进行度量的函数，函数值是遗传算法实现优胜劣汰的主要依据</li><li>遗传操作（Genetic Operator）：作用于种群而产生新的种群的操作。选择（Selection）、交叉（Cross-over）、变异（Mutation）</li></ul><p>遗传算法主要由染色体编码、初始种群设定、适应度函数设定、遗传操作设计等几大部分所组成，</p><p>算法基本步骤：</p><ol><li>选择编码策略，将问题搜索空间中每个可能的点用相应的编码策略表示出来，即形成染色体；</li><li>定义遗传策略，包括种群规模N，交叉、变异方法，以及选择概率Pr、交叉概率Pc、变异概率Pm等遗传参数；</li><li>令t=0，随机选择N个染色体初始化种群P(0)；</li><li>定义适应度函数f；</li><li>计算P(t)中每个染色体的适应值；</li><li>t=t+1；</li><li>运用选择算子，从P(t-1)中得到P(t)；</li><li>对P(t)中的每个染色体，按概率Pc参与交叉；</li><li>对染色体中的基因，以概率Pm参与变异运算；</li><li>判断群体性能是否满足预先设定的终止标准，若不满足返回(5)。</li></ol><h3 id="遗传编码">遗传编码</h3><h4 id="二进制编码">二进制编码</h4><p>二进制编码是将原问题的结构变换为染色体的位串结构。假设某一参数的取值范围是<img src="https://math.now.sh?inline=%5BA%EF%BC%8CB%5D%EF%BC%8CA%3CB" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。用长度为<img src="https://math.now.sh?inline=L" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的二进制编码串来表示该参数，将<img src="https://math.now.sh?inline=%5BA%EF%BC%8CB%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>等分成<img src="https://math.now.sh?inline=2%5EL-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个子部分，记每一个等分的长度为<img src="https://math.now.sh?inline=%CE%B4" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>优点：易于理解和实现，可表示的模式数最多</p><p>缺点：海明悬崖。当算法从7改进到8时，就必须改变所有的位</p><h4 id="格雷编码">格雷编码</h4><p>要求两个连续整数的编码之间只能有一个码位不同，其余码位都是完全相同的。有效地解决了海明悬崖问题。</p><p>基本原理：</p><ul><li>二进制码-&gt;格雷码（编码）：从最右边一位起，依次将每一位与左边一位异或，作为对应格雷码该位的值，最左边一位不变；</li><li>格雷码-&gt;二进制码（解码）：从左边第二位起，将每位与左边一位解码后的值异或，作为该位解码后的值，最左边一位依然不变。</li></ul><h4 id="符号编码">符号编码</h4><p>个体染色体编码串中的基因值取自一个无数值含义，而只有代码含义的符号集。</p><h3 id="适应度函数">适应度函数</h3><p>适应度函数是一个用于对个体的适应性进行度量的函数。个体的适应度值越大，它被遗传到下一代种群中的概率越大</p><p>常用的适应度函数</p><ul><li>原始适应度函数：直接将待求解问题的目标函数<img src="https://math.now.sh?inline=f%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>定义为遗传算法的适应度函数。<ul><li>例如：求最大值<img src="https://math.now.sh?inline=max_%7Bx%20%5Cin%20%5Ba%2Cb%5D%7Df%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，<img src="https://math.now.sh?inline=f%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>即为<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的原始适应度函数。</li><li>优点：能够直接反映出待求解问题的最初求解目标</li><li>缺点：有可能出现适应度值为负的情况</li></ul></li><li>标准适应度函数<ul><li>在遗传算法中，一般要求适应度函数非负，并其适应度值越大越好。这就往往需要对原始适应函数进行某种变换，将其转换为标准的度量方式，以满足进化操作的要求，这样所得到的适应度函数被称为标准适应度函数<img src="https://math.now.sh?inline=f_%7BNormal%7D%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul></li></ul><h3 id="基本遗传操作">基本遗传操作</h3><p>选择(selection)操作：根据选择概率按某种策略从当前种群中挑选出一定数目的个体，使它们能够有更多的机会被遗传到下一代中</p><ul><li>比例选择：各个个体被选中的概率与其适应度大小成正比。</li><li>轮盘赌选择：个体被选中的概率取决于该个体的相对适应度。<img src="https://math.now.sh?inline=P%28x_i%29%3D%5Cfrac%7Bf(x_i)%7D%7B%5Csum_%7Bj%3D1%7D%5EN%20f(x_j)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中，<img src="https://math.now.sh?inline=P%28x_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是个体<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的相对适应度，即个体<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>被选中的概率，<img src="https://math.now.sh?inline=f%28x_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是个体<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的原始适应度。</li></ul><p>交叉(crossover)操作：按照某种方式对选择的父代个体的染色体的部分基因进行交配重组，从而形成新的个体。</p><p>二进制交叉：二进制编码情况下所采用的交叉操作</p><ul><li>单点交叉：先在两个父代个体的编码串中随机设定一个交叉点，然后对这两个父代个体交叉点前面或后面部分的基因进行交换，并生成子代中的两个新的个体。</li><li>两点交叉：先在两个父代个体的编码串中随机设定两个交叉点，然后再按这两个交叉点进行部分基因交换，生成子代中的两个新的个体。</li><li>均匀交叉：先随机生成一个与父串具有相同长度的二进制串（交叉模版），然后再利用该模版对两个父串进行交叉，即将模版中1对应的位进行交换，而0对应的位不交换，依此生成子代中的两个新的个体。</li></ul><p>实值交叉：在实数编码情况下所采用的交叉操作，主要包括离散交叉和算术交叉</p><ul><li>部分离散交叉：先在两个父代个体的编码向量中随机选择一部分分量，然后对这部分分量进行交换，生成子代中的两个新的个体。</li><li>整体交叉：对两个父代个体的编码向量中的所有分量，都以<img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的概率进行交换，从而生成子代中的两个新的个体。</li></ul><p>变异(Mutation)操作：对选中个体的染色体中的某些基因进行变动，以形成新的个体。遗传算法中的变异操作增加了算法的局部随机搜索能力，从而可以维持种群的多样性。</p><ul><li>二进制变异：先随机地产生一个变异位，然后将该变异位置上的基因值由“0”变为“1”，或由“1”变为“0”，产生一个新的个体。</li><li>实值变异：用另外一个在规定范围内的随机实数去替换原变异位置上的基因值，产生一个新的个体。<ul><li>基于次序的变异：先随机地产生两个变异位置，然后交换这两个变异位置上的基因。</li></ul></li></ul><p>精英主义 （Elitism）</p><p>仅仅从产生的子代中选择基因去构造新的种群可能会丢失掉上一代种群中的很多信息。也就是说当利用交叉和变异产生新的一代时，我们有很大的可能把在某个中间步骤中得到的最优解丢失。</p><p>使用精英主义（Elitism）方法，在每一次产生新的一代时，我们首先把当前最优解原封不动的复制到新的一代中，其他步骤不变。这样任何时刻产生的一个最优解都可以存活到遗传算法结束。</p><h3 id="遗传算法特点">遗传算法特点</h3><ul><li>自组织、自适应和自学习性—概率转移准则，非确定性规则<ul><li>确定进化方案后，算法将利用进化过程中得到的信息自行组织搜索；基于自然的选择策略，优胜劣汰；</li><li>遗传算法很快就能找到良好的解，即使是在很复杂的解空间中<ul><li>采用随机方法进行最优解搜索，选择体现了向最优解迫近</li><li>交叉体现了最优解的产生，变异体现了全局最优解的复盖</li></ul></li></ul></li><li>本质并行性—群体搜索<ul><li>算法本身非常适合大规模并行，各种群分别独立进化，不需要相互间交换信息</li><li>可以同时搜索解空间的多个区域并相互间交流信息，使得演化计算能以较少的计算获得较大的收益。</li></ul></li><li>不需要其他知识，只需要影响搜索方向的目标函数和相应的适应度函数<ul><li>对待求解问题的指标函数没有什么特殊的要求，如不要求连续性、导数存在、单峰值等假设</li><li>容易形成通用算法程序</li><li>遗传算法不能解决那些“大海捞针”的问题，所谓“大海捞针”问题就是没有一个确切的适应度函数表征个体好坏的问题，遗传算法对这类问题无法找到收敛的路径。</li></ul></li><li>理论上证明算法的收敛性很困难</li><li>多用于解决实际问题</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法详解</title>
    <link href="/2022/10/19/KMP/"/>
    <url>/2022/10/19/KMP/</url>
    
    <content type="html"><![CDATA[<p>KMP算法详解</p><span id="more"></span><h1>KMP算法详解</h1><p>一直都没弄明白，也没下决心去弄明白。昨天感觉基本上差不多了，整理一下，再加深一下印象。</p><h2 id="问题">问题</h2><p>给你两个字符串 <code>haystack</code>和 <code>needle</code>，请你在 <code>haystack</code>字符串中找出 <code>needle</code>字符串的第一个匹配项的下标（下标从 <code>0</code>开始）。如果 <code>needle</code>不是 <code>haystack</code>的一部分，则返回 <code>-1</code> 。</p><p>AC代码：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strStr</span><span class="hljs-params">(haystack <span class="hljs-type">string</span>, needle <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;    needlelen := <span class="hljs-built_in">len</span>(needle)    haystacklen := <span class="hljs-built_in">len</span>(haystack)    next := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,needlelen)    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>    j := <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;needlelen;i++&#123;        <span class="hljs-keyword">for</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; needle[i] != needle[j]&#123;            j = next[j<span class="hljs-number">-1</span>]        &#125;        <span class="hljs-keyword">if</span> needle[i] == needle[j]&#123;            j++        &#125;        next[i] = j    &#125;    j = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;haystacklen;i++&#123;        <span class="hljs-keyword">for</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; needle[j] != haystack[i]&#123;            j = next[j<span class="hljs-number">-1</span>]        &#125;        <span class="hljs-keyword">if</span> needle[j] == haystack[i]&#123;            j++        &#125;        <span class="hljs-keyword">if</span> j == needlelen&#123;            <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;</code></pre></div><h2 id="简介">简介</h2><p>判断一个字符串（模式串）是不是另外一个字符串（文本串）的子串，怎么做？</p><p>最容易想到的：暴力匹配。</p><p>比如有下面的两个字符串：</p><p><code>abacac</code>和 <code>ac</code></p><p>开始肯定是第一个 <code>a</code>开始和 <code>ac</code>进行匹配，匹配失败了，然后从 <code>b</code>再开始匹配。最坏情况，每一个都要判断到匹配字符串的最后一个字符，两层循环，时间复杂度很容易想到就是<img src="https://math.now.sh?inline=O%28mn%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>但是事实上，如果从人工匹配的角度来看，我们都知道 <code>b</code>不可能匹配成功，让你用肉眼匹配，傻子才会去看 <code>b</code>。但是计算机程序为了全部判断还是要去尝试一下。</p><p>那么怎么把这种无效的匹配让开呢？直观上可能想到，我判断第一个能不能匹配上不就行了，应该能降低时间复杂度？</p><p>那么再举一个例子：<code>aaaaaaaaaa</code>和 <code>ab</code>，时间复杂度一样是<img src="https://math.now.sh?inline=O%28mn%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>所以不仅仅要看第一个，看第一个也无法完全抹去无效的匹配。这时候需要一种高效的匹配算法，核心思想就是在匹配的过程中要记录，匹配失败后从第一个可能成功的地方开始即可，不要做无效工作。</p><p>因此就有了超难理解的KMP算法以及各种比KMP还要复杂的算法。这里就先好好的讲一下KMP，希望以后可以真正理解，抬手就来。</p><h2 id="概念">概念</h2><p>前缀表：<strong>记录下标 <code>i</code>之前（包括 <code>i</code>）的字符串中，有多大长度的相同前缀后缀。</strong></p><p><strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong> 。</p><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong> 。</p><p>啥意思？举例子就好了</p><table><thead><tr><th>模式串下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>字符串</td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td><td>c</td><td>a</td><td>b</td><td>c</td><td>d</td><td>a</td><td>b</td></tr><tr><td>前缀表</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table><p>怎么算的？</p><p>下标为 <code>0</code>，字符串为 <code>a</code>，前缀为空（因为不包含最后一个字符，因此字符就没了），后缀为空（因为不包含第一个字符，因此字符就没了），因此相同前缀后缀长度为0（因为都是空串）</p><p>下标为 <code>1</code>，字符串为 <code>ab</code>，前缀为 <code>a</code>，后缀为 <code>b</code>，因此相同前缀后缀长度为 <code>0</code></p><p>下标为 <code>2</code>，字符串为 <code>abc</code>，前缀为 <code>ab</code>，后缀为 <code>bc</code>，因此相同前缀后缀长度为 <code>0</code></p><p>下标为 <code>3</code>，字符串为 <code>abcd</code>，前缀为 <code>abc</code>，后缀为 <code>bcd</code>，因此相同前缀后缀长度为 <code>0</code></p><p><strong>下标为 <code>4</code>，字符串为 <code>abcda</code>，前缀为 <code>abcd</code>，后缀为 <code>bcda</code>，因此相同前缀后缀长度为 <code>1</code>，也就是 <code>a</code></strong></p><p>下标为 <code>5</code>，字符串为 <code>abcdab</code>，前缀为 <code>abcda</code>，后缀为 <code>bcdab</code>，因此相同前缀后缀长度为 <code>2</code>，也就是 <code>ab</code></p><p>下标为 <code>6</code>，字符串为 <code>abcdabc</code>，前缀为 <code>abcdab</code>，后缀为 <code>bcdabc</code>，因此相同前缀后缀长度为 <code>3</code>，也就是 <code>abc</code></p><p><strong>下标为 <code>7</code>，字符串为 <code>abcdabca</code>，前缀为 <code>abcdabc</code>，后缀为 <code>bcdabca</code>，因此相同前缀后缀长度为 <code>1</code>，也就是 <code>a</code></strong></p><p>…</p><p>下标为 <code>12</code>，字符串为 <code>abcdabcabcdab</code>，前缀为 <code>abcdabcabcda</code>，后缀为 <code>bcdabcabcdab</code>，因此相同前缀后缀长度为 <code>6</code>，也就是 <code>abcdab</code></p><p>人工计算还是挺好算的，用眼睛看看简单算算就行了。网上有些资料是从 <code>-1</code>开始，然后右移一位，我认为不好理解，不如保留前缀表的本意</p><p><strong>所以算来算去，前缀表有什么用处呢？</strong></p><p>前缀表可以帮助我们在匹配不成功的时候找到前面最佳的重新开始的位置，从而保证我们只遍历文本串一次就能判断模式串与文本串是否匹配。（废话）</p><p>先举例：后面的 <code>i</code>指文本串的下标，<code>j</code>指模式串的下标。（文本串下标保证递增，绝对不回退）</p><table><thead><tr><th>文本串下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>字符串</td><td>a</td><td>c</td><td>b</td><td>a</td><td>b</td><td>a</td></tr></tbody></table><table><thead><tr><th>模式串下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>字符串</td><td>a</td><td>c</td><td>b</td><td>a</td><td>c</td></tr><tr><td>前缀表</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td></tr></tbody></table><p>开始匹配，<code>i</code>和 <code>j</code>匹配的很顺利，转眼就到了 <code>i=j=4</code>，然后发现糟了，匹配不上了，现在 <code>j</code>要回退，找到重新开始匹配的位置。</p><p><code>j</code>退到哪里呢？因为 <code>j</code>是没有匹配上的，而 <code>j-1</code>如果有意义（<code>j≠0</code>），一定是能匹配上的！（为什么？因为只有匹配上了 <code>j</code>才会移动，<code>j</code>移动过的位置一定是之前匹配好了的）</p><p>那么 <code>j-1</code>是匹配上的又说明了什么呢？<strong>说明对于 <code>0~j-1</code>的字符串，如果有相同的前缀后缀，一定也是能和i-1匹配的上的，因此就不需要回退超过前缀的位置！</strong></p><p>还是上面的例子，模式串的 <code>j-1</code>前缀表的值是 <code>1</code>，说明 <code>j-1</code>位置的 <code>a</code>在模式串的前面也出现过，就是模式串 <code>0</code>位置的 <code>a</code>。由于 <code>j-1</code>是和 <code>i-1</code>匹配上了的，因此 <code>j=0</code>和 <code>i-1</code>也是匹配上了的，不需要再去看模式串 <code>0</code>的位置，只需要看0的后一个位置 <code>1</code>和 <code>i</code>是否能匹配上就好了！</p><p>流程步骤：</p><ol><li><code>i</code>和 <code>j</code>匹配不上了，<strong>隐含条件是 <code>i-1</code>和 <code>j-1</code>是可以匹配的</strong></li><li>看一下 <code>j-1</code>后缀的相同长度的前缀长度，也就是 <code>next[j-1]</code>的值</li><li>回退 <code>j</code>到 <code>next[j-1]</code>的位置，<strong>隐含了这一步将相同长度的前缀绕过</strong></li></ol><p>然后 <code>j=next[j-1]</code>后就去判断 <code>j</code>和 <code>i</code>是不是相同就好了，很不幸的是，还是不相同，<code>i</code>指向的是 <code>b</code>，<code>j</code>指向的是 <code>c</code>。</p><p>那么没办法，留着这个前缀也无法匹配了，只好再次回退，这一退就退到 <code>j=0</code>了，但是还是不相等。</p><p><code>j=0</code>就没有办法再次回退了，只好 <code>i++</code>，舍弃这一个部分的文本串，开始新的文本串。</p><p>到这里应该明白了前缀表的作用了，字面上很难理解，跟着流程走一遍就明白它的思想了，确实精妙</p><h2 id="字符串匹配">字符串匹配</h2><p>所以在已知 <code>next</code>数组的前提下，这个字符串匹配的代码就很简单了。虽然简单，但是结构一点都不可以修改，循环和顺序都是精心设计的。</p><div class="code-wrapper"><pre><code class="hljs go">j = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;haystacklen;i++&#123;    <span class="hljs-keyword">for</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; needle[j] != haystack[i]&#123; <span class="hljs-comment">// 匹配不上就一直回退，j=0说明真的匹配不上了，跳出来i++</span>        j = next[j<span class="hljs-number">-1</span>]    &#125;    <span class="hljs-comment">// j=0也会跳到这里尝试一下</span>    <span class="hljs-keyword">if</span> needle[j] == haystack[i]&#123; <span class="hljs-comment">// 匹配上的就能j++去看模式串的下一个字符了，然后进入下一个循环i++，判断文本串的下一个字符能不能和模式串的这个字符匹配上</span>        j++    &#125;&#125;</code></pre></div><p><strong>还有一个问题，<code>next</code>数组怎么求？</strong></p><h2 id="next数组"><code>next</code>数组</h2><p>首先要明确一点，<code>next</code>数组是针对模式串而言的，与文本串半毛钱关系没有</p><table><thead><tr><th>模式串下标</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>字符串</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>e</td></tr><tr><td>前缀表</td><td>0</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>0</td></tr></tbody></table><p>其实思想和匹配是相同的，不同的地方在于上面的是用模式串和文本串进行匹配，这里是用自己和自己进行匹配，匹配的过程中看看能匹配上多少，就能得出 <code>next</code>数组的数值了</p><p><code>next[0]=0</code>，初始化毫无争议，因为空串一定是<code>0</code></p><p>指针 <code>i</code>同样一直向前，指针 <code>j</code>会进行回退，因为 <code>next[0]</code>确定了，因此直接初始化<code>i=1</code></p><p>最开始，<code>j</code>指向的是 <code>0</code>的位置，就在这里等着到底哪个 <code>i</code>能和我这个可爱的 <code>j</code>匹配上</p><p>到了 <code>i=2</code>，匹配上了！这时候 <code>j</code>不满足了，是不是 <code>i+1</code>也能和 <code>j+1</code>匹配上呢？所以就 <code>j++</code>，尝试匹配下一个</p><p>要是匹配不上了怎么办呢？比如 <code>j=3</code>,<code>i=6</code>匹配不上了，也隐含了条件，就是 <code>j=2</code>是能和 <code>i-1</code>匹配上的（要是匹配不上<code>j</code>也不可能不等于<code>0</code>）</p><p>那么j=2时候的相同长度的前后缀在哪里呢？因为如果相同也不需要去看了，所以更新<code>j=next[j-1]</code>就可以了，和上面的字符串的匹配思想是完全相同的。</p><p>如果还是匹配不上，那么<code>j</code>只好乖乖变为<code>0</code>，等待着下一个能匹配上的将<code>j+1</code>了</p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs go">next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span> <span class="hljs-comment">// 初始化</span>j := <span class="hljs-number">0</span> <span class="hljs-comment">// j指向首位</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span>;i&lt;needlelen;i++&#123; <span class="hljs-comment">// 遍历模式串，不回退</span>    <span class="hljs-keyword">for</span> j &gt; <span class="hljs-number">0</span> &amp;&amp; needle[i] != needle[j]&#123;        j = next[j<span class="hljs-number">-1</span>] <span class="hljs-comment">// 匹配不上了，绕过已知的相同长度的前后缀，直到变为j=0的初始状态</span>    &#125;    <span class="hljs-comment">// 如果j=0还是有一次判断的机会的</span>    <span class="hljs-keyword">if</span> needle[i] == needle[j]&#123; <span class="hljs-comment">// 匹配上了将j解放出来，+1再试试</span>        j++    &#125;    next[i] = j <span class="hljs-comment">// 赋值next数组</span>&#125;</code></pre></div><h2 id="时间复杂度分析">时间复杂度分析</h2><p>设 <code>n</code>为文本串长度，<code>m</code>为模式串长度</p><p>在匹配的过程中，根据前缀表不断调整匹配的位置，如果没有一个字符能匹配的上，时间复杂度就是文本串的指针从头移到尾，也就是<img src="https://math.now.sh?inline=O%28n%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>如果能匹配上一些字符，回退的次数也不可能超过 <code>n</code>次。因此时间复杂度是<img src="https://math.now.sh?inline=O%282n%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>生成 <code>next</code>数组，不会比匹配的时间复杂度高（因为如果模式串比文本串还要长，根本就不需要匹配了）</p><p>所以从平方级别的时间复杂度直接降到了线性的时间复杂度。</p><h2 id="总结">总结</h2><p>看过很多遍，应该也曾经懂过，就是从来没有整理过，因此可能也没有真正懂过。</p><p>希望这次能真真正正懂了，后面忘记了再来看看这篇文章，希望能快一些想起来。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第10章 神经网络与深度学习</title>
    <link href="/2022/10/18/UCAS/machine-learning/machine-learning-10/"/>
    <url>/2022/10/18/UCAS/machine-learning/machine-learning-10/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第10章 神经网络与深度学习</p><span id="more"></span><h1>第10章 神经网络与深度学习</h1><h2 id="概述">概述</h2><h3 id="背景与现状">背景与现状</h3><p>ANN到DL的技术发展</p><ul><li>ANN始于1890年：开始于美国心理学家W.James对于人脑结构与功能的研究。</li><li>M-P模型 （1943 年）：神经科学家麦卡洛克和数学家皮兹建立了神经网络和数学模型（MP模型），人工神经网络的大门由此开启。</li><li>Hebb学习规则（1949年）：加拿大著名心理学家唐纳德·赫布提出了Hebb学习规则，这是一种无监督的学习规则。 Hebb学习规则表明了网络是可以学习的，这启发了后面一系列关于神经网络的研究工作。</li><li>感知机（1958 年）：心理学家Frank Rosenblatt受到Hebb思想的启发提出了感知机。感知机是最早的人工神经网络，也是具有学习功能M-P模型。整个1958 年-1969年期间，有许多科学家和学者都投入到了感知机研究。但是由于当时的计算水平相对落后，计算也显得很吃力。</li><li>1969年进入冰河期：马文明斯基在发表《 Perceptrons 》时，证明了感知器的致命弱点：不能够解决异或问题。</li><li>神经网络（1986 年）BP 算法：Rumelhar和Hinton提出了反向传播算法（BP 算法），是一种监督学习算法，解决了两层神经网络计算的复杂性。</li><li>卷积神经网络（1989年)：1989年， LeCun发明了卷积神经网络LeNet，并将其用于数字识别，且取得了较好的成绩，不过当时并没有引起足够的注意。</li><li>RNN模型：递归（recurrent）的现代定义由Jordan（1986 年），随后Elman（1990 年）的RNN网络。</li><li>LSTM模型（1997年）：LSTM的提出，尽管该模型在序列建模上的特性非常突出，但由于正处于ANN 的下坡期，也没有引起足够的重视。</li><li>深层信度网络（2006 年）：2006DL元年，Hinton提出了深层网络训练中梯度消失问题的解决方案： 无监督预训练对权值进行初始化，并<br>进行有监督训练微调 。但是由于没有特别有效的实验验证，该论文并没有引起重视。</li><li>ReLU激活函数（2011 年）：该激活函数能够有效的抑制梯度消失问题。</li><li>语音识别突破（2011 年）：微软首次将DL 应用在语音识别上，取得了重大突破。</li><li>ImageNet竞赛夺冠（2012 年）：Hinton团队首次参加ImageNet图像识别比赛，其通过构建的AlexNet网络一举夺得冠军。</li><li>AlphaGo （强化学习）：2016年 3 月人工智能围棋比赛，谷歌（ Google ）旗下 DeepMind 公司的戴维 · 西尔弗、艾佳 · 黄和戴密斯 · 哈萨比斯与他们的团队开发的 AlphaGo 战胜了世界围棋冠军、职业九段选手李世石，并以 4:1 的总比分获胜。</li><li>深度学习的技术突破：生成对抗、注意力机制、预训练模型</li></ul><p>DL在AI的成功应用</p><p>语音识别</p><p>2009年， Hinton把深层神经网络介绍给做语音识别的学者们。2010年，语音识别就产生了巨大突破。本质上是把传统的混合高斯模型（GMM）替换成了<br>深度神经网络（DNN）模型，但相对识别错误率一下降低20%多，这个改进幅度超过了过去很多年的总和。这里的关键是把原来模型中通过 GMM 建模的手工特征换成了通过 DNN 进行更加复杂的特征学习。</p><p>在此之后，在深度学习框架下，人们还在不断利用更好的模型和更多的训练数据进一步改进结果。现在语音识别已经真正变得比较成熟，并且被广泛商用，目前所有的商用语音识别算法没有一个不是基于深度学习的。</p><p>计算视觉：通过组合低层特征形成更加抽象的高层特征</p><p>DL在图像识别</p><p>Yann LeCun早在1989年就开始了卷积神经网络的研究，取得了在一些小规模（手写字）的图像识别的成果，但在像素丰富的图片上迟迟没有突破，直到2012年Hinton和他学生在ImageNet上的突破，使识别精度提高了一大步；截至2015年最好的模型ResNet</p><p>2012年 Google Brain 用 16000 个 CPU 核的计算平台训练 10 亿神经元的深度网络，无外界干涉下自动识别了“Cat”</p><p>2014年香港中文大学教授汤晓鸥研究组DeepID的深度学习模型，在 LFW 数据库上获得了99.15%的识别率，人用肉眼在LFW上的识别率为97.52%，深度学习在学术研究层面上已经超过了人用肉眼的识别 。</p><p>自然语言处理</p><p>词向量表示学习</p><p>词向量是指通过对大量文本的无监督学习，根据前后文自动学习到每个词的紧凑向量表达，包括NNML 、 Word2Vector 、预训练模型等。</p><p>预训练模型：ELMo、 GPT和BERT 等，全线提升自然语言领域的多项任务的Baseline</p><p>递归神经网络 RNN：文本的各个词之间是有顺序的，RNN能更好的挖掘和利用这个性质，在自然语言各个领域都在尝试进行中。 已经有BPTT 、 LSTM等。</p><h3 id="神经网络模型概述">神经网络模型概述</h3><p>神经网络模型学习框架</p><p><a href="https://imgse.com/i/xuQS9e"><img src="https://s1.ax1x.com/2022/09/30/xuQS9e.md.png" alt="xuQS9e.md.png"></a></p><p>损失函数：</p><p>平方损失：<img src="https://math.now.sh?inline=L%28y%2C%20%5Chat%7By%7D%29%3D(y-f(x%2C%20%5Ctheta))%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>交叉熵损失：<img src="https://math.now.sh?inline=L%28y%2C%20f(x%2C%20%5Ctheta%29)%3D-%5Csum_%7Bi%3D1%7D%5EC%20y_i%20%5Clog%20f_i(x%2C%20%5Ctheta)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=f_i%28x%2C%20%5Ctheta%29%20%5Cin%5B0%2C1%5D%2C%20%5Cquad%20%5Csum_%7Bi%3D1%7D%5EC%20f_i(x%2C%20%5Ctheta)%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>单个神经元模型：</p><p><a href="https://imgse.com/i/xuQHPS"><img src="https://s1.ax1x.com/2022/09/30/xuQHPS.md.png" alt="xuQHPS.md.png"></a></p><p>单个神经元模型：</p><ul><li>感知机</li><li>最小方差回归</li><li>Logistic模型</li></ul><p>多层感知机</p><p>卷积网络</p><p>核函数网络：单隐层神经网络、非线性体现在径向基核函数</p><ul><li>径向基网络</li><li>支持向量机</li></ul><p>自组织映射</p><p>RBM</p><ul><li>同层神经元间无连接，并彼此相互独立</li><li>是一个无向图(权值对称)，即连接可看作双向的</li><li><img src="https://math.now.sh?inline=h" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>层为隐层，<img src="https://math.now.sh?inline=v" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>层为可见层</li></ul><p>递归网络</p><h3 id="深度网络模型概述">深度网络模型概述</h3><p>深度前馈网络</p><p>常见的结构：</p><ul><li>全连接网络DFL</li><li>预训练+全连接网络 Au+FL</li><li>卷积+全连接网络 CNN+FL</li><li>CNN + FL+ ReLu + Tricks</li></ul><p>递归神经网络</p><p>常见的结构：</p><ul><li>Bi结构</li><li>Deep结构</li><li>CNN+RNN结构</li></ul><p>生成对抗网络(GAN)</p><p>两个网络博弈：G（Generator）和D（Discriminator）</p><ul><li>G是一个生成图片的网络，它接收一个随机的噪声z，通过这个噪声生成图片，记做G(z)。</li><li>D是一个判别网络，判别一张图片是不是“真实的”。它输入一张图片x，输出D（x）代表x为真实图片的概率，如果为1，就代表100%是真实的图片，而输出为0，就代表不可能是真实的图片。</li></ul><p>深度强化学习</p><p>强化学习：学习目标：策略概率 <img src="https://math.now.sh?inline=p%28a%2Fs%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>值函数网络：Deep Q-Learning</p><p>策略网络：Deep Policy Network</p><h2 id="多层感知机">多层感知机</h2><p>含有数据输入层、1个以上隐藏层、 1个输出层；各层神经元全连接，同一层神经元之间无连接。</p><p><a href="https://imgse.com/i/xu1LBn"><img src="https://s1.ax1x.com/2022/09/30/xu1LBn.md.png" alt="xu1LBn.md.png"></a></p><p>多层感知机的运算：</p><p><a href="https://imgse.com/i/xu3VN6"><img src="https://s1.ax1x.com/2022/09/30/xu3VN6.md.png" alt="xu3VN6.md.png"></a></p><p>激活函数（包括硬门限阈值函数），是导致网络运算非线性的直接原因。</p><h3 id="问题描述">问题描述</h3><p>学习问题：</p><p>学习目标：调整神经元连接权重值，使得平均误差能量最小。</p><p>两种方法：批量学习和在线学习。</p><p>目标：最小化损失函数</p><p>批量学习（Batch Learning）</p><ul><li>N个样本（一个batch）</li><li>随机采样 batch 训练样本集</li><li>Batch by Batch 调整权值</li><li>优点：梯度向量形式固定，有利于并行处理</li><li>缺点：需要内存资源大</li></ul><p>在线学习（Online Learning）：sample by sample 调整权值</p><p><a href="https://imgse.com/i/xu8Hwn"><img src="https://s1.ax1x.com/2022/09/30/xu8Hwn.png" alt="xu8Hwn.png"></a><br>优点：容易执行、存储量小、有效解决大规模和困难模式的分类。</p><p>缺点：学习过程随机、不稳定。</p><h3 id="BP基本思想">BP基本思想</h3><p>两个方向的信号流、两个方向的函数运算</p><p>函数信号：计算输出函数信号</p><p>误差信号：计算梯度向量</p><p>数据前馈运算</p><p><a href="https://imgse.com/i/xuGRB9"><img src="https://s1.ax1x.com/2022/09/30/xuGRB9.md.png" alt="xuGRB9.md.png"></a></p><p>梯度反馈运算</p><p><a href="https://imgse.com/i/xuGhA1"><img src="https://s1.ax1x.com/2022/09/30/xuGhA1.md.png" alt="xuGhA1.md.png"></a></p><p>BP 算法小结</p><ol><li>数据初始化</li><li>Epoch 采样</li><li>前向计算</li><li>反向梯度计算</li><li>求参数梯度</li><li>迭代</li></ol><p>激活函数</p><p>异或问题</p><p>改善性能的试探法</p><p>函数逼近</p><h2 id="卷积网络">卷积网络</h2><p>卷积层：卷积层具有局部连接和权重共享特点。</p><p>一维、二维卷积</p><p>卷积层的输出尺度</p><p>卷积层的参数个数</p><p>子采样层：每个通道，通过下采样，缩减尺度。</p><p>典型实例：LeNet-5</p><h2 id="Recurrent-网络">Recurrent 网络</h2><p>四种基本递归结构</p><ol><li>输入-输出递归模型（NARX 模型）</li><li>状态空间模型</li><li>递归多层感知机</li><li>二阶网络</li></ol><p>通用逼近定理：如果网络具有充分多的隐藏神经元，任意的非线性动态系统可以由递归神经网络以期望的精度来逼近，对于状态空间的紧致性没有限制。</p><p>计算能力</p><p>Recurrent 网络</p><p>RNN分回合训练</p><p>RNN连续训练</p><p>RNN长期依赖</p><p>RNN扩展的递归结构</p><h2 id="前沿概述">前沿概述</h2><h3 id="深度学习">深度学习</h3><p>深层结构：神经网络 + 深层结构 + 优化 + 计算资源 + 人工智能应用</p><p>梯度消失：解决梯度消失</p><ul><li>前馈网络：自编码、ReLU 激活函数</li><li>Recurrent 网络：二次优化、非线性逐次状态估计、ReLU 激活函数</li></ul><p>视觉识别</p><p>自然语言处理</p><h3 id="生成对抗学习">生成对抗学习</h3><p>生成对抗模型原理</p><p>生成器（Generator）：尽可能去学习真实样本的分布，迷惑鉴别器。</p><p>鉴别器（Discriminator）：尽可能的正确判断输入数据是来自真实数据还是来自生成器。</p><p>损失函数：<img src="https://math.now.sh?inline=%5Cmin%20_G%20%5Cmax%20_D%20V%28D%2C%20G%29%3D%5Cmathbb%7BE%7D_%7B%5Cboldsymbol%7Bx%7D%20%5Csim%20p_%7B%5Ctext%20%7Bdata%20%7D%7D(%5Cboldsymbol%7Bx%7D)%7D%5B%5Clog%20D(%5Cboldsymbol%7Bx%7D)%5D%2B%5Cmathbb%7BE%7D_%7B%5Cboldsymbol%7Bz%7D%20%5Csim%20p_%7B%5Cboldsymbol%7Bz%7D%7D(%5Cboldsymbol%7Bz%7D)%7D%5B%5Clog%20(1-D(G(%5Cboldsymbol%7Bz%7D)))%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>训练过程：生成器与鉴别器交替训练，互相提升各自的生成能力和鉴别能力，最终寻找二者之间的一个纳什均衡。</p><h3 id="强化学习">强化学习</h3><p>马尔科夫决策过程：</p><p>智能体环境交互-智能体的目标是最大化将来的期望累积奖励</p><h3 id="知识图谱">知识图谱</h3><p>背景</p><p>知识图谱的概念最早出现于Google公司的知识图谱项目，体现在使用Google搜索引擎时，出现于搜索结果右侧的相关知识展示。</p><p>截止到2016 年底，Google知识图谱中的知识数量已经达到了600亿条，关于1500个类别的5.7亿个实体，以及它们之间的3.5万种关系。</p><p>实体、关系和事实：</p><ul><li>实体(entity)：现实世界中可区分、可识别的事物或概念。</li><li>关系(relation)：实体和实体之间的语义关联。</li><li>事实(fact)： (head entity, relation, tail entity) 三元组形式。</li></ul><p>狭义知识图谱</p><p>狭义知识图谱：具有图结构的三元组知识库。</p><p>节点：实体。 边：事实（由头实体指向尾实体）。 边的类型：关系。</p><p>链接预测、三元组分类：知识图谱上的链接预测</p><p>分布式知识表示方法分类：</p><ul><li>位移距离模型 (translational distance models)：采用基于距离的打分函数来衡量三元组成立的可能性。</li><li>语义匹配模型 (semantic matching models)：采用基于相似度的打分函数来衡量三元组成立的可能性。<ul><li>简单匹配模型：RESCAL及其变种-将头实体和尾实体的表示进行组合后再与关系的表示进行匹配</li><li>复杂匹配模型：深度神经网络-利用较为复杂的神经网络结构完成实体和关系的语义匹配</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第15讲 基于深度神经网络的IR模型</title>
    <link href="/2022/10/17/UCAS/information-retrieval/information-retrieval-15/"/>
    <url>/2022/10/17/UCAS/information-retrieval/information-retrieval-15/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第15讲 基于深度神经网络的IR模型</p><span id="more"></span><h1>第15讲 基于深度神经网络的IR模型</h1><h2 id="深度神经网络基础">深度神经网络基础</h2><p>最简单的神经网络-神经元</p><p>激活函数：主要作用是引入非线性，增强网络的表示能力。</p><p>最简单的多层神经网络-多层感知机</p><p>Softmax归一化是在使用神经网络进行分类时常用的方法，对于分类问题，通常需要给出可能属于每一个类别的概率，即需要输出介于 0 和 1 之间，且加和为 1</p><p>参数的学习</p><p>正则化</p><p>卷积神经网络</p><p>循环神经网络</p><h2 id="Neural-IR-Model">Neural IR Model</h2><p>Neural IR 模型分类</p><p>Representation based：学习文本的分布式表示 在高维空间匹配</p><ul><li>词表示：one hot → distributed</li><li>句子表示：bag of words → distributed</li><li>匹配能力取决于学习文本表示的算法能力</li><li>代表模型：DSSM, CDSSM</li></ul><p>Matching function：文本之间先进行交互匹配，再对匹配信号进行融合</p><ul><li>输入：比较底层的输入</li><li>匹配函数：cosine, dot product → NN</li><li>优点：可以考虑更加丰富的匹配信号， 如软匹配 (soft matching)</li><li>代表模型：MatchPyramid , DRMM, K NRM, PACRR, NPRF</li></ul><p>Combination of both: 既考虑 Representation 又考虑 Matching function</p><ul><li>代表模型：Duet</li></ul><p>DSSM：Deep Structured Semantic Models</p><p>word hashing: Bag of letter trigrams representation</p><p>模型：DNN学习查询，文本的语义表示， cosine相似度作为匹配评分</p><p>MatchPyramid：</p><p>考虑各种层次的匹配信号，包括单词层次、短语层次以及句子层次等等；</p><p>在图像领域，基于 CNN 特征提取的图像金字塔被证明是有效的</p><p>DRMM：相比普通的文本匹配任务，检索任务更需要关注相关性匹配</p><p>通过显式地对精确匹配信号，查询词重要度以及多样匹配要求进行建模，得到的模型更加适合于检索任务。</p><p>DRMM是第一个在 TREC 数据集能够取得比传统检索模型更好效果的基于 DNN 模型</p><p>DRMM的设计思路在一定程度上借鉴了传统的 TF-IDF</p><p>K-NRM：使用kernel pooling 技术提取多层次的软匹配 (soft match)特征</p><p>PACRR：通过将具有不同大小(k= lg 卷积核的卷积层作用于查询与文档间的单词-单词相似度矩阵，来对 k gram 匹配信息进行建模。</p><p>DUET：Representation与Matching function 的方法是互补的</p><p>SNRM：监督学习得到文本稀疏表示，解决效率问题</p><p>NPRF：将反馈文档视为原始查询的扩充表示，通过增强与查询相关的信息匹配信号获得更好的交互矩阵</p><p>总结与展望</p><ul><li>基于DNN 的检索模型的研究虽然目前取得了一定的成果，但还有许多问题没有解决<ul><li>尚未得到明显优于传统模型（如BM25+QE ）的结果</li><li>很多论文回避了与传统PRF 模型的比较</li></ul></li><li>CNN、统计直方图：有用； RNN ：没有效果</li><li>长文本IR 应用中往往 DNN 方法效果有限</li><li>但是在商品推荐、基于title 的检索、 microblog retrieval 等短文本应用中效果不错</li><li>通过CNN 等方法提取的特征 Vs 基于信息理论进行概率估计得到的特征</li><li>很多在NLP 领域证明非常有效的方法，在 IR 领域尚未发挥威力</li></ul><h2 id="BERT">BERT</h2><p>基于BERT的检索模型</p><p>稠密向量检索模型</p><p>直接改变了原有第一阶段的检索模式，通过BERT等预训练语言模型，将查询和文档都映射到语义空间中，编码成单个稠密向量表示，用ANN 算法来进行检索。在一定程度上缓解了词汇不匹配问题，并将检索阶段的匹配效果推到了一个新的台阶</p><p>模型框架：一般采用双塔结构对查询和文档单独地编码得到二者独立的表达，从而使文档可以进行离线索引。</p><p>RepBERT：平均词项表示作为文档的单个向量</p><p>ANCE：利用k-1的模型来检索得到top-n文档并随机采样负样本，每隔一段时间都需要对训练数据中的负样本进行更新，因此该方法的训练代价较大。</p><p>RocketQA：与ANCE相比，做了额外的denoised操作；</p><p>TCT-ColBERT：通过蒸馏技术，将ColBERT的强建模能力蒸馏到类似于RepBERT这样的双塔架构上去</p><p>Condenser：为了将更完整的序列信息压缩到CLS 位置上</p><p>DAR：通过插值、扰动的方式在文档表示层面进行数据增强</p><p>JPQ：除了直接采用乘积量化（Product Quantization, PQ ）方法来压缩向量外，将乘积量化后的文档d†表示用于模型训练，通过排序排序训练目标来优化 PQ 的聚类中心表示</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第7讲 图卷积神经网络</title>
    <link href="/2022/10/13/UCAS/advanced-ai/advanced-ai-7/"/>
    <url>/2022/10/13/UCAS/advanced-ai/advanced-ai-7/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第7讲 图卷积神经网络</p><span id="more"></span><h1>第7讲 图卷积神经网络</h1><p>卷积神经网络在欧式数据（图像、文本、声音和视频等）上获得了巨大的成功，广泛应用于图像分类、目标检测、机器翻译等</p><p>卷积神经网络可以学习局部小结构，使用局部的卷积核，然后形成多维的模式</p><p>卷积如何迁移到非欧空间上去？</p><p>卷积是在函数<img src="https://math.now.sh?inline=f" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和函数<img src="https://math.now.sh?inline=g" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的数学运算，从而得到函数<img src="https://math.now.sh?inline=h" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>连续形式：<img src="https://math.now.sh?inline=h%28t%29%3D(f%20*%20g)(t)%20%5Cstackrel%7B%5Ctext%20%7B%20def%20%7D%7D%7B%3D%7D%20%5Cint%20f(t-%5Ctau)%20g(t)%20d%20%5Ctau" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>离散形式：<img src="https://math.now.sh?inline=h%28x%2C%20y%29%3D(f%20*%20g)(x%2C%20y)%5Cstackrel%7B%5Ctext%20%7B%20def%20%7D%7D%7B%3D%7D%20%5Csum_%7Bm%2C%20n%7D%20f(x-m%2C%20y-n)%20g(m%2C%20n)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>在图上定义卷积的方法：</p><p>谱方法：在谱空间中定义卷积：</p><ul><li>通过图傅里叶变换和卷积原理定义卷积<ul><li>图数据符合幂律分布，造成了极大的挑战</li></ul></li><li>主要挑战是在谱空间定义的卷积在结点空间并没有局部化</li></ul><p>空间方法：在向量空间中定义卷积</p><ul><li>卷积被定义为目标结点到它的所有邻居的一个加权平均函数</li><li>主要挑战是邻域的大小在结点之间差异很大，可能服从幂律分布</li></ul><h2 id="谱方法">谱方法</h2><p>定义一个图<img src="https://math.now.sh?inline=G%3D%28V%2CE%2CW%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（结点、边、邻接矩阵）</p><p>图上的每个结点<img src="https://math.now.sh?inline=V" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上都有<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维的特征，因此<img src="https://math.now.sh?inline=X%20%5Cin%20R%5E%7Bn%20*%20d%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是结点的特征矩阵，每一列是结点的一个信号</p><p>图的拉普拉斯算子：<img src="https://math.now.sh?inline=L%3DD-W" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=D_%7Bii%7D%3D%5Csum_j%20W_%7Bij%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>归一化的拉普拉斯算子：<img src="https://math.now.sh?inline=L%3DI-D%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7DWD%5E%7B-%5Cfrac%7B1%7D%7B2%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>图<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的傅里叶变换：</p><p><img src="https://math.now.sh?inline=L" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的正交特征向量是<img src="https://math.now.sh?inline=%5C%7Bu_l%5C%7D_%7Bl%3D1%7D%5En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，对应的非负特征值是<img src="https://math.now.sh?inline=%5C%7B%5Clambda_l%5C%7D_%7Bl%3D1%7D%5En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，可以对拉普拉斯矩阵进行分解：<img src="https://math.now.sh?inline=L%3DU%20%5CLambda%20U%5E%7BT%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>对于一个信号<img src="https://math.now.sh?inline=x%20%5Cin%20R%5En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的图傅里叶变换为<img src="https://math.now.sh?inline=%5Chat%7Bx%7D%3DU%5ETx" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>两个信号的卷积的傅里叶变换是两个信号的傅里叶变换的逐点相乘</strong><img src="https://math.now.sh?inline=x%20*_%7BG%7D%20y%3DU%5Cleft%28%5Cleft(%5Cboldsymbol%7BU%7D%5E%7BT%7D%20%5Cboldsymbol%7Bx%7D%5Cright%29%20%5Codot%5Cleft(%5Cboldsymbol%7BU%7D%5E%7B%5Cboldsymbol%7BT%7D%7D%20y%5Cright)%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，卷积核就是<img src="https://math.now.sh?inline=U%5ETy" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><a href="https://imgse.com/i/xd8xQU"><img src="https://s1.ax1x.com/2022/10/13/xd8xQU.md.png" alt="xd8xQU.md.png"></a></p><p>图卷积神经网络：</p><p><a href="https://imgse.com/i/xdGCw9"><img src="https://s1.ax1x.com/2022/10/13/xdGCw9.md.png" alt="xdGCw9.md.png"></a></p><p>缺点：</p><ul><li>需要拉普拉斯矩阵的特征分解，特征向量不太好获得</li><li>计算成本高，傅里叶乘法的时间复杂度是<img src="https://math.now.sh?inline=O%28n%5E2%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>在结点空间上不是局部化的（操作的是全局信号）</li></ul><p>ChebyNet：参数化-将参数的数量从n降为K</p><p><a href="https://imgse.com/i/xdJCjS"><img src="https://s1.ax1x.com/2022/10/13/xdJCjS.md.png" alt="xdJCjS.md.png"></a></p><p>优点：</p><ul><li>不再需要特征分解</li><li>时间复杂度从<img src="https://math.now.sh?inline=O%28n%5E2%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>下降到<img src="https://math.now.sh?inline=O%28%7CE%7C%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>卷积在结点空间上是局部化的（卷积严格定位在半径为 K 的球中）</li></ul><p>Graph wavelet neural network：图小波神经网络</p><p>将傅里叶基换为小波基：稀疏、局部化、计算代价低</p><h2 id="空间方法">空间方法</h2><p>方法类比卷积：</p><ol><li>对于每个节点，根据某些邻近度指标选择固定数量的结点作为其相邻结点</li><li>根据邻近度指标给邻居排序</li><li>共享参数</li></ol><p>GraphSAGE：从每个结点开始随机游走，采样<img src="https://math.now.sh?inline=K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个结点，不用临近度指标判断。然后通过聚合函数进行参数共享</p><p>图卷积网络（GCN）：通过归一化的拉普拉斯矩阵从不固定数量的邻居结点中聚合信息，通过特征变换共享参数</p><p>GAT：Graph Attention Network：通过注意力机制学习聚合矩阵</p><p>MoNet：空间方法的一般意义框架：所有的空间方法都是定义多个核函数，来测量目标结点和其他结点之间的相似度</p><h2 id="谱方法与空间方法的关系">谱方法与空间方法的关系</h2><p>谱方法是空间方法的特例</p><ul><li>谱方法通过特别的空间变换定义核函数</li><li>空间方法直接定义核函数</li></ul><h2 id="图池化">图池化</h2><p>图粗化：将结点进行聚类，每一类作为一个超级结点</p><p>结点选择：学习一个评价标准去挑选比较重要的结点</p><h2 id="图神经网络的表达能力">图神经网络的表达能力</h2><p>图神经网络在结点分类、链接预测、图分类上取得了巨大的成功，但是图神经网络的设计大多基于直觉、启发式方法或者实验试错，缺少对于图神经网络的理论理解。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：模式识别与机器学习-第5章 统计机器学习</title>
    <link href="/2022/10/13/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-5/"/>
    <url>/2022/10/13/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-5/</url>
    
    <content type="html"><![CDATA[<p>《模式识别与机器学习》课程笔记：第5章 统计机器学习</p><span id="more"></span><h1>第5章 统计机器学习</h1><h2 id="机器学习简介">机器学习简介</h2><p>桑克（R.Shank）“一台计算机若不会学习，就不能说它具有智能。”</p><p>机器学习更强调面向算法，而统计学更偏重于面向模型。换而言之，机器学习强调算法的结果要好，所以机器学习很关注损失函数。而统计学要先扔出来一大堆模型假设，然后站在模型上面通过严格的数学推导做出结果。</p><p>统计机器学习：是基于数据构建概率统计模型并运用模型对数据进行预测分析的一门学科。</p><p>机器学习的学习过程：</p><ul><li>经验（E）：训练数据</li><li>模型（T）：需要学习的目标函数</li><li>学习算法：怎么样从经验中推断出模型</li><li>评价（P）：测试数据</li></ul><p>机器学习的特点：</p><ul><li>数据大量且廉价，知识昂贵而稀少</li><li>数据产生过程的细节是未知的，但是数据产生的过程不是完全随机的。</li><li>通过利用数据中的某些模式或规律从数据中学习模型：反推数据生成路径。</li><li>模型通常不是完整过程的精确复制品，而是一种良好且有用的近似。</li><li>模型可以描述从数据中获取知识，或对预测将来(具有预测性)，或者两者兼而有之。</li><li>几乎所有的科学都关注于用模型拟合数据：推理。</li></ul><p>机器学习方法分类：</p><ul><li>有监督学习：有标记数据 e.g. Fisher,、感知器算法、线性判别分析</li><li>无监督学习：无标注数据，降维方法K-L</li><li>半监督学习：无标注数据+有标注数据</li><li>多任务学习：共享相关任务之间的表征</li><li>迁移学习：训练数据与测试数据不是同分布的</li><li>强化学习：间接的标注数据（状态和对应的reward）</li><li>主动学习：主动选择训练数据</li><li>自监督学习：从无标注数据提取监督信号。</li></ul><p>自监督学习是自主监督学习。它提取并使用自然可用的相关上下文和嵌入式元数据作为监督信号。</p><h2 id="统计机器学习">统计机器学习</h2><h3 id="框架">框架</h3><p>输入训练样本，目标是损失函数期望风险最小化</p><p>期望风险最小化：</p><p>经验风险最小化：（导致过拟合）</p><p>结构风险最小化：</p><h3 id="过拟合及正则化">过拟合及正则化</h3><p>怎么样在测试数据上预测得好？</p><p>两方面：</p><ul><li>模型对训练数据拟合得好-需要复杂的模型</li><li>模型具有一定的能力来容忍测试数据的不同行为-需要稳定的模型</li></ul><p>正则项：在原来的经验损失函数中添加一个惩罚项，不鼓励复杂的模型</p><h3 id="泛化能力分析">泛化能力分析</h3><p>偏差-方差分解：expected loss=bias2+variance+noise</p><p>偏差：度量了模型的期望预测和真实结果的偏离程度</p><p>方差：刻画了数据扰动所造成的影响</p><p>噪声：与f相互独立，刻画了问题的难易程度</p><p>由正则化参数<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>控制的偏差和方差对模型复杂性的依赖性说明：</p><p>大的<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>值将权重参数拉至零导致较大偏差，较小的<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>值允许对噪声进行微调，从而导致较大的方差</p><ul><li>简单模型：低方差、高偏差</li><li>复杂模型：高方差、低偏差</li></ul><p>对模型复杂度问题的深刻理解：</p><ul><li>非常灵活的模型具有低偏差和高方差。</li><li>相对刚性的模型有大的偏差和低的方差。</li><li>具有最佳预测能力的模型是使得偏差和方差之间最佳平衡的模型。</li><li>偏差-方差分解的实际应用价值有限：<ul><li>偏差和方差无法计算，因为它依赖于了解x和y的真实分布。</li><li>偏差-方差分解基于数据集集合的平均值，而实际上我们只有单个观测数据集。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Pattern Recognition and Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第9章 概率图模型</title>
    <link href="/2022/10/12/UCAS/machine-learning/machine-learning-9/"/>
    <url>/2022/10/12/UCAS/machine-learning/machine-learning-9/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第9章 概率图模型</p><span id="more"></span><h1>第9章 概率图模型</h1><h2 id="有向图模型：贝叶斯网络">有向图模型：贝叶斯网络</h2><p>图结构：有向无环图</p><p>结点：一个或一组随机变量</p><p>边：随机变量之间的单向、直接影响</p><p>联合概率分布分解形式：<img src="https://math.now.sh?inline=P%28%5Cmathbf%7Bx%7D%29%3D%5Cprod_%7Bi%3D1%7D%5En%20P%5Cleft(x_i%20%5Cmid%20%5Cmathbf%7Bx%7D_%7B%5Cpi%20i%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中， <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%5C%7Bx_1%2C%20x_2%2C%20%5Cldots%2C%20x_n%5Cright%5C%7D%20%3B%20%5Cmathbf%7Bx%7D_%7B%5Cpi%20i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 所有父结点构成的集合</p><p>条件独立性 D-分离准则（D-separation criterion）：判断贝叶斯网络结点之间的条件独立性。</p><p>贝叶斯网络的全局马尔科夫性：给定结点集合A，B，C，若A到B中结点的所有无向路径都是被C阻塞的（blocked），则称A和B被C D-分离（D-separated），即A和B关于C条件独立。</p><p>若一条无向路径包含结点x满足以下条件之一，则称其是阻塞的：</p><ul><li>x 是tail-to-tail 或head-to-tail 结点，并且x包含在C中。<img src="https://math.now.sh?inline=x_v%20%5Cperp%20x_%7BV%20%5Cbackslash%5C%7Bv%5C%7D%20%5Cbackslash%20P%20A%28v%29%20%5Cbackslash%20D%20E(v)%7D%20%5Cmid%20x_%7BP%20A(v)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>x 是head-to-head 结点，并且x(及x 的任意后代均)不包含在C中。<img src="https://math.now.sh?inline=x_v%20%5Cperp%20x_%7BV%20%5Cbackslash%5C%7Bv%5C%7D%20%5Cbackslash%20M%20B%28v%29%7D%20%5Cmid%20x_%7BM%20B(v)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>贝叶斯网络的局部马尔科夫性：</p><ul><li>给定某变量的父结点，则该变量条件独立于所有其他非其后代结点。</li><li>给定某变量的马尔可夫毯（父结点，子结点，子结点的父结点），则该变量条件独立于其他变量。</li></ul><h2 id="无向图模型：马尔可夫随机场">无向图模型：马尔可夫随机场</h2><p>图结构：无向图</p><p>结点：一个或一组随机变量。</p><p>边：随机变量之间的相互依赖（非“因果关系”）。</p><p>团：对于图中的结点子集，若其中任意两个节点之间都有连边，则称该结点子集为一个团（clique）。</p><p>极大团：若在团中加入其他任意一个结点都不再形成团，则称该团为极大团（maximal clique）。</p><p>分解形式：<img src="https://math.now.sh?inline=P%28%5Cmathbf%7Bx%7D%29%3D%5Cfrac%7B1%7D%7BZ%7D%20%5Cprod_%7BC%20%5Cin%20%5Cmathbb%7BC%7D%7D%20%5Cpsi_C%5Cleft(%5Cmathbf%7Bx%7D_C%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中， <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%5C%7Bx_1%2C%20x_2%2C%20%5Cldots%2C%20x_n%5Cright%5C%7D%20%EF%BC%9B%20%5Cmathbb%7BC%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 为团集合， <img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D_C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 为团 <img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 对应的变量集合，<img src="https://math.now.sh?inline=%5Cpsi_C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 为定义在团 <img src="https://math.now.sh?inline=%5Cmathrm%7BC%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 上的非负势函数，<img src="https://math.now.sh?inline=Z%3D%5Csum_%7B%5Cmathbf%7Bx%7D%7D%20%5Cprod_%7BC%20%5Cin%20%5Cmathbb%7BC%7D%7D%20%5Cpsi_C%5Cleft%28%5Cmathbf%7Bx%7D_C%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是归一化因子</p><p>条件独立性：</p><p>马尔可夫随机场的全局马尔科夫性：给定结点集合A，B，C，若从A中的结点到B中结点必须经过C中的结点，则称A和B被C分离，即A和B关于C条件独立。</p><p>局部马尔科夫性：给定某变量的马尔可夫毯（邻接变量），则该变量条件独立于其他变量。<img src="https://math.now.sh?inline=x_v%20%5Cperp%20x_%7BV%20%5Cbackslash%5C%7Bv%5C%7D%20%5Cbackslash%20M%20B%28v%29%7D%20%5Cmid%20x_%7BM%20B(v)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>成对马尔科夫性：给定其他所有变量，两个非相邻变量条件独立。<img src="https://math.now.sh?inline=x_u%20%5Cperp%20x_v%20%5Cmid%20x_%7BV%20%5Cbackslash%5C%7Bu%2C%20v%5C%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> if <img src="https://math.now.sh?inline=%28u%2C%20v%29%20%5Cnotin%20E" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="学习与推断">学习与推断</h2><p>基本定义</p><p>推断：已知联合概率分布 <img src="https://math.now.sh?inline=%5Cmathrm%7BP%7D%5Cleft%28%5Cmathrm%7Bx%7D_1%2C%20%5Cmathrm%7Bx%7D_2%2C%20%5Cldots%2C%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bn%7D%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，估计 <img src="https://math.now.sh?inline=%5Cmathrm%7BP%7D%5Cleft%28%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BQ%7D%7D%20%5Cmid%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BE%7D%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，其中 <img src="https://math.now.sh?inline=%5Cmathrm%7Bx%7D_Q%20%5Ccap%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BE%7D%7D%3D%5Cemptyset%20%EF%BC%8C%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BQ%7D%7D%20%5Ccup%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BE%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 是集合<img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cmathrm%7Bx%7D_1%2C%20%5Cmathrm%7Bx%7D_2%2C%20%5Cldots%2C%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bn%7D%7D%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的子集。 <img src="https://math.now.sh?inline=%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BQ%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 是问题变量， <img src="https://math.now.sh?inline=%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BE%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 是证据变量。</p><p>学习：从观测数据<img src="https://math.now.sh?inline=%5Cmathrm%7Bx%7D%5E%7B%281%29%7D%2C%20%5Cmathrm%7Bx%7D%5E%7B(2)%7D%2C%20%5Cldots%2C%20%5Cmathrm%7Bx%7D%5E%7B(%5Cmathrm%7Bm%7D)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 中学习联合概率分布 <img src="https://math.now.sh?inline=%5Cmathrm%7BP%7D%5Cleft%28%5Cmathrm%7Bx%7D_1%2C%20%5Cmathrm%7Bx%7D_2%2C%20%5Cldots%2C%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bn%7D%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，寻找最符合观测数据的概率图模型。</p><p>推断：已知联合概率分布 <img src="https://math.now.sh?inline=%5Cmathrm%7BP%7D%5Cleft%28%5Cmathrm%7Bx%7D_1%2C%20%5Cmathrm%7BX%7D_2%2C%20%5Cldots%2C%20%5Cmathrm%7BX%7D_%7B%5Cmathrm%7Bn%7D%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，估计<img src="https://math.now.sh?inline=P%5Cleft%28%5Cmathbf%7Bx%7D_Q%20%5Cmid%20%5Cmathbf%7Bx%7D_E%5Cright%29%3D%5Cfrac%7BP%5Cleft(%5Cmathbf%7Bx%7D_Q%2C%20%5Cmathbf%7Bx%7D_E%5Cright)%7D%7BP%5Cleft(%5Cmathbf%7Bx%7D_E%5Cright)%7D%3D%5Cfrac%7BP%5Cleft(%5Cmathbf%7Bx%7D_Q%2C%20%5Cmathbf%7Bx%7D_E%5Cright)%7D%7B%5Csum_%7B%5Cmathbf%7Bx%7D_Q%7D%20P%5Cleft(%5Cmathbf%7Bx%7D_Q%2C%20%5Cmathbf%7Bx%7D_E%5Cright)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中 <img src="https://math.now.sh?inline=x_Q%20%5Ccap%20x_E%3D%5Cvarnothing%20%EF%BC%8C%20x_Q%20%5Ccup%20x_E%3D%5Cleft%5C%7Bx_1%2C%20x_2%2C%20%5Cldots%2C%20x_n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>枚举 : 假设 <img src="https://math.now.sh?inline=x_Q" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 有 <img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 个变量，每个变量的取值个数的期望是 <img src="https://math.now.sh?inline=r" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，则时间复杂度为 <img src="https://math.now.sh?inline=r%5Ek" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>推断的核心问题 : 如何高效地计算边际分布 <img src="https://math.now.sh?inline=%5Cmathrm%7BP%7D%5Cleft%28%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BE%7D%7D%5Cright%29%3D%5Csum_%7Bx_Q%7D%20P%5Cleft(x_Q%20%5Cmid%20x_E%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>推断方法</p><p>精确推断：计算<img src="https://math.now.sh?inline=P%28x_E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>或<img src="https://math.now.sh?inline=P%28x_Q%7Cx_E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的精确值。</p><p>变量消去（variable elimination）</p><p>思路：利用图模型的紧凑概率分布形式来削减计算量。</p><p>优点：简单直观，代数上的消去对应图中结点的消去。</p><p>缺点：针对不同证据变量会造成大量冗余计算。</p><p>信念传播（belief propagation）</p><p>思路：将变量消去过程中产生的中间结果视为可复用的消息，避免重复计算。</p><p>消息传递仅在邻接变量之间发生，与边的方向性无关。</p><p>树结构：有向树=无向树</p><p>树结构上的消息传递：</p><p>消息计算公式：</p><p>边际分布：</p><p>二次扫描算法：</p><ul><li>指定一个根结点，从所有叶结点开始向根节点传递消息，直到根结点收到所有邻接结点的消息。</li><li>从根结点开始向叶结点传递消息，直到所有叶结点均收到消息。</li></ul><h2 id="近似推断">近似推断</h2><p>近似推断：在较低的时间复杂度下获得原问题的近似解。通过采样一组服从特定分布的样本，来近似原始分布，适用范围更广，操作性更强。</p><p>前向采样（forward sampling）</p><p>思路：依据贝叶斯网络的（条件）概率直接采样。采样后，进行需要的概率统计。</p><p>缺点：对于小概率事件采样困难，可能经过很多次采样也无法获得足够多的样本</p><p>仅适用于贝叶斯网络，不适用于马尔可夫随机场。</p><p>吉布斯采样（Gibbs sampling）</p><p>思路：直接依照条件概率<img src="https://math.now.sh?inline=P%28x_Q%7Cx_E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>采样。</p><p>马尔可夫毯的性质：</p><p>优点：</p><ul><li>直接从<img src="https://math.now.sh?inline=P%28x_Q%7Cx_E%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>采样，解决小概率事件采样难的问题</li><li>同时适用于贝叶斯网络和马尔可夫随机场</li><li>简单易推导，时间复杂度低。</li></ul><h2 id="实例模型">实例模型</h2><h3 id="隐马尔可夫模型">隐马尔可夫模型</h3><p>隐马尔可夫模型是关于时序的概率模型，是最简单的动态贝叶斯网络模型。</p><p>状态变量<img src="https://math.now.sh?inline=%5Cleft%5C%7By_1%2C%20y_2%2C%20%5Cldots%2C%20y_n%5Cright%5C%7D%20%EF%BC%8C%20y_t%20%5Cin%20Y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 表示第 <img src="https://math.now.sh?inline=%5Cmathrm%7Bt%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 时刻的系统状态，观测变量 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_1%2C%20x_2%2C%20%5Cldots%2C%20x_n%5Cright%5C%7D%20%EF%BC%8C%20x_t%20%5Cin%20X" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 表示第 <img src="https://math.now.sh?inline=%5Cmathrm%7Bt%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 时刻的观测值。</p><p>观测变量仅依赖于当前时刻的状态变量，当前状态仅依赖于前一时刻的状态。状态集合 <img src="https://math.now.sh?inline=Y%3D%5Cleft%5C%7Bs_1%2C%20s_2%2C%20%5Cldots%2C%20s_N%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，观测值集合 <img src="https://math.now.sh?inline=X%3D%5Cleft%5C%7Bo_1%2C%20o_2%2C%20%5Cldots%2C%20o_M%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>联合概率：<img src="https://math.now.sh?inline=P%5Cleft%28x_1%2C%20y_1%2C%20%5Cldots%2C%20x_n%2C%20y_n%5Cright%29%3DP%5Cleft(y_1%5Cright)%20P%5Cleft(x_1%20%5Cmid%20y_1%5Cright)%20%5Cprod_%7Bt%3D2%7D%5En%20P%5Cleft(x_t%20%5Cmid%20y_t%5Cright)%20P%5Cleft(y_t%20%5Cmid%20y_%7Bt-1%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>状态转移矩阵<img src="https://math.now.sh?inline=%5Cmathrm%7BA%7D%3D%5Cleft%5Ba_%7Bi%20j%7D%5Cright%5D_%7B%5Cmathrm%7BN%7D%20%5Ctimes%20%5Cmathrm%7BN%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=a_%7Bi%20j%7D%3DP%5Cleft%28y_%7Bt%2B1%7D%3Ds_j%20%5Cmid%20y_t%3Ds_i%5Cright%29%20%5Cquad%201%20%5Cleq%20i%2C%20j%20%5Cleq%20N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示 <img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 时刻处于状态 <img src="https://math.now.sh?inline=s_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的条件下， <img src="https://math.now.sh?inline=%5Cmathrm%7Bt%7D%2B1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 时刻转移到状态 <img src="https://math.now.sh?inline=s_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的概率</p><p>观测概率矩阵<img src="https://math.now.sh?inline=%5Cmathrm%7BB%7D%3D%5Cleft%5Bb_%7Bi%20j%7D%5Cright%5D_%7B%5Cmathrm%7BN%7D%20%5Ctimes%20%5Cmathrm%7BM%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=b_%7Bi%20j%7D%3DP%5Cleft%28x_t%3Do_j%20%5Cmid%20y_t%3Ds_i%5Cright%29%20%5Cquad%201%20%5Cleq%20i%20%5Cleq%20N%2C%20%5Cquad%201%20%5Cleq%20j%20%5Cleq%20M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示 <img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 时刻处于状态 <img src="https://math.now.sh?inline=s_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的条件下观测到 <img src="https://math.now.sh?inline=o_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的概率</p><p>初始状态概率向量 <img src="https://math.now.sh?inline=%5Cpi%3D%5Cleft%28%5Cpi_1%2C%20%5Cpi_2%2C%20%5Cldots%2C%20%5Cpi_N%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cpi_i%3DP%5Cleft%28y_1%3Ds_i%5Cright%29%20%5Cquad%201%20%5Cleq%20i%20%5Cleq%20N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示系统初始状态为<img src="https://math.now.sh?inline=s_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的概率。</p><p>生成过程：</p><p>给定<img src="https://math.now.sh?inline=A%20%EF%BC%8C%20B%20%EF%BC%8C%20%5Cpi" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，生成观测序列 <img src="https://math.now.sh?inline=%5Cleft%5C%7Bx_1%2C%20x_2%2C%20%5Cldots%2C%20x_n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ol><li>设置<img src="https://math.now.sh?inline=t%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，并根据初始状态概率<img src="https://math.now.sh?inline=%CF%80" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>生成初始状态<img src="https://math.now.sh?inline=y_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>根据<img src="https://math.now.sh?inline=y_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和观测概率矩阵B生成<img src="https://math.now.sh?inline=x_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>根据<img src="https://math.now.sh?inline=y_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和状态转移矩阵A 生成<img src="https://math.now.sh?inline=y_%7Bt%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>若<img src="https://math.now.sh?inline=t%3Cn" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则设置<img src="https://math.now.sh?inline=t%3Dt%2B1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，并转到第（2）步；否则，停止。</li></ol><p>三个基本问题</p><ul><li>概率计算问题：给定模型<img src="https://math.now.sh?inline=%5Clambda%3D%28A%2C%20B%2C%20%5Cpi%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和观测序列<img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%5C%7Bx_1%2C%20%5Cldots%2C%20x_n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，计算在模型<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>下观测<img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到的概率<img src="https://math.now.sh?inline=P%28%5Cmathbf%7Bx%7D%20%5Cmid%20%5Clambda%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。（评估模型与观测序列之间的匹配程度）</li><li>直接计算法：给定模型<img src="https://math.now.sh?inline=%5Clambda%3D%28A%2C%20B%2C%20%5Cpi%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和观测序列<img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%5C%7Bx_1%2C%20%5Cldots%2C%20x_n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，求使得<img src="https://math.now.sh?inline=P%28%5Cmathbf%7By%7Cx%7D%20%5Cmid%20%5Clambda%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最大的状态观测序列<img src="https://math.now.sh?inline=%5Cmathbf%7By%7D%3D%5Cleft%5C%7By_1%2C%20%5Cldots%2C%20y_n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。（根据观测序列推测状态序列）</li><li>学习问题：给定观测序列<img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%5C%7Bx_1%2C%20%5Cldots%2C%20x_n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，调整模型<img src="https://math.now.sh?inline=%5Clambda%3D%28A%2C%20B%2C%20%5Cpi%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>参数，使得该序列出现的概率<img src="https://math.now.sh?inline=P%28%5Cmathbf%7Bx%7D%20%5Cmid%20%5Clambda%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最大。（训练模型使其更好地描述观测序列）</li></ul><h3 id="条件随机场">条件随机场</h3><p>条件随机场(Conditional Random Field) 是给定随机变量<img src="https://math.now.sh?inline=%F0%9D%90%B1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件下，随机变量<img src="https://math.now.sh?inline=%F0%9D%90%B2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的马尔可夫随机场。<img src="https://math.now.sh?inline=%F0%9D%90%BA%28%F0%9D%91%89%2C%F0%9D%90%B8%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<img src="https://math.now.sh?inline=%F0%9D%90%B2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中的随机变量构成的无向图，图中每个变量在给定<img src="https://math.now.sh?inline=%F0%9D%90%B1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件下都满足马尔可夫性：</p><p>线性链条件随机场(linear-chain CRF)是随机变量<img src="https://math.now.sh?inline=%F0%9D%90%B2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为线性链时的条件随机场</p><p><img src="https://math.now.sh?inline=%5Cmathbf%7Bx%7D%3D%5Cleft%5C%7Bx_1%2C%20x_2%2C%20%5Ccdots%2C%20x_n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 是观测序列。 <img src="https://math.now.sh?inline=%5Cmathrm%7By%7D%3D%5Cleft%5C%7By_1%2C%20y_2%2C%20%5Ccdots%2C%20y_n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 是标记序列（或称状态序列 )，在给定<img src="https://math.now.sh?inline=%F0%9D%90%B1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件下，<img src="https://math.now.sh?inline=%F0%9D%90%B2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件分布<img src="https://math.now.sh?inline=%F0%9D%91%83%28%F0%9D%90%B2%7C%F0%9D%90%B1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>构成条件随机场。<img src="https://math.now.sh?inline=P%5Cleft%28y_i%20%5Cmid%20%5Cmathbf%7Bx%7D%2C%20y_1%2C%20%5Ccdots%2C%20y_%7Bi-1%7D%2C%20y_%7Bi%2B1%7D%2C%20%5Ccdots%2C%20y_n%5Cright%29%3DP%5Cleft(y_i%20%5Cmid%20%5Cmathbf%7Bx%7D%2C%20y_%7Bi-1%7D%2C%20y_%7Bi%2B1%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=P%28%5Cmathbf%7By%7D%20%5Cmid%20%5Cmathbf%7Bx%7D%29%3D%5Cfrac%7B1%7D%7BZ%7D%20%5Cexp%20%5Cleft(%5Csum_%7Bi%2C%20j%7D%20%5Clambda_j%20t_j%5Cleft(y_%7Bi%2B1%7D%2C%20y_i%2C%20%5Cmathbf%7Bx%7D%2C%20i%5Cright)%2B%5Csum_%7Bi%2C%20k%7D%20%5Cmu_k%20s_k%5Cleft(y_i%2C%20%5Cmathbf%7Bx%7D%2C%20i%5Cright)%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第14讲 面向信息检索的分布式词项表示</title>
    <link href="/2022/10/12/UCAS/information-retrieval/information-retrieval-14/"/>
    <url>/2022/10/12/UCAS/information-retrieval/information-retrieval-14/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第14讲 面向信息检索的分布式词项表示</p><span id="more"></span><h1>第14讲 面向信息检索的分布式词项表示</h1><p>怎样更鲁棒的匹配用户搜索意图？</p><p>查询扩展/Query expansion：</p><ul><li>相关反馈/Relevance feedback 能够通过向查询中添加扩展词，从而对捕捉用户搜索意图有所帮助</li><li>也可以利用 词项相似度/word similarities 信息:<ul><li>基于人工 同义词表/thesaurus of synonyms 的查询扩展</li><li>词项相似度指标<ul><li>基于大规模文档语料计算</li><li>基于查询日志挖掘（Web上的常见做法）计算</li></ul></li></ul></li></ul><p>文档扩展/Document expansion:</p><p>使用锚文本/anchor text可以通过提供人工创作的同义词（即锚文本）来解决此问题，但不适用于新的或不太受欢迎的网页（注：链接稀疏，锚文本少）或无超链接的语料</p><p>基于查询日志的查询扩展</p><p>不考虑上下文语境的查询扩展可能会导致问题</p><p>从查询日志学习考虑上下文语境的查询重写：识别同一用户基于同一信息需求的多次查询请求</p><p>自动同义词库生成</p><ul><li>尝试通过分析文档集来自动生成同义词库</li><li>基本概念：两个词之间的相似性</li><li>假设1：如果两个单词与相似单词同时出现，则它们是相似的。</li><li>假设2：如果两个单词与同一个词在给定的语法关系中出现，则它们是相似的。</li><li>基于共现的相似度更鲁棒，基于语法关系的相似度更准确。</li></ul><p>表示词项之间的关系</p><p>使用词项的标准符号编码，每个词项都是一个维度</p><p>不同的词项没有内在的相似性</p><p>基于分布式相似度的表示：用相邻词项的意义来表示一个词项</p><p>解决方案：低维向量</p><p>基本思想: 将“大部分的”重要信息存储在一个维度固定的低维向量中 - 即“密集向量”</p><p>传统方法：潜在语义索引/分析</p><p>使用奇异值分解（Singular Value Decomposition,SVD）–或只是随机映射（random projection）以找到低维基向量或正交向量</p><h2 id="神经嵌入">神经嵌入</h2><p>词项的意义由向量表示：为每个词类构建一个密集向量，该向量应当能够准确的预测其上下文词项</p><p>学习神经词嵌入：基本思路</p><ul><li>定义一个向量表示的模型，该模型预测一个中心词 wt 的 上下文词（或者反过来）</li><li>同时也有一个损失函数</li><li>不断调整（所有词的）向量表示使得损失最小化</li><li>最终得到每个词的低维密集向量表示</li></ul><p>思路：直接基于预测能力学习低维词向量</p><p>Word2Vec包含一组算法预测每个词的上下文（或者反过来）</p><p>神经网络的优化：（求导的）链式法则</p><p>Word2vec里的线性关系</p><p>Word2vec的向量表示非常善于对相似性和相似性的维度编码!</p><p>仅通过在嵌入空间中进行向量减法就可以很好地解决类比测试相似度的问题</p><p>Dual Embedding Space Model (DESM)</p><p>一种简单的利用词嵌入的检索模型</p><p>文档由其词项嵌入的中心向量表示</p><p>查询-文档相似度：查询词向量与文档向量的平均相似度</p><p>DESM 是一个弱排序模型，但是具有发现微妙相似性/关联性的能力</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言圣经-复合数据类型</title>
    <link href="/2022/10/11/Go/go-basic-4/"/>
    <url>/2022/10/11/Go/go-basic-4/</url>
    
    <content type="html"><![CDATA[<p>Go语言圣经-复合数据类型</p><span id="more"></span><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。</p><p>一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0</p><p>如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。</p><p>一个slice可以用来模拟一个stack</p><p>最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack：</p><div class="code-wrapper"><pre><code class="hljs go">stack = <span class="hljs-built_in">append</span>(stack, v) <span class="hljs-comment">// push v</span></code></pre></div><p>stack的顶部位置对应slice的最后一个元素：</p><div class="code-wrapper"><pre><code class="hljs go">top := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// top of stack</span></code></pre></div><p>通过收缩stack可以弹出栈顶的元素</p><div class="code-wrapper"><pre><code class="hljs go">stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// pop</span></code></pre></div><p>要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    <span class="hljs-built_in">copy</span>(slice[i:], slice[i+<span class="hljs-number">1</span>:])    <span class="hljs-keyword">return</span> slice[:<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;    fmt.Println(remove(s, <span class="hljs-number">2</span>)) <span class="hljs-comment">// &quot;[5 6 8 9]&quot;</span>&#125;</code></pre></div><p>如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(slice []<span class="hljs-type">int</span>, i <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;    slice[i] = slice[<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]    <span class="hljs-keyword">return</span> slice[:<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;    fmt.Println(remove(s, <span class="hljs-number">2</span>)) <span class="hljs-comment">// &quot;[5 6 9 8]</span>&#125;</code></pre></div><h1>JSON</h1><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Movie <span class="hljs-keyword">struct</span> &#123;    Title  <span class="hljs-type">string</span>    Year   <span class="hljs-type">int</span>  <span class="hljs-string">`json:&quot;released&quot;`</span>    Color  <span class="hljs-type">bool</span> <span class="hljs-string">`json:&quot;color,omitempty&quot;`</span>    Actors []<span class="hljs-type">string</span>&#125;<span class="hljs-keyword">var</span> movies = []Movie&#123;    &#123;Title: <span class="hljs-string">&quot;Casablanca&quot;</span>, Year: <span class="hljs-number">1942</span>, Color: <span class="hljs-literal">false</span>,        Actors: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Humphrey Bogart&quot;</span>, <span class="hljs-string">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,    &#123;Title: <span class="hljs-string">&quot;Cool Hand Luke&quot;</span>, Year: <span class="hljs-number">1967</span>, Color: <span class="hljs-literal">true</span>,        Actors: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Paul Newman&quot;</span>&#125;&#125;,    &#123;Title: <span class="hljs-string">&quot;Bullitt&quot;</span>, Year: <span class="hljs-number">1968</span>, Color: <span class="hljs-literal">true</span>,        Actors: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Steve McQueen&quot;</span>, <span class="hljs-string">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,    <span class="hljs-comment">// ...</span>&#125;</code></pre></div><p>这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成：</p><div class="code-wrapper"><pre><code class="hljs go">data, err := json.Marshal(movies)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    log.Fatalf(<span class="hljs-string">&quot;JSON marshaling failed: %s&quot;</span>, err)&#125;fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data)</code></pre></div><p>另一个json.MarshalIndent函数将产生整齐缩进的输出。该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进：</p><div class="code-wrapper"><pre><code class="hljs go">data, err := json.MarshalIndent(movies, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;    &quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    log.Fatalf(<span class="hljs-string">&quot;JSON marshaling failed: %s&quot;</span>, err)&#125;fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data)</code></pre></div><p>编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> titles []<span class="hljs-keyword">struct</span>&#123; Title <span class="hljs-type">string</span> &#125;<span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="hljs-literal">nil</span> &#123;    log.Fatalf(<span class="hljs-string">&quot;JSON unmarshaling failed: %s&quot;</span>, err)&#125;fmt.Println(titles) <span class="hljs-comment">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></code></pre></div><h1>文本和HTML模板</h1>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言圣经-程序结构-基础数据类型</title>
    <link href="/2022/10/10/Go/go-basic-2-3/"/>
    <url>/2022/10/10/Go/go-basic-2-3/</url>
    
    <content type="html"><![CDATA[<p>Go语言圣经-程序结构-基础数据类型</p><span id="more"></span><p>var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p><p>简短变量声明语句中必须至少要声明一个新的变量</p><p>如果用“var x int”声明语句声明一个x变量，那么&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是 <code>*int</code>，指针被称之为“指向int类型的指针”。</p><p>指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Echo4 prints its command-line arguments.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;flag&quot;</span>    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-keyword">var</span> n = flag.Bool(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;omit trailing newline&quot;</span>)<span class="hljs-keyword">var</span> sep = flag.String(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;separator&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    flag.Parse()    fmt.Print(strings.Join(flag.Args(), *sep))    <span class="hljs-keyword">if</span> !*n &#123;        fmt.Println()    &#125;&#125;</code></pre></div><p>程序中的 <code>sep</code>和 <code>n</code>变量分别是指向对应命令行标志参数变量的指针，因此必须用 <code>*sep</code>和 <code>*n</code>形式的指针语法间接引用它们。</p><p>另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 <code>*T</code>。</p><div class="code-wrapper"><pre><code class="hljs go">p := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)   <span class="hljs-comment">// p, *int 类型, 指向匿名的 int 变量</span>fmt.Println(*p) <span class="hljs-comment">// &quot;0&quot;</span>*p = <span class="hljs-number">2</span>          <span class="hljs-comment">// 设置 int 匿名变量的值为 2</span>fmt.Println(*p) <span class="hljs-comment">// &quot;2&quot;</span></code></pre></div><p>下面的两个newInt函数有着相同的行为：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">var</span> dummy <span class="hljs-type">int</span>    <span class="hljs-keyword">return</span> &amp;dummy&#125;</code></pre></div><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 类型名字 底层类型</code></pre></div><p>在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的</p><p>Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。</p><p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p><p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。</p><p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p><p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。每个函数有一个单一的rune类型的参数，然后返回一个布尔值。而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</p><p>将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)</p><p>如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数</p><p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加一。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span><span class="hljs-keyword">const</span> (    Sunday Weekday = <span class="hljs-literal">iota</span>    Monday    Tuesday    Wednesday    Thursday    Friday    Saturday)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言圣经-入门</title>
    <link href="/2022/10/09/Go/go-basic-1/"/>
    <url>/2022/10/09/Go/go-basic-1/</url>
    
    <content type="html"><![CDATA[<p>Go语言圣经-入门</p><span id="more"></span><h1>命令行参数</h1><p><code>os</code> 包以跨平台的方式，提供了一些与操作系统交互的函数和变量。程序的命令行参数可从 <code>os</code> 包的 <code>Args</code> 变量获取；<code>os</code> 包外部使用 <code>os.Args</code> 访问该变量。</p><p><code>os.Args</code> 的第一个元素：<code>os.Args[0]</code>，是命令本身的名字；其它的元素则是程序启动时传给它的参数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s, sep <span class="hljs-type">string</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(os.Args); i++ &#123;s += sep + os.Args[i]sep = <span class="hljs-string">&quot; &quot;</span>&#125;fmt.Println(s)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs tap">&gt; go run main.go<span class="hljs-number"> 4 </span>2<span class="hljs-number"> 5 </span>4 14<span class="hljs-number"> 2 </span>5<span class="hljs-number"> 4 </span>1</code></pre></div><p><code>for</code> 循环的另一种形式，在某种数据类型的区间（range）上遍历</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s, sep <span class="hljs-type">string</span><span class="hljs-keyword">for</span> _, j := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;s += sep + jsep = <span class="hljs-string">&quot; &quot;</span>&#125;fmt.Println(s)&#125;</code></pre></div><p>使用 <code>strings</code> 包的 <code>Join</code> 函数：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot; &quot;</span>))&#125;</code></pre></div><h1>查找重复的行</h1><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Dup1 prints the text of each line that appears more than</span><span class="hljs-comment">// once in the standard input, preceded by its count.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)input := bufio.NewScanner(os.Stdin)<span class="hljs-keyword">for</span> input.Scan() &#123;counts[input.Text()]++&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)&#125;&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">abc</span><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">abc</span><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">def</span><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">efd</span><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">efd</span>2       abc2       efd</code></pre></div><p>Printf的多种转换形式：</p><div class="code-wrapper"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">d</span></span>          十进制整数<span class="hljs-tag">%<span class="hljs-selector-tag">x</span></span>, %o, %b  十六进制，八进制，二进制整数。<span class="hljs-tag">%<span class="hljs-selector-tag">f</span></span>, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00<span class="hljs-tag">%<span class="hljs-selector-tag">t</span></span>          布尔：true或false<span class="hljs-tag">%<span class="hljs-selector-tag">c</span></span>          字符（rune） (Unicode码点)<span class="hljs-tag">%<span class="hljs-selector-tag">s</span></span>          字符串<span class="hljs-tag">%<span class="hljs-selector-tag">q</span></span>          带双引号的字符串&quot;abc&quot;或带单引号的字符&#x27;c&#x27;<span class="hljs-tag">%<span class="hljs-selector-tag">v</span></span>          变量的自然形式（natural format）<span class="hljs-tag">%<span class="hljs-selector-tag">T</span></span>          变量的类型<span class="hljs-tag">%</span>%          字面上的百分号标志（无操作数）</code></pre></div><p>以 <code>ln</code> 结尾的格式化函数，则遵循 <code>Println</code> 的方式，以跟 <code>%v</code> 差不多的方式格式化参数，并在最后添加一个换行符。</p><p>第二个版本，可以接收文件并判断重复行</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Dup2 prints the count and text of lines that appear more than once</span><span class="hljs-comment">// in the input.  It reads from stdin or from a list of named files.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bufio&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)files := os.Args[<span class="hljs-number">1</span>:]<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) == <span class="hljs-number">0</span> &#123;countLines(os.Stdin, counts)&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> files &#123;f, err := os.Open(arg)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup2: %v\n&quot;</span>, err)<span class="hljs-keyword">continue</span>&#125;countLines(f, counts)f.Close()&#125;&#125;<span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countLines</span><span class="hljs-params">(f *os.File, counts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;input := bufio.NewScanner(f)<span class="hljs-keyword">for</span> input.Scan() &#123;counts[input.Text()]++&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span>&#125;</code></pre></div><p><code>map</code> 是一个由 <code>make</code> 函数创建的数据结构的引用。<code>map</code> 作为参数传递给某函数时，该函数接收这个引用的一份拷贝（copy，或译为副本），被调用函数对 <code>map</code> 底层数据结构的任何修改，调用者函数都可以通过持有的 <code>map</code> 引用看到。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;data, err := os.ReadFile(filename)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup3: %v\n&quot;</span>, err)<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">for</span> _, line := <span class="hljs-keyword">range</span> strings.Split(<span class="hljs-type">string</span>(data), <span class="hljs-string">&quot;\n&quot;</span>) &#123;counts[line]++&#125;&#125;<span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)&#125;&#125;&#125;</code></pre></div><p>引入了 <code>ReadFile</code> 函数（来自于 <code>os</code>包），其读取指定文件的全部内容，<code>strings.Split</code> 函数把字符串分割成子串的切片。</p><h1>GIF动画</h1><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Lissajous generates GIF animations of random Lissajous figures.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;image&quot;</span><span class="hljs-string">&quot;image/color&quot;</span><span class="hljs-string">&quot;image/gif&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;math&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;<span class="hljs-keyword">const</span> (whiteIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// first color in palette</span>blackIndex = <span class="hljs-number">1</span> <span class="hljs-comment">// next color in palette</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// The sequence of images is deterministic unless we seed</span><span class="hljs-comment">// the pseudo-random number generator using the current time.</span><span class="hljs-comment">// Thanks to Randall McPherson for pointing out the omission.</span>rand.Seed(time.Now().UTC().UnixNano())lissajous(os.Stdout)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<span class="hljs-keyword">const</span> (cycles  = <span class="hljs-number">5</span>     <span class="hljs-comment">// number of complete x oscillator revolutions</span>res     = <span class="hljs-number">0.001</span> <span class="hljs-comment">// angular resolution</span>size    = <span class="hljs-number">100</span>   <span class="hljs-comment">// image canvas covers [-size..+size]</span>nframes = <span class="hljs-number">64</span>    <span class="hljs-comment">// number of animation frames</span>delay   = <span class="hljs-number">8</span>     <span class="hljs-comment">// delay between frames in 10ms units</span>)freq := rand.Float64() * <span class="hljs-number">3.0</span> <span class="hljs-comment">// relative frequency of y oscillator</span>anim := gif.GIF&#123;LoopCount: nframes&#125;phase := <span class="hljs-number">0.0</span> <span class="hljs-comment">// phase difference</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)img := image.NewPaletted(rect, palette)<span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;x := math.Sin(t)y := math.Sin(t*freq + phase)img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>),blackIndex)&#125;phase += <span class="hljs-number">0.1</span>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)&#125;gif.EncodeAll(out, &amp;anim) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring encoding errors</span>&#125;</code></pre></div><h1>获取URL</h1><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Fetch prints the content found at a URL.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;b, err := io.ReadAll(resp.Body)resp.Body.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)os.Exit(<span class="hljs-number">1</span>)&#125;fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, b)&#125;&#125;</code></pre></div><p>改进：</p><p>避免申请缓冲区、url参数没有 <code>http://</code> 前缀、打印出HTTP协议的状态码</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Fetch prints the content found at a URL.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<span class="hljs-keyword">if</span> !strings.HasPrefix(url, <span class="hljs-string">&quot;http://&quot;</span>) &#123;url = <span class="hljs-string">&quot;http://&quot;</span> + url&#125;resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;_, err = io.Copy(os.Stdout, resp.Body)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: reading %s: %v\n&quot;</span>, url, err)os.Exit(<span class="hljs-number">1</span>)&#125;fmt.Println(resp.Status)resp.Body.Close()&#125;&#125;</code></pre></div><h1>并发获取多个URL</h1><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Fetchall fetches URLs in parallel and reports their times and sizes.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;start := time.Now()ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<span class="hljs-keyword">go</span> fetch(url, ch) <span class="hljs-comment">// start a goroutine</span>&#125;<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;fmt.Println(&lt;-ch) <span class="hljs-comment">// receive from channel ch</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%.2fs elapsed\n&quot;</span>, time.Since(start).Seconds())&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;start := time.Now()resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;ch &lt;- fmt.Sprint(err) <span class="hljs-comment">// send to channel ch</span><span class="hljs-keyword">return</span>&#125;nbytes, err := io.Copy(io.Discard, resp.Body)resp.Body.Close() <span class="hljs-comment">// don&#x27;t leak resources</span><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;while reading %s: %v&quot;</span>, url, err)<span class="hljs-keyword">return</span>&#125;secs := time.Since(start).Seconds()ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%.2fs  %7d  %s&quot;</span>, secs, nbytes, url)&#125;</code></pre></div><p>goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。main函数本身也运行在一个goroutine中，而go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。</p><h1>Web服务</h1><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Server1 is a minimal &quot;echo&quot; server.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;log&quot;</span>    <span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler) <span class="hljs-comment">// each request calls handler</span>    log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))&#125;<span class="hljs-comment">// handler echoes the Path component of the request URL r.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;    fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)&#125;</code></pre></div><p>为访问的url添加某种状态。比如，下面这个版本输出了同样的内容，但是会对请求的次数进行计算</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Server2 is a minimal &quot;echo&quot; and counter server.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;sync&quot;</span>)<span class="hljs-keyword">var</span> mu sync.Mutex<span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)http.HandleFunc(<span class="hljs-string">&quot;/count&quot;</span>, counter)log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))&#125;<span class="hljs-comment">// handler echoes the Path component of the requested URL.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;mu.Lock()count++mu.Unlock()fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)&#125;<span class="hljs-comment">// counter echoes the number of calls so far.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;mu.Lock()fmt.Fprintf(w, <span class="hljs-string">&quot;Count %d\n&quot;</span>, count)mu.Unlock()&#125;</code></pre></div><p>handler函数会把请求的http头和请求的form数据都打印出来，这样可以使检查和调试这个服务更为方便</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// handler echoes the HTTP request.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;    fmt.Fprintf(w, <span class="hljs-string">&quot;%s %s %s\n&quot;</span>, r.Method, r.URL, r.Proto)    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Header &#123;        fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q] = %q\n&quot;</span>, k, v)    &#125;    fmt.Fprintf(w, <span class="hljs-string">&quot;Host = %q\n&quot;</span>, r.Host)    fmt.Fprintf(w, <span class="hljs-string">&quot;RemoteAddr = %q\n&quot;</span>, r.RemoteAddr)    <span class="hljs-keyword">if</span> err := r.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;        log.Print(err)    &#125;    <span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form &#123;        fmt.Fprintf(w, <span class="hljs-string">&quot;Form[%q] = %q\n&quot;</span>, k, v)    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第13讲 决策树与面向文档的机器学习</title>
    <link href="/2022/10/07/UCAS/information-retrieval/information-retrieval-13/"/>
    <url>/2022/10/07/UCAS/information-retrieval/information-retrieval-13/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第13讲 决策树与面向文档的机器学习</p><span id="more"></span><h1>第13讲 决策树与面向文档的机器学习</h1><p>面向文本分类的决策树</p><ul><li>树结构：内部节点由词项作为标记</li><li>分支标记：词项权重的“测试” (test)，或仅仅是出现/不出现</li><li>叶节点标记：类别</li><li>分类器<ul><li>分类器通过“测试”后的降序树对文档进行分类</li><li>然后将叶节点的标签分配给文档</li></ul></li><li>大多数决策树都是二叉树</li></ul><p>决策树的学习</p><p>学习一个序列的特征测试，典型的做法是由上到下的贪心搜索，每一步选择具有最高信息收益的未使用特征</p><p>叶节点标记：yes/no 类别标记，或连续值</p><p>如果有<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征，决策树的节点数量上限是<img src="https://math.now.sh?inline=2%5Ek" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（太大了，会有计算开支等方面的问题）</p><p><strong>我们可以通过在每个节点上递归选择最佳拆分特征，以贪心的方式创建树</strong></p><p>属性选择基本思想：（理想情况下）一个好的特征能够把所有样本划分成“全部正样本”和“全部负样本”两个子集</p><p>利用信息论：</p><p>信息熵（Entropy）：考虑每个节点的类分解</p><p>信息增益</p><p>对每个节点，我们选择使信息增益最大的特征f</p><p>数值特征 (例如tf-idf)：通常使用二元的切分 (f &lt; t), t怎样确定?</p><p>穷尽式（搜索）：评估观察值之间的每个分割点的信息增益。</p><ul><li>慢；通过优化计数方法可以稍微提高效率</li></ul><p>分箱（Discretize into bins）</p><ul><li>将所有的数值切分到k个箱中</li><li>（连续的数值）特征被离散化</li><li>分箱操作可以基于整个语料集的统计</li></ul><p>（树的构建）什么时候停止?</p><ul><li>当一个节点的所有样本都属于同一个类别</li><li>当树的深度d达到一个固定阈值</li><li>如果没有合适的属性可以拆分中区分具有统计意义的类（例如，使用卡方检验或Fisher精确检验），则停止构建。</li><li>最常用/最佳方法：使用单独的验证数据<ul><li>构建一个较大的树（可以给树的深度设定阈值）</li><li>自下而上的修剪未能（显著）改善验证数据分类性能的节点</li></ul></li></ul><h2 id="面向文本的决策树学习">面向文本的决策树学习</h2><p>宏平均：计算每个类别的性能指标，然后取平均值</p><p>微平均：收集所有类别的决策（分类）结果，计算列联表，评价</p><p>判别式 (discriminative) 分类方法: Logistic Regression (逻辑回归) 与 Support vector machines (支持向量机)</p><p>Ensemble 方法</p><p>随机森林 （Random Forests）</p><p>从原始数据集重复采样（bootstrap采样），在采样数据上构建K个树，p=特征数量</p><ul><li>获得K个大小为N的bootstrap采样，其中N是原始数据集大小</li><li>通过在每个节点的p个特征中随机选择m个，并选择最佳特征来扩展每个决策树。</li><li>m的典型取值： sqrt(p)</li><li>预测(Runtime)：汇总树的预测（最受欢迎的投票）以产生最终分类</li></ul><p>原则：我们希望在不同的学习器(learner)之间进行投票，因此我们不希望这些模型过于相似。这两个标准确保了各个树的多样性</p><p>优点：</p><ul><li>在实践中非常流行，有段时间是密集数据（dense data）上最流行的分类器（&lt;=几千个特征）</li><li>容易实现 (训练多个树).</li><li>容易并行化 (但并不意味着效率高)。适合用于 MapReduce.</li></ul><p>缺点：</p><ul><li>现在和一些新方法相比准确度并不高 – Gradient-boosted trees (特征少) 与 深度神经网络(视觉, 语音, 语言, …)通常更好</li><li>需要多次遍历数据 – 至少是树的最大深度 (虽然远小于boosted trees )</li><li>容易过拟合 – 需要权衡准确度（accuracy）与拟合度（fit）</li></ul><p>Boosted Decision Trees (BDT, 增强决策树)</p><ul><li>一个比随机森林（RF）提出更晚的算法</li><li>与独立训练树的RF不同，BDT的树通过增强(boosting)的方式依次(sequetially)训练树：<ul><li>每个树都在加权数据上训练，通过加权强调之前（训练）<br>的树错误标记的样本</li></ul></li><li>这两个方法都能够通过训练产生高质量模型</li><li>但是BDT通常都更适用于中等数量特征的数据集</li></ul><p>随机森林（RF） vs 增强树（BDT）</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第8章 信息论模型</title>
    <link href="/2022/10/05/UCAS/machine-learning/machine-learning-8/"/>
    <url>/2022/10/05/UCAS/machine-learning/machine-learning-8/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第8章 信息论模型</p><span id="more"></span><h1>第8章 信息论模型</h1><h2 id="熵、最大熵">熵、最大熵</h2><p>信息量（信息增益量）定义：<img src="https://math.now.sh?inline=I%5Cleft%28x_k%5Cright%29%3D%5Clog%20%5Cleft(%5Cfrac%7B1%7D%7Bp_k%7D%5Cright)%3D-%5Clog%20p_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=X%3D%5Cleft%5C%7Bx_k%20%5Cmid%20k%3D0%2C%20%5Cpm%201%2C%20%5Cldots%2C%20%5Cpm%20N%5Cright%5C%7D%2C%20%5Cquad%20p_k%3DP%5Cleft%28X%3Dx_k%5Cright%29%2C%20%5Cquad%200%20%5Cleq%20p_k%20%5Cleq%201%2C%20%5Cquad%20%5Csum_%7Bk%3D-N%7D%5EN%20p_k%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>信息量性质：概率越小的状态，信息量越大</p><p>信息熵定义：信息量在全部数值域上的概率平均值</p><ul><li>离散熵：<img src="https://math.now.sh?inline=H%28X%29%3DE%5BI(x)%5D%3D%5Csum_%7Bk%3D-N%7D%5E%7Bk%3DN%7D%20p_k%20I%5Cleft(x_k%5Cright)%3D-%5Csum_%7Bk%3D-N%7D%5E%7Bk%3DN%7D%20p_k%20%5Clog%20p_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>微分熵：<img src="https://math.now.sh?inline=h%28X%29%3D-%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%20p_x(x)%20%5Clog%20p_x(x)%20d%20x%3D-E%5Cleft%5B%5Clog%20p_x(x)%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（微分熵不是严格意义的信息熵）</li></ul><p>微分熵性质：平移不变、尺度变化，且可以是负值</p><p>当根据不完整的信息作为依据进行推断时，应该由满足分布限制条件的<strong>具有最大熵的概率分布</strong>推得。</p><p>最大微分熵问题：<img src="https://math.now.sh?inline=h%28X%29%3D-%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%20p_x(x)%20%5Clog%20p_x(x)%20d%20x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>已知均值和方差，高斯分布的微分熵最大</p><h2 id="互信息">互信息</h2><p>条件信息量：<img src="https://math.now.sh?inline=L%28x%20%5Cmid%20y%29%3D%5Clog%20%5Cfrac%7B1%7D%7Bp(x%20%5Cmid%20y)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>条件熵：</p><ul><li>给定<img src="https://math.now.sh?inline=y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=X" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件熵：<img src="https://math.now.sh?inline=H%28X%20%5Cmid%20y%29%3D%5Csum_x%20p(x%20%5Cmid%20y)%20%5Clog%20%5Cfrac%7B1%7D%7Bp(x%20%5Cmid%20y)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>给定<img src="https://math.now.sh?inline=Y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=X" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件熵：<img src="https://math.now.sh?inline=H%28X%20%5Cmid%20Y%29%3D%5Csum_y%20p(y)%20H(X%20%5Cmid%20y)%3D%5Csum_y%20p(y)%20%5Csum_x%20p(x%20%5Cmid%20y)%20%5Clog%20%5Cfrac%7B1%7D%7Bp(x%20%5Cmid%20y)%7D%3D%5Csum_y%20%5Csum_x%20p(x%2C%20y)%20%5Clog%20%5Cfrac%7B1%7D%7Bp(x%20%5Cmid%20y)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>联合熵：</p><ul><li>联合概率密度：<img src="https://math.now.sh?inline=p%28x%2C%20y%29%3Dp(x%20%5Cmid%20y)%20p(y)%3Dp(y%20%5Cmid%20x)%20p(x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>联合信息量：<img src="https://math.now.sh?inline=L%28x%2C%20y%29%3D%5Clog%20%5Cfrac%7B1%7D%7Bp(x%2C%20y)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>联合微分熵：<img src="https://math.now.sh?inline=H%28X%2C%20Y%29%3D%5Csum_y%20%5Csum_x%20p(x%2C%20y)%20%5Clog%20%5Cfrac%7B1%7D%7Bp(x%2C%20y)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>互信息：信息熵与条件熵的差：<img src="https://math.now.sh?inline=I%28X%20%3B%20Y%29%3D%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%20%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%20p_%7BX%2C%20Y%7D(x%2C%20y)%20%5Clog%20%5Cfrac%7Bp_%7BX%2C%20Y%7D(x%2C%20y)%7D%7Bp_X(x)%20p_Y(y)%7D%20d%20x%20d%20y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>互信息性质：非负性、对称性、不变性</p><p>相对熵是衡量两个分布的平均信息差异</p><p><img src="https://math.now.sh?inline=D_%7Bp_x%20%5C%7C_x%7D%3D%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%20p_x%28x%29%20%5Clog%20%5Cleft(%5Cfrac%7Bp_x(x)%7D%7Bq_x(x)%7D%5Cright)%20d%20x%3DE%5Cleft%5B%5Clog%20%5Cleft(%5Cfrac%7Bp_x(x)%7D%7Bq_x(x)%7D%5Cright)%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>相对熵和互信息之间的关系：<img src="https://math.now.sh?inline=I%28X%20%3B%20Y%29%3D%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%20%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%20p_%7Bx%2C%20y%7D(x%2C%20y)%20%5Clog%20%5Cleft(%5Cfrac%7Bp_%7Bx%2C%20y%7D(x%2C%20y)%7D%7Bp_x(x)%20p_y(y)%7D%5Cright)%20d%20x%20d%20y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="信息论优化模型">信息论优化模型</h2><p>最大熵模型：最大化 <img src="https://math.now.sh?inline=%5Cmathrm%7BH%7D%28%5Cmathrm%7BY%7D%20%5Cmid%20%5Cmathrm%7BX%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>, 求取类别后验概率分布 <img src="https://math.now.sh?inline=%5Cmathrm%7Bp%7D%28%5Cmathrm%7By%7D%20%5Cmid%20%5Cmathrm%7Bx%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>, 用于分类、预测等</p><p>最大互信息模型: 最大化 <img src="https://math.now.sh?inline=I%28Y%20%3B%20X%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>; 最大化 <img src="https://math.now.sh?inline=I%5Cleft%28Y_a%20%3B%20Y_b%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最小互信息模型：最小化 <img src="https://math.now.sh?inline=I%5Cleft%28Y_a%20%3B%20Y_b%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>; 最小化 <img src="https://math.now.sh?inline=I%5Cleft%28Y_l%2C%20Y_2%2C%20%5Cldots%20Y_m%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>, 独立分析</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础学习（微软教程）</title>
    <link href="/2022/10/03/Go/go-basic-ms/"/>
    <url>/2022/10/03/Go/go-basic-ms/</url>
    
    <content type="html"><![CDATA[<p>Go基础学习（微软教程）</p><span id="more"></span><h1>什么是 Go？</h1><p>Go 语言表现力强，且简单明了。 它在设计时考虑了惯用语言，这使程序员能够高效地编写高效且可靠的代码。 以 Go 语言编写的程序可以在 Unix 系统上运行，例如 Linux 和 macOS，还有 Windows。 Go 语言之所以值得注意，部分原因在于它独特的并发机制，使得编写可同时利用多个内核的程序非常容易。 它主要是一种强化静态类型的语言，这意味着变量类型在编译时是已知的。 不过，它确实具有一些动态类型化功能。</p><p>下面是 Go 编程语言的基本原理优势：</p><ul><li>Go 许可证是完全开放源代码的。</li><li>Go 程序编译为单独的二进制文件，这样更易于共享和分发。</li><li>交叉编译到各种平台和操作系统</li><li>Go 语言致力于使语言变得简单，并用更少的代码行执行更多操作。</li><li>并发是头等概念，使任何函数可以作为轻量级线程运行，而程序员只需少量工作。</li><li>Go 语言提供自动内存管理，包括垃圾回收。</li><li>编译和执行速度很快。</li><li>Go 语言需要使用所有代码，否则会引发错误。</li><li>有一种官方格式设置可帮助保持项目之间的一致性。</li><li>Go 语言具有大量全面标准库，并且可以在不使用第三方依赖项的情况下生成多个应用程序。</li><li>Go 保证语言与以前版本的后向兼容性。</li></ul><h1>安装Go</h1><p>如果不想在本地安装 Go，可以使用 <a href="https://play.golang.org/">Go Playground</a>。 Go Playground 是一款 Web 服务，可在浏览器中运行 Go 应用程序。</p><p>本地安装包<a href="https://go.dev/dl/">下载地址</a></p><div class="code-wrapper"><pre><code class="hljs bash">wget https://go.dev/dl/go1.19.1.linux-amd64.tar.gz // 版本号可能改变</code></pre></div><p>提取本地安装包</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> tar -C /usr/local -xzf go1.19.1.linux-amd64.tar.gz</code></pre></div><p>编辑配置文件，添加到环境变量：</p><div class="code-wrapper"><pre><code class="hljs bash">vim ~/.bashrc<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/go/bin<span class="hljs-built_in">source</span> ~/.bashrc</code></pre></div><p>确认是否已经安装好：</p><div class="code-wrapper"><pre><code class="hljs bash">go version</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">go</span> version go1.<span class="hljs-number">19</span>.<span class="hljs-number">1</span> linux/amd64</code></pre></div><h2 id="配置Go工作区">配置Go工作区</h2><p>Go 在组织项目文件方面与其他编程语言不同。 首先，Go 是在工作区的概念下工作的。 工作区就是应用程序源代码所在的位置。 所有 Go 项目共享同一个工作区。 不过，从版本 1.11 开始，Go 已开始更改此方法。 你尚且不必担心，因为我们将在下一个模块中介绍工作区。 现在，Go 工作区位于 $HOME/go，但如果需要，可以为所有项目设置其他位置。</p><p>若要将工作区设置为其他位置，可以使用 $GOPATH 环境变量。 在处理更复杂的项目时，此环境变量有助于避免将来出现问题。</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">GOPATH</span>=/mnt/d/Programming_Design/Go</code></pre></div><h2 id="Go-工作区文件夹">Go 工作区文件夹</h2><p>每个 Go 工作区都包含三个基本文件夹：</p><ul><li><em>bin</em> ：包含应用程序中的可执行文件。</li><li><em>src</em> ：包括位于工作站中的所有应用程序源代码。</li><li><em>pkg</em> ：包含可用库的已编译版本。 编译器可以链接这些库，而无需重新编译它们。</li></ul><p>例如，工作站文件夹结构树可能与下面的示例类似：</p><div class="code-wrapper"><pre><code class="hljs nix">bin<span class="hljs-symbol">/</span>    hello    coolapppkg<span class="hljs-symbol">/</span>    github.com<span class="hljs-operator">/</span>gorilla<span class="hljs-symbol">/</span>        mux.asrc<span class="hljs-symbol">/</span>    github.com<span class="hljs-operator">/</span>golang<span class="hljs-operator">/</span>example<span class="hljs-symbol">/</span>        .git<span class="hljs-symbol">/</span>    hello<span class="hljs-symbol">/</span>        hello.go</code></pre></div><h2 id="VSCode-Go-插件">VSCode Go 插件</h2><p>在安装插件之前要先更改go的源</p><div class="code-wrapper"><pre><code class="hljs bash">The <span class="hljs-string">&quot;gopls&quot;</span> <span class="hljs-built_in">command</span> is not available. Run <span class="hljs-string">&quot;go install -v golang.org/x/tools/gopls@latest&quot;</span> to install.</code></pre></div><p>然后点击上边的窗口的install All，即可完成插件的安装</p><h2 id="第一个Go应用">第一个Go应用</h2><p>文件夹组织形式：</p><p><a href="https://imgse.com/i/xQJIts"><img src="https://s1.ax1x.com/2022/10/03/xQJIts.png" alt="xQJIts.png"></a></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)&#125;</code></pre></div><p>运行：</p><div class="code-wrapper"><pre><code class="hljs bash">go run main.go</code></pre></div><div class="code-wrapper"><pre><code class="hljs erlang-repl">Hello World!</code></pre></div><p>只生成二进制文件但是不运行：</p><div class="code-wrapper"><pre><code class="hljs bash">go build main.go</code></pre></div><h3 id="代码解释">代码解释</h3><p>我们在 <code>package main</code> 语句中告诉 Go，我们将要创建的应用是一个可执行程序（可以运行的文件）。 我们的“Hello World!”应用是 <code>main</code> 包的一部分。</p><p>包是一组常用的源代码文件。 每个可执行应用都具有此第一行，即使项目或文件具有不同的名称。</p><p><code>import</code> 语句使你的程序可以访问其他包中的其他代码。 在本例中，fmt 为标准库包。</p><p>你需要此 <code>import</code> 语句，因为你将在此程序的稍后部分使用此包中的函数将消息打印到屏幕上。 可以在程序中包含你想要或需要的任意数量的 <code>import</code> 语句。 但是，Go 在这方面是惯用的。 <strong>如果导入包，但不使用包中的相应函数，应用将不会进行编译</strong>。 <strong>Visual Studio Code 的一大功能是，当你保存文件时，它会自动删除程序中未使用的导入</strong>。</p><p>VSCode 是自动帮助我们删除的，但是和Python什么的不一样，<strong>如果多了冗余的包程序是无法运行的</strong>。</p><div class="code-wrapper"><pre><code class="hljs vim"># <span class="hljs-keyword">command</span>-<span class="hljs-built_in">line</span>-arguments./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">4</span>:<span class="hljs-number">8</span>: imported <span class="hljs-built_in">and</span> not used: <span class="hljs-string">&quot;math&quot;</span></code></pre></div><p><code>func</code> 语句是用于声明函数的保留字。 第一个函数名为“main”，因为它是程序的起始点。 整个 <code>package main</code> 中只能有一个 <code>main()</code> 函数（在第一行中定义的那个）。 在 <code>main()</code> 函数中，你调用了 <code>fmt</code> 包中的 <code>Println</code> 函数。 你发送了你希望在屏幕上看到的文本消息。</p><h1>声明和使用变量</h1><h2 id="声明变量">声明变量</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> firstName <span class="hljs-type">string</span>            <span class="hljs-comment">// 声明单一变量</span><span class="hljs-keyword">var</span> secondName, lastName <span class="hljs-type">string</span> <span class="hljs-comment">// 如果多个变量的类型相同，可以用逗号分隔一起声明多个变量</span><span class="hljs-keyword">var</span> age <span class="hljs-type">int</span><span class="hljs-comment">// 也可以在一个括号内批量声明变量</span><span class="hljs-keyword">var</span> (thirdName, fourthName <span class="hljs-type">string</span>secondage             <span class="hljs-type">int</span>)</code></pre></div><p>（VSCode会自动进行格式化，完全不用担心格式的问题）</p><h2 id="初始化变量">初始化变量</h2><p>可以在声明的时候直接对变量进行初始化，会自动对变量的类型进行推断，不用显式指定类型</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (    firstName <span class="hljs-type">string</span> = <span class="hljs-string">&quot;John&quot;</span>    lastName  <span class="hljs-type">string</span> = <span class="hljs-string">&quot;Doe&quot;</span>    age       <span class="hljs-type">int</span>    = <span class="hljs-number">32</span>)</code></pre></div><p>等价于下面的写法：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (    firstName, lastName, age = <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>, <span class="hljs-number">32</span>)</code></pre></div><h2 id="在main函数内部声明-初始化（更加常用）">在main函数内部声明+初始化（更加常用）</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;firstName, lastName := <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>age := <span class="hljs-number">32</span>fmt.Println(firstName, lastName, age)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">John</span> Doe <span class="hljs-number">32</span></code></pre></div><p>请注意，在定义变量名称后，需要在此处加入一个冒号等于号 (<code>:=</code>) 和相应的值。 使用冒号等于号时， <em>要声明的变量必须是新变量</em> 。 如果使用冒号等于号并已经声明该变量，将不会对程序进行编译。</p><h2 id="声明常量">声明常量</h2><p>用于声明常量的关键字是 <code>const</code></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> HTTPStatusOK = <span class="hljs-number">200</span><span class="hljs-keyword">const</span> (StatusOK              = <span class="hljs-number">0</span>StatusConnectionReset = <span class="hljs-number">1</span>StatusOtherError      = <span class="hljs-number">2</span>)</code></pre></div><p>常量和变量之间既有相似之处，也有一些重要差异。 例如，你可以在不使用常量的情况下声明常量。 你不会收到错误消息。 不能使用冒号等于号来声明常量。 如果采用这种方式，Go 会发出警告。</p><p>在 Go 中，当你（在函数内部）声明一个变量但不使用它时，Go 会抛出错误，而不是像某些其他编程语言一样抛出警告。</p><h1>基本数据类型</h1><h2 id="整数数字">整数数字</h2><p>一般来说，定义整数类型的关键字是 <code>int</code>。 但 Go 还提供了 <code>int8</code>、<code>int16</code>、<code>int32</code> 和 <code>int64</code> 类型，其大小分别为 8、16、32 或 64 位的整数。 使用 32 位操作系统时，如果只是使用 <code>int</code>，则大小通常为 32 位。 在 64 位系统上，<code>int</code> 大小通常为 64 位。 但是，此行为可能因计算机而不同。 可以使用 <code>uint</code>。 但是，只有在出于某种原因需要将值表示为无符号数字的情况下，才使用此类型。 此外，Go 还提供 <code>uint8</code>、<code>uint16</code>、<code>uint32</code> 和 <code>uint64</code> 类型。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> integer8 <span class="hljs-type">int8</span> = <span class="hljs-number">127</span><span class="hljs-keyword">var</span> integer16 <span class="hljs-type">int16</span> = <span class="hljs-number">32767</span><span class="hljs-keyword">var</span> integer32 <span class="hljs-type">int32</span> = <span class="hljs-number">2147483647</span><span class="hljs-keyword">var</span> integer64 <span class="hljs-type">int64</span> = <span class="hljs-number">9223372036854775807</span></code></pre></div><p>不能进行隐式转换，如果两个变量的类型不同，需要进行强制转换，否则编译不能通过。</p><h2 id="浮点数字">浮点数字</h2><p>Go 提供两种浮点数大小的数据类型：<code>float32</code> 和 <code>float64</code>。 如果需要存储较大的数字，则可以使用这些类型，这些类型无法适应前面提到的任何一个整数类型。 这两种类型的区别是它们可以容纳的最大位数。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> <span class="hljs-type">float32</span> <span class="hljs-type">float32</span> = <span class="hljs-number">2147483647</span><span class="hljs-keyword">var</span> <span class="hljs-type">float64</span> <span class="hljs-type">float64</span> = <span class="hljs-number">9223372036854775807</span>fmt.Println(<span class="hljs-type">float32</span>, <span class="hljs-type">float64</span>)</code></pre></div><p>可以使用 <code>math</code> 包中提供的 <code>math.MaxFloat32</code> 和 <code>math.MaxFloat64</code> 常量来查找这两种类型的限制。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(math.MaxFloat32, math.MaxFloat64)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">4028234663852886</span>e+<span class="hljs-number">38</span> <span class="hljs-number">1</span>.<span class="hljs-number">7976931348623157</span>e+<span class="hljs-number">308</span></code></pre></div><h2 id="布尔型">布尔型</h2><p>布尔类型仅可能有两个值：<code>true</code> 和 <code>false</code>。 你可以使用关键字 <code>bool</code> 声明布尔类型。 Go 不同于其他编程语言，在 Go 中，你不能将布尔类型隐式转换为 0 或 1。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> featureFlag <span class="hljs-type">bool</span> = <span class="hljs-literal">true</span></code></pre></div><h2 id="字符串">字符串</h2><p>最后，让我们看一下编程语言中最常见的数据类型：string。 在 Go 中，关键字 <code>string</code> 用于表示字符串数据类型。 若要初始化字符串变量，你需要在双引号（<code>&quot;</code>）中定义值。 单引号（<code>'</code>）用于单个字符（以及 runes，正如我们在上一节所述）。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> firstName <span class="hljs-type">string</span> = <span class="hljs-string">&quot;John&quot;</span>lastName := <span class="hljs-string">&quot;Doe&quot;</span>fmt.Println(firstName, lastName)</code></pre></div><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">John Doe</span></code></pre></div><h2 id="默认值">默认值</h2><p>到目前为止，几乎每次声明变量时，都使用值对其进行了初始化。 但与在其他编程语言中不同的是，在 Go 中，如果你不对变量初始化，所有数据类型都有默认值。 此功能非常方便，因为在使用之前，你无需检查变量是否已初始化。</p><p>下面列出了我们目前浏览过类型的几个默认值：</p><ul><li><code>int</code> 类型的 <code>0</code>（及其所有子类型，如 <code>int64</code>）</li><li><code>float32</code> 和 <code>float64</code> 类型的 <code>+0.000000e+000</code></li><li><code>bool</code> 类型的 <code>false</code></li><li><code>string</code> 类型的空值</li></ul><h2 id="类型转换">类型转换</h2><p>Go 中隐式强制转换不起作用。 接下来，需要显式强制转换。 Go 提供了将一种数据类型转换为另一种数据类型的一些本机方法。</p><p>一种方法是对每个类型使用内置函数，如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> integer16 <span class="hljs-type">int16</span> = <span class="hljs-number">127</span><span class="hljs-keyword">var</span> integer32 <span class="hljs-type">int32</span> = <span class="hljs-number">32767</span>fmt.Println(<span class="hljs-type">int32</span>(integer16) + integer32)</code></pre></div><p>Go 的另一种转换方法是使用 <a href="https://golang.org/pkg/strconv/">strconv 包</a>。 将 <code>string</code> 与 <code>int</code></p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;i, _ := strconv.Atoi(<span class="hljs-string">&quot;-42&quot;</span>)s := strconv.Itoa(<span class="hljs-number">-42</span>)fmt.Println(i, s)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit"><span class="hljs-string">-42</span> <span class="hljs-string">-42</span></code></pre></div><p>有一个下划线 (<code>_</code>) 用作变量的名称。 在 Go 中（或Python中），这意味着我们不会使用该变量的值，而是要将其忽略。</p><h1>创建函数</h1><p>在 Go 中，函数允许你将一组可以从应用程序的其他部分调用的语句组合在一起。 你可以使用函数来组织代码并使其更易于阅读，而不是创建包含许多语句的程序。 更具可读性的代码也更易于维护。</p><p>与之交互的函数是 <code>main()</code> 函数。 Go 中的所有可执行程序都具有此函数，因为它是程序的起点。 你的程序中只能有一个 <code>main()</code> 函数。</p><h2 id="命令行参数">命令行参数</h2><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;number1, _ := strconv.Atoi(os.Args[<span class="hljs-number">1</span>])number2, _ := strconv.Atoi(os.Args[<span class="hljs-number">2</span>])fmt.Println(<span class="hljs-string">&quot;Sum:&quot;</span>, number1+number2)&#125;</code></pre></div><p>os.Args 变量包含传递给程序的每个命令行参数。 由于这些值的类型为 string，因此需要将它们转换为 int 以进行求和。</p><div class="code-wrapper"><pre><code class="hljs go">&gt; <span class="hljs-keyword">go</span> run main.<span class="hljs-keyword">go</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span>Sum: <span class="hljs-number">8</span></code></pre></div><h2 id="自定义函数">自定义函数</h2><p>使用 <code>func</code> 关键字来定义函数，然后为其指定名称。 在命名后，指定函数的参数列表。 你可以指定零个或多个参数。 你还可以定义函数的返回类型，该函数也可以是零个或多个。 （我们将在下一节中讨论如何返回多个值）。在定义所有这些值之后，你可以编写函数的正文内容。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sum := sum(os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>])fmt.Println(<span class="hljs-string">&quot;Sum:&quot;</span>, sum)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(number1 <span class="hljs-type">string</span>, number2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;int1, _ := strconv.Atoi(number1)int2, _ := strconv.Atoi(number2)<span class="hljs-keyword">return</span> int1 + int2&#125;</code></pre></div><p>此代码创建一个名为 <code>sum</code> 的函数，该函数采用两个 <code>string</code> 参数，并将它们强制转换为 <code>int</code>，然后返回求和所得的结果。 定义返回类型时，函数需要返回该类型的值。</p><p>在 Go 中，你还可以为函数的返回值设置名称，将其当作一个变量。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(number1 <span class="hljs-type">string</span>, number2 <span class="hljs-type">string</span>)</span></span> (result <span class="hljs-type">int</span>) &#123;int1, _ := strconv.Atoi(number1)int2, _ := strconv.Atoi(number2)result = int1 + int2<span class="hljs-keyword">return</span>&#125;</code></pre></div><h3 id="返回多个值">返回多个值</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sum, mul := calc(os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>])fmt.Println(<span class="hljs-string">&quot;Sum:&quot;</span>, sum)fmt.Println(<span class="hljs-string">&quot;Mul:&quot;</span>, mul)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(number1 <span class="hljs-type">string</span>, number2 <span class="hljs-type">string</span>)</span></span> (sum <span class="hljs-type">int</span>, mul <span class="hljs-type">int</span>) &#123;int1, _ := strconv.Atoi(number1)int2, _ := strconv.Atoi(number2)sum = int1 + int2mul = int1 * int2<span class="hljs-keyword">return</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-punctuation">&gt;</span> <span class="hljs-string">go run main.go 3 5</span><span class="hljs-attribute">Sum</span><span class="hljs-punctuation">:</span> <span class="hljs-string">8</span><span class="hljs-attribute">Mul</span><span class="hljs-punctuation">:</span> <span class="hljs-string">15</span></code></pre></div><h2 id="更改函数参数值（指针）">更改函数参数值（指针）</h2><p>将值传递给函数时，该函数中的每个更改都不会影响调用方。 Go 是“按值传递”编程语言。 每次向函数传递值时，Go 都会使用该值并创建本地副本（内存中的新变量）。 在函数中对该变量所做的更改都不会影响你向函数发送的更改。</p><p><em>指针</em>是包含另一个变量的内存地址的变量。 当你发送指向某个函数的指针时，不会传递值，而是传递地址内存。 因此，对该变量所做的每个更改都会影响调用方。</p><p>在 Go 中，有两个运算符可用于处理指针：</p><ul><li><code>&amp;</code> 运算符使用其后对象的地址。</li><li><code>*</code> 运算符取消引用指针。 也就是说，你可以前往指针中包含的地址访问其中的对象。</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;firstName := <span class="hljs-string">&quot;John&quot;</span>updateName(&amp;firstName)fmt.Println(firstName)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateName</span><span class="hljs-params">(name *<span class="hljs-type">string</span>)</span></span> &#123;*name = <span class="hljs-string">&quot;David&quot;</span>&#125;</code></pre></div><p>首先要做的就是修改函数的签名，以指明你要接收指针。 为此，请将参数类型从 <code>string</code> 更改为 <code>*string</code>。 （后者仍是字符串，但现在它是指向字符串 的 指针。）然后，将新值分配给该变量时，需要在该变量的左侧添加星号 (<code>*</code>) 以暂停该变量的值。 调用 <code>updateName</code> 函数时，系统不会发送值，而是发送变量的内存地址。 这就是前面的代码在变量左侧带有 <code>&amp;</code> 符号的原因。</p><h1>了解包</h1><p>Go 包与其他编程语言中的库或模块类似。 你可以打包代码，并在其他位置重复使用它。 包的源代码可以分布在多个 <code>.go</code> 文件中。 到目前为止，我们已编写 <code>main</code> 包，并对其他本地包进行了一些引用。</p><h2 id="main-包">main 包</h2><p>你可能注意到，在 Go 中，甚至最直接的程序都是包的一部分。 通常情况下，默认包是 <code>main</code> 包，即目前为止一直使用的包。 如果程序是 <code>main</code> 包的一部分，Go 会生成二进制文件。 运行该文件时，它将调用 <code>main()</code> 函数。</p><p>换句话说，当你使用 <code>main</code> 包时，程序将生成独立的可执行文件。 但当程序非是 <code>main</code> 包的一部分时，Go 不会生成二进制文件。 它生成包存档文件（扩展名为“.a”的文件）。</p><p>在 Go 中，包名称需遵循约定。 包使用其导入路径的最后一部分作为名称。 例如，Go 标准库包含名为 <code>math/cmplx</code> 的包，该包提供用于处理复数的有用代码。 此包的导入路径为 <code>math/cmplx</code>，导入包的方式如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math/cmplx&quot;</span></code></pre></div><h2 id="创建包">创建包</h2><p>在名为 <code>calculator</code> 的目录中 创建名为 <code>sum.go</code> 的文件。 树目录应如下列目录所示：</p><p><a href="https://imgse.com/i/xQUdgI"><img src="https://s1.ax1x.com/2022/10/03/xQUdgI.png" alt="xQUdgI.png"></a></p><p>用包的名称初始化 <code>sum.go</code> 文件：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> calculator</code></pre></div><p>你现在可以开始编写包的函数和变量。 不同于其他编程语言，Go 不会提供 <code>public</code> 或 <code>private</code> 关键字，以指示是否可以从包的内外部调用变量或函数。 但 Go 须遵循以下两个简单规则：</p><ul><li>如需将某些内容设为专用内容，请以小写字母开始。</li><li>如需将某些内容设为公共内容，请以大写字母开始。</li></ul><p>接下来，让我们将以下代码添加到我们要创建的计算器包：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> calculator<span class="hljs-keyword">var</span> logMessage = <span class="hljs-string">&quot;[LOG]&quot;</span><span class="hljs-comment">// Version of the calculator</span><span class="hljs-keyword">var</span> Version = <span class="hljs-string">&quot;1.0&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">internalSum</span><span class="hljs-params">(number <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> number - <span class="hljs-number">1</span>&#125;<span class="hljs-comment">// Sum two integer numbers</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(number1, number2 <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;    <span class="hljs-keyword">return</span> number1 + number2&#125;</code></pre></div><p>让我们看一下该代码中的一些事项：</p><ul><li>只能从包内调用 <code>logMessage</code> 变量。</li><li>可以从任何位置访问 <code>Version</code> 变量。 建议你添加注释来描述此变量的用途。 （此描述适用于包的任何用户。）</li><li>只能从包内调用 <code>internalSum</code> 函数。</li><li>可以从任何位置访问 <code>Sum</code> 函数。 建议你添加注释来描述此函数的用途。</li></ul><p>若要确认一切正常，可在 <code>calculator</code> 目录中运行 <code>go build</code> 命令。 如果执行此操作，请注意系统不会生成可执行的二进制文件。</p><h2 id="创建模块">创建模块</h2><p>你已将计算器功能放入包中。 现在可以将包放到模块中。 Go 模块通常包含可提供相关功能的包。 包的模块还指定了 Go 运行你组合在一起的代码所需的上下文。 此上下文信息包括编写代码时所用的 Go 版本。</p><p>此外，模块还有助于其他开发人员引用代码的特定版本，并更轻松地处理依赖项。 另一个优点是，我们的程序源代码无需严格存在于 <code>$GOPATH/src</code> 目录中。 如果释放该限制，则可以更方便地在其他项目中同时使用不同包版本。</p><p><strong>（下面与教程不同，自己探索出了一个可用不报错的方法）</strong></p><p>VSCode GOPATH设置：<code>&quot;go.gopath&quot;: &quot;/mnt/d/Programming_Design/Go&quot;</code></p><p>首先设置 <code>go env -w GO111MODULE=on</code></p><p>如果 <code>helloworld</code>要引用 <code>calculator</code>，则文件夹的组织形式如下：</p><p><a href="https://imgse.com/i/xlDdl4"><img src="https://s1.ax1x.com/2022/10/05/xlDdl4.png" alt="xlDdl4.png"></a></p><p>在 <code>$GOPATH/src/calculator</code>创建 <code>go.mod</code>文件，其中文件第一行与文件夹同名</p><div class="code-wrapper"><pre><code class="hljs go">module calculator<span class="hljs-keyword">go</span> <span class="hljs-number">1.19</span></code></pre></div><p>在 <code>$GOPATH/src/helloworld</code>创建 <code>go.mod</code>文件，其中文件第一行与文件夹同名，下面要写好版本号和包的路径</p><div class="code-wrapper"><pre><code class="hljs go">module helloworld<span class="hljs-keyword">go</span> <span class="hljs-number">1.19</span>require <span class="hljs-string">&quot;calculator&quot;</span> v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>replace <span class="hljs-string">&quot;calculator&quot;</span> =&gt; <span class="hljs-string">&quot;../calculator&quot;</span></code></pre></div><p>然后可以导入这个包并运行主文件</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;calculator&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;total := calculator.Sum(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)fmt.Println(total)fmt.Println(<span class="hljs-string">&quot;Version: &quot;</span>, calculator.Version)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">8</span><span class="hljs-attribute">Version</span>:  <span class="hljs-number">1</span>.<span class="hljs-number">0</span></code></pre></div><h2 id="引用外部（第三方）包">引用外部（第三方）包</h2><p>有时，程序需要引用其他开发人员编写的包。</p><p>测试后不是很明白，基本上是在主文件和 <code>.mod</code>文件中写入包的名称和版本即可。然后根据控制台的输出将包安装好即可使用</p><p><code>main.go</code>：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;calculator&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;rsc.io/quote&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;total := calculator.Sum(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)fmt.Println(total)fmt.Println(<span class="hljs-string">&quot;Version: &quot;</span>, calculator.Version)fmt.Println(quote.Hello())&#125;</code></pre></div><p><code>go.mod</code>：</p><div class="code-wrapper"><pre><code class="hljs go">module helloworld<span class="hljs-keyword">go</span> <span class="hljs-number">1.19</span>require (calculator v1<span class="hljs-number">.0</span><span class="hljs-number">.0</span>rsc.io/quote v1<span class="hljs-number">.5</span><span class="hljs-number">.2</span>)require (golang.org/x/text v0<span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-number">-20170915032832</span><span class="hljs-number">-14</span>c0d48ead0c <span class="hljs-comment">// indirect</span>rsc.io/sampler v1<span class="hljs-number">.3</span><span class="hljs-number">.0</span> <span class="hljs-comment">// indirect</span>)replace calculator =&gt; ../calculator</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">8</span><span class="hljs-attribute">Version</span>:  <span class="hljs-number">1</span>.<span class="hljs-number">0</span><span class="hljs-attribute">Ahoy</span>, world!</code></pre></div><h1>使用控制流</h1><h2 id="if-语句的语法">if 语句的语法</h2><p>与其他编程语言不同的是，在 Go 中，你不需要在条件中使用括号。 <code>else</code> 子句可选。 但是，大括号仍然是必需的。 此外，为了减少行，Go 不支持<a href="http://en.wikipedia.org/wiki/%3F:">三元 <code>if</code> 语句</a>，因此每次都需要编写完整的 <code>if</code> 语句。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">givemeanumber</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> num := givemeanumber(); num &lt; <span class="hljs-number">0</span> &#123;fmt.Println(num, <span class="hljs-string">&quot;is negative&quot;</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">10</span> &#123;fmt.Println(num, <span class="hljs-string">&quot;has only one digit&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(num, <span class="hljs-string">&quot;has multiple digits&quot;</span>)&#125;&#125;</code></pre></div><p>其中，有一个在 Go 中常见的约定进行高效编程的方式 <code>if num := givemeanumber(); num &lt; 0</code>，同时接收函数的返回值，但是不重复进行接收，然后使用到if语句中进行判断。当然这个 <code>num</code>变量在 <code>if</code>的外部是无法使用的。</p><h2 id="使用-switch-语句控制流">使用 switch 语句控制流</h2><p>像其他编程语言一样，Go 支持 <code>switch</code> 语句。 可以使用 <code>switch</code> 语句来避免链接多个 <code>if</code> 语句。 使用 <code>switch</code> 语句，就不需维护和读取包含多个 <code>if</code> 语句的代码。 这些语句还可以让复杂的条件更易于构造。 请参阅以下部分的 <code>switch</code> 语句。</p><p>普通的switch语句：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sec := time.Now().Unix()rand.Seed(sec)i := rand.Int31n(<span class="hljs-number">10</span>)<span class="hljs-keyword">switch</span> i &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:fmt.Print(<span class="hljs-string">&quot;zero...&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:fmt.Print(<span class="hljs-string">&quot;one...&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:fmt.Print(<span class="hljs-string">&quot;two...&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Print(<span class="hljs-string">&quot;no match...&quot;</span>)&#125;fmt.Println(<span class="hljs-string">&quot;ok&quot;</span>)&#125;</code></pre></div><p>有时，多个表达式仅与一个 <code>case</code> 语句匹配。 在 Go 中，如果希望 <code>case</code> 语句包含多个表达式，请使用逗号 (<code>,</code>) 来分隔表达式。 此方法可避免代码重复。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">location</span><span class="hljs-params">(city <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<span class="hljs-keyword">var</span> region <span class="hljs-type">string</span><span class="hljs-keyword">var</span> continent <span class="hljs-type">string</span><span class="hljs-keyword">switch</span> city &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Delhi&quot;</span>, <span class="hljs-string">&quot;Hyderabad&quot;</span>, <span class="hljs-string">&quot;Mumbai&quot;</span>, <span class="hljs-string">&quot;Chennai&quot;</span>, <span class="hljs-string">&quot;Kochi&quot;</span>:region, continent = <span class="hljs-string">&quot;India&quot;</span>, <span class="hljs-string">&quot;Asia&quot;</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Lafayette&quot;</span>, <span class="hljs-string">&quot;Louisville&quot;</span>, <span class="hljs-string">&quot;Boulder&quot;</span>:region, continent = <span class="hljs-string">&quot;Colorado&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Irvine&quot;</span>, <span class="hljs-string">&quot;Los Angeles&quot;</span>, <span class="hljs-string">&quot;San Diego&quot;</span>:region, continent = <span class="hljs-string">&quot;California&quot;</span>, <span class="hljs-string">&quot;USA&quot;</span><span class="hljs-keyword">default</span>:region, continent = <span class="hljs-string">&quot;Unknown&quot;</span>, <span class="hljs-string">&quot;Unknown&quot;</span>&#125;<span class="hljs-keyword">return</span> region, continent&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;region, continent := location(<span class="hljs-string">&quot;Irvine&quot;</span>)fmt.Printf(<span class="hljs-string">&quot;John works in %s, %s\n&quot;</span>, region, continent)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-keyword">John </span>works in California, USA</code></pre></div><p>在 <code>case</code> 语句的表达式中包含的值对应于 <code>switch</code> 语句验证的变量的数据类型。</p><h3 id="调用函数">调用函数</h3><p><code>switch</code> 还可以调用函数。 在该函数中，可以针对可能的返回值编写 <code>case</code> 语句。</p><p>第一种是在switch上调用函数，对返回值进行判断</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> time.Now().Weekday().String() &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Monday&quot;</span>, <span class="hljs-string">&quot;Tuesday&quot;</span>, <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Thursday&quot;</span>, <span class="hljs-string">&quot;Friday&quot;</span>:fmt.Println(<span class="hljs-string">&quot;It&#x27;s time to learn some Go.&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;It&#x27;s weekend, time to rest!&quot;</span>)&#125;fmt.Println(time.Now().Weekday().String())&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs applescript">It&#x27;s <span class="hljs-built_in">time</span> <span class="hljs-keyword">to</span> learn <span class="hljs-keyword">some</span> Go.Wednesday</code></pre></div><p>第二种是在case上调用函数</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;regexp&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> email = regexp.MustCompile(<span class="hljs-string">`^[^@]+@[^@.]+\.[^@.]+`</span>)<span class="hljs-keyword">var</span> phone = regexp.MustCompile(<span class="hljs-string">`^[(]?[0-9][0-9][0-9][). \-]*[0-9][0-9][0-9][.\-]?[0-9][0-9][0-9][0-9]`</span>)contact := <span class="hljs-string">&quot;foo@bar.com&quot;</span><span class="hljs-keyword">switch</span> &#123;<span class="hljs-keyword">case</span> email.MatchString(contact):fmt.Println(contact, <span class="hljs-string">&quot;is an email&quot;</span>)<span class="hljs-keyword">case</span> phone.MatchString(contact):fmt.Println(contact, <span class="hljs-string">&quot;is a phone number&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Println(contact, <span class="hljs-string">&quot;is not recognized&quot;</span>)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-symbol">foo@</span>bar.com <span class="hljs-keyword">is</span> an email</code></pre></div><p>上面的 <code>switch</code> 语句中省略了条件，就像在 <code>if</code> 语句中那样。 此模式类似于比较 <code>true</code> 值，就像强制 <code>switch</code> 语句一直运行一样。</p><p><strong>一个条件 <code>switch</code> 块比一长串的 <code>if</code> 和 <code>else if</code> 语句更易于维护。</strong></p><h3 id="使逻辑进入到下一个-case">使逻辑进入到下一个 case</h3><p>在某些编程语言中，你会在每个 <code>case</code> 语句末尾写一个 <code>break</code> 关键字。 但在 Go 中，当逻辑进入某个 case 时，它会退出 <code>switch</code> 块，除非你显式停止它。 若要使逻辑进入到下一个紧邻的 case，请使用 <code>fallthrough</code> 关键字。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> num := <span class="hljs-number">15</span>; &#123;<span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">50</span>:fmt.Printf(<span class="hljs-string">&quot;%d is less than 50\n&quot;</span>, num)<span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">case</span> num &gt; <span class="hljs-number">100</span>:fmt.Printf(<span class="hljs-string">&quot;%d is greater than 100\n&quot;</span>, num)<span class="hljs-keyword">fallthrough</span><span class="hljs-keyword">case</span> num &lt; <span class="hljs-number">200</span>:fmt.Printf(<span class="hljs-string">&quot;%d is less than 200\n&quot;</span>, num)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">15 </span>is less than <span class="hljs-number">50</span><span class="hljs-symbol">15 </span>is greater than <span class="hljs-number">100</span><span class="hljs-symbol">15 </span>is less than <span class="hljs-number">200</span></code></pre></div><p>请注意，由于 <code>num</code> 为 15（小于 50），因此它与第一个 case 匹配。 但是，<code>num</code> 不大于 100。 由于第一个 <code>case</code> 语句包含 <code>fallthrough</code> 关键字，因此逻辑会立即转到下一个 <code>case</code> 语句，而不会对该 case 进行验证。 因此，在使用 <code>fallthrough</code> 关键字时必须谨慎。 该代码产生的行为可能不是你想要的。</p><h2 id="for-表达式">for 表达式</h2><p>另一个常用控制流是循环。 Go 只使用一个循环构造，即 <code>for</code> 循环。 但是，你可以通过多种方式表示循环。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sum := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; i++ &#123;sum += i&#125;fmt.Println(<span class="hljs-string">&quot;sum of 1..100 is&quot;</span>, sum)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">sum</span> of <span class="hljs-number">1</span>..<span class="hljs-number">100</span> is <span class="hljs-number">5050</span></code></pre></div><h3 id="空预处理语句和后处理语句">空预处理语句和后处理语句</h3><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> num <span class="hljs-type">int64</span>rand.Seed(time.Now().Unix())<span class="hljs-keyword">for</span> num != <span class="hljs-number">5</span> &#123;num = rand.Int63n(<span class="hljs-number">15</span>)fmt.Println(num)&#125;&#125;</code></pre></div><p>只要 <code>num</code> 变量保存的值与 <code>5</code> 不同，程序就会输出一个随机数。</p><h3 id="无限循环和-break-语句">无限循环和 break 语句</h3><p>可以在 Go 中编写的另一种循环模式是无限循环。 在这种情况下，你不编写条件表达式，也不编写预处理语句或后处理语句， 而是采取退出循环的方式进行编写。 否则，逻辑永远都不会退出。 若要使逻辑退出循环，请使用 <code>break</code> 关键字。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> num <span class="hljs-type">int32</span>sec := time.Now().Unix()rand.Seed(sec)<span class="hljs-keyword">for</span> &#123;fmt.Print(<span class="hljs-string">&quot;Writing inside the loop...&quot;</span>)<span class="hljs-keyword">if</span> num = rand.Int31n(<span class="hljs-number">10</span>); num == <span class="hljs-number">5</span> &#123;fmt.Println(<span class="hljs-string">&quot;finish!&quot;</span>)<span class="hljs-keyword">break</span>&#125;fmt.Println(num)&#125;&#125;</code></pre></div><p>在 Go 中，可以使用 <code>continue</code> 关键字跳过循环的当前迭代。 例如，可以使用此关键字在循环继续之前运行验证。 也可以在编写无限循环并需要等待资源变得可用时使用它。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;sum := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> num := <span class="hljs-number">1</span>; num &lt;= <span class="hljs-number">100</span>; num++ &#123;<span class="hljs-keyword">if</span> num%<span class="hljs-number">5</span> == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">continue</span>&#125;sum += num&#125;fmt.Println(<span class="hljs-string">&quot;The sum of 1 to 100, but excluding numbers divisible by 5, is&quot;</span>, sum)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> sum of <span class="hljs-number">1</span> to <span class="hljs-number">100</span>, but excluding numbers divisible by <span class="hljs-number">5</span>, is <span class="hljs-number">4000</span></code></pre></div><h2 id="使用-defer、panic-和-recover-函数进行控制">使用 defer、panic 和 recover 函数进行控制</h2><h3 id="defer-函数">defer 函数</h3><p>在 Go 中，<code>defer</code> 语句会推迟函数（包括任何参数）的运行，直到包含 <code>defer</code> 语句的函数完成。 通常情况下，当你想要避免忘记任务（例如关闭文件或运行清理进程）时，可以推迟某个函数的运行。</p><p>可以根据需要推迟任意多个函数。 <code>defer</code> 语句按逆序运行，先运行最后一个，最后运行第一个。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span>; i++ &#123;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;deferred&quot;</span>, -i)fmt.Println(<span class="hljs-string">&quot;regular&quot;</span>, i)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">regular</span> <span class="hljs-number">1</span><span class="hljs-attribute">regular</span> <span class="hljs-number">2</span><span class="hljs-attribute">regular</span> <span class="hljs-number">3</span><span class="hljs-attribute">regular</span> <span class="hljs-number">4</span><span class="hljs-attribute">deferred</span> -<span class="hljs-number">4</span><span class="hljs-attribute">deferred</span> -<span class="hljs-number">3</span><span class="hljs-attribute">deferred</span> -<span class="hljs-number">2</span><span class="hljs-attribute">deferred</span> -<span class="hljs-number">1</span></code></pre></div><p>在此示例中，请注意，每次推迟 <code>fmt.Println(&quot;deferred&quot;, -i)</code> 时，都会存储 <code>i</code> 的值，并会将其运行任务添加到队列中。 在 <code>main()</code> 函数输出完 <code>regular</code> 值后，所有推迟的调用都会运行。 这就是你看到输出采用逆序（后进先出）的原因。</p><p><code>defer</code> 函数的一个典型用例是在使用完文件后将其关闭。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;newfile, <span class="hljs-type">error</span> := os.Create(<span class="hljs-string">&quot;learnGo.txt&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-type">error</span> != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Error: Could not create file.&quot;</span>)<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">defer</span> newfile.Close()<span class="hljs-keyword">if</span> _, <span class="hljs-type">error</span> = io.WriteString(newfile, <span class="hljs-string">&quot;Learning Go!&quot;</span>); <span class="hljs-type">error</span> != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Error: Could not write to file.&quot;</span>)<span class="hljs-keyword">return</span>&#125;newfile.Sync()&#125;</code></pre></div><p>创建或打开某个文件后，可以推迟 <code>.Close()</code> 函数的执行，以免在你完成后忘记关闭该文件。</p><h3 id="panic-函数">panic 函数</h3><p>运行时错误会使 Go 程序崩溃，例如尝试通过使用超出范围的索引或取消引用 nil 指针来访问数组。 你也可以强制程序崩溃。</p><p>内置 <code>panic()</code> 函数可以停止 Go 程序中的正常控制流。 当你使用 <code>panic</code> 调用时，任何延迟的函数调用都将正常运行。 进程会在堆栈中继续，直到所有函数都返回。 然后，程序会崩溃并记录日志消息。 此消息包含错误信息和堆栈跟踪，有助于诊断问题的根本原因。</p><p>调用 <code>panic()</code> 函数时，可以添加任何值作为参数。 通常，你会发送一条错误消息，说明为什么会进入紧急状态。</p><p>例如，下面的代码将 <code>panic</code> 和 <code>defer</code> 函数组合在一起。 尝试运行此代码以了解控制流的中断。 请注意，清理过程仍会运行。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">highlow</span><span class="hljs-params">(high <span class="hljs-type">int</span>, low <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> high &lt; low &#123;fmt.Println(<span class="hljs-string">&quot;Panic!&quot;</span>)<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;highlow() low greater than high&quot;</span>)&#125;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;Deferred: highlow(&quot;</span>, high, <span class="hljs-string">&quot;,&quot;</span>, low, <span class="hljs-string">&quot;)&quot;</span>)fmt.Println(<span class="hljs-string">&quot;Call: highlow(&quot;</span>, high, <span class="hljs-string">&quot;,&quot;</span>, low, <span class="hljs-string">&quot;)&quot;</span>)highlow(high, low+<span class="hljs-number">1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;highlow(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)fmt.Println(<span class="hljs-string">&quot;Program finished successfully!&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs awk">Call: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">0</span> )Call: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">1</span> )Call: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">2</span> )Panic!Deferred: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">2</span> )Deferred: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">1</span> )Deferred: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">0</span> )panic: highlow() low greater than highgoroutine <span class="hljs-number">1</span> [running]:main.highlow(<span class="hljs-number">0</span>x4b8018?, <span class="hljs-number">0</span>xc000012018?)        <span class="hljs-regexp">/mnt/</span>d<span class="hljs-regexp">/Programming_Design/</span>Go<span class="hljs-regexp">/src/</span>helloworld/main.go:<span class="hljs-number">8</span> +<span class="hljs-number">0</span>x285main.highlow(<span class="hljs-number">0</span>x2, <span class="hljs-number">0</span>x2)        <span class="hljs-regexp">/mnt/</span>d<span class="hljs-regexp">/Programming_Design/</span>Go<span class="hljs-regexp">/src/</span>helloworld/main.go:<span class="hljs-number">13</span> +<span class="hljs-number">0</span>x211main.highlow(<span class="hljs-number">0</span>x2, <span class="hljs-number">0</span>x1)        <span class="hljs-regexp">/mnt/</span>d<span class="hljs-regexp">/Programming_Design/</span>Go<span class="hljs-regexp">/src/</span>helloworld/main.go:<span class="hljs-number">13</span> +<span class="hljs-number">0</span>x211main.highlow(<span class="hljs-number">0</span>x2, <span class="hljs-number">0</span>x0)        <span class="hljs-regexp">/mnt/</span>d<span class="hljs-regexp">/Programming_Design/</span>Go<span class="hljs-regexp">/src/</span>helloworld/main.go:<span class="hljs-number">13</span> +<span class="hljs-number">0</span>x211main.main()        <span class="hljs-regexp">/mnt/</span>d<span class="hljs-regexp">/Programming_Design/</span>Go<span class="hljs-regexp">/src/</span>helloworld/main.go:<span class="hljs-number">17</span> +<span class="hljs-number">0</span>x25<span class="hljs-keyword">exit</span> status <span class="hljs-number">2</span></code></pre></div><p>下面是运行代码时会发生的情况：</p><ol><li>一切正常运行。 程序将输出传递到 <code>highlow()</code> 函数中的高值和低值。</li><li>如果 <code>low</code> 的值大于 <code>high</code> 的值，则程序会崩溃。 会显示“<code>Panic!</code>”消息。 此时，控制流中断，所有推迟的函数都开始输出“<code>Deferred...</code>”消息。</li><li>程序崩溃，并显示完整的堆栈跟踪。 不会显示“<code>Program finished successfully!</code>”消息。</li></ol><h3 id="recover-函数">recover 函数</h3><p>有时，你可能想要避免程序崩溃，改为在内部报告错误。 或者，你可能想要先清理混乱情况，然后再让程序崩溃。 例如，你可能想要关闭与某个资源的连接，以免出现更多问题。</p><p>Go 提供内置 <code>recover()</code> 函数，让你可以在程序崩溃之后重新获得控制权。 你只会在你同时调用 <code>defer</code> 的函数中调用 <code>recover</code>。 如果调用 <code>recover()</code> 函数，则在正常运行的情况下，它会返回 <code>nil</code>，没有任何其他作用。</p><p>尝试修改前面的代码中的 <code>main</code> 函数，以添加对 <code>recover()</code> 的调用，如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">highlow</span><span class="hljs-params">(high <span class="hljs-type">int</span>, low <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> high &lt; low &#123;fmt.Println(<span class="hljs-string">&quot;Panic!&quot;</span>)<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;highlow() low greater than high&quot;</span>)&#125;<span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;Deferred: highlow(&quot;</span>, high, <span class="hljs-string">&quot;,&quot;</span>, low, <span class="hljs-string">&quot;)&quot;</span>)fmt.Println(<span class="hljs-string">&quot;Call: highlow(&quot;</span>, high, <span class="hljs-string">&quot;,&quot;</span>, low, <span class="hljs-string">&quot;)&quot;</span>)highlow(high, low+<span class="hljs-number">1</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;handler := <span class="hljs-built_in">recover</span>()<span class="hljs-keyword">if</span> handler != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;main(): recover&quot;</span>, handler)&#125;&#125;()highlow(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)fmt.Println(<span class="hljs-string">&quot;Program finished successfully!&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Call</span>: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">0</span> )<span class="hljs-attribute">Call</span>: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">1</span> )<span class="hljs-attribute">Call</span>: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">2</span> )<span class="hljs-attribute">Panic</span>!<span class="hljs-attribute">Deferred</span>: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">2</span> )<span class="hljs-attribute">Deferred</span>: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">1</span> )<span class="hljs-attribute">Deferred</span>: highlow( <span class="hljs-number">2</span> , <span class="hljs-number">0</span> )<span class="hljs-attribute">main</span>(): recover highlow() low greater than high</code></pre></div><p>在 <code>main()</code> 函数中，你会将一个可以调用 <code>recover()</code> 函数的匿名函数推迟。 当程序处于紧急状态时，对 <code>recover()</code> 的调用无法返回 <code>nil</code>。 你可以在此处执行一些操作来清理混乱，但在本例中，你只是简单地输出一些内容。</p><p><code>panic</code> 和 <code>recover</code> 函数的组合是 Go 处理异常的惯用方式。 其他编程语言使用 <code>try/catch</code> 块。 Go 首选此处所述的方法。</p><h2 id="练习-在-Go-中使用控制流">练习 - 在 Go 中使用控制流</h2><h3 id="编写-FizzBuzz-程序">编写 FizzBuzz 程序</h3><p>首先，编写一个用于输出数字（1 到 100）的程序，其中有以下变化：</p><ul><li>如果数字可被 3 整除，则输出 <code>Fizz</code>。</li><li>如果数字可被 5 整除，则输出 <code>Buzz</code>。</li><li>如果数字可同时被 3 和 5 整除，则输出 <code>FizzBuzz</code>。</li><li>如果前面的情况都不符合，则输出该数字。</li></ul><p>尝试使用 <code>switch</code> 语句。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (    <span class="hljs-string">&quot;fmt&quot;</span>    <span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fizzbuzz</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;    <span class="hljs-keyword">switch</span> &#123;    <span class="hljs-keyword">case</span> num%<span class="hljs-number">15</span> == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FizzBuzz&quot;</span>    <span class="hljs-keyword">case</span> num%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Fizz&quot;</span>    <span class="hljs-keyword">case</span> num%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Buzz&quot;</span>    &#125;    <span class="hljs-keyword">return</span> strconv.Itoa(num)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    <span class="hljs-keyword">for</span> num := <span class="hljs-number">1</span>; num &lt;= <span class="hljs-number">100</span>; num++ &#123;        fmt.Println(fizzbuzz(num))    &#125;&#125;</code></pre></div><h3 id="查找质数">查找质数</h3><p>编写一个程序来查找小于 20 的所有质数。 质数是大于 1 的任意数字，只能被它自己和 1 整除。 “整除”表示经过除法运算后没有余数。 与大多数编程语言一样，Go 还提供了一种方法来检查除法运算是否产生余数。 我们可以使用模数 <code>%</code>（百分号）运算符。</p><p>在本练习中，你将更新一个名为 <code>findprimes</code> 的函数，以检查数值是否为质数。 该函数有一个整数参数，并返回一个布尔值。 函数通过检查是否有余数来测试输入数字是否为质数。 如果数字为质数，则该函数返回 true。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findprimes</span><span class="hljs-params">(number <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; number; i++ &#123;<span class="hljs-keyword">if</span> number%i == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">if</span> number &gt; <span class="hljs-number">1</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Prime numbers less than 20:&quot;</span>)<span class="hljs-keyword">for</span> number := <span class="hljs-number">1</span>; number &lt; <span class="hljs-number">20</span>; number++ &#123;<span class="hljs-keyword">if</span> findprimes(number) &#123;fmt.Printf(<span class="hljs-string">&quot;%v &quot;</span>, number)&#125;&#125;fmt.Println()&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Prime</span> numbers less than <span class="hljs-number">20</span>:<span class="hljs-attribute">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span> <span class="hljs-number">17</span> <span class="hljs-number">19</span></code></pre></div><h3 id="要求用户输入一个数字，如果该数字为负数，则进入紧急状态">要求用户输入一个数字，如果该数字为负数，则进入紧急状态</h3><p>编写一个要求用户输入一个数字的程序。 在开始时使用以下代码片段：</p><p>此程序要求用户输入一个数字，然后将其输出。 修改示例代码，使之符合以下要求：</p><ul><li>持续要求用户输入一个整数。 此循环的退出条件应该是用户输入了一个负数。</li><li>当用户输入负数时，让程序崩溃。 然后输出堆栈跟踪错误。</li><li>如果数字为 0，则输出“<code>0 is neither negative nor positive</code>”。 继续要求用户输入数字。</li><li>如果数字为正数，则输出“<code>You entered: X</code>”（其中的 <code>X</code> 为输入的数字）。 继续要求用户输入数字。</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;val := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> &#123;fmt.Print(<span class="hljs-string">&quot;Enter number: &quot;</span>)fmt.Scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;val)<span class="hljs-keyword">if</span> val &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Negative!&quot;</span>)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> val == <span class="hljs-number">0</span> &#123;fmt.Println(<span class="hljs-string">&quot;0 is neither negative nor positive&quot;</span>)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;You entered: %d\n&quot;</span>, val)&#125;&#125;&#125;</code></pre></div><h1>使用数组</h1><p>Go 中的数组是一种特定类型且长度固定的数据结构。 它们可具有零个或多个元素，你必须在声明或初始化它们时定义大小。 此外，它们一旦创建，就无法调整大小。 鉴于这些原因，数组在 Go 程序中并不常用，但它们是切片和映射的基础。</p><h2 id="声明数组">声明数组</h2><p>要在 Go 中声明数组，必须定义其元素的数据类型以及该数组可容纳的元素数目。 然后，可采用下标表示法访问数组中的每个元素，其中第一个元素是 0，最后一个元素是数组长度减去 1（长度 - 1）。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>a[<span class="hljs-number">1</span>] = <span class="hljs-number">10</span>fmt.Println(a[<span class="hljs-number">0</span>])fmt.Println(a[<span class="hljs-number">1</span>])fmt.Println(a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>])&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">0100</code></pre></div><p>已声明的数组访问其元素时不会遇到错误。 默认情况下，Go 会用默认数据类型初始化每个元素。 这样的话，<code>int</code> 的默认值为零。 不过，你可为特定位置分配值。 这就是为什么你会看到 <code>a[1] = 10</code>。 你可采用上述表示法来访问该元素。 另请注意，为了打印出第一个元素，我们使用了 <code>a[0]</code>。 为了打印出最后一个元素，我们使用了 <code>a[len(a)-1]</code>。 <code>len</code> 函数是 Go 中的内置函数，用于获取数组、切片或映射中的元素数。</p><h2 id="初始化数组">初始化数组</h2><p>声明数组时，还可使用非默认值来初始化数组。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;cities := [<span class="hljs-number">5</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;Paris&quot;</span>, <span class="hljs-string">&quot;Berlin&quot;</span>, <span class="hljs-string">&quot;Madrid&quot;</span>&#125;fmt.Println(<span class="hljs-string">&quot;Cities:&quot;</span>, cities)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-symbol">Cities:</span> [<span class="hljs-built_in">New</span> York Paris Berlin Madrid ]</code></pre></div><h2 id="数组中的省略号">数组中的省略号</h2><p>如果你不知道你将需要多少个位置，但知道你将具有多少数据，那么还有一种声明和初始化数组的方法是使用省略号 (<code>...</code>)</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;cities := [...]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;New York&quot;</span>, <span class="hljs-string">&quot;Paris&quot;</span>, <span class="hljs-string">&quot;Berlin&quot;</span>, <span class="hljs-string">&quot;Madrid&quot;</span>&#125;fmt.Println(<span class="hljs-string">&quot;Cities:&quot;</span>, cities)&#125;</code></pre></div><p>另一种有趣的数组初始化方法是使用省略号并仅为最新的位置指定值。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;numbers := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">99</span>: <span class="hljs-number">-1</span>&#125;fmt.Println(<span class="hljs-string">&quot;First Position:&quot;</span>, numbers[<span class="hljs-number">0</span>])fmt.Println(<span class="hljs-string">&quot;Last Position:&quot;</span>, numbers[<span class="hljs-number">99</span>])fmt.Println(<span class="hljs-string">&quot;Length:&quot;</span>, <span class="hljs-built_in">len</span>(numbers))&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-built_in">First</span> <span class="hljs-built_in">Position</span><span class="hljs-operator">:</span> <span class="hljs-number">0</span><span class="hljs-built_in">Last</span> <span class="hljs-built_in">Position</span><span class="hljs-operator">:</span> <span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-built_in">Length</span><span class="hljs-operator">:</span> <span class="hljs-number">100</span></code></pre></div><p>注意数组的长度是 100，因为你为第 99 个位置指定了一个值。</p><h2 id="多维数组">多维数组</h2><p>如果需要处理复杂数据结构，请记住 Go 支持多维数组。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> twoD [<span class="hljs-number">3</span>][<span class="hljs-number">5</span>]<span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++ &#123;twoD[i][j] = (i + <span class="hljs-number">1</span>) * (j + <span class="hljs-number">1</span>)&#125;fmt.Println(<span class="hljs-string">&quot;Row&quot;</span>, i, twoD[i])&#125;fmt.Println(<span class="hljs-string">&quot;\nAll at once:&quot;</span>, twoD)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs tap">Row<span class="hljs-number"> 0 </span>[1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5]Row<span class="hljs-number"> 1 </span>[2<span class="hljs-number"> 4 </span>6<span class="hljs-number"> 8 </span>10]Row<span class="hljs-number"> 2 </span>[3<span class="hljs-number"> 6 </span>9<span class="hljs-number"> 12 </span>15]All at once: [[1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5] [2<span class="hljs-number"> 4 </span>6<span class="hljs-number"> 8 </span>10] [3<span class="hljs-number"> 6 </span>9<span class="hljs-number"> 12 </span>15]]</code></pre></div><h1>了解切片</h1><p>与数组一样，切片也是 Go 中的一种数据类型，它表示一系列类型相同的元素。 不过，与数组更重要的区别是切片的大小是动态的，不是固定的。</p><p>切片是数组或另一个切片之上的数据结构。 我们将源数组或切片称为基础数组。 通过切片，可访问整个基础数组，也可仅访问部分元素。</p><p>切片只有 3 个组件：</p><ul><li><strong>指向基础数组中第一个可访问元素的指针</strong> 。 此元素不一定是数组的第一个元素 <code>array[0]</code>。</li><li><strong>切片的长度</strong> 。 切片中的元素数目。</li><li><strong>切片的容量</strong> 。 切片开头与基础数组结束之间的元素数目。</li></ul><h2 id="声明和初始化切片">声明和初始化切片</h2><p>要声明切片，可采用与声明数组相同的方式操作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;months := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>, <span class="hljs-string">&quot;April&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;June&quot;</span>, <span class="hljs-string">&quot;July&quot;</span>, <span class="hljs-string">&quot;August&quot;</span>, <span class="hljs-string">&quot;September&quot;</span>, <span class="hljs-string">&quot;October&quot;</span>, <span class="hljs-string">&quot;November&quot;</span>, <span class="hljs-string">&quot;December&quot;</span>&#125;fmt.Println(months)fmt.Println(<span class="hljs-string">&quot;Length:&quot;</span>, <span class="hljs-built_in">len</span>(months))fmt.Println(<span class="hljs-string">&quot;Capacity:&quot;</span>, <span class="hljs-built_in">cap</span>(months))&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mipsasm">[<span class="hljs-keyword">January </span>February March April May <span class="hljs-keyword">June </span><span class="hljs-keyword">July </span>August September October November December]<span class="hljs-symbol">Length:</span> <span class="hljs-number">12</span><span class="hljs-symbol">Capacity:</span> <span class="hljs-number">12</span></code></pre></div><h2 id="切片项">切片项</h2><p>Go 支持切片运算符 <code>s[i:p]</code>，其中：</p><ul><li><code>s</code> 表示数组。</li><li><code>i</code> 表示指向要添加到新切片的基础数组（或另一个切片）的第一个元素的指针。 变量 <code>i</code> 对应于数组 <code>array[i]</code> 中索引位置 <code>i</code> 处的元素。 请记住，此元素不一定是基础数组的第一个元素 <code>array[0]</code>。</li><li><code>p</code> 表示创建新切片时要使用的基础数组中的元素数目。 变量 <code>p</code> 对应于可用于新切片的基础数组中的最后一个元素。 可在位置 <code>array[i+1]</code> 找到基础数组中位置 <code>p</code> 处的元素。 请注意，此元素不一定是基础数组的最后一个元素 <code>array[len(array)-1]</code>。</li></ul><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;months := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>, <span class="hljs-string">&quot;April&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;June&quot;</span>, <span class="hljs-string">&quot;July&quot;</span>, <span class="hljs-string">&quot;August&quot;</span>, <span class="hljs-string">&quot;September&quot;</span>, <span class="hljs-string">&quot;October&quot;</span>, <span class="hljs-string">&quot;November&quot;</span>, <span class="hljs-string">&quot;December&quot;</span>&#125;quarter1 := months[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]quarter2 := months[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]quarter3 := months[<span class="hljs-number">6</span>:<span class="hljs-number">9</span>]quarter4 := months[<span class="hljs-number">9</span>:<span class="hljs-number">12</span>]fmt.Println(quarter1, <span class="hljs-built_in">len</span>(quarter1), <span class="hljs-built_in">cap</span>(quarter1))fmt.Println(quarter2, <span class="hljs-built_in">len</span>(quarter2), <span class="hljs-built_in">cap</span>(quarter2))fmt.Println(quarter3, <span class="hljs-built_in">len</span>(quarter3), <span class="hljs-built_in">cap</span>(quarter3))fmt.Println(quarter4, <span class="hljs-built_in">len</span>(quarter4), <span class="hljs-built_in">cap</span>(quarter4))&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-string">[January February March]</span> <span class="hljs-number">3</span> <span class="hljs-number">12</span><span class="hljs-string">[April May June]</span> <span class="hljs-number">3</span> <span class="hljs-number">9</span><span class="hljs-string">[July August September]</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><span class="hljs-string">[October November December]</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span></code></pre></div><p>注意，切片的长度不变，但容量不同。 我们来了解 <code>quarter2</code> 切片。 声明此切片时，你指出希望切片从位置编号 3 开始，最后一个元素位于位置编号 6。 切片长度为 3 个元素，但容量为 9，原因是基础数组有更多元素或位置可供使用，但对切片而言不可见。</p><p>切片容量仅指出切片可扩展的程度。 因此可从 <code>quarter2</code> 创建扩展切片</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;months := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;January&quot;</span>, <span class="hljs-string">&quot;February&quot;</span>, <span class="hljs-string">&quot;March&quot;</span>, <span class="hljs-string">&quot;April&quot;</span>, <span class="hljs-string">&quot;May&quot;</span>, <span class="hljs-string">&quot;June&quot;</span>, <span class="hljs-string">&quot;July&quot;</span>, <span class="hljs-string">&quot;August&quot;</span>, <span class="hljs-string">&quot;September&quot;</span>, <span class="hljs-string">&quot;October&quot;</span>, <span class="hljs-string">&quot;November&quot;</span>, <span class="hljs-string">&quot;December&quot;</span>&#125;quarter2 := months[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>]quarter2Extended := quarter2[:<span class="hljs-number">4</span>]fmt.Println(quarter2, <span class="hljs-built_in">len</span>(quarter2), <span class="hljs-built_in">cap</span>(quarter2))fmt.Println(quarter2Extended, <span class="hljs-built_in">len</span>(quarter2Extended), <span class="hljs-built_in">cap</span>(quarter2Extended))&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mipsasm">[April May <span class="hljs-keyword">June] </span><span class="hljs-number">3</span> <span class="hljs-number">9</span>[April May <span class="hljs-keyword">June </span><span class="hljs-keyword">July] </span><span class="hljs-number">4</span> <span class="hljs-number">9</span></code></pre></div><h2 id="追加项">追加项</h2><p>切片与数组之间有何不同？ 第一个区别是切片的大小不是固定的，而是动态的。 创建切片后，可向其添加更多元素，这样切片就会扩展。</p><p>Go 提供了内置函数 <code>append(slice, element)</code>，便于你向切片添加元素。 将要修改的切片和要追加的元素作为值发送给该函数。 然后，<code>append</code> 函数会返回一个新的切片，将其存储在变量中。 对于要更改的切片，变量可能相同。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> numbers []<span class="hljs-type">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;numbers = <span class="hljs-built_in">append</span>(numbers, i)fmt.Printf(<span class="hljs-string">&quot;%d\tcap=%d\t%v\n&quot;</span>, i, <span class="hljs-built_in">cap</span>(numbers), numbers)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>      cap=<span class="hljs-number">1</span>   [<span class="hljs-number">0</span>]<span class="hljs-symbol">1 </span>      cap=<span class="hljs-number">2</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span>]<span class="hljs-symbol">2 </span>      cap=<span class="hljs-number">4</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>]<span class="hljs-symbol">3 </span>      cap=<span class="hljs-number">4</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<span class="hljs-symbol">4 </span>      cap=<span class="hljs-number">8</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<span class="hljs-symbol">5 </span>      cap=<span class="hljs-number">8</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<span class="hljs-symbol">6 </span>      cap=<span class="hljs-number">8</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<span class="hljs-symbol">7 </span>      cap=<span class="hljs-number">8</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span>]<span class="hljs-symbol">8 </span>      cap=<span class="hljs-number">16</span>  [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span>]<span class="hljs-symbol">9 </span>      cap=<span class="hljs-number">16</span>  [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]</code></pre></div><p>当切片容量不足以容纳更多元素时，Go 的容量将翻倍。 它将新建一个具有新容量的基础数组。 无需执行任何操作即可使容量增加。 Go 会自动扩充容量。</p><h2 id="删除项">删除项</h2><p>Go 没有内置函数用于从切片中删除元素。 可使用上述切片运算符 <code>s[i:p]</code> 来新建一个仅包含所需元素的切片。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;letters := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>&#125;remove := <span class="hljs-number">2</span><span class="hljs-keyword">if</span> remove &lt; <span class="hljs-built_in">len</span>(letters) &#123;fmt.Println(<span class="hljs-string">&quot;Before&quot;</span>, letters, <span class="hljs-string">&quot;Remove &quot;</span>, letters[remove])letters = <span class="hljs-built_in">append</span>(letters[:remove], letters[remove+<span class="hljs-number">1</span>:]...)fmt.Println(<span class="hljs-string">&quot;After&quot;</span>, letters)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-built_in">Before</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">A</span> <span class="hljs-variable">B</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span> <span class="hljs-built_in">Remove</span>  <span class="hljs-built_in">C</span><span class="hljs-built_in">After</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">A</span> <span class="hljs-variable">B</span> <span class="hljs-built_in">D</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span></code></pre></div><h2 id="创建切片的副本">创建切片的副本</h2><p>Go 具有内置函数 <code>copy(dst, src []Type)</code> 用于创建切片的副本。</p><p>更改切片中的元素时，基础数组将随之更改。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;letters := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>&#125;fmt.Println(<span class="hljs-string">&quot;Before&quot;</span>, letters)slice1 := letters[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]slice2 := letters[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]slice1[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Z&quot;</span>fmt.Println(<span class="hljs-string">&quot;After&quot;</span>, letters)fmt.Println(<span class="hljs-string">&quot;Slice2&quot;</span>, slice2)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-built_in">Before</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">A</span> <span class="hljs-variable">B</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span><span class="hljs-built_in">After</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">A</span> <span class="hljs-variable">Z</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span><span class="hljs-variable">Slice2</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Z</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">]</span></code></pre></div><p>创建副本则不会产生影响</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;letters := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>&#125;fmt.Println(<span class="hljs-string">&quot;Before&quot;</span>, letters)slice1 := letters[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]slice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">3</span>)<span class="hljs-built_in">copy</span>(slice2, letters[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])slice1[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Z&quot;</span>fmt.Println(<span class="hljs-string">&quot;After&quot;</span>, letters)fmt.Println(<span class="hljs-string">&quot;Slice2&quot;</span>, slice2)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-built_in">Before</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">A</span> <span class="hljs-variable">B</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span><span class="hljs-built_in">After</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">A</span> <span class="hljs-variable">Z</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span> <span class="hljs-built_in">E</span><span class="hljs-punctuation">]</span><span class="hljs-variable">Slice2</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">B</span> <span class="hljs-built_in">C</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">]</span></code></pre></div><h1>使用映射</h1><p>Go 中的映射是一个哈希表，是键值对的集合。 映射中所有的键都必须具有相同的类型，它们的值也是如此。 不过，可对键和值使用不同的类型。 例如，键可以是数字，值可以是字符串。 若要访问映射中的特定项，可引用该项的键。</p><h2 id="声明和初始化映射">声明和初始化映射</h2><p>若要声明映射，需要使用 <code>map</code> 关键字。 然后，定义键和值类型，如下所示：<code>map[T]T</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;studentsAge := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;john&quot;</span>: <span class="hljs-number">32</span>,<span class="hljs-string">&quot;bob&quot;</span>:  <span class="hljs-number">31</span>,&#125;fmt.Println(studentsAge)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">map</span>[<span class="hljs-keyword">bo</span><span class="hljs-variable">b:31</span> john:<span class="hljs-number">32</span>]</code></pre></div><p>如果不想使用项来初始化映射，可使用内置函数 <code>make()</code> 在上一部分创建切片。</p><h2 id="添加项">添加项</h2><p>要添加项，无需像对切片一样使用内置函数。 映射更加简单。 你只需定义键和值即可。 如果没有键值对，则该项会添加到映射中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;studentsAge := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)studentsAge[<span class="hljs-string">&quot;john&quot;</span>] = <span class="hljs-number">32</span>studentsAge[<span class="hljs-string">&quot;bob&quot;</span>] = <span class="hljs-number">31</span>fmt.Println(studentsAge)&#125;</code></pre></div><h2 id="访问项">访问项</h2><p>若要访问映射中的项，可使用常用的下标表示法 <code>m[key]</code></p><p>在映射中使用下标表示法时，即使映射中没有键，你也总会获得默认值的响应。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;studentsAge := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)studentsAge[<span class="hljs-string">&quot;john&quot;</span>] = <span class="hljs-number">32</span>studentsAge[<span class="hljs-string">&quot;bob&quot;</span>] = <span class="hljs-number">31</span>fmt.Println(<span class="hljs-string">&quot;Bob&#x27;s age is&quot;</span>, studentsAge[<span class="hljs-string">&quot;bob&quot;</span>])fmt.Println(<span class="hljs-string">&quot;Christy&#x27;s age is&quot;</span>, studentsAge[<span class="hljs-string">&quot;christy&quot;</span>])&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ada">Bob<span class="hljs-symbol">&#x27;s</span> age <span class="hljs-keyword">is</span> <span class="hljs-number">31</span>Christy<span class="hljs-symbol">&#x27;s</span> age <span class="hljs-keyword">is</span> <span class="hljs-number">0</span></code></pre></div><p>在很多情况下，访问映射中没有的项时 Go 不会返回错误，这是正常的。 但有时需要知道某个项是否存在。 在 Go 中，映射的下标表示法可生成两个值。 第一个是项的值。 第二个是指示键是否存在的布尔型标志。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;studentsAge := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)studentsAge[<span class="hljs-string">&quot;john&quot;</span>] = <span class="hljs-number">32</span>studentsAge[<span class="hljs-string">&quot;bob&quot;</span>] = <span class="hljs-number">31</span>age, exist := studentsAge[<span class="hljs-string">&quot;christy&quot;</span>]<span class="hljs-keyword">if</span> exist &#123;fmt.Println(<span class="hljs-string">&quot;Christy&#x27;s age is&quot;</span>, age)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;Christy&#x27;s age couldn&#x27;t be found&quot;</span>)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ada">Christy<span class="hljs-symbol">&#x27;s</span> age couldn<span class="hljs-symbol">&#x27;t</span> be found</code></pre></div><h2 id="删除项-2">删除项</h2><p>若要从映射中删除项，请使用内置函数 <code>delete()</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;studentsAge := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)studentsAge[<span class="hljs-string">&quot;john&quot;</span>] = <span class="hljs-number">32</span>studentsAge[<span class="hljs-string">&quot;bob&quot;</span>] = <span class="hljs-number">31</span><span class="hljs-built_in">delete</span>(studentsAge, <span class="hljs-string">&quot;bob&quot;</span>)<span class="hljs-built_in">delete</span>(studentsAge, <span class="hljs-string">&quot;christy&quot;</span>)fmt.Println(studentsAge)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">map</span>[john:<span class="hljs-number">32</span>]</code></pre></div><p>如果你尝试删除不存在的项，Go 不会执行 panic</p><h2 id="映射中的循环">映射中的循环</h2><p>最后，让我们看看如何在映射中进行循环来以编程方式访问其所有的项。 为此，可使用基于范围的循环</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;studentsAge := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)studentsAge[<span class="hljs-string">&quot;john&quot;</span>] = <span class="hljs-number">32</span>studentsAge[<span class="hljs-string">&quot;bob&quot;</span>] = <span class="hljs-number">31</span><span class="hljs-keyword">for</span> name, age := <span class="hljs-keyword">range</span> studentsAge &#123;fmt.Printf(<span class="hljs-string">&quot;%s\t%d\n&quot;</span>, name, age)&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">john</span>    <span class="hljs-number">32</span><span class="hljs-attribute">bob</span>     <span class="hljs-number">31</span></code></pre></div><p><code>range</code> 会首先生成项的键，然后再生成该项的值。 可使用 <code>_</code> 变量忽略其中任何一个</p><h1>使用结构</h1><p>有时，你需要在一个结构中表示字段的集合。在 Go 中，可使用结构将可能构成记录的不同字段组合在一起。Go 中的结构也是一种数据结构，它可包含零个或多个任意类型的字段，并将它们表示为单个实体。</p><h2 id="声明和初始化结构">声明和初始化结构</h2><p>若要声明结构，需要使用 <code>struct</code> 关键字，还要使用希望新的数据类型具有的字段及其类型的列表。</p><p>若要访问结构的各个字段，可使用点表示法 (<code>.</code>) 做到这一点</p><p>可使用 <code>&amp;</code> 运算符生成指向结构的指针以修改结构中的项</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;ID        <span class="hljs-type">int</span>FirstName <span class="hljs-type">string</span>LastName  <span class="hljs-type">string</span>Address   <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;employee := Employee&#123;LastName: <span class="hljs-string">&quot;Doe&quot;</span>, FirstName: <span class="hljs-string">&quot;John&quot;</span>&#125;fmt.Println(employee)employeeCopy := &amp;employeeemployeeCopy.FirstName = <span class="hljs-string">&quot;David&quot;</span>fmt.Println(employee)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;0 John Doe &#125;</span><span class="language-xml"></span><span class="language-xml"></span><span class="hljs-template-variable">&#123;0 David Doe &#125;</span></code></pre></div><h2 id="结构嵌入">结构嵌入</h2><p>通过 Go 中的结构，可将某结构嵌入到另一结构中。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;ID        <span class="hljs-type">int</span>FirstName <span class="hljs-type">string</span>LastName  <span class="hljs-type">string</span>Address   <span class="hljs-type">string</span>&#125;<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;PersonManagerID <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Contractor <span class="hljs-keyword">struct</span> &#123;PersonCompanyID <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;employee := Employee&#123;Person: Person&#123;FirstName: <span class="hljs-string">&quot;John&quot;</span>,&#125;,&#125;employee.LastName = <span class="hljs-string">&quot;Doe&quot;</span>employee.ManagerID = <span class="hljs-number">2</span>fmt.Println(employee)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">0</span> John Doe &#125; <span class="hljs-number">2</span>&#125;</span></code></pre></div><h2 id="用-JSON-编码和解码结构">用 JSON 编码和解码结构</h2><p>最后，可使用结构来对 JSON 中的数据进行编码和解码。 Go 对 JSON 格式提供很好的支持，该格式已包含在标准库包中。</p><p>你还可执行一些操作，例如重命名结构中字段的名称。 例如，假设你不希望 JSON 输出显示 <code>FirstName</code> 而只显示 <code>name</code>，或者忽略空字段， 可使用如下例所示的字段标记：</p><p>然后，若要将结构编码为 JSON，请使用 <code>json.Marshal</code> 函数。 若要将 JSON 字符串解码为数据结构，请使用 <code>json.Unmarshal</code> 函数。 下例将所有内容组合在一起，将员工数组编码为 JSON，并将输出解码为新的变量：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;ID        <span class="hljs-type">int</span>FirstName <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span>LastName  <span class="hljs-type">string</span>Address   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;address,omitempty&quot;`</span>&#125;<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;PersonManagerID <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> Contractor <span class="hljs-keyword">struct</span> &#123;PersonCompanyID <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;employees := []Employee&#123;&#123;Person: Person&#123;LastName: <span class="hljs-string">&quot;Doe&quot;</span>, FirstName: <span class="hljs-string">&quot;John&quot;</span>,&#125;,&#125;,&#123;Person: Person&#123;LastName: <span class="hljs-string">&quot;Campbell&quot;</span>, FirstName: <span class="hljs-string">&quot;David&quot;</span>,&#125;,&#125;,&#125;data, _ := json.Marshal(employees)fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data)<span class="hljs-keyword">var</span> decoded []Employeejson.Unmarshal(data, &amp;decoded)fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, decoded)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-attr">[&#123;<span class="hljs-string">&quot;ID&quot;</span>:0,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;John&quot;</span>,<span class="hljs-string">&quot;LastName&quot;</span>:<span class="hljs-string">&quot;Doe&quot;</span>,<span class="hljs-string">&quot;ManagerID&quot;</span>:0&#125;,&#123;<span class="hljs-string">&quot;ID&quot;</span>:0,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;David&quot;</span>,<span class="hljs-string">&quot;LastName&quot;</span>:<span class="hljs-string">&quot;Campbell&quot;</span>,<span class="hljs-string">&quot;ManagerID&quot;</span>:0&#125;]</span><span class="hljs-selector-attr">[&#123;&#123;0 John Doe &#125; 0&#125; &#123;&#123;0 David Campbell &#125; 0&#125;]</span></code></pre></div><h1>练习 - 数据类型</h1><h2 id="编写一个程序来计算斐波纳契数列">编写一个程序来计算斐波纳契数列</h2><p>在这第一个挑战中，你将编写一个程序来计算某个数字的斐波纳契数列。 这是在学习新语言时要编码的一个典型的编程练习。 你将编写一个函数，它返回一个包含按斐波纳契数列排列的所有数字的切片，而这些数字是通过根据用户输入的大于 2 的数字计算得到的。 让我们假设小于 <code>2</code> 的数字会导致错误，并返回一个 nil 切片。</p><p>请记住，斐波那契数列是一个数字列表，其中每个数字是前两个斐波那契数字之和。 例如，数字 <code>6</code> 的序列是 <code>1,1,2,3,5,8</code>，数字 <code>7</code> 的序列是 <code>1,1,2,3,5,8,13</code>，数字 <code>8</code> 的序列是 <code>1,1,2,3,5,8,13,21</code>，以此类推。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)&#125;nums := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;nums[i] = nums[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-2</span>]&#125;<span class="hljs-keyword">return</span> nums&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> num <span class="hljs-type">int</span>fmt.Print(<span class="hljs-string">&quot;What&#x27;s the Fibonacci sequence you want? &quot;</span>)fmt.Scanln(&amp;num)fmt.Println(<span class="hljs-string">&quot;The Fibonacci sequence is:&quot;</span>, fibonacci(num))&#125;</code></pre></div><h2 id="创建罗马数字转换器">创建罗马数字转换器</h2><p>编写一个程序来转换罗马数字（例如将 <code>MCLX</code> 转换成 <code>1,160</code>）。 使用映射加载要用于将字符串字符转换为数字的基本罗马数字。 例如，<code>M</code> 将是映射中的键，其值将为 <code>1000</code>。 使用以下字符串字符映射表列表：</p><ul><li><code>M</code> =&gt; 1000</li><li><code>D</code> =&gt; 500</li><li><code>C</code> =&gt; 100</li><li><code>L</code> =&gt; 50</li><li><code>X</code> =&gt; 10</li><li><code>V</code> =&gt; 5</li><li><code>I</code> =&gt; 1</li></ul><p>如果用户输入的字母与上述列表中的不同，则打印一个错误。</p><p>请记住在有些情况下，较小的数字会排在较大的数字前面，因此不能仅仅将数字相加。 例如，数字 <code>MCM</code> 应打印为 <code>1,900</code>。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">romanToArabic</span><span class="hljs-params">(numeral <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;romanMap := <span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-number">1000</span>,<span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">500</span>,<span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">100</span>,<span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>,<span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>,<span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>,<span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>,&#125;arabicVals := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(numeral)+<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> index, digit := <span class="hljs-keyword">range</span> numeral &#123;<span class="hljs-keyword">if</span> val, present := romanMap[digit]; present &#123;arabicVals[index] = val&#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;Error: The roman numeral %s has a bad digit: %c\n&quot;</span>, numeral, digit)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;&#125;total := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> index := <span class="hljs-number">0</span>; index &lt; <span class="hljs-built_in">len</span>(numeral); index++ &#123;<span class="hljs-keyword">if</span> arabicVals[index] &lt; arabicVals[index+<span class="hljs-number">1</span>] &#123;arabicVals[index] = -arabicVals[index]&#125;total += arabicVals[index]&#125;<span class="hljs-keyword">return</span> total&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;MCLX is&quot;</span>, romanToArabic(<span class="hljs-string">&quot;MCLX&quot;</span>))fmt.Println(<span class="hljs-string">&quot;MCMXCIX is &quot;</span>, romanToArabic(<span class="hljs-string">&quot;MCMXCIX&quot;</span>))fmt.Println(<span class="hljs-string">&quot;MCMZ is&quot;</span>, romanToArabic(<span class="hljs-string">&quot;MCMZ&quot;</span>))&#125;</code></pre></div><h1>如何在 Go 中处理错误</h1><p>编写程序时，需要考虑程序失败的各种方式，并且需要管理失败。 无需让用户看到冗长而混乱的堆栈跟踪错误。 让他们看到有关错误的有意义的信息更好。 正如你所看到的，Go 具有 <code>panic</code> 和 <code>recover</code> 之类的内置函数来管理程序中的异常或意外行为。 但错误是已知的失败，你的程序应该可以处理它们。</p><p>Go 的错误处理方法只是一种只需要 <code>if</code> 和 <code>return</code> 语句的控制流机制。 例如，在调用函数以从 <code>employee</code> 对象获取信息时，可能需要了解该员工是否存在。 Go 处理此类预期错误的一贯方法如下所示：</p><div class="code-wrapper"><pre><code class="hljs go">employee, err := getInformation(<span class="hljs-number">1000</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;    <span class="hljs-comment">// Something is wrong. Do something.</span>&#125;</code></pre></div><p>注意 <code>getInformation</code> 函数返回了 <code>employee</code> 结构，还返回了错误作为第二个值。 该错误可能为 <code>nil</code>。 如果错误为 <code>nil</code>，则表示成功。 如果错误不是 <code>nil</code>，则表示失败。 非 <code>nil</code> 错误附带一条错误消息，你可以打印该错误消息，也可以记录该消息（更可取）。</p><h2 id="错误处理策略">错误处理策略</h2><p>当函数返回错误时，该错误通常是最后一个返回值。 正如上一部分所介绍的那样，调用方负责检查是否存在错误并处理错误。</p><p>你可能还需要在传播错误之前添加更多信息。 为此，可以使用 <code>fmt.Errorf()</code> 函数，该函数与我们之前看到的函数类似，但它返回一个错误。 例如，你可以向错误添加更多上下文，但仍返回原始错误，如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInformation</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> (*Employee, <span class="hljs-type">error</span>) &#123;    employee, err := apiCallEmployee(<span class="hljs-number">1000</span>)    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;got an error when getting the employee information: %v&quot;</span>, err)    &#125;    <span class="hljs-keyword">return</span> employee, <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>另一种策略是在错误为暂时性错误时运行重试逻辑。 例如，可以使用重试策略调用函数三次并等待两秒钟</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInformation</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> (*Employee, <span class="hljs-type">error</span>) &#123;    <span class="hljs-keyword">for</span> tries := <span class="hljs-number">0</span>; tries &lt; <span class="hljs-number">3</span>; tries++ &#123;        employee, err := apiCallEmployee(<span class="hljs-number">1000</span>)        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;            <span class="hljs-keyword">return</span> employee, <span class="hljs-literal">nil</span>        &#125;        fmt.Println(<span class="hljs-string">&quot;Server is not responding, retrying ...&quot;</span>)        time.Sleep(time.Second * <span class="hljs-number">2</span>)    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;server has failed to respond to get the employee information&quot;</span>)&#125;</code></pre></div><h2 id="创建可重用的错误">创建可重用的错误</h2><p>有时错误消息数会增加，你需要维持秩序。 或者，你可能需要为要重用的常见错误消息创建一个库。 在 Go 中，你可以使用 <code>errors.New()</code> 函数创建错误并在若干部分中重复使用这些错误，如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ErrNotFound = errors.New(<span class="hljs-string">&quot;Employee not found!&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getInformation</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> (*Employee, <span class="hljs-type">error</span>) &#123;    <span class="hljs-keyword">if</span> id != <span class="hljs-number">1001</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrNotFound    &#125;    employee := Employee&#123;LastName: <span class="hljs-string">&quot;Doe&quot;</span>, FirstName: <span class="hljs-string">&quot;John&quot;</span>&#125;    <span class="hljs-keyword">return</span> &amp;employee, <span class="hljs-literal">nil</span>&#125;</code></pre></div><p>最后，如果你具有错误变量，则在处理调用方函数中的错误时可以更具体。 <code>errors.Is()</code> 函数允许你比较获得的错误的类型</p><div class="code-wrapper"><pre><code class="hljs go">employee, err := getInformation(<span class="hljs-number">1000</span>)<span class="hljs-keyword">if</span> errors.Is(err, ErrNotFound) &#123;    fmt.Printf(<span class="hljs-string">&quot;NOT FOUND: %v\n&quot;</span>, err)&#125; <span class="hljs-keyword">else</span> &#123;    fmt.Print(employee)&#125;</code></pre></div><h2 id="用于错误处理的推荐做法">用于错误处理的推荐做法</h2><p>在 Go 中处理错误时，请记住下面一些推荐做法：</p><ul><li>始终检查是否存在错误，即使预期不存在。 然后正确处理它们，以免向最终用户公开不必要的信息。</li><li>在错误消息中包含一个前缀，以便了解错误的来源。 例如，可以包含包和函数的名称。</li><li>创建尽可能多的可重用错误变量。</li><li>了解使用返回错误和 panic 之间的差异。 不能执行其他操作时再使用 panic。 例如，如果某个依赖项未准备就绪，则程序运行无意义（除非你想要运行默认行为）。</li><li>在记录错误时记录尽可能多的详细信息（我们将在下一部分介绍记录方法），并打印出最终用户能够理解的错误。</li></ul><h1>如何在 Go 中记录</h1><p>日志在程序中发挥着重要作用，因为它们是在出现问题时你可以检查的信息源。 通常，发生错误时，最终用户只会看到一条消息，指示程序出现问题。 从开发人员的角度来看，我们需要简单错误消息以外的更多信息。 这主要是因为我们想要再现该问题以编写适当的修补程序。</p><h2 id="log-包"><code>log</code> 包</h2><p>对于初学者，Go 提供了一个用于处理日志的简单标准包。 可以像使用 <code>fmt</code> 包一样使用此包。 该标准包不提供日志级别，且不允许为每个包配置单独的记录器。 如果需要编写更复杂的日志记录配置，可以使用记录框架执行此操作。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;log&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;log.Print(<span class="hljs-string">&quot;Hey, I&#x27;m a log!&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>/<span class="hljs-number">10</span>/<span class="hljs-number">05</span> <span class="hljs-number">15</span>:<span class="hljs-number">37</span>:<span class="hljs-number">16</span> Hey, I&#x27;m a log!</code></pre></div><p>默认情况下，<code>log.Print()</code> 函数将日期和时间添加为日志消息的前缀。 你可以通过使用 <code>fmt.Print()</code> 获得相同的行为，但使用 <code>log</code> 包还能执行其他操作，例如将日志发送到文件。 稍后我们将详细介绍 <code>log</code> 包功能。</p><p>你可以使用 <code>log.Fatal()</code> 函数记录错误并结束程序，就像使用 <code>os.Exit(1)</code> 一样。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;log&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;log.Fatal(<span class="hljs-string">&quot;Hey, I&#x27;m an error log!&quot;</span>)fmt.Print(<span class="hljs-string">&quot;Can you see me?&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>/<span class="hljs-number">10</span>/<span class="hljs-number">05</span> <span class="hljs-number">15</span>:<span class="hljs-number">38</span>:<span class="hljs-number">56</span> Hey, I&#x27;m an error log!<span class="hljs-attribute">exit</span> status <span class="hljs-number">1</span></code></pre></div><p>使用 <code>log.Panic()</code> 函数时会出现类似行为，但是还会获取错误堆栈跟踪。</p><p>另一重要函数是 <code>log.SetPrefix()</code>。 可使用它向程序的日志消息添加前缀。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;log&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;log.SetPrefix(<span class="hljs-string">&quot;main(): &quot;</span>)log.Print(<span class="hljs-string">&quot;Hey, I&#x27;m a log!&quot;</span>)log.Fatal(<span class="hljs-string">&quot;Hey, I&#x27;m an error log!&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">main</span>(): <span class="hljs-number">2022</span>/<span class="hljs-number">10</span>/<span class="hljs-number">05</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">36</span> Hey, I&#x27;m a log!<span class="hljs-attribute">main</span>(): <span class="hljs-number">2022</span>/<span class="hljs-number">10</span>/<span class="hljs-number">05</span> <span class="hljs-number">15</span>:<span class="hljs-number">40</span>:<span class="hljs-number">36</span> Hey, I&#x27;m an error log!<span class="hljs-attribute">exit</span> status <span class="hljs-number">1</span></code></pre></div><h2 id="记录到文件">记录到文件</h2><p>除了将日志打印到控制台之外，你可能还希望将日志发送到文件，以便稍后或实时处理这些日志。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;file, err := os.OpenFile(<span class="hljs-string">&quot;info.log&quot;</span>, os.O_CREATE|os.O_APPEND|os.O_WRONLY, <span class="hljs-number">0644</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">defer</span> file.Close()log.SetOutput(file)log.Print(<span class="hljs-string">&quot;Hey, I&#x27;m a log!&quot;</span>)&#125;</code></pre></div><p>最后，可能有 <code>log</code> 包中的函数不足以处理问题的情况。 你可能会发现，使用记录框架而不编写自己的库很有用。 Go 的几个记录框架有 <a href="https://github.com/sirupsen/logrus">Logrus</a>、<a href="https://github.com/rs/zerolog">zerolog</a>、<a href="https://github.com/uber-go/zap">zap</a> 和 <a href="https://github.com/apex/log">Apex</a>。</p><h1>在 Go 中使用方法</h1><p>面向对象编程 (OOP) 是一种广受欢迎的编程模式，大部分编程语言都支持（至少部分支持）。 Go 是其中一种语言，但它并不完全支持所有 OOP 原则。</p><p>Go 中的方法是一种特殊类型的函数，但存在一个简单的区别：你必须在函数名称之前加入一个额外的参数。 此附加参数称为 <em>接收方</em> 。</p><p>如你希望分组函数并将其绑定到自定义类型，则方法非常有用。 Go 中的这一方法类似于在其他编程语言中创建类，因为它允许你实现面向对象编程 (OOP) 模型中的某些功能，例如嵌入、重载和封装。</p><h2 id="声明方法">声明方法</h2><p>到目前为止，你仅将结构用作可在 Go 中创建的另一种自定义类型。 在此模块中你将了解到，通过添加方法你可以将行为添加到你所创建的结构中。</p><p>在声明方法之前，必须先创建结构。 假设你想要创建一个几何包，并决定创建一个名为 <code>triangle</code> 的三角形结构作为此程序包的一个组成部分。 然后，你需要使用一种方法来计算此三角形的周长。 你可以在 Go 中将其表示为：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> triangle <span class="hljs-keyword">struct</span> &#123;size <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t triangle)</span></span> perimeter() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> t.size * <span class="hljs-number">3</span>&#125;</code></pre></div><p>结构看起来像普通结构，但 <code>perimeter()</code> 函数在函数名称之前有一个类型 <code>triangle</code> 的额外参数。 也就是说，在使用结构时，你可以按如下方式调用函数：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;t := triangle&#123;<span class="hljs-number">3</span>&#125;fmt.Println(<span class="hljs-string">&quot;Perimeter:&quot;</span>, t.perimeter())&#125;</code></pre></div><p>如果尝试按平常的方式调用 <code>perimeter()</code> 函数，则此函数将无法正常工作，因为此函数的签名表明它需要接收方。 正因如此，调用此方法的唯一方式是先声明一个结构，获取此方法的访问权限。 这也意味着，只要此方法属于不同的结构，你甚至可以为其指定相同的名称。 例如，你可以使用 <code>perimeter()</code> 函数声明一个 <code>square</code> 结构，具体如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> triangle <span class="hljs-keyword">struct</span> &#123;size <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> square <span class="hljs-keyword">struct</span> &#123;size <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t triangle)</span></span> perimeter() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> t.size * <span class="hljs-number">3</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s square)</span></span> perimeter() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> s.size * <span class="hljs-number">4</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;t := triangle&#123;<span class="hljs-number">3</span>&#125;s := square&#123;<span class="hljs-number">4</span>&#125;fmt.Println(<span class="hljs-string">&quot;Perimeter (triangle):&quot;</span>, t.perimeter())fmt.Println(<span class="hljs-string">&quot;Perimeter (square):&quot;</span>, s.perimeter())&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Perimeter</span> (triangle): <span class="hljs-number">9</span><span class="hljs-attribute">Perimeter</span> (square): <span class="hljs-number">16</span></code></pre></div><p>通过对 <code>perimeter()</code> 函数的两次调用，编译器将根据接收方类型来确定要调用的函数。 这有助于在各程序包之间保持函数的一致性和名称的简短，并避免将包名称作为前缀。</p><h2 id="方法中的指针">方法中的指针</h2><p>有时，方法需要更新变量，或者，如果参数太大，则可能需要避免复制它。 在遇到此类情况时，你需要使用指针传递变量的地址。 在之前的模块中，当我们在讨论指针时提到，每次在 Go 中调用函数时，Go 都会复制每个参数值以便使用。</p><p>如果你需要更新方法中的接收方变量，也会执行相同的行为。 例如，假设你要创建一个新方法以使三角形的大小增加一倍。 你需要在接收方变量中使用指针，具体如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *triangle)</span></span> doubleSize() &#123;t.size *= <span class="hljs-number">2</span>&#125;</code></pre></div><p>如果方法仅可访问接收方的信息，则不需要在接收方变量中使用指针。 但是，依据 Go 的约定，如果结构的任何方法具有指针接收方，则此结构的所有方法都必须具有指针接收方，即使某个方法不需要也是如此。</p><h2 id="声明其他类型的方法">声明其他类型的方法</h2><p>方法的一个关键方面在于，需要为任何类型定义方法，而不只是针对自定义类型（如结构）进行定义。 但是，你不能通过属于其他包的类型来定义结构。 因此，不能在基本类型（如 <code>string</code>）上创建方法。</p><p>尽管如此，你仍然可以利用一点技巧，基于基本类型创建自定义类型，然后将其用作基本类型。 例如，假设你要创建一个方法，以将字符串从小写字母转换为大写字母。 你可以按如下所示写入方法：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-keyword">type</span> upperstring <span class="hljs-type">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s upperstring)</span></span> Upper() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> strings.ToUpper(<span class="hljs-type">string</span>(s))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := upperstring(<span class="hljs-string">&quot;Learning Go!&quot;</span>)fmt.Println(s)fmt.Println(s.Upper())&#125;</code></pre></div><h2 id="嵌入方法">嵌入方法</h2><p>在之前的模块中，您已了解到可以在一个结构中使用属性，并将同一属性嵌入另一个结构中。 也就是说，可以重用来自一个结构的属性，以避免出现重复并保持代码库的一致性。 类似的观点也适用于方法。 即使接收方不同，也可以调用已嵌入结构的方法。</p><p>例如，假设你想要创建一个带有逻辑的新三角形结构，以加入颜色。 此外，你还希望继续使用之前声明的三角形结构。 然后，你可以初始化 <code>coloredTriangle</code> 结构，并从 <code>triangle</code> 结构调用 <code>perimeter()</code> 方法（甚至访问其字段）</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> triangle <span class="hljs-keyword">struct</span> &#123;size <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> coloredTriangle <span class="hljs-keyword">struct</span> &#123;trianglecolor <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t triangle)</span></span> perimeter() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> t.size * <span class="hljs-number">3</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;t := coloredTriangle&#123;triangle&#123;<span class="hljs-number">3</span>&#125;, <span class="hljs-string">&quot;blue&quot;</span>&#125;fmt.Println(<span class="hljs-string">&quot;Size:&quot;</span>, t.size)fmt.Println(<span class="hljs-string">&quot;Perimeter&quot;</span>, t.perimeter())&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Size</span>: <span class="hljs-number">3</span><span class="hljs-attribute">Perimeter</span> <span class="hljs-number">9</span></code></pre></div><h2 id="重载方法">重载方法</h2><p>让我们回到之前讨论过的 <code>triangle</code> 示例。 如果要在 <code>coloredTriangle</code> 结构中更改 <code>perimeter()</code> 方法的实现，会发生什么情况？ 不能存在两个同名的函数。 但是，因为方法需要额外参数（接收方），所以，你可以使用一个同名的方法，只要此方法专门用于要使用的接收方即可。 这就是重载方法的方式。</p><p>如果你仍需要从 <code>triangle</code> 结构调用 <code>perimeter()</code> 方法，则可通过对其进行显示访问来执行此操作</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> triangle <span class="hljs-keyword">struct</span> &#123;size <span class="hljs-type">int</span>&#125;<span class="hljs-keyword">type</span> coloredTriangle <span class="hljs-keyword">struct</span> &#123;trianglecolor <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t coloredTriangle)</span></span> perimeter() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> t.size * <span class="hljs-number">3</span> * <span class="hljs-number">2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t triangle)</span></span> perimeter() <span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> t.size * <span class="hljs-number">3</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;t := coloredTriangle&#123;triangle&#123;<span class="hljs-number">3</span>&#125;, <span class="hljs-string">&quot;blue&quot;</span>&#125;fmt.Println(<span class="hljs-string">&quot;Size:&quot;</span>, t.size)fmt.Println(<span class="hljs-string">&quot;Perimeter (colored)&quot;</span>, t.perimeter())fmt.Println(<span class="hljs-string">&quot;Perimeter (normal)&quot;</span>, t.triangle.perimeter())&#125;</code></pre></div><h2 id="方法中的封装">方法中的封装</h2><p>“封装”表示对象的发送方（客户端）无法访问某个方法。 通常，在其他编程语言中，你会将 <code>private</code> 或 <code>public</code> 关键字放在方法名称之前。 <strong>在 Go 中，只需使用大写标识符，即可公开方法，使用非大写的标识符将方法设为私有方法</strong>。</p><p>Go 中的封装仅在程序包之间有效。 换句话说，你只能隐藏来自其他程序包的实现详细信息，而不能隐藏程序包本身。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geometry<span class="hljs-keyword">type</span> Triangle <span class="hljs-keyword">struct</span> &#123;size <span class="hljs-type">int</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Triangle)</span></span> doubleSize() &#123;t.size *= <span class="hljs-number">2</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Triangle)</span></span> SetSize(size <span class="hljs-type">int</span>) &#123;t.size = size&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Triangle)</span></span> Perimeter() <span class="hljs-type">int</span> &#123;t.doubleSize()<span class="hljs-keyword">return</span> t.size * <span class="hljs-number">3</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;geometry&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;t := geometry.Triangle&#123;&#125;t.SetSize(<span class="hljs-number">3</span>)fmt.Println(<span class="hljs-string">&quot;Perimeter&quot;</span>, t.Perimeter())&#125;</code></pre></div><h1>在 Go 中使用接口</h1><p>Go 中的接口是一种用于表示其他类型的行为的数据类型。 接口类似于对象应满足的蓝图或协定。 在你使用接口时，你的基本代码将变得更加灵活、适应性更强，因为你编写的代码未绑定到特定的实现。 因此，你可以快速扩展程序的功能。</p><p>与其他编程语言中的接口不同，Go 中的接口是满足隐式实现的。 Go 并不提供用于实现接口的关键字，因此，如果你之前使用的是其他编程语言中的接口，但不熟悉 Go，那么此概念可能会造成混淆。</p><h2 id="声明接口">声明接口</h2><p>Go 中的接口是一种抽象类型，只包括具体类型必须拥有或实现的方法。 正因如此，我们说接口类似于蓝图。</p><p>假设你希望在几何包中创建一个接口来指示形状必须实现的方法。 你可以按如下所示定义接口：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Shape <span class="hljs-keyword">interface</span> &#123;    Perimeter() <span class="hljs-type">float64</span>    Area() <span class="hljs-type">float64</span>&#125;</code></pre></div><p><code>Shape</code> 接口表示你想要考虑 <code>Shape</code> 的任何类型都需要同时具有 <code>Perimeter()</code> 和 <code>Area()</code> 方法。 例如，在创建 <code>Square</code> 结构时，它必须实现两种方法，而不是仅实现一种。 另外，请注意接口不包含这些方法的实现细节（例如，用于计算某个形状的周长和面积）。 接口仅表示一种协定。 三角形、圆圈和正方形等形状有不同的计算面积和周长方式。</p><h2 id="实现接口">实现接口</h2><p>正如上文所讨论的内容，你没有用于实现接口的关键字。 当 Go 中的接口具有接口所需的所有方法时，则满足按类型的隐式实现。</p><p>让我们创建一个 <code>Square</code> 结构，此结构具有 <code>Shape</code> 接口中的两个方法</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Square <span class="hljs-keyword">struct</span> &#123;size <span class="hljs-type">float64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Square)</span></span> Area() <span class="hljs-type">float64</span> &#123;<span class="hljs-keyword">return</span> s.size * s.size&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Square)</span></span> Perimeter() <span class="hljs-type">float64</span> &#123;<span class="hljs-keyword">return</span> s.size * <span class="hljs-number">4</span>&#125;</code></pre></div><p>请注意 <code>Square</code> 结构的方法签名与 <code>Shape</code> 接口的签名的匹配方式。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s Shape = Square&#123;<span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, s)fmt.Println(<span class="hljs-string">&quot;Area: &quot;</span>, s.Area())fmt.Println(<span class="hljs-string">&quot;Perimeter:&quot;</span>, s.Perimeter())&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">main</span><span class="hljs-operator">.</span><span class="hljs-built_in">Square</span><span class="hljs-built_in">Area</span><span class="hljs-operator">:</span>  <span class="hljs-number">9</span><span class="hljs-built_in">Perimeter</span><span class="hljs-operator">:</span> <span class="hljs-number">12</span></code></pre></div><p>此时，无论你是否使用接口，都没有任何区别。 接下来，让我们创建另一种类型，如 <code>Circle</code>，然后进行相同的操作：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-keyword">type</span> Shape <span class="hljs-keyword">interface</span> &#123;Perimeter() <span class="hljs-type">float64</span>Area() <span class="hljs-type">float64</span>&#125;<span class="hljs-keyword">type</span> Square <span class="hljs-keyword">struct</span> &#123;size <span class="hljs-type">float64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Square)</span></span> Area() <span class="hljs-type">float64</span> &#123;<span class="hljs-keyword">return</span> s.size * s.size&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Square)</span></span> Perimeter() <span class="hljs-type">float64</span> &#123;<span class="hljs-keyword">return</span> s.size * <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;radius <span class="hljs-type">float64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Circle)</span></span> Area() <span class="hljs-type">float64</span> &#123;<span class="hljs-keyword">return</span> math.Pi * c.radius * c.radius&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Circle)</span></span> Perimeter() <span class="hljs-type">float64</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * math.Pi * c.radius&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printInformation</span><span class="hljs-params">(s Shape)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, s)fmt.Println(<span class="hljs-string">&quot;Area: &quot;</span>, s.Area())fmt.Println(<span class="hljs-string">&quot;Perimeter:&quot;</span>, s.Perimeter())fmt.Println()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> s Shape = Square&#123;<span class="hljs-number">3</span>&#125;printInformation(s)c := Circle&#123;<span class="hljs-number">6</span>&#125;printInformation(c)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">main</span>.Square<span class="hljs-attribute">Area</span>:  <span class="hljs-number">9</span><span class="hljs-attribute">Perimeter</span>: <span class="hljs-number">12</span><span class="hljs-attribute">main</span>.Circle<span class="hljs-attribute">Area</span>:  <span class="hljs-number">113</span>.<span class="hljs-number">09733552923255</span><span class="hljs-attribute">Perimeter</span>: <span class="hljs-number">37</span>.<span class="hljs-number">69911184307752</span></code></pre></div><p>使用接口的优点在于，对于 <code>Shape</code>的每个新类型或实现，<code>printInformation</code> 函数都不需要更改。 正如之前所述，当你使用接口时，代码会变得更灵活、更容易扩展。</p><h2 id="扩展现有实现">扩展现有实现</h2><p>假设你具有以下代码，并且希望通过编写负责处理某些数据的 <code>Writer</code> 方法的自定义实现来扩展其功能。</p><p>通过使用以下代码，你可以创建一个程序，此程序使用 GitHub API 从 Microsoft 获取三个存储库：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;resp, err := http.Get(<span class="hljs-string">&quot;https://api.github.com/users/microsoft/repos?page=15&amp;per_page=5&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;io.Copy(os.Stdout, resp.Body)&#125;</code></pre></div><p>改写后：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-keyword">type</span> GitHubResponse []<span class="hljs-keyword">struct</span> &#123;FullName <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;full_name&quot;`</span>&#125;<span class="hljs-keyword">type</span> customWriter <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w customWriter)</span></span> Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">var</span> resp GitHubResponsejson.Unmarshal(p, &amp;resp)<span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> resp &#123;fmt.Println(r.FullName)&#125;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p), <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;resp, err := http.Get(<span class="hljs-string">&quot;https://api.github.com/users/microsoft/repos?page=15&amp;per_page=5&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;writer := customWriter&#123;&#125;io.Copy(writer, resp.Body)&#125;</code></pre></div><h2 id="编写自定义服务器-API">编写自定义服务器 API</h2><p>最后，我们一起来探讨接口的另一种用例，如果你要创建服务器 API，你可能会发现此用例非常实用。 编写 Web 服务器的常用方式是使用 <code>net/http</code> 程序包中的 <code>http.Handler</code> 接口</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net/http&quot;</span>)<span class="hljs-comment">// 创建 float32 类型的自定义类型，然后编写 String() 方法的自定义实现</span><span class="hljs-keyword">type</span> dollars <span class="hljs-type">float32</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dollars)</span></span> String() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;$%.2f&quot;</span>, d)&#125;<span class="hljs-comment">// 写入 http.Handler 可使用的 ServeHTTP 方法的实现。</span><span class="hljs-keyword">type</span> database <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]dollars<span class="hljs-comment">// 通过使用 database 类型作为接收方来写入 ServeHTTP 方法。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<span class="hljs-keyword">for</span> item, price := <span class="hljs-keyword">range</span> db &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, item, price)&#125;&#125;<span class="hljs-comment">// 在 main() 函数中，我们将 database 类型实例化，并使用一些值对其进行初始化。 我们使用 http.ListenAndServe 函数启动了 HTTP 服务器，在其中定义了服务器地址，包括要使用的端口和实现 ServerHTTP 方法自定义版本的 db 对象。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;db := database&#123;<span class="hljs-string">&quot;Go T-Shirt&quot;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Go Jacket&quot;</span>: <span class="hljs-number">55</span>&#125;log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, db))&#125;</code></pre></div><h1>练习 - 方法和接口</h1><h2 id="创建用于管理在线商店的程序包">创建用于管理在线商店的程序包</h2><p>编写一个程序，此程序使用自定义程序包来管理在线商店的帐户。 你的挑战包括以下四个要素：</p><ol><li>创建一个名为 <code>Account</code> 的自定义类型，此类型包含帐户所有者的名字和姓氏。 此类型还必须加入 <code>ChangeName</code> 的功能。</li><li>创建另一个名为 <code>Employee</code> 的自定义类型，此类型包含用于将贷方数额存储为类型 <code>float64</code> 并嵌入 <code>Account</code> 对象的变量。 类型还必须包含 <code>AddCredits</code>、<code>RemoveCredits</code> 和 <code>CheckCredits</code> 的功能。 你需要展示你可以通过 <code>Employee</code> 对象更改帐户名称。</li><li>将字符串方法写入 <code>Account</code> 对象，以便按包含名字和姓氏的格式打印 <code>Employee</code> 名称。</li><li>最后，编写使用已创建程序包的程序，并测试此挑战中列出的所有功能。 也就是说，主程序应更改名称、打印名称、添加贷方、删除贷方以及检查余额。</li></ol><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> Account <span class="hljs-keyword">struct</span> &#123;firstname <span class="hljs-type">string</span>lastname  <span class="hljs-type">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Account)</span></span> ChangeName(afterfirstname <span class="hljs-type">string</span>) &#123;a.firstname = afterfirstname&#125;<span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;Accountcredit <span class="hljs-type">float64</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> String() <span class="hljs-type">string</span> &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Firstname:%s,Lastname:%s,Credit:%.2f\n&quot;</span>, e.firstname, e.lastname, e.credit)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateEmployee</span><span class="hljs-params">(firstname, lastname <span class="hljs-type">string</span>, credit <span class="hljs-type">float64</span>)</span></span> (*Employee, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">return</span> &amp;Employee&#123;Account&#123;firstname, lastname&#125;, credit&#125;, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Employee)</span></span> AddCredits(amount <span class="hljs-type">float64</span>) (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0.0</span> &#123;e.credit += amount<span class="hljs-keyword">return</span> e.credit, <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>, errors.New(<span class="hljs-string">&quot;invalid amount&quot;</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Employee)</span></span> RemoveCredits(amount <span class="hljs-type">float64</span>) (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<span class="hljs-keyword">if</span> e.credit-amount &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>, errors.New(<span class="hljs-string">&quot;too much&quot;</span>)&#125;<span class="hljs-keyword">if</span> amount &lt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>, errors.New(<span class="hljs-string">&quot;invalid amount&quot;</span>)&#125;e.credit -= amount<span class="hljs-keyword">return</span> e.credit, <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> CheckCredits() <span class="hljs-type">float64</span> &#123;<span class="hljs-keyword">return</span> e.credit&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;bruce, _ := CreateEmployee(<span class="hljs-string">&quot;Bruce&quot;</span>, <span class="hljs-string">&quot;Lee&quot;</span>, <span class="hljs-number">500</span>)fmt.Println(bruce.CheckCredits())credits, err := bruce.AddCredits(<span class="hljs-number">250</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Error:&quot;</span>, err)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(<span class="hljs-string">&quot;New Credits Balance = &quot;</span>, credits)&#125;_, err = bruce.RemoveCredits(<span class="hljs-number">2500</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;Can&#x27;t withdraw or overdrawn!&quot;</span>, err)&#125;bruce.ChangeName(<span class="hljs-string">&quot;Mark&quot;</span>)fmt.Println(bruce)&#125;</code></pre></div><h1>goroutine（轻量线程）</h1><p>并发是独立活动的组合，就像 Web 服务器虽然同时处理多个用户请求，但它是自主运行的。 并发在当今的许多程序中都存在。 Web 服务器就是一个例子，但你也能看到，在批量处理大量数据时也需要使用并发。</p><p>Go 有两种编写并发程序的样式。 一种是在其他语言中通过线程实现的传统样式。</p><h2 id="Go-实现并发的方法">Go 实现并发的方法</h2><p>通常，编写并发程序时最大的问题是在进程之间共享数据。 Go 采用不同于其他编程语言的通信方式，因为 Go 是通过 channel 来回传递数据的。 这意味着只有一个活动 (goroutine) 有权访问数据，设计上不存在争用条件。 学完本模块中的 goroutine 和 channel 之后，你将更好地理解 Go 的并发方法。</p><p>可以使用下面的标语来概括 Go 的方法：“不是通过共享内存通信，而是通过通信共享内存。”</p><h2 id="Goroutine">Goroutine</h2><p>goroutine 是轻量线程中的并发活动，而不是在操作系统中进行的传统活动。 假设你有一个写入输出的程序和另一个计算两个数字相加的函数。 一个并发程序可以有数个 goroutine 同时调用这两个函数。</p><p>我们可以说，程序执行的第一个 goroutine 是 <code>main()</code> 函数。 如果要创建其他 goroutine，则必须在调用该函数之前使用 <code>go</code> 关键字</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    login()    <span class="hljs-keyword">go</span> launch()&#125;</code></pre></div><p>许多程序喜欢使用匿名函数来创建 goroutine</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    login()    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;        launch()    &#125;()&#125;</code></pre></div><h2 id="编写并发程序">编写并发程序</h2><p>由于我们只想将重点放在并发部分，因此我们使用现有程序来检查 API 终结点是否响应。</p><p>串行程序：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;start := time.Now()apis := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;https://management.azure.com&quot;</span>,<span class="hljs-string">&quot;https://dev.azure.com&quot;</span>,<span class="hljs-string">&quot;https://api.github.com&quot;</span>,<span class="hljs-string">&quot;https://outlook.office.com/&quot;</span>,<span class="hljs-string">&quot;https://api.somewhereintheinternet.com/&quot;</span>,<span class="hljs-string">&quot;https://graph.microsoft.com&quot;</span>,&#125;<span class="hljs-keyword">for</span> _, api := <span class="hljs-keyword">range</span> apis &#123;_, err := http.Get(api)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Printf(<span class="hljs-string">&quot;ERROR: %s is down!\n&quot;</span>, api)<span class="hljs-keyword">continue</span>&#125;fmt.Printf(<span class="hljs-string">&quot;SUCCESS: %s is up and running!\n&quot;</span>, api)&#125;elapsed := time.Since(start)fmt.Printf(<span class="hljs-string">&quot;Done! It took %v seconds!\n&quot;</span>, elapsed.Seconds())&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit"><span class="hljs-keyword">SUCCESS: </span>https://management.azure.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://dev.azure.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://api.github.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://outlook.office.com/ is up and running!<span class="hljs-keyword">ERROR: </span>https://api.somewhereintheinternet.com/ is down!<span class="hljs-keyword">SUCCESS: </span>https://graph.microsoft.com is up and running!Done! It took 5.163787068 seconds!</code></pre></div><p>同时检查所有站点？我们需要并发运行的代码部分是向站点进行 HTTP 调用的部分。 换句话说，我们需要为程序要检查的每个 API 创建一个 goroutine。为了创建 goroutine，我们需要在调用函数前使用 <code>go</code> 关键字。</p><p>首先创建一个新函数：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkAPI</span><span class="hljs-params">(api <span class="hljs-type">string</span>)</span></span> &#123;    _, err := http.Get(api)    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;        fmt.Printf(<span class="hljs-string">&quot;ERROR: %s is down!\n&quot;</span>, api)        <span class="hljs-keyword">return</span>    &#125;    fmt.Printf(<span class="hljs-string">&quot;SUCCESS: %s is up and running!\n&quot;</span>, api)&#125;</code></pre></div><p>修改 <code>main()</code> 函数中的代码，为每个 API 创建一个 goroutine</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, api := <span class="hljs-keyword">range</span> apis &#123;<span class="hljs-keyword">go</span> checkAPI(api)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Done</span>! It took <span class="hljs-number">3</span>.<span class="hljs-number">42</span>e-<span class="hljs-number">05</span> seconds!</code></pre></div><p>即使看起来 <code>checkAPI</code> 函数没有运行，它实际上是在运行。 它只是没有时间完成。</p><p>添加 <code>time.Sleep(3 * time.Second)</code></p><div class="code-wrapper"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>https://api.somewhereintheinternet.com/ is down!<span class="hljs-keyword">SUCCESS: </span>https://api.github.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://management.azure.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://dev.azure.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://outlook.office.com/ is up and running!<span class="hljs-keyword">SUCCESS: </span>https://graph.microsoft.com is up and running!Done! It took 3.001536063 seconds!</code></pre></div><h1>将 channel 用作通信机制</h1><p>Go 中的 channel 是 goroutine 之间的通信机制。 这就是为什么我们之前说过 Go 实现并发的方式是：“不是通过共享内存通信，而是通过通信共享内存。”需要将值从一个 goroutine 发送到另一个时，可以使用通道。</p><h2 id="Channel-语法">Channel 语法</h2><p>由于 channel 是发送和接收数据的通信机制，因此它也有类型之分。 这意味着你只能发送 channel 支持的数据类型。 除使用关键字 <code>chan</code> 作为 channel 的数据类型外，还需指定将通过 channel 传递的数据类型，如 <code>int</code> 类型。</p><p>每次声明一个 channel 或希望在函数中指定一个 channel 作为参数时，都需要使用 <code>chan &lt;type&gt;</code>，如 <code>chan int</code>。 要创建 channel，需使用内置的 <code>make()</code> 函数，如下所示：</p><div class="code-wrapper"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</code></pre></div><p>一个 channel 可以执行两项操作：发送数据和接收数据。 若要指定 channel 具有的操作类型，需要使用 channel 运算符 <code>&lt;-</code>。 此外，在 channel 中发送数据和接收数据属于阻止操作。</p><p>如果希望 channel 仅发送数据，则必须在 channel 之后使用 <code>&lt;-</code> 运算符。 如果希望 channel 接收数据，则必须在 channel 之前使用 <code>&lt;-</code> 运算符</p><div class="code-wrapper"><pre><code class="hljs go">ch &lt;- x <span class="hljs-comment">// sends (or write) x through channel ch</span>x = &lt;-ch <span class="hljs-comment">// x receives (or reads) data sent to the channel ch</span>&lt;-ch <span class="hljs-comment">// receives data, but the result is discarded</span></code></pre></div><p>可在 channel 中执行的另一项操作是关闭 channel</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch)</code></pre></div><p>关闭 channel 时，你希望数据将不再在该 channel 中发送。 如果试图将数据发送到已关闭的 channel，则程序将发生严重错误。 如果试图通过已关闭的 channel 接收数据，则可以读取发送的所有数据。 随后的每次“读取”都将返回一个零值。</p><p>使用 channel 来删除睡眠功能并稍做清理：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-comment">// 通过 channel 发送该消息，而不是在 checkAPI 函数中打印结果</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkAPI</span><span class="hljs-params">(api <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;_, err := http.Get(api)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;ERROR: %s is down!\n&quot;</span>, api)<span class="hljs-keyword">return</span>&#125;ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;SUCCESS: %s is up and running!\n&quot;</span>, api)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 创建channel</span>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)start := time.Now()apis := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;https://management.azure.com&quot;</span>,<span class="hljs-string">&quot;https://dev.azure.com&quot;</span>,<span class="hljs-string">&quot;https://api.github.com&quot;</span>,<span class="hljs-string">&quot;https://outlook.office.com/&quot;</span>,<span class="hljs-string">&quot;https://api.somewhereintheinternet.com/&quot;</span>,<span class="hljs-string">&quot;https://graph.microsoft.com&quot;</span>,&#125;<span class="hljs-keyword">for</span> _, api := <span class="hljs-keyword">range</span> apis &#123;<span class="hljs-keyword">go</span> checkAPI(api, ch)&#125;fmt.Print(&lt;-ch)elapsed := time.Since(start)fmt.Printf(<span class="hljs-string">&quot;Done! It took %v seconds!\n&quot;</span>, elapsed.Seconds())&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>https://api.somewhereintheinternet.com/ is down!Done! It took 0.088759104 seconds!</code></pre></div><p>但是事实上并没有实现功能</p><h2 id="无缓冲-channel">无缓冲 channel</h2><p>使用 <code>make()</code> 函数创建 channel 时，会创建一个无缓冲 channel，这是默认行为。 无缓冲 channel 会阻止发送操作，直到有人准备好接收数据。 这就是为什么我们之前说发送和接收都属于阻止操作。 这也是上面的程序在收到第一条消息后立即停止的原因。</p><p>我们可以说 <code>fmt.Print(&lt;-ch)</code> 会阻止程序，因为它从 channel 读取，并等待一些数据到达。 一旦有任何数据到达，它就会继续下一行，然后程序完成。</p><p>其他 goroutine 发生了什么？ 它们仍在运行，但都没有在侦听。 而且，由于程序提前完成，一些 goroutine 无法发送数据。</p><p><strong>读取数据和接收数据都属于阻止操作</strong></p><p>要解决此问题，只需更改循环的代码，然后只接收确定要发送的数据</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-comment">// 通过 channel 发送该消息，而不是在 checkAPI 函数中打印结果</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkAPI</span><span class="hljs-params">(api <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;_, err := http.Get(api)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;ERROR: %s is down!\n&quot;</span>, api)<span class="hljs-keyword">return</span>&#125;ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;SUCCESS: %s is up and running!\n&quot;</span>, api)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 创建channel</span>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)start := time.Now()apis := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;https://management.azure.com&quot;</span>,<span class="hljs-string">&quot;https://dev.azure.com&quot;</span>,<span class="hljs-string">&quot;https://api.github.com&quot;</span>,<span class="hljs-string">&quot;https://outlook.office.com/&quot;</span>,<span class="hljs-string">&quot;https://api.somewhereintheinternet.com/&quot;</span>,<span class="hljs-string">&quot;https://graph.microsoft.com&quot;</span>,&#125;<span class="hljs-keyword">for</span> _, api := <span class="hljs-keyword">range</span> apis &#123;<span class="hljs-keyword">go</span> checkAPI(api, ch)&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(apis); i++ &#123;fmt.Print(&lt;-ch)&#125;elapsed := time.Since(start)fmt.Printf(<span class="hljs-string">&quot;Done! It took %v seconds!\n&quot;</span>, elapsed.Seconds())&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>https://api.somewhereintheinternet.com/ is down!<span class="hljs-keyword">SUCCESS: </span>https://api.github.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://management.azure.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://graph.microsoft.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://dev.azure.com is up and running!<span class="hljs-keyword">SUCCESS: </span>https://outlook.office.com/ is up and running!Done! It took 1.029620196 seconds!</code></pre></div><p>无缓冲 channel 在同步发送和接收操作。 即使使用并发，通信也是同步的。</p><h1>有缓冲 channel</h1><p>默认情况下 channel 是无缓冲行为。 这意味着只有存在接收操作时，它们才接受发送操作。 否则，程序将永久被阻止等待。</p><p>有时需要在 goroutine 之间进行此类同步。 但是，有时你可能只需要实现并发，而不需要限制 goroutine 之间的通信方式。</p><p>有缓冲 channel 在不阻止程序的情况下发送和接收数据，因为有缓冲 channel 的行为类似于队列。 创建 channel 时，可以限制此队列的大小</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, message <span class="hljs-type">string</span>)</span></span> &#123;ch &lt;- message&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;size := <span class="hljs-number">4</span>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, size)send(ch, <span class="hljs-string">&quot;one&quot;</span>)send(ch, <span class="hljs-string">&quot;two&quot;</span>)send(ch, <span class="hljs-string">&quot;three&quot;</span>)send(ch, <span class="hljs-string">&quot;four&quot;</span>)fmt.Println(<span class="hljs-string">&quot;All data sent to the channel ...&quot;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; size; i++ &#123;fmt.Println(&lt;-ch)&#125;fmt.Println(<span class="hljs-string">&quot;Done!&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs livecodeserver">All data sent <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> channel ...<span class="hljs-literal">one</span><span class="hljs-literal">two</span><span class="hljs-literal">three</span><span class="hljs-literal">four</span>Done!</code></pre></div><p>channel 与 goroutine 有着紧密的联系。 如果没有另一个 goroutine 从 channel 接收数据，则整个程序可能会永久处于被阻止状态。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    size := <span class="hljs-number">2</span>    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, size)    send(ch, <span class="hljs-string">&quot;one&quot;</span>)    send(ch, <span class="hljs-string">&quot;two&quot;</span>)    <span class="hljs-keyword">go</span> send(ch, <span class="hljs-string">&quot;three&quot;</span>)    <span class="hljs-keyword">go</span> send(ch, <span class="hljs-string">&quot;four&quot;</span>)    fmt.Println(<span class="hljs-string">&quot;All data sent to the channel ...&quot;</span>)    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;        fmt.Println(&lt;-ch)    &#125;    fmt.Println(<span class="hljs-string">&quot;Done!&quot;</span>)&#125;</code></pre></div><h2 id="无缓冲-channel-与有缓冲-channel">无缓冲 channel 与有缓冲 channel</h2><p>现在，你可能想知道何时使用这两种类型。 这完全取决于你希望 goroutine 之间的通信如何进行。 无缓冲 channel 同步通信。 它们保证每次发送数据时，程序都会被阻止，直到有人从 channel 中读取数据。</p><p>相反，有缓冲 channel 将发送和接收操作解耦。 它们不会阻止程序，但你必须小心使用，因为可能最终会导致死锁（如前文所述）。 使用无缓冲 channel 时，可以控制可并发运行的 goroutine 的数量。 例如，你可能要对 API 进行调用，并且想要控制每秒执行的调用次数。 否则，你可能会被阻止。</p><h2 id="Channel-方向">Channel 方向</h2><p>Go 中 channel 的一个有趣特性是，在使用 channel 作为函数的参数时，可以指定 channel 是要发送数据还是接收数据。 随着程序的增长，可能会使用大量的函数，这时候，最好记录每个 channel 的意图，以便正确使用它们。 或者，你要编写一个库，并希望将 channel 公开为只读，以保持数据一致性。</p><p>要定义 channel 的方向，可以使用与读取或接收数据时类似的方式进行定义。 但是你在函数参数中声明 channel 时执行此操作。 将 channel 类型定义为函数中的参数的语法如下所示：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span> <span class="hljs-comment">// it&#x27;s a channel to only send data</span>&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// it&#x27;s a channel to only receive data</span></code></pre></div><p>通过仅接收的 channel 发送数据时，在编译程序时会出现错误。</p><p>让我们使用以下程序作为两个函数的示例，一个函数用于读取数据，另一个函数用于发送数据：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">send</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>, message <span class="hljs-type">string</span>)</span></span> &#123;    fmt.Printf(<span class="hljs-string">&quot;Sending: %#v\n&quot;</span>, message)    ch &lt;- message&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;    fmt.Printf(<span class="hljs-string">&quot;Receiving: %#v\n&quot;</span>, &lt;-ch)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)    send(ch, <span class="hljs-string">&quot;Hello World!&quot;</span>)    read(ch)&#125;</code></pre></div><p>运行程序时，将看到以下输出：</p><div class="code-wrapper"><pre><code class="hljs avrasm"><span class="hljs-symbol">Sending:</span> <span class="hljs-string">&quot;Hello World!&quot;</span><span class="hljs-symbol">Receiving:</span> <span class="hljs-string">&quot;Hello World!&quot;</span></code></pre></div><p>程序阐明每个函数中每个 channel 的意图。 如果试图使用一个 channel 在一个仅用于接收数据的 channel 中发送数据，将会出现编译错误。 例如，尝试执行如下所示的操作：</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;    fmt.Printf(<span class="hljs-string">&quot;Receiving: %#v\n&quot;</span>, &lt;-ch)    ch &lt;- <span class="hljs-string">&quot;Bye!&quot;</span>&#125;</code></pre></div><p>运行程序时，将看到以下错误：</p><div class="code-wrapper"><pre><code class="hljs vim"># <span class="hljs-keyword">command</span>-<span class="hljs-built_in">line</span>-arguments./main.<span class="hljs-keyword">go</span>:<span class="hljs-number">12</span>:<span class="hljs-number">5</span>: invalid operation: ch &lt;- <span class="hljs-string">&quot;Bye!&quot;</span> (send <span class="hljs-keyword">to</span> receive-<span class="hljs-keyword">only</span> <span class="hljs-built_in">type</span> &lt;-chan <span class="hljs-built_in">string</span>)</code></pre></div><p><strong>编译错误总比误用 channel 好。</strong></p><h2 id="多路复用">多路复用</h2><p>最后，让我们讨论一个关于如何在使用 <code>select</code> 关键字的同时与多个 channel 交互的简短主题。 有时，在使用多个 channel 时，需要等待事件发生。 例如，当程序正在处理的数据中出现异常时，可以包含一些逻辑来取消操作。</p><p><code>select</code> 语句的工作方式类似于 <code>switch</code> 语句，但它适用于 channel。 它会阻止程序的执行，直到它收到要处理的事件。 如果它收到多个事件，则会随机选择一个。</p><p><code>select</code> 语句的一个重要方面是，它在处理事件后完成执行。 如果要等待更多事件发生，则可能需要使用循环。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;time.Sleep(<span class="hljs-number">3</span> * time.Second)ch &lt;- <span class="hljs-string">&quot;Done processing!&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replicate</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;time.Sleep(<span class="hljs-number">1</span> * time.Second)ch &lt;- <span class="hljs-string">&quot;Done replicating!&quot;</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<span class="hljs-keyword">go</span> process(ch1)<span class="hljs-keyword">go</span> replicate(ch2)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> process := &lt;-ch1:fmt.Println(process)<span class="hljs-keyword">case</span> replicate := &lt;-ch2:fmt.Println(replicate)&#125;&#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs erlang-repl">Done replicating!Done processing!</code></pre></div><p>请注意，<code>replicate</code> 函数先完成。 这就是你在终端中先看到其输出的原因。 main 函数存在一个循环，因为 <code>select</code> 语句在收到事件后立即结束，但我们仍在等待 <code>process</code> 函数完成。</p><h1>练习 - 利用并发方法更快地计算斐波纳契数</h1><p>实现并发的改进版本。 完成此操作需要几秒钟的时间（不超过 15 秒），应使用有缓冲 channel。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(number <span class="hljs-type">float64</span>, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;x, y := <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(number); i++ &#123;x, y = y, x+y&#125;r := rand.Intn(<span class="hljs-number">3</span>)time.Sleep(time.Duration(r) * time.Second)ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;Fib(%v): %v\n&quot;</span>, number, x)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">15</span>)start := time.Now()<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">15</span>; i++ &#123;<span class="hljs-keyword">go</span> fib(<span class="hljs-type">float64</span>(i), ch)&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">15</span>; i++ &#123;fmt.Printf(&lt;-ch)&#125;elapsed := time.Since(start)fmt.Printf(<span class="hljs-string">&quot;Done! It took %v seconds!\n&quot;</span>, elapsed.Seconds())&#125;</code></pre></div><p>编写一个新版本以计算斐波纳契数，直到用户使用 fmt.Scanf() 函数在终端中输入 quit。 如果用户按 Enter，则应计算新的斐波纳契数。</p><p>使用两个无缓冲 channel：一个用于计算斐波纳契数，另一个用于等待用户的“退出”消息。 你需要使用 select 语句。</p><div class="code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-keyword">var</span> quit = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;x, y := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> c &lt;- x:x, y = y, x+y<span class="hljs-keyword">case</span> &lt;-quit:fmt.Println(<span class="hljs-string">&quot;Done calculating Fibonacci!&quot;</span>)<span class="hljs-keyword">return</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;start := time.Now()command := <span class="hljs-string">&quot;&quot;</span>data := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<span class="hljs-keyword">go</span> fib(data)<span class="hljs-keyword">for</span> &#123;num := &lt;-datafmt.Println(num)fmt.Scanf(<span class="hljs-string">&quot;%s&quot;</span>, &amp;command)<span class="hljs-keyword">if</span> command == <span class="hljs-string">&quot;quit&quot;</span> &#123;quit &lt;- <span class="hljs-literal">true</span><span class="hljs-keyword">break</span>&#125;&#125;time.Sleep(<span class="hljs-number">1</span> * time.Second)elapsed := time.Since(start)fmt.Printf(<span class="hljs-string">&quot;Done! It took %v seconds!\n&quot;</span>, elapsed.Seconds())&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Backend</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第12讲 支持向量机和排序学习</title>
    <link href="/2022/10/02/UCAS/information-retrieval/information-retrieval-12/"/>
    <url>/2022/10/02/UCAS/information-retrieval/information-retrieval-12/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第12讲 支持向量机和排序学习</p><span id="more"></span><h1>第12讲 支持向量机和排序学习</h1><h2 id="支持向量机">支持向量机</h2><p>线性可分情况下，不仅要区分开，而且要使得区分间隔最大</p><p>最优超平面）是使得两类的分类间隔(Margin)最大的超平面，即每类中离超平面最近的样本到超平面的距离最大。距离这个最优超平面最近的样本被称为支持向量。</p><p>求解最优超平面就相当于，在上述约束条件下,求2/||W||的最大值 ，即以下损失函数最小值</p><p>二次优化问题可以采用Lagrange方法求解</p><p>非线性可分情况下的处理</p><p>广义最优分类面方法：在线性不可分的情况下，就是某些训练样本不能满足约束条件，因此可以在条件中增加一个松弛项ζ(发音Zeta，也称<br>引入Soft Margin，软边界)，变换约束条件。</p><p>变换到高维空间的支持向量机</p><ul><li>SVM训练相对较慢，分类速度一般。但是分类效果较好。</li><li>在面对非线性可分情况时，可以引入松弛变量进行处理或者通过空间变换到另一个线性可分空间进行处理。</li><li>SVM有很多实现工具，SMO/SVM light/SVM torch/LibSVM等等</li></ul><p>为什么要使间隔最大化？</p><ul><li>分界面附近的点代表了不确定的分类决策，分类器会以两边各50%的概率做出决策</li><li>具有很大分类间隔的分类器不会做出确定性很低的决策，它给出了一个分类的安全间隔</li><li>度量中的微小错误和文档中的轻微变化不会导致错误分类</li><li>SVM 分类器：在决策面周围有大的间隔</li><li>与放置(无穷的)决策超平面相比，如果要在类别间放置一个宽间隔，那么选择会少很多</li><li>减少记忆容量、增加测试文档分类泛化能力</li></ul><p>SVM用于支持多类问题：结构化SVM</p><h2 id="排序学习">排序学习</h2><h3 id="基于布尔权重的学习">基于布尔权重的学习</h3><ul><li>词项权重(如tfidf)的目标是为了度量词项的重要性<ul><li>将一篇文档中所有词项的权重加起来便可以计算文档和查询的相关度，基于该相关度可以对所有文档排序</li></ul></li><li>上述过程可以想象成一个文本分类问题<ul><li>词项权重可以从已判定的训练集合中学习得到</li></ul></li><li>上述研究方法被归入一类称为机器学习的相关度或排序学习</li></ul><p>权重学习主要方法：</p><p>给定训练样例集合，每个样例表示为三元组&lt;q, d, R(d,q)&gt;</p><p>从上述样例中学习权重，使得学到的评分接近训练集中的相关性判定结果。</p><h3 id="基于实数权重的学习">基于实数权重的学习</h3><p>评分函数是两个因子的线性组合：</p><ul><li>查询和文档的向量空间相似度评分</li><li>查询词项在文档中存在的最小窗口宽度</li></ul><p>我们的一个因子取决于查询词项在文档中的词袋统计量，另一个因子取决于邻近度权重</p><p>基于机器学习的检索结果排序</p><h3 id="基于序回归的排序学习">基于序回归的排序学习</h3><p>将IR排序问题看成序回归</p><p>对于同一查询，文档之间可以按照相对得分排序即可，并不一定要求每篇文档有一个全局的绝对得分。因此，只需要一个排序，而不要得到相关度的绝对得分，问题空间可以减小。</p><p>排序SVM的构建</p><ul><li>给定一些已经判定的查询</li><li>对训练集中的每条查询q, 我们都有针对该查询的一系列文档集合，这些文档已经由人工按照其与查询的相关度排序</li><li>对每个文档、查询对，构造特征向量 ψj = ψ(dj , q)，这里的特征可以采用前面讨论的特征</li><li>对于两篇文档di 和dj ，可以计算特征向量之间的差异向量</li></ul><h3 id="排序学习总结">排序学习总结</h3><p>排序学习算法现在一般分为以下三类</p><ul><li>Pointwise (即本讲介绍的权重学习方法)：每个文档是一个训练样本，预测文档相关/不相关</li><li>Pairwise （即本讲介绍的序回归方法）：文档对构成一个训练样本，预测一个文档相关性是否高于另一个文档</li><li>Listwise（基于列表的排序学习，未介绍）：一个文档排序列表构成一个训练样本，预测最优排序</li></ul><p>虽然近年来基于深度学习和大规模预训练语言模型的方法已成功应用于IR，排序学习仍然是一种整合不同文本特征的有效方法。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第7章 降维与特征选择</title>
    <link href="/2022/09/30/UCAS/machine-learning/machine-learning-7/"/>
    <url>/2022/09/30/UCAS/machine-learning/machine-learning-7/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第7章 降维与特征选择</p><span id="more"></span><h1>第7章 降维与特征选择</h1><h2 id="概述">概述</h2><p>机器学习算法的有效性和计算复杂度是敏感于数据的特征表达和维度。</p><p>特征降维的意义：</p><p>数据压缩：简化数据表示，加快数据通信传输、节省存储资源、…</p><p>学习算法效率：</p><ul><li>计算上，简化计算，加快速度</li><li>性能上，提升精确度</li><li>可理解性，发现数据的潜在本质特征</li></ul><p>特征选择：从D个特征中选择d个，来表达模式</p><p>特征提取：采用特征变换的方法，生成d个新的特征</p><h2 id="特征选择">特征选择</h2><h3 id="特征选择框架">特征选择框架</h3><p>特征选择问题：从D维特征中选择d维（d&lt;D）特征子集</p><ul><li>使数据的压缩率高</li><li>使学习机预测性能最佳</li><li>使学习机学习速度加快</li></ul><p>特征选择的处理过程：</p><p><a href="https://imgse.com/i/xFNOw8"><img src="https://s1.ax1x.com/2022/09/22/xFNOw8.md.png" alt="xFNOw8.md.png"></a></p><h3 id="特征子集生成">特征子集生成</h3><p>特征子集生成问题：D维特征中，选择d维（d&lt;D）特征子集，子集个数为<img src="https://math.now.sh?inline=C_D%5Ed%3D%5Cfrac%7BD%20!%7D%7B%28D-d%29%20!%20d%20!%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ol><li>穷举（最优子集搜索）：计算特征的所有可能组合，并逐一评价。</li><li>单独最优特征组合：对每个特征分别评估，找前d个单独最优特征。优点：算法简单，缺点：没有考虑特征之间的关系，存在特征冗余</li><li>SFS（Sequential forward selection, 前向序贯）：每次加入一个特征，该特征使得新的特征组合最优。</li><li>GSFS (广义SFS)：每次加入k个特征，使加入特征后的组合最优。</li><li>SBS（Sequential backward selection, 后向序贯）：每次减掉一个特征，使剩余特征组合最优。</li><li>GSBS（广义SBS）：每次减k个特征，使剩余特征组合最优。</li><li>L-R 法（增加L个，减R个）每次增加L个再减R个（L &gt; R），或减R个增加L个（L &lt; R）</li><li>广义的L-R（ZL , ZR）：增L和减R分Z步进行</li></ol><h3 id="特征评价准则">特征评价准则</h3><ol><li>可分性度量：在选择的特征集下，采用类别可分性的程度，评价特征选择的好与坏。常用于Filter框架下。</li><li>学习算法精度的度量：在选择的特征集下，通过学习算法的精确度，评价特征选择的好与坏。常用于wrapper框架下。</li></ol><p>基于距离的可分性判据：</p><p>通常依赖于类内类间的距离度量，前提是数据具有类别标签。可分性评估是在选择的特征子集维度上计算数据统计量。</p><p>距离的可分性判据的特点：</p><ul><li>容易理解和实现</li><li>与错误率无直接关系，不敏感于数据交叠情况</li><li>常用于Filter特征选择框架下</li></ul><p>基于概率分布的可分性判据：从类别概率密度的角度，讨论两个类别的交叠程度</p><p>常见的概率距离准则：</p><p>熵可分性判据：</p><h3 id="特征选择方法">特征选择方法</h3><p>Filter 方法：</p><p>不依赖于学习算法（如分类器）的结果，直接由数据构建评估函数，对选择的特征子集进行评估。</p><p>通常方法：根据特征评价准则进行评估，选择最优的特征子集。</p><p>评价准则：距离准则、概率可分、熵可分准则。</p><p>优点：计算复杂度低，效率高。</p><p>缺点：选择的特征之间存在冗余信息。</p><p>Wrapper 方法：</p><p>原理：通过学习算法（如分类器），对选择的特征子集进行评估。</p><p>优点：选择的特征可以支持学习算法。</p><p>缺点：算法的计算复杂度高。</p><p>Embedded 方法：</p><p>原理：特征选择过程在学习算法中完成，目标是完成学习过程。</p><p>特点：不是专门的特征选择过程</p><p>缺点：计算复杂度高。</p><h2 id="特征提取">特征提取</h2><p>优点：</p><ul><li>数据更紧致的压缩</li><li>优化预测性能</li><li>加快学习速度</li></ul><p>不同的应用问题会有不同的特征提取研究问题</p><h3 id="线性变换">线性变换</h3><p>特征提取目标：学习变换矩阵</p><p>给定 <img src="https://math.now.sh?inline=X%3D%5Cleft%28x_1%2C%20x_2%2C%20%5Cldots%2C%20x_n%5Cright%29%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>, 通过某种降维准则, 学习变换矩阵 <img src="https://math.now.sh?inline=W%3D%5Cleft%28w_1%2C%20w_2%2C%20%5Cldots%2C%20w_d%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>两种降维表示途径：</p><ul><li>投影：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BL%3DXW%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>矩阵分解：低秩表示：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%3DLR%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><h4 id="主成分分析PCA">主成分分析PCA</h4><p>目标函数：均方误差最小原则（求最优重构子空间）</p><p><img src="https://math.now.sh?inline=%5Cmin%20_%7BL%2C%20R%7D%5C%7C%5Cboldsymbol%7BX%7D-%5Cboldsymbol%7BL%7D%20%5Cboldsymbol%7BR%7D%5C%7C%5E2%20%5Cquad" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> s.t. <img src="https://math.now.sh?inline=%5Cboldsymbol%7BR%7D%20%5Cboldsymbol%7BR%7D%5ET%3D%5Cboldsymbol%7BI%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cleft%5C%7C%5Cboldsymbol%7BX%7D-%5Cboldsymbol%7BL%7D%20%5Cboldsymbol%7BW%7D%5ET%5Cright%5C%7C%5E2%3D%5Csum_i%5Cleft%5C%7C%5Cboldsymbol%7Bx%7D_i%5ET-%5Cboldsymbol%7Bl%7D_i%5ET%20%5Cboldsymbol%7BW%7D%5ET%5Cright%5C%7C%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最小误差等价于最大投影</p><p>求解目标函数：<img src="https://math.now.sh?inline=%5Cmax%20%5Cboldsymbol%7B_w%20w%5ET%20S%20w%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>特征值的意义：样本在w方向的投影平均值（或和）最大</p><p>PCA算法流程：</p><ol><li>标准化样本<img src="https://math.now.sh?inline=x_i%3Dx_i-%5Cbar%7Bx%7D%2C%20%5Cquad%20%5Cbar%7Bx%7D%3D%281%20%2F%20n%29%20%5Csum_i%20x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>求样本的协方差矩阵<img src="https://math.now.sh?inline=%5Cboldsymbol%7BXX%5ET%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>特征值，并降排序<img src="https://math.now.sh?inline=%5Clambda_1%3E%5Clambda_2%3E%5Cldots%3E%5Clambda_m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对应非零特征向量</li><li>变换矩阵<img src="https://math.now.sh?inline=%5Cboldsymbol%7BW%3D%5Cleft%28w_1%2C%20w_2%2C%20%5Cldots%2C%20w_l%5Cright%29%7D%2C%20l%3Cm" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>降维表示<img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D%5ET%3D%5Cboldsymbol%7Bx%7D%5ET%20%5Cboldsymbol%7BW%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><h4 id="线性鉴别分析LDA">线性鉴别分析LDA</h4><p>PCA能保证类别区分的有效性，LDA特征的优点：类内最小、类间最大。</p><p>特征方向的提取：<img src="https://math.now.sh?inline=S_w%5E%7B-1%7D%20S_b%20%5Cboldsymbol%7Bw%7D%3D%5Clambda%20%5Cboldsymbol%7Bw%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="非线性变换">非线性变换</h3><h4 id="核主成分分析KPCA">核主成分分析KPCA</h4><ol><li>求核矩阵<img src="https://math.now.sh?inline=K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的特征值，对应特征向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Calpha%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的问题：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BK%5Calpha%7D%3D%5Clambda%5Cboldsymbol%7B%5Calpha%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>核矩阵<img src="https://math.now.sh?inline=K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的特征值降序<img src="https://math.now.sh?inline=%5Clambda_1%3E%5Clambda_2%3E%5Cldots%3E%5Clambda_m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，前<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征值对应特征向量<img src="https://math.now.sh?inline=%5Calpha_1%2C%20%5Calpha_2%2C%20%5Cldots%2C%20%5Calpha_d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>高维空间中的投影方向$w_i=\Phi \boldsymbol{\alpha}_i <img src="https://math.now.sh?inline=%EF%BC%8C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>\boldsymbol{\Lambda}=\left(\boldsymbol{\alpha}_1, \boldsymbol{\alpha}_2, \ldots, \boldsymbol{\alpha}_d\right)<img src="https://math.now.sh?inline=%EF%BC%8C%E6%8A%95%E5%BD%B1%E7%9F%A9%E9%98%B5" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>W=\Phi \boldsymbol{\Lambda}$</li><li>降维表示<ol><li>训练集低维表示：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BL%7D%3D%5CPhi%5ET%20%5Cboldsymbol%7BW%7D%3D%5CPhi%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7B%5CPhi%7D%20%5Cboldsymbol%7B%5CLambda%7D%3D%5Cboldsymbol%7BK%7D%20%5Cboldsymbol%7B%5CLambda%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>新样本<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的低维表示：<img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D%3D%5Cphi%28%5Cboldsymbol%7Bx%7D%29%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7B%5CPhi%7D%20%5Cboldsymbol%7B%5CLambda%7D%3DK(%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7BX%7D)%20%5Cboldsymbol%7B%5CLambda%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>其中<img src="https://math.now.sh?inline=K%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7BX%7D%29%3D%5Cleft(k%5Cleft(%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7Bx%7D_1%5Cright)%2C%20k%5Cleft(%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7Bx%7D_2%5Cright)%2C%20%5Cldots%2C%20k%5Cleft(%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7Bx%7D_n%5Cright)%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol></li></ol><h4 id="局部线性变换LLE">局部线性变换LLE</h4><p>LLE方法是一种流形学习，保持样本间的局部线性关系，整体实现非线性映射。</p><h4 id="非负矩阵分解">非负矩阵分解</h4><p>基本思想：通过矩阵分解，进行数据降维；分解后的矩阵为非负矩阵</p><p>不同的目标函数情况：</p><ol><li>范数误差最小</li><li>KL误差</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第11讲 文本分类</title>
    <link href="/2022/09/30/UCAS/information-retrieval/information-retrieval-11/"/>
    <url>/2022/09/30/UCAS/information-retrieval/information-retrieval-11/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第11讲 文本分类</p><span id="more"></span><h1>第11讲 文本分类</h1><p>常设查询（Standing Queries）</p><p>从检索到文本分类：假设某用户有一个经常关注的信息需求，用户会经常输入这个查询来寻找关于这个主题的新内容，关注于浏览新内容，此时排序问题变成了一个分类问题（相关 vs. 不相关）</p><p><strong>需要构建分类函数</strong></p><h2 id="人工分类">人工分类</h2><p>专家分类一般都是准确的</p><p>当数据规模不大、标注者人数较少时，分类一致</p><p>当数据规模变大，人工分类困难且代价昂贵</p><h2 id="人工编写的基于规则的分类器">人工编写的基于规则的分类器</h2><p>新闻机构，情报机构等使用的一个技术，广泛部署于政府和企业</p><p>供应商提供“ IDE”来编写此类规则，商业系统具有复杂的查询语言</p><p>如果领域专家花时间精心完善规则，则准确性会很高，但是建立和维护这些规则非常昂贵</p><h2 id="有监督学习">有监督学习</h2><p>监督学习分类器可以使用各种特征</p><h3 id="词袋模型">词袋模型</h3><p>仅使用词项特征，使用文本中的所有词项</p><h3 id="特征选择的意义">特征选择的意义</h3><ul><li>文本语料具有大量的词项/特征</li><li>特征选择可以使得某些分类器可用</li><li>减少训练时间</li><li>使运行时模型更小，更快</li><li>可以提高模型泛化能力</li></ul><p>最简单的特征选择方法：</p><ul><li>仅使用最常见词项</li><li>没有特别的（理论）依据</li><li>但是很好理解：<ul><li>这些词的概率可以被很好地估计（因为词频高），并且最常被用作相关性的证据</li><li>在实际应用中，词频特征选择往往能达到一些更高的方法的90%的性能</li></ul></li></ul><p>更聪明的特征选择方法：卡方（chi-square）等</p><h3 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h3><p>朴素贝叶斯分类的目标是寻找具有最大后验概率的类别</p><p>对数计算：通过取对数将原来的乘积计算变成求和计算</p><p>参数估计：极大似然估计</p><p>避免零概率：加一平滑</p><p>朴素贝叶斯对于训练集的大小和测试文档的大小而言是线性的，在某种意义上是最优的。</p><ul><li>相对于其他很多更复杂的学习方法，朴素贝叶斯对不相关特征更具鲁棒性</li><li>相对于其他很多更复杂的学习方法，朴素贝叶斯对概念漂移更鲁棒(概念漂移是指类别的定义随时间变化)</li><li>当有很多同等重要的特征时，该方法优于决策树类方法</li><li>如果满足独立性假设，那么朴素贝叶斯是最优的</li><li>速度非常快、存储开销少</li></ul><p>分类结果的评价：评估必须在独立于训练数据的测试数据上完成</p><p>评价指标：正确率(Precision)，召回率(Recall)，F1，分类准确率r/n ，其中 n 是所有测试文档的数量，r是正确分类的测试文档数量</p><h3 id="向量空间分类">向量空间分类</h3><p>训练集包含一系列文档，每篇都标记着它的类别</p><p>在向量空间分类中，该集合对应着空间中一系列标记的点或向量。</p><p>利用Rocchio方法进行向量空间分类</p><p>基本思想：计算每个类的中心向量（所有文档向量的算术平均），将每篇测试文档分到离它最近的那个中心向量</p><p>Rocchio简单地将每个类别表示成其中心向量，分类基于文档向量到原型的相似度或聚类来进行，并不保证分类结果与训练集一致，即得到分类器后，不能保证训练集中的文档能否正确分类。</p><p>很多情况下，Rocchio的效果不如朴素贝叶斯：Rocchio算法不能正确处理非凸、多模式类别问题</p><h3 id="kNN分类器">kNN分类器</h3><p>将每篇测试文档分给训练集中离它最近的那篇文档所属的类别。</p><ul><li>不需要训练过程，但是文档的线性预处理过程和朴素贝叶斯的训练开销相当。对于训练集来说我们一般都要进行预处理，因此现实当中<br>kNN的训练时间是线性的。</li><li>当训练集非常大的时候，kNN分类的精度很高</li><li>如果训练集很小， kNN可能效果很差。</li><li>kNN倾向于大类，可以将相似度考虑在内来缓解这个问题。</li></ul><h3 id="线性分类器">线性分类器</h3><p>线性分类器计算特征值的一个线性加权和</p><p>很多常用的文本分类器都是线性分类器：朴素贝叶斯、Rocchio、logistic回归、线性SVM等等</p><p>不同的方法选择超平面的策略不同，造成了在测试文档分类性能的巨大差异</p><p>不能通过更强大的非线性分类器来获得更好的分类性能</p><p>不存在某个学习方法对于任何分类问题都最优</p><p>kNN高方差低偏差，而朴素贝叶斯分类器低方差高偏差</p><p>单标签问题：类别之间互斥，每篇文档属于且仅属于某一个类</p><p>多标签分类问题：一篇文档可以属于0、1或更多个类，针对某个类的决策并不影响其他类别上的决策</p><p>对于给定的分类问题，要考虑很多因素从而选择合适的分类器算法。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战-自然语言处理</title>
    <link href="/2022/09/28/UCAS/machine-learning/machine-learning-competition-nlp/"/>
    <url>/2022/09/28/UCAS/machine-learning/machine-learning-competition-nlp/</url>
    
    <content type="html"><![CDATA[<p>机器学习算法竞赛实战-自然语言处理</p><span id="more"></span><h1>第15章 自然语言处理</h1><h2 id="自然语言处理的发展历程">自然语言处理的发展历程</h2><ol><li>1950年到1970年：基于经验、规则的阶段</li><li>1970年到2008年：基于统计方法的阶段</li><li>2008年至今：基于深度学习技术的阶段</li></ol><h2 id="自然语言处理的常见场景">自然语言处理的常见场景</h2><ol><li>分类、回归任务</li><li>信息检索、文本匹配等任务</li><li>序列对序列、序列标注</li><li>机器阅读</li></ol><h2 id="自然语言处理的常见技术">自然语言处理的常见技术</h2><ol><li>基于词袋模型、TF-IDF的特征提取</li><li>N-Gram模型</li><li>词嵌入模型</li><li>上下文相关预训练模型</li><li>常用的深度学习模型结构：TextCNN、BiLSTM+Attention、DPCNN</li></ol><h1>第16章 实战案例</h1>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战-计算广告</title>
    <link href="/2022/09/28/UCAS/machine-learning/machine-learning-competition-advertisement/"/>
    <url>/2022/09/28/UCAS/machine-learning/machine-learning-competition-advertisement/</url>
    
    <content type="html"><![CDATA[<p>机器学习算法竞赛实战-计算广告</p><span id="more"></span><h1>第12章 计算广告</h1><h2 id="什么是计算广告">什么是计算广告</h2><p>计算广告是指借助大数据的分析建模，使得广告能够覆盖广泛区域和实现消费者的多跨度精准曝光，让同一份广告尽可能接触到更多有效的流量和更多对广告感兴趣的人，从而用同样低的成本，让广告的效果尽可能更好，使产品和服务获得更多商业上的成功。</p><h3 id="主要问题">主要问题</h3><p>如何协调广告主、平台和消费者三方之间的利益</p><h3 id="计算广告系统架构">计算广告系统架构</h3><p>在线投放引擎：</p><ul><li>广告检索：Web端发来广告请求时，系统根据该广告位的页面标签或者用户标签从广告索引中查找符合条件的广告。</li><li>广告排序：当出现多个广告主抢夺一个广告位的情况时，需要对投放各个广告可能会产生的效益分别进行预估，对广告进行排序</li></ul><p>分布式计算平台：</p><ul><li>行为定向：挖掘广告投放日志中的用户行为属性</li><li>点击率建模：在分布式计算平台上训练并得到点击率模型的参数和相应特征，用以辅助广告投放系统进行决策</li></ul><p>流式计算平台：</p><ul><li>实时受众定向：将最近一段短时间内发生的用户行为和广告投放日志及时地加工成实时用户标签，用以辅助广告检索模块。</li><li>实时点击反馈：实时反馈用户行为和广告投放日志的变化，主要生成实时点击率相关特征，用以辅助广告检索模块。</li></ul><h2 id="广告类型">广告类型</h2><p>合约广告：包括CPT广告和定向广告。CPT广告指的是按照时间成本计算，广告主以固定的价格买断一段时间内的广告位来展示自己的广告；定向广告指的是广告主选择自己要投放的兴趣标签，然后算法为其匹配相应的受众人群并进行广告投放。</p><p>竞价广告：采用“价高者得”的方案来决策每次展示哪个广告，使得媒体主可以实时对不同广告进行比价，从而最大化收益。</p><p>程序化交易广告：广告主可以实时地在每一次广告展示中选择自己的目标受众，并且参与竞价。</p><h2 id="广告召回">广告召回</h2><p>根据用户或商品属性以及页面上下文属性从广告索引中检索符合投放条件的候选广告。</p><h3 id="广告召回模块">广告召回模块</h3><p>布尔表达式召回：根据广告主设置的定向标签组合成布尔表达式。</p><p>向量检索召回：通过传统的Word2Vec方式获取广告的向量表示，然后通过相似度计算对受众人群进行召回；或者通过深度学习模型获取广告的向量表示。</p><p>基于TDM（深度树匹配模型）的召回：基于深度学习的大规模推荐系统算法框架。</p><p>目前的找回策略大多是多路召回与权重检索相结合。</p><h3 id="DSSM语义召回">DSSM语义召回</h3><p>为用户侧特征和广告侧特征构建不同的塔，在经过多层全连接后，计算相似度并进行广告检索。</p><p>广泛应用于搜索、推荐等领域的召回和排序问题中。</p><h2 id="广告排序">广告排序</h2><p>对广告召回模块送来的广告候选集计算值，并按照所得值的大小倒排序。</p><p>点击率预估：向用户投放一个广告，然后预测用户点击广告的概率</p><p>特征处理：特征交叉组合、连续值特征的处理、点击率平滑、向量化表示</p><p>常见模型：</p><ul><li>FM：隐向量学习提升模型表达</li><li>Wide&amp;Deep：记忆性与泛化性的信息互补</li><li>DeepFM：在FM基础上引入神经网络隐式高阶交叉信息</li><li>DIN：融合Attention机制的深度学习模型</li></ul><h2 id="广告竞价">广告竞价</h2><p>在广告竞拍机制中，广告的实际曝光量取决于广告的流量覆盖大小和在竞争广告中的相对竞争力水平，其中前者取决于广告的人群定向（匹配对应特征的用户数量）、广告素材尺寸（匹配的广告位）以及投放时段、预算等设置项；影响后者的因素主要有出价、广告质量、以及对用户体验的控制策略等。</p><h1>第13章 实战案例</h1><h1>第14章 实战案例</h1>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第5讲 序列数据的深度学习模型</title>
    <link href="/2022/09/28/UCAS/advanced-ai/advanced-ai-5/"/>
    <url>/2022/09/28/UCAS/advanced-ai/advanced-ai-5/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第5讲 序列数据的深度学习模型</p><span id="more"></span><h1>第5讲 序列数据的深度学习模型</h1><h2 id="循环神经网络">循环神经网络</h2><p>序列数据建模：</p><ul><li>学习序列数据，常需要转换输入序列到不同领域的输出序列</li><li>如果没有分离的目标序列，可以通过预测输入序列中的下一项来得到“教师信号”</li><li>预测序列的下一项，模糊了监督学习与非监督学习的差别</li></ul><p>为什么不使用标准的神经网络？</p><ul><li>输入和输出数据在不同例子中可以有不同的长度</li><li>不共享从文本的不同位置上学到的特征</li></ul><p>RNN的特点：</p><ul><li>隐藏状态可以高效存储过去的很多信息</li><li>非线性的状态转移可以允许通过很复杂的方式更新他们的隐藏状态</li></ul><p>一般来说，RNN每一时间的输入和输出是不一样的</p><p>序列学习：对于序列数据是将序列项依次传入，每个序列项再对应不同的输出</p><p>时序展开：在RNN中每一个时间步骤用到的参数都是一样的</p><p>RNN可看作权值共享的多层、前向网络，训练权值约束的前向网络</p><p>Back Propagation Through Time：前向传播和反向传播</p><p>示例：</p><p>语言模型</p><p>新序列采样</p><p>字符级别的语言模型</p><p>序列生成</p><h2 id="长序列的循环神经网络">长序列的循环神经网络</h2><p>训练长序列 (100 time steps) RNN中，梯度很容易膨胀或消散</p><p>即使好的初始化，也难以检测当前目标输出对很多步之前的输入的依赖关系</p><p>GRU</p><p>LSTM：</p><p>解决了RNN长期(like hundreds of time steps)记忆的问题</p><p>LSTM是一个存储单元，使用logistic和linear单元执行乘法运算</p><p>记忆单元：存储RNN的长期信息</p><p>LSTM vs GRU</p><p>GRU是更加简单的模型，更容易创建一个更大的网络，而且它只有两个门，在计算性上也运行得更快，可以扩大模型的规模。</p><p>LSTM更加强大和灵活，有三个门而不是两个。</p><p>双向循环神经网络（Bidirectional RNN）</p><p>深层循环神经网络（Deep RNNs）</p><h2 id="序列模型">序列模型</h2><p>机器翻译</p><p>图片说明</p><p>使用集束搜索（Beam search algorithm）而不使用贪心搜索</p><p>改进集束搜索（Refinements to Beam Search），序列长度归一化</p><p>注意力模型</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第10讲 相关反馈及查询扩展</title>
    <link href="/2022/09/27/UCAS/information-retrieval/information-retrieval-10/"/>
    <url>/2022/09/27/UCAS/information-retrieval/information-retrieval-10/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第10讲 相关反馈及查询扩展</p><span id="more"></span><h1>第10讲 相关反馈及查询扩展</h1><h2 id="动机">动机</h2><p>考虑查询q: [aircraft] . . .</p><p>某篇文档 d 包含“plane”, 但是不包含 “aircraft”</p><p>显然对于查询q，一个简单的IR系统不会返回文档d，即使d是和q最相关的文档</p><p>提高召回率的方法：</p><p>局部(local)方法：对用户查询进行局部的即时的分析</p><p>全局(Global)方法: 进行一次性的全局分析(比如分析整个文档集)来产生同/近义词词典</p><p>关于相关反馈和查询扩展：</p><p>相关反馈的本质是将检索返回的文档的相关性判定(不同的判定来源：人工或非人工)作为返回信息，希望提升检索效果（召回率和正确率）。</p><p>相关反馈常常用于查询扩展，所以提到相关反馈往往默认为有查询扩展</p><p>而查询扩展的最初含义是对查询进行扩充，近年来越来越向查询重构偏移，即现在的查询扩展是指对原有查询进行修改。</p><ul><li>基于相关反馈(局部方法的代表)进行查询扩展/重构</li><li>基于本讲的全局方法进行查询扩展/重构</li><li>局部和全局方法相结合的方法</li></ul><h2 id="相关反馈基础">相关反馈基础</h2><p>相关反馈的基本思想</p><ul><li>用户提交一个(简短的)查询</li><li>搜索引擎返回一系列文档</li><li>用户或系统将部分返回文档标记为相关的，将部分文档标记为不相关的</li><li>搜索引擎根据标记结果计算得到信息需求的一个新查询表示。当然我们希望该表示好于初始的查询表示</li><li>搜索引擎对新查询进行处理，返回新结果，会有更高的召回率</li></ul><p>显式相关反馈：用户显式参加交互过程</p><p>隐式相关反馈：系统跟踪用户的行为来推测返回文档的相关性，从而进行反馈。</p><p>伪相关反馈或盲相关反馈：没有用户参与，系统直接假设返回文档的前k篇是相关的，然后进行反馈。</p><h2 id="相关反馈详细介绍">相关反馈详细介绍</h2><p>相关反馈中的核心概念：矩心</p><p>矩心是一系列点的中心</p><p>Rocchio算法是向量空间模型中相关反馈的实现方式</p><p>相关反馈中的假设：</p><p>假设 A1: 对于某初始查询，用户知道在文档集中使用哪些词项来表达</p><p>假设A2: 相关文档中出现的词项类似 (因此，可以基于相关反馈，从一篇相关文档跳到另一篇相关文档)</p><p>相关反馈的评价：</p><p>基于存留文档集(residual collection)：用户没有判断的文档集</p><p>一轮相关反馈往往非常有用，相对一轮相关反馈，两轮相关反馈效果的提高有限。</p><p>用户相关反馈存在的问题：</p><ul><li>用户相关反馈开销很大<ul><li>相关反馈生成的新查询往往很长</li><li>长查询的处理开销很大</li></ul></li><li>用户不愿意提供显式的相关反馈</li><li>很难理解，为什么会返回(应用相关反馈之后)某篇特定文档</li><li>Excite搜索引擎曾经提供完整的相关反馈功能，但是后来废弃了这一功能</li></ul><p>隐式相关反馈</p><p>通过观察用户对当前检索结果采取的行为来给出对检索结果的相关性判定。</p><p>判定不一定很准确，但是省却了用户的显式参与过程。</p><p>用户行为种类：鼠标键盘动作和用户眼球动作</p><p>隐式相关反馈小结：</p><p>优点：</p><ul><li>不需要用户显式参与，减轻用户负担</li><li>用户行为某种程度上反映用户的兴趣，具有可行性</li></ul><p>缺点：</p><ul><li>对行为分析有较高要求</li><li>准确度不一定能保证</li><li>某些情况下需要增加额外设备</li></ul><p>伪相关反馈</p><p>伪相关反馈对于真实相关反馈的人工部分进行自动化</p><p>伪相关反馈算法：对于用户查询返回有序的检索结果，假定前 k 篇文档是相关的进行相关反馈 (如 Rocchio)</p><p>优点：</p><ul><li>不用考虑用户的因素，处理简单</li><li>很多实验也取得了较好效果</li></ul><p>缺点：</p><ul><li>没有通过用户判断，所以准确率难以保证</li><li>不是所有的查询都会提高效果</li></ul><p>相关反馈小结：</p><ul><li>文档选择：从检索结果中选择相关或不相关文档。用户显式/隐式，或者系统假设。</li><li>词项选择：从相关不相关文档中选择需要处理的词项</li><li>查询扩展/重构：修改原始查询</li></ul><h2 id="查询扩展">查询扩展</h2><p>查询扩展是另一种提高召回率的方法</p><p>使用 “全局查询扩展” 来指那些 “查询重构(query reformulation)的全局方法”</p><p>在全局查询扩展中，查询基于一些全局的资源（同义词或近义词）进行修改，这些资源是与查询无关的</p><p>查询扩展的方法</p><ul><li>基于相关反馈的查询扩展</li><li>人工词典法：通过人工构建的同(近)义词词典 (人工编辑人员维护的词典，如 PubMed)来扩展原始查询</li><li>自动词典法：自动导出的同(近)义词词典 (比如，基于词语的共现统计信息)</li><li>其他外部资源法：比如基于查询日志挖掘出查询等价类(Web上很普遍，比如上面的 “palm” 例子)</li></ul><p>交互式查询扩展 (Interactive QE)：用户通常很懒，用户提交的扩展词项并不一定有用</p><p>基于词项相似度的查询扩展：</p><p>基于候选词和原始查询词项共现 (co-occurrences)的查询扩展</p><p>查询扩展的优点：</p><ul><li>通常可以检索到更多的相关文档</li><li>统计测试表明MAP显著提高</li><li>在伪相关反馈的应用场景下，如果反馈集文档质量很差，会严重降低检索效果</li><li>可能会产生查询漂移</li><li>对于某些查询任务，例如主页搜索，由于相关文档总数非常少，查询扩展通常无效</li></ul><p>使用外部资源进行查询扩展(External QE)</p><p>选择性查询扩展(Selective QE)</p><ul><li>在伪相关反馈应用场景，如果预测反馈集质量很低，则不再执行QE</li><li>适用于对排名靠前文档查准率(early precision)有要求的任务</li></ul><p>搜索引擎中的查询扩展主要依赖的资源：查询日志</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-20220925</title>
    <link href="/2022/09/25/diary/diary20220925/"/>
    <url>/2022/09/25/diary/diary20220925/</url>
    
    <content type="html"><![CDATA[<p><strong>公开于2023年11月19日</strong></p><span id="more"></span><p>四年相识、三年相恋、抵不过些许距离。</p><p>并没有表现得太过于悲伤，甚至都没有留下眼泪。可能是因为从日常的点点滴滴中已经知道这个结果了，最后的两三个月完全就是在硬撑着，我一厢情愿地在努力，但是她的心里早就已经有了答案。</p><p>相识的第一天，2018年9月24日，中秋节。两个人走进教室，拿出简历，面试。面试后一起下楼，简单的说了第一句打招呼的话语，分开。那是第一次见面，内心里有一种悸动，真的似乎有点喜欢。此时的我，刚刚经历了高考的失利，急于在这个看起来与我的能力并不匹配的学校中证明我自己。去竞选班干部，去参加各种学生组织，去认识更多的人，同时也不再压抑内心的感情，积极去找寻自己的爱情。当初对爱情只是懵懂，被拒绝了一次，拒绝了别人一次，有点怕了。有时候我也毫不掩饰我对她的喜欢，去车站接，送奶茶，约出来走走等等。就这样默默暗恋了一年。</p><p>第二年的中秋节，2019年9月13日，我终于鼓起勇气，约出来转到了湖大再转回来，说出了压在心底一年的话。这样就收获了我的初恋。当时的我，并不优秀，对未来一片迷茫，不知道四年大学毕业后要去到哪里。“我们在一无所有的情况下选择去尝试”，我同时也坚定了要共度一生的想法，想要给她今后一个更好的生活，于是我努力学习，从一个将将摸到保研边的中等生，逐渐变成了一个强者，拿下了很好的成绩排名，拿到了学校里面的绝大部分奖项，拿到了国家奖学金，成功保研。因为有了动力，一切都变得理所应当，再苦再累真的值得。</p><p>我们之间的感情没有那么多的激情燃烧，更多的是平淡。我尽量在她需要我的时候出现在她的身边，平时四周转一转，一起去图书馆学习，感冒了送她去医院，脚伤了每天接送，中午晚上点好饭送到身边。我很享受这种平淡的生活，因为我已经认准了她，什么东西都不能减少我对她的爱。我也认为她是和我一样性格的人，有自己的个性，有上进心进取心，不安于现状希望改变。就这样过了两年的美好时光，我们走入了大四的毕业季。</p><p>大四开始的我，松弛了下来，暂时与紧张的学习生活说了再见，开始无底线的放松。而她却要每天准备考研，还有两节课要上。而且由于搬校区的缘故，我见到她并不是很容易了。在这期间有了一些她不怎么讲话的迹象，甚至在我离开长沙和她吃的最后一顿饭上也是心不在焉。我把它归结为考研焦虑，并没有太过在意。也还是因为我对这段感情太有信心了吧，我相信时间距离都不是问题，我们只要努力把自己变得更好，总有一天会克服种种困难生活在一起衣食无忧。这也导致了大四下学期去实习的时候有点忽略了对她的关心，感觉是因为都忙，说的话也变少了。这种下了分手的种子。</p><p>6月正式本科毕业，2022年6月21日，突然的完全不理我，突然的提出分手，我直接崩溃掉。原来她并没有任何的信心，只是我自己自作多情罢了。原来这半年我基本不知道任何有关她的生活，我不知道她实习的工作怎么样，不知道她去面试了教师岗位，不知道她成功考上教师编制。我终于发现了这个问题，但是事实上已经晚了。虽然这一次分手我用回忆挽回，但是并没有打消她的念头，也并没有增加很多她对我的爱。而且由于距离，也阻隔了表达爱的方式。就好像“inception”一样，动了念头就很难再忘记掉了。</p><p>然后是短短四天的青岛旅行，差不多一年以来的首次见面。尤其是最后一天的晚上，最后一次吃饭基本上全程都在看手机。虽然是在修朋友圈的照片，但是我当然也是有一点点不高兴的。从上次几乎分手后我就十分在乎她的感受，但是我从来都没有勇气当面问出这些话语。这样过了两个月，我不断询问她的感受，不断讲给她我现在的想法。然而一切都是没有作用的。不爱了真的就不爱了。2022年9月24日，正式分手。我拼了命的想要挽回，我真的放不下，也不可能放得下三年的感情，换回来的仅仅是“不甜”、“不爱了”如此冰冷的字眼。我也并没有像我想象中的那么悲伤绝望，甚至一滴眼泪都没有落下。也许是因为早已经知道了这个结果吧。但是还是一夜没有睡着觉，真的无法接受这个冰冷的事实。</p><p>人，真的是会变的，会根据环境而变化。上大学的时候我们周围什么都没有，只有彼此。而步入社会，找到了稳定的工作，接触了各种各样的有趣的人，就会重新审视自己之前的生活，自己之前爱过的人。“我想换人了”“我倾向于比较条件，你的条件不如我”“及时止损”如此冰冷的话语，真的很难相信是从她的聊天框里面弹出来的。或许她发现自己面前存在着无数种可能性，为什么还要等着可能一年仅能见几次面，至少还要等上三年的远方的人呢？总之她不再怀念我们共度的三年时光了，毅然放手投入了新生活的怀抱，只能留下我在这里独自悲伤。</p><p>所以什么是爱情？我这几天不断在问自己这个问题。我一直认为爱情是一份承诺，是能克服重重困难一起走下去的勇气。现在我觉得这个想法确实太过于理想化了。可能我自己是这种想法，但是我不能要求别人有完全相同的想法。女孩子可能需要的并不是这种承诺，也不愿意有勇气，更愿意的是就在此时此刻，能有一个人在身边照顾她，关心她，两个人在一起的样子才是爱情。爱情也不可能没有物质需求，如果没有面包，只有爱情 ，那么这段爱情能撑到什么时候呢？如果能有一个人在身边照顾她，不愁吃穿，稳定工作，未来立刻触手可及，有人会不希望过上这种生活吗？可能以前觉得，两个人向着一个目标而努力，最终实现了理想，爱情自然修成了正果。但是如果不努力就能得到爱情，还努力做什么呢？为什么还要体验那种拼搏痛苦的生活，为什么不能躺在现实中直接享受呢？我这个人，对待每一件事情都很认真，对待每一个人也很认真，过于认真就过于理想化，理想化的目标，我能坚持但是并不能保证别人也坚持。世界是很残酷的，人也是很残酷的，坚持初心的人真的很少。</p><p>我的第一段恋爱之旅就这样结束了。我不恨她，她没有什么错误，也从来没有对我做出过任何的承诺，也没有做任何对不起我的事情。只能说，我们的爱情观确实不一致。好的恋爱让我们都成长了很多，学会更好地爱自己、爱他人。如果我还能有下一段爱情，我会更加谨慎地做出选择，没有结果，或者是短期内看不到结果的爱情，我宁愿不要，也不会去轻易去做出承诺，即使我知道我的承诺我一定坚持。</p><p>我不能这样悲伤下去，我要抬头向前看。虽然可能以后都不会有合适的人，合适的爱情，但，还是要过好每一天，珍惜自己现在的生活。最近纠结于这段感情，对父母疏远了一些，但其实他们才是这个世界上真的真的无条件爱我的人，我又有什么理由不爱他们呢？</p><p>放下过去，原谅自己，弥补过错，重新开始。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第6章 聚类分析</title>
    <link href="/2022/09/25/UCAS/machine-learning/machine-learning-6/"/>
    <url>/2022/09/25/UCAS/machine-learning/machine-learning-6/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第6章 聚类分析</p><span id="more"></span><h1>第6章 聚类分析</h1><h2 id="概述">概述</h2><p>聚类是无监督机器学习问题</p><ul><li>目标：感知样本间的相似度，进行类别归纳</li><li>聚类研究的重要应用：1. 潜在类别预测，2. 数据压缩</li><li>既可以作为一个单独过程，用于寻找数据内在的分布结构，也可以作为分类、稀疏表示等其他学习任务的前驱过程。</li></ul><p>影响聚类结果的因素：</p><ol><li>属性选择导致不同结果</li><li>相似性度量是判断样本间、类别间的相似的标准</li><li>聚类规则是样本聚集条件，例如，近邻、损失函数</li></ol><h3 id="相似性度量">相似性度量</h3><p><strong>样本-样本：（向量相似性）</strong></p><p><img src="https://math.now.sh?inline=d_p%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D%5Cleft(%5Csum_%7Bi%3D1%7D%5El%20w_i%5Cleft%7Cx_i-y_i%5Cright%7C%5Ep%5Cright)%5E%7B1%20%2F%20p%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=s_%7B%5Ctext%20%7Bcosine%20%7D%7D%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D%5Cfrac%7B%5Cboldsymbol%7Bx%7D%5ET%20%5Cboldsymbol%7By%7D%7D%7B%5C%7C%5Cboldsymbol%7Bx%7D%5C%7C%5C%7C%5Cboldsymbol%7By%7D%5C%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=r_%7B%5Ctext%20%7BPearson%20%7D%7D%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D%5Cfrac%7B%5Cboldsymbol%7Bx%7D_d%5ET%20%5Cboldsymbol%7By%7D_d%7D%7B%5Cleft%5C%7C%5Cboldsymbol%7Bx%7D_d%5Cright%5C%7C%5Cleft%5C%7C%5Cboldsymbol%7By%7D_d%5Cright%5C%7C%7D%20%5Cquad%20%5Cboldsymbol%7Bx%7D_d%3D%5Cleft%5Bx_1-%5Cbar%7Bx%7D%2C%20%5Cldots%2C%20x_l-%5Cbar%7Bx%7D%5Cright%5D%5ET%20%5Cquad%20%5Cboldsymbol%7By%7D_d%3D%5Cleft%5By_1-%5Cbar%7By%7D%2C%20%5Cldots%2C%20y_l-%5Cbar%7By%7D%5Cright%5D%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=s_T%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D%5Cfrac%7B1%7D%7B1%2B%5Cfrac%7B(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7By%7D)%5ET(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7By%7D)%7D%7B%5Cboldsymbol%7Bx%7D%5ET%20%5Cboldsymbol%7By%7D%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>样本-集合：</strong></p><ol><li>集合为离散点集</li></ol><p>到集合最远点距离：<img src="https://math.now.sh?inline=d%28x%2C%20C%29%3D%5Cmax%20_%7By%20%5Cin%20C%7D%20d(x%2C%20y)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>到集合最近点距离：<img src="https://math.now.sh?inline=d%28x%2C%20C%29%3D%5Cmin%20_%7By%20%5Cin%20C%7D%20d(x%2C%20y)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>到集合平均点距离：<img src="https://math.now.sh?inline=d%28x%2C%20C%29%3D%5Cfrac%7B1%7D%7B%7CC%7C%7D%20%5Csum_%7B%5Cmathrm%7By%7D%20%5Cin%20%5Cmathrm%7BC%7D%7D%20d(x%2C%20y)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ol start="2"><li>集合为连续区域</li></ol><p>集合为平面：<img src="https://math.now.sh?inline=d%28x%2C%20H%29%3D%5Cmin%20_%7Bz%20%5Cin%20H%7D%20d(x%2C%20z)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>集合为圆：<img src="https://math.now.sh?inline=d%28x%2C%20Q%29%3D%5Cmin%20_%7Bz%20%5Cin%20Q%7D%20d(x%2C%20z)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>集合-集合：（类间距离）</strong></p><p>集合间最远点距离：<img src="https://math.now.sh?inline=d_%7B%5Cmax%20%7D%5Cleft%28C_i%2C%20C_j%5Cright%29%3D%5Cmax%20_%7Bx%20%5Cin%20C_i%2C%20y%20%5Cin%20C_j%7D%20d(%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>集合间最近点距离：<img src="https://math.now.sh?inline=d_%7B%5Cmin%20%7D%5Cleft%28C_i%2C%20C_j%5Cright%29%3D%5Cmin%20_%7Bx%20%5Cin%20C_i%2C%20y%20%5Cin%20C_j%7D%20d(%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>集合间所有点平均距离：<img src="https://math.now.sh?inline=d_%7Ba%20v%20g%7D%5E%7Bs%20s%7D%5Cleft%28C_i%2C%20C_j%5Cright%29%3D%5Cfrac%7B1%7D%7B%5Cleft%7CC_i%5Cright%7C%5Cleft%7CC_j%5Cright%7C%7D%20%5Cquad%20%5Csum_%7Bx%20%5Cin%20C_i%2C%20y%20%5Cin%20C_j%7D%20d(%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>集合表征点间距离（如平均值）：<img src="https://math.now.sh?inline=d_%7Bc%20e%20n%7D%5Cleft%28C_i%2C%20C_j%5Cright%29%3Dd%5Cleft(%5Cboldsymbol%7B%5Cmu%7D_i%2C%20%5Cboldsymbol%7B%5Cmu%7D_j%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>集合内样本间距离（类内距离）：<img src="https://math.now.sh?inline=%5Coperatorname%7Bavg%7D%28C%29%3D%5Cfrac%7B2%7D%7B%7CC%7C(%7CC%7C-1)%7D%20%5Csum_%7B1%20%5Cleqslant%20i%3Cj%20%5Cleqslant%7CC%7C%7D%20%5Coperatorname%7Bdist%7D%5Cleft(%5Cboldsymbol%7Bx%7D_i%2C%20%5Cboldsymbol%7Bx%7D_j%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="性能度量">性能度量</h3><p>聚类性能的外部指标指通过已知类簇划分，对聚类结果进行评价；判别同类别样本对标签一致与否，避免相同类簇划分，不同标签名称导致的不一致。</p><p>Jaccard系数、FM系数和Rand系数</p><p>聚类性能的内部指标：没有已知的类簇划分进行参考，通过聚类具有的类内相似和类间相异的特点进行评价。</p><p>DB指数：<img src="https://math.now.sh?inline=%5Cmathrm%7BDBI%7D%3D%5Cfrac%7B1%7D%7Bk%7D%20%5Csum_%7Bi%3D1%7D%5Ek%20%5Cmax%20_%7Bj%20%5Cneq%20i%7D%5Cleft%28%5Cfrac%7B%5Coperatorname%7Bavg%7D%5Cleft(C_i%5Cright%29%2B%5Coperatorname%7Bavg%7D%5Cleft(C_j%5Cright)%7D%7Bd_%7B%5Coperatorname%7Bcen%7D%7D%5Cleft(%5Cboldsymbol%7B%5Cmu%7D_i%2C%20%5Cboldsymbol%7B%5Cmu%7D_j%5Cright)%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，越小越好</p><p>Dunn指数：<img src="https://math.now.sh?inline=%5Cmathrm%7BDI%7D%3D%5Cmin%20_%7B1%20%5Cleqslant%20i%20%5Cleqslant%20k%7D%5Cleft%5C%7B%5Cmin%20_%7Bj%20%5Cneq%20i%7D%5Cleft%28%5Cfrac%7Bd_%7B%5Cmin%20%7D%5Cleft(C_i%2C%20C_j%5Cright%29%7D%7B%5Cmax%20_%7B1%20%5Cleqslant%20l%20%5Cleqslant%20k%7D%20%5Coperatorname%7Bdiam%7D%5Cleft(C_l%5Cright)%7D%5Cright)%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，越大越好</p><h2 id="序贯方法">序贯方法</h2><p>基本思想：逐一比较单个样本与类簇的相似性，有相似类则归类，无相似类则建立新类。</p><p>优点：一种简单的，快速算法</p><p>相似性的关键度量：类别相似性：样本—类簇（样本—集合）。</p><p>缺点：所有样本过滤一遍后才知道类别总数，而先出现的样本不能找到（后出现的）合适类别</p><p>改进算法：采用两个阶段，类别确定、分类。</p><p>两阶段序贯方法：</p><p>缺点：以上两种方法依赖于阈值</p><p>改进方法：弱化阈值作用，采用两个阈值，形成灰色带。</p><p>双阈值序贯方法</p><p>三种算法缺点：</p><ol><li>当类别一旦产生，不可变，尽管后来类簇增加，类别很相近也无法合并。</li><li>敏感于样本顺序，样本类别未必是最合适的。</li></ol><p>增强算法</p><p>增强处理1：对类别集合进行合并操作</p><p>增强处理2：对样本类别重置</p><h2 id="层次聚类">层次聚类</h2><p>基本思想：</p><p>聚类嵌套定义：<img src="https://math.now.sh?inline=R_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=R_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是样本集<img src="https://math.now.sh?inline=X" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的两种聚类划分，如果<img src="https://math.now.sh?inline=R_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中所有的类簇都是<img src="https://math.now.sh?inline=R_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中类簇的子集，则称<img src="https://math.now.sh?inline=R_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>嵌套在<img src="https://math.now.sh?inline=R_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>内，记作<img src="https://math.now.sh?inline=R_1%20%5Csubset%20R_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>层次聚类策略：类簇之间（依据相似性）不断合并、或不断的分化, 直到满足聚类停止条件。</p><p>自底向上/归并算法：</p><p>第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次迭代：计算所有两个类簇的相似性，归并最相似的两个类簇，更新类别划分<img src="https://math.now.sh?inline=R_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>缺点：没有归并的类簇间相似性，被重复计算</p><p>基于矩阵的归并算法</p><p>利用矩阵记录类簇间的相似性</p><ul><li>删除对应合并的两行和列</li><li>增加一行和列： 新类簇与其他类簇的相似度</li></ul><p>优点：不必重新计算“没有合并的类簇间”的相似性</p><p>分化算法：过程与归并相反</p><p>第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次迭代：在所有类簇的所有划分中，计算所有两个类簇相似性，选择最不相似的类簇集合划分，更新类别划分<img src="https://math.now.sh?inline=R_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>缺点：没有划分的类簇间相似性，被重复计算</p><p>如何确定聚类个数？</p><h2 id="K均值聚类">K均值聚类</h2><p>Kmeans：将样本分给最近的类心，然后重新调整类心；通过多次迭代，逐步进行类别划分。</p><p>最优准则：最小化误差平方和<img src="https://math.now.sh?inline=J%20e%3D%5Csum_%7Bi%3D1%7D%5EK%20%5Csum_%7By%20%5Cin%20C_i%7D%5Cleft%5C%7C%5Cboldsymbol%7By%7D-%5Cboldsymbol%7Bm%7D_i%5Cright%5C%7C%5E2%3D%5Csum_%7Bi%3D1%7D%5EK%20J%20e_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_i%3D%5Cfrac%7B1%7D%7BN_i%7D%20%5Csum_%7By%20%5Cin%20C_i%7D%20%5Cboldsymbol%7By%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D%20%5Cin%20C_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 是第<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bi%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个类簇的样本。</p><p>一般方法：最近类心原则，批量划分后修正类心</p><p>改进方法：单个划分最优原则，单个划分后修正类心</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第9讲 完整搜索系统中的评分计算</title>
    <link href="/2022/09/24/UCAS/information-retrieval/information-retrieval-9/"/>
    <url>/2022/09/24/UCAS/information-retrieval/information-retrieval-9/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第9讲 完整搜索系统中的评分计算</p><span id="more"></span><h1>第9讲 完整搜索系统中的评分计算</h1><p>不排序的问题严重性</p><ul><li>用户只希望看到一些而不是成千上万的结果</li><li>很难构造只产生一些结果的查询</li><li>即使是专家也很难</li><li>排序能够将成千上万条结果缩减至几条结果，因此非常重要</li></ul><p>排序的重要性：</p><ul><li>摘要阅读(Viewing abstracts)：用户更可能阅读第一页的结果的摘要</li><li>点击(Clicking)：点击的分布甚至更有偏向性<ul><li>一半情况下，用户点击排名最高的页面</li><li>即使排名最高的页面不如排名第二的页面相关，仍然有接近30%的用户会点击它。</li></ul></li><li>正确排序相当重要</li><li>排对最高的页面非常重要</li></ul><h2 id="结果排序的实现">结果排序的实现</h2><p>倒排索引中的词项频率存储</p><ul><li>每条倒排记录中，除了docIDd 还要存储tft,d</li><li>通常存储的是原始的整数词频，而不是对数词频对应的实数值<ul><li>这是因为实数值不易压缩</li></ul></li><li>对tf采用一元码编码效率很高</li><li>总体而言，额外存储tf所需要的开销不是很大：采用位编码压缩方式，每条倒排记录增加不到一个字节的存储量</li><li>或者在可变字节码方式下每条倒排记录额外需要一个字节即可</li></ul><p>两种常见的评分累加算法：</p><p>以词项为单位(term-at-a-time, TAAT)，首先获得词项t的posting list，然后累加得分</p><p>以文档为单位的计算，首先获得包含查询词的所有文档，将这些文档按照静态评分排序，然后依次累加得分</p><p>精确top K检索及其加速办法：</p><p>目标：从文档集的所有文档中找出K个离查询最近的文档</p><p>步骤：对每个文档评分(余弦相似度)，按照评分高低排序，选出前K个结果</p><p>加速方法：</p><p>快速计算余弦：不考虑查询词项的权重</p><p>堆法N中选K：不对所有文档进行排序，只需要挑出最高的K个结果</p><p>提前终止计算：得到了top K结果，不需要再进行后续计算</p><p>精确topK检索的问题：仍然无法避免大量文档参与计算</p><p>非精确topK检索：非精确topK的结果如果和精确topK的结果相似度相差不大，应该也能让用户满意</p><p>找一个文档集合A，K&lt;|A|&lt;&lt;N，利用A中的top K结果代替整个文档集的top K结果</p><p>方法一：索引去除</p><p>从查询词的角度：只考虑那些包含高idf查询词项的文档</p><p>从文档的角度：只考虑那些包含多个查询词项的文档</p><p>仅考虑高idf词项、仅考虑包含多个词项的文档</p><p>方法二：胜者表</p><p>对每个词项t，预先计算出其倒排记录表中权重最高的r篇文档，如果采用tfidf机制，即tf最高的r篇</p><p>方法三：静态质量得分排序方式</p><p>为每篇文档赋予一个与查询无关的[0,1]之间的值，记为g(d)，例如Pagerank</p><p>最终文档排名基于g(d)和相关度的线性组合</p><p>目标是找net-score最高的top K文档</p><p>方法四：影响度(Impact)排序</p><p>提前结束法：</p><p>遍历倒排记录表时，可以在如下情况之一发生时停止：</p><ul><li>遍历了固定的文档数目r</li><li>wft,d 低于某个预定的阈值</li><li>将每个词项的结果集合合并</li><li>仅计算合并集合中文档的得分</li></ul><p>将词项按照idf排序：</p><ul><li>对于多词项组成的查询，按照idf从大到小扫描词项</li><li>在此过程中，会不断更新文档的得分(即本词项的贡献)，如果文档得分基本不变的话，停止</li><li>可以应用于余弦相似度或者其他组合得分</li></ul><p>方法五： 簇剪枝</p><p>随机选 <img src="https://math.now.sh?inline=%5Csqrt%20N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>篇文档作为先导者，对于其他文档，计算和它最近的先导者</p><p>非docID的倒排记录表排序方法</p><p>与查询无关的一种反映结果好坏程度的指标</p><p>以文档为单位(Document-at-a-time)的处理、以词项为单位(Term-at-a-time)的处理方式</p><p>WAND（Weak AND） 评分算法</p><ul><li>实验表明, WAND 可以降低 90% 以上的评分计算开支</li><li>WAND并非仅仅适用于cosine评分排序</li><li>WAND 及其不同的改进版能够满足安全排序（Safe Ranking, 即精确排序）</li></ul><h2 id="完整的搜索系统">完整的搜索系统</h2><p>多层次索引基本思路:</p><ul><li>建立多层索引，每层对应索引词项的重要性</li><li>查询处理过程中，从最高层索引开始</li><li>如果最高层索引已经返回至少k (比如, k = 100)个结果，那么停止处理并将结果返回给用户</li><li>如果结果 &lt; k 篇文档，那么从下一层继续处理，直至索引用完或者返回至少k 个结果为止</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战-时间序列</title>
    <link href="/2022/09/24/UCAS/machine-learning/machine-learning-competition-time/"/>
    <url>/2022/09/24/UCAS/machine-learning/machine-learning-competition-time/</url>
    
    <content type="html"><![CDATA[<p>机器学习算法竞赛实战-时间序列</p><span id="more"></span><h1>第9章 时间序列</h1><h2 id="什么是时间序列">什么是时间序列</h2><p>时间序列是按时间顺序索引（或列出或图示）的一系列数据点。组成时间序列的数据由相对确定的时间戳组成。</p><p>对时间序列的分析基于以下假设：数据文件中标签的数据值表示以等间隔时间进行的连续测量值。假设数据存在相关性，然后通过建模找到对应的相关性，并利用它预测未来的数据走向。</p><p>可以从变量角度将这些问题归纳为单变量时间序列和多变量时间序列</p><p>可以从预测目标角度将这些问题归纳为单步预测和多步预测</p><p>单变量时间序列仅具有单个时间相关变量，所以仅受时间因素的影响。这类问题重点在于分析数据的变化特点，受相关性、趋势性、周期性和循环性等因素的影响。</p><p>多变量时间序列具有多个时间相关变量，除了受时间因素的影响，还受其他变量的影响。需要考虑更多的因素，挑战也更大。</p><p>单步预测问题比较基础，仅在训练集的时间基础上添加一个时间单位便可以作为测试集</p><p>多步预测问题比较复杂，是在训练集的时间基础上添加多个时间单位作为测试集</p><p>交叉验证的时候为了保留时间相关性，需要采用滚动交叉验证的方式：</p><ul><li>首先使用初始时间到t时刻的数据来训练模型</li><li>然后用从t到t+n时刻的数据进行线下验证，并计算评价指标的分数</li><li>将训练样本扩展到t+n时刻，用从t+n到t+2n时刻的数据进行验证</li><li>不断重复，直到达到最后一个可用的标签值</li></ul><h3 id="基本规则方法">基本规则方法</h3><p>加权平均：离当前时间点越近的数据的重要性越高</p><p>指数平滑：将每个时间单位的权重按照指数级进行衰减（指数平滑像是拥有无限记忆且权值呈指数级递减的移动平均法）</p><h2 id="时间序列模式">时间序列模式</h2><p>趋势性：在很长一段时间内呈现的数据持续上升或持续下降的变动</p><p>周期性：在一段时间序列内重复出现的波动，是各种因素综合影响的结果。</p><p>相关性：在某一段序列往往存在正相关或负相关，前后时间点会有很大的关联</p><p>随机性：除了上述三种模式外的随机扰动</p><h2 id="特征提取方式">特征提取方式</h2><p>历史平移：直接将历史记录作为特征</p><p>窗口统计：从多个序列单位中提取特征</p><p>序列熵特征：描述序列的确定性和不确定性</p><p>还有时间特征与统计特征</p><h2 id="模型的多样性">模型的多样性</h2><p>传统的时序模型：ARIMA（差分自回归滑动平均模型）</p><p>树模型：对时间序列进行平稳性调整</p><p>深度学习模型</p><ul><li>卷积神经网络</li><li>长短期记忆网络</li></ul><h1>第10章 实战案例</h1><h1>第11章 实战案例</h1>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第5章 回归分析</title>
    <link href="/2022/09/22/UCAS/machine-learning/machine-learning-5/"/>
    <url>/2022/09/22/UCAS/machine-learning/machine-learning-5/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第5章 回归分析</p><span id="more"></span><h1>第5章 回归分析</h1><h2 id="概述">概述</h2><p>回归问题：</p><p>根据给定的训练集<img src="https://math.now.sh?inline=T%3D%5Cleft%5C%7B%5Cleft%28%5Cboldsymbol%7Bx%7D_1%2C%20y_1%5Cright%29%2C%20%5Ccdots%2C%5Cleft(%5Cboldsymbol%7Bx%7D_l%2C%20y_l%5Cright)%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D_i%20%5Cin%20C%3DR%5En%2C%20%5Cquad%20y_i%20%5Cin%20%5Cmathrm%7BY%7D%3DR%2C%20%5Cquad%20i%3D1%2C2%2C%20%5Cldots%2C%20l" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（预测的结果<img src="https://math.now.sh?inline=y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是连续函数值）</p><p>要求寻找<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的决策函数<img src="https://math.now.sh?inline=f%28x%29%3A%20%5Cmathrm%7BC%7D%20%5Crightarrow%20%5Cmathrm%7BY%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>性能评价：</p><p>均方误差：<img src="https://math.now.sh?inline=E%28f%20%3B%20D%29%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5Em%5Cleft(f%5Cleft(%5Cboldsymbol%7Bx%7D_i%5Cright)-y_i%5Cright)%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>泛化误差可分解为偏差、方差和噪声之和</p><p>线性回归原理：使用线性函数来预测数据的分布</p><h2 id="最小二乘估计">最小二乘估计</h2><p>目标函数：最小误差平方和</p><p><img src="https://math.now.sh?inline=%5Cmin%20_%5Ctheta%20%5Csum_%7Bt%3D1%7D%5En%5Cleft%28y_t-%5Ctheta%5ET%20%5Cmathrm%7Bx%7D_t-%5Ctheta_0%5Cright%29%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>求解：<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%5Chat%7B%5Ctheta%7D%20%5C%5C%20%5Chat%7B%5Ctheta%7D_0%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%28%5Cmathbf%7BX%7D%5ET%20%5Cmathbf%7BX%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5ET%20%5Cmathbf%7By%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="最大似然估计">最大似然估计</h2><p>正态分布假设的似然函数</p><p>误差服从正态分布：<img src="https://math.now.sh?inline=y_t%3D%5Ctheta%5ET%20%5Cmathbf%7Bx%7D_t%2B%5Ctheta_0%2B%5Cepsilon_t%2C%20%5Cquad%20t%3D1%2C%20%5Cldots%2C%20n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>似然函数：<img src="https://math.now.sh?inline=L%5Cleft%28%5Ctheta%2C%20%5Ctheta_0%2C%20%5Csigma%5E2%5Cright%29%3D%5Cprod_%7Bt%3D1%7D%5En%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%20%5Csigma%5E2%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E2%7D%5Cleft(y_t-%5Ctheta%5ET%20%5Cmathbf%7Bx%7D_t-%5Ctheta_0%5Cright)%5E2%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，可以转换为对数的形式</p><p>高斯误差的最大似然估计<img src="https://math.now.sh?inline=%5Cunderset%7B%5Ctheta%7D%7B%5Cmax%20%7D-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E2%7D%20%5Csum_%7Bt%3D1%7D%5En%5Cleft%28y_t-%5Ctheta%5ET%20%5Cmathbf%7Bx%7D_t-%5Ctheta_0%5Cright%29%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>=最小二乘估计</p><p>优化学习：梯度下降方法</p><h2 id="最大后验估计">最大后验估计</h2><p>正态分布的先验似然函数：<img src="https://math.now.sh?inline=p%5Cleft%28y%20%5Cmid%20%5Cmathbf%7Bx%7D%2C%20%5Ctheta%2C%20%5Ctheta_0%5Cright%29%3DL%5Cleft(%5Ctheta%2C%20%5Ctheta_0%2C%20%5Csigma%5E2%5Cright)%3D%5Cprod_%7Bt%3D1%7D%5En%20%5Cfrac%7B1%7D%7B%5Csqrt%7B2%20%5Cpi%20%5Csigma%5E2%7D%7D%20%5Cexp%20%5Cleft(-%5Cfrac%7B1%7D%7B2%20%5Csigma%5E2%7D%5Cleft(y_t-%5Ctheta%5ET%20%5Cmathbf%7Bx%7D_t-%5Ctheta_0%5Cright)%5E2%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最大后验估计目标函数：<img src="https://math.now.sh?inline=%5Cmin%20_%5Ctheta%20%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bt%3D1%7D%5En%5Cleft%28y_t-%5Ctheta%5ET%20%5Cmathrm%7Bx%7D_t-%5Ctheta_0%5Cright%29%5E2%2B%5Cfrac%7B%5Clambda%7D%7B2%7D%5C%7C%5Ctheta%5C%7C%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Clambda%3D%5Cfrac%7B%5Csigma%5E2%7D%7B%5Csigma_%5Ctheta%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>高斯分布的最大后验估计 = 正则化最小二乘估计</p><p>正则化最小二乘估计解：<img src="https://math.now.sh?inline=%5Cmin%20_%5Ctheta%20%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bt%3D1%7D%5En%5Cleft%28y_t-%5Ctheta%5ET%20%5Cmathrm%7Bx%7D_t-%5Ctheta_0%5Cright%29%5E2%2B%5Cfrac%7B%5Clambda%7D%7B2%7D%5C%7C%5Ctheta%5C%7C%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%5Chat%7B%5Ctheta%7D%20%5C%5C%20%5Chat%7B%5Ctheta%7D_0%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%28%5Cmathbf%7BX%7D%5ET%20%5Cmathbf%7BX%7D%2B%5Clambda%20%5Cmathbf%7BI%7D%5Cright%29%5E%7B-1%7D%20%5Cmathbf%7BX%7D%5ET%20%5Cmathbf%7By%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>正则项解决过拟合问题</p><h2 id="扩展的非线性模型">扩展的非线性模型</h2><p>线性基函数回归</p><p>线性回归：<img src="https://math.now.sh?inline=y%28%5Cmathbf%7Bx%7D%2C%20%5Cmathbf%7Bw%7D%29%3Dw_0%2Bw_1%20x_1%2B%5Cldots%2Bw_D%20x_D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>扩展的非线性回归：<img src="https://math.now.sh?inline=y%28%5Cmathrm%7Bx%7D%2C%20%5Cmathrm%7Bw%7D%29%3Dw_0%2B%5Csum_%7Bj%3D1%7D%5E%7BM-1%7D%20w_j%20%5Cphi_j(%5Cmathrm%7Bx%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>基函数形式：多项式函数、高斯分布函数、sigmoid类型的函数、tanh类型的函数</p><p>多项式回归：<img src="https://math.now.sh?inline=y%28x%2C%20%5Cmathbf%7Bw%7D%29%3Dw_0%2Bw_1%20x%2Bw_2%20x%5E2%2B%5Cldots%2Bw_M%20x%5EM%3D%5Csum_%7Bj%3D0%7D%5EM%20w_j%20x%5Ej" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="误差分析">误差分析</h2><p>正则项对Bias和Variance的影响</p><p>参数估计</p><p>最小二乘估计是无偏估计</p><p>正则化最小二乘估计是有偏估计</p><p>使得参数估计更加稳定</p><p>相当于增加正则项</p><p>相当于加入白噪声</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第4讲 图像数据的深度学习模型</title>
    <link href="/2022/09/22/UCAS/advanced-ai/advanced-ai-4/"/>
    <url>/2022/09/22/UCAS/advanced-ai/advanced-ai-4/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第4讲 图像数据的深度学习模型</p><span id="more"></span><h1>第4讲 图像数据的深度学习模型</h1><h2 id="卷积神经网络">卷积神经网络</h2><p>计算机视觉需要应用大量的图像数据</p><p>卷积神经网络是一种特殊的深层神经网络模型</p><ul><li>它的神经元间的连接是非全连接的</li><li>同一层中某些神经元之间的连接的权重是共享的（即相同的）。</li></ul><p>20世纪60年代，Hubel和Wiesel研究猫脑皮层</p><ul><li>用于局部敏感和方向选择的神经元，其独特的网络结构可以有效地降低反馈神经网络的复杂性</li><li>基于猫的初级视皮层(VI区)的研究：简单细胞和复杂细胞</li><li>两层神经网络模拟初级视皮层中的简单细胞和复杂细胞<ul><li>每层的神经元被组织成二维平面</li><li>“简单细胞”层提取其输入中的局部特征</li><li>“复杂细胞”层组合“简单细胞”层中相应的子区域，使得整个网络对局部变换具有一定的不变性。</li></ul></li></ul><p>局部连接</p><p>局部感知野：图像的空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱，减少了需要训练的权值数目</p><p>参数共享：图像的一部分的统计特性与其他部分是一样的。在输入的不同位置检测同一种特征具有平移不变性</p><p>一维、二维、三维卷积</p><p>其中三维卷积：假设输入数据的大小为a1×a2×a3，过滤器大小为f，即过滤器维度为f×f×f。三维卷积最终的输出为(a1−f+1)×(a2−f+1)×(a3−f+1)。</p><p>多卷积核：</p><ul><li>每个卷积核都会将图像生成为另一幅图像。</li><li>两个卷积核就可以生成两幅图像，这两幅图像可以看做是一张图像的不同的通道。</li></ul><p>边缘检测示例：卷积运算是输入图像与过滤器（也叫核）进行的运算，得到输出图像。卷积核与图像对应的位置相乘求和得到一个新值。</p><p>假定要识别图像中的特定曲线，也就是说，对这种曲线有很高的输出，对其他形状则输出很低，这也就像是神经元的激活。</p><p>Padding：边缘不填充</p><ul><li>随着不断卷积，图像会变得越来越小，有时你可不想让它变小</li><li>最角落的点只被使用了一次，这意味着在下传的过程中丢掉了图像边缘位置的信息。</li></ul><p>卷积步长：卷积中的步幅是另一个构建卷积神经网络的基本操作</p><p>输入与输出的尺寸关系：<img src="https://math.now.sh?inline=%5Clfloor%20%5Cfrac%7Bn%2B2p-f%7D%7Bs%7D%2B1%20%5Crfloor" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>单层卷积网络：每一个卷积核的输出对应一个实数b（偏差），然后在进行激活函数的非线性转换得到输出</p><p>Pooling池化：</p><p>通过卷积获得了特征之后，下一步利用这些特征去做分类。</p><ul><li>使用卷积时是利用了图像的“静态”特征</li><li>Pooling对不同位置的特征进行聚合统计</li></ul><p>池化层中没有需要学习的参数，所以通常不把池化层当做独立的一层来看。</p><p>池化层是一般不会设置padding，即一般padding为0。</p><p>fitter为2，stride为2是最常见的参数设置，尺寸图像缩小为原来的一半。</p><p>卷积时用的尺寸计算公式同样适用于池化层。</p><h2 id="CNN">CNN</h2><p>CNN基本结构：卷积层和子采样层</p><p>卷积神经网络是一个多层的神经网络</p><ul><li>每层由多个二维平面组成</li><li>每个平面由多个独立神经元组成</li></ul><p>CNN训练过程</p><p>监督训练：Bp算法</p><p>向前传播</p><ul><li>从样本集中取一个样本<img src="https://math.now.sh?inline=%28Xp%2CYp%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，将<img src="https://math.now.sh?inline=X" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>输入网络</li><li>计算相应的实际输出<img src="https://math.now.sh?inline=Op%3DF_n%28%E2%80%A6(F_2(%20F_1(%20XpW%5E%7B(1%29%7D%20)W%5E%7B(2)%7D)%E2%80%A6)W%5E%7B(n)%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>反向传播</p><ul><li>计算实际输出<img src="https://math.now.sh?inline=Op" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与相应的理想输出<img src="https://math.now.sh?inline=Yp" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的差</li><li>按极小化误差的方法反向传播调整权矩阵</li><li>代价函数<ul><li>最小化平方误差(MSE)，最小化相对熵(Relative Entropy)</li></ul></li><li>反向传播主要考虑三个方面：<ul><li>输出层，代价函数的确定及求导</li><li>Pooling，数据的下采样及残差的上采样</li><li>卷积层，数据的卷积运算及残差的反卷积运算</li></ul></li></ul><p>卷积网络的核心思想：将局部感受野、权值共享以及时间或空间亚采样这三种结构思想结合起来获得了某种程度的位移、尺度、形变不变性。</p><p>层间联系和空域信息的紧密关系，使其适于图像处理和理解：图像和网络的拓扑结构能很好的吻合</p><p>避免了显式的特征抽取，而隐式地从训练数据中进行学习：特征提取和模式分类同时进行，并同时在训练中产生；权重共享可以减少网络的训练参数，使神经网络结构变得更简单，适应性更强。</p><p>CNN的改进：</p><p>Rectified linear function：加速收敛和稀疏化</p><p>dropout：将隐层节点以一定概率清0</p><p>局部对比归一</p><p>非线性变换、池化</p><p>残差网络（Residual Networks（ResNets））</p><ul><li>因为残差网络很容易学习恒等式函数，所以随着网络加深，至少不会让网络变差。</li><li>学习结果对网络权重的波动变化更敏感</li></ul><h2 id="图像数据应用">图像数据应用</h2><ul><li>目标定位</li><li>特征点检测</li><li>目标检测</li><li>人脸识别</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第8讲 检索评价</title>
    <link href="/2022/09/21/UCAS/information-retrieval/information-retrieval-8/"/>
    <url>/2022/09/21/UCAS/information-retrieval/information-retrieval-8/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第8讲 检索评价</p><span id="more"></span><h1>第8讲 检索评价</h1><h2 id="检索评价">检索评价</h2><ul><li>通过评估可以评价不同技术的优劣，不同因素对系统的影响，从而促进本领域研究水平的不断提高</li><li>信息检索系统的目标是较少消耗情况下尽快、全面返回准确的结果。</li><li>计算机应用学科偏重于研究“更好的”方法/算法/模型，需要一种公平可靠的方法和指标体系进行评价</li></ul><p>评价什么？</p><ul><li>效率：时间开销、空间开销、响应速度</li><li>效果：<ul><li>返回的文档中有多少相关文档</li><li>所有相关文档中返回了多少</li><li>返回得靠不靠前</li></ul></li><li>其他指标：覆盖率、访问量、数据更新速度</li></ul><p>使用相同的文档集合，相同的查询主题集合，相同的评价指标，对不同的检索系统进行比较。</p><p>评价指标：某个或某几个可衡量、可比较的值</p><p>评价过程：设计上保证公平、合理</p><p>IR中评价的难点：相关性（Relevance）是一个主观概念，文档相关性依赖于查询（数据标记工作量庞大）</p><h2 id="评价指标">评价指标</h2><ol><li>对单个查询进行评估的指标：在单个查询上检索系统的得分</li></ol><p>召回率(Recall)：返回的相关结果数占实际相关结果总数的比率</p><p>正确率(Precision)：返回的结果中真正相关结果的比率</p><p>虽然Precision和Recall都很重要，但是不同的应用、不用的用户可能会对两者的要求不一样。</p><ul><li>垃圾邮件过滤：宁愿漏掉一些垃圾邮件，但是尽量少将正常邮件判定成垃圾邮件。</li><li>有些用户希望返回的结果全一点，他有时间挑选；有些用户希望返回结果准一点，他不需要结果很全就能完成任务。</li></ul><p><strong>问题①：召回率难以计算：</strong></p><p>对于大规模语料集合，列举每个查询的所有相关文档是不可能的事情，因此，这种情况几乎不可能准确地计算召回率可以采用Pooling方法，或者不考虑召回</p><p>缓冲池(Pooling)方法：对多个检索系统的Top k个结果组成的集合(并集)进行人工标注，标注出的相关文档集合作为整个相关文档集合。这种做法被验证是可行的(可以比较不同系统的相对效果)，在TREC会议中被广泛采用。</p><p><strong>问题②：两个指标需要融成一个指标，或者只采用单一指标</strong></p><p>F值(F-measure)：召回率R和正确率P的调和平均值</p><p>Fβ：表示召回率的重要程度是正确率的β(&gt;=0)倍，β&gt;1更重视召回率， β&lt;1更重视正确率</p><p>E(Effectiveness)值：召回率R和正确率P的加权平均值，b&gt;1表示更重视P</p><p>精确率是所有判定中正确的比率，一般不使用这一评价指标</p><ul><li>由于和查询相关毕竟占文档集的极少数，所以即使什么都不返回，可能对大部分查询来说可以得到 99.99%以上的精确率</li><li>信息检索用户希望找到某些文档并且能够容忍结果中有一定的不相关性，返回一些即使不好的文档也比不返回任何文档强</li></ul><p><strong>问题③：两个指标都是基于(无序)集合进行计算，并没有考虑（排）序的作用</strong></p><p>R-Precision：检索结果中，在所有相关文档总数位置上的准确率，如某个查询的相关文档总数为80，则计算检索结果中在前80篇文档的正确率。</p><p>正确率-召回率 曲线：检索结果以排序方式排列，用户不可能马上看到全部文档，因此，在用户观察的过程中，正确率和召回率在不断变化。</p><p>在上面的曲线对应的系统结果更好，也就是线下的面积（AUC）</p><p>P-R 曲线的插值问题：利用存在的召回率点对不存在的召回率点进行插值</p><p>优点：</p><ul><li>简单直观</li><li>既考虑了检索结果的覆盖度，又考虑了检索结果的排序情况</li></ul><p>缺点：单个查询的P-R曲线虽然直观，但是难以明确表示两个查询的检索结果的优劣</p><p>基于P-R曲线的单一指标：P-R曲线上P=R的那个点（Break Point）</p><p>平均正确率(Average Precision, AP)：对不同召回率点上的正确率进行平均</p><p>不考虑召回率的指标：</p><p>Precision@N：在第N个位置上的正确率，对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页的结果，</p><ol start="2"><li>对多个查询进行评估的指标：在多个查询上检索系统的得分</li></ol><p>平均的求法：</p><ul><li>宏平均(Macro Average): 对每个查询求出某个指标，然后对这些指标进行算术平均</li><li>微平均(Micro Average): 将所有查询视为一个查询，将各种情况的文档总数求和，然后进行指标的计算</li><li>宏平均对所有查询一视同仁，微平均受返回相关文档数目比较大的查询影响</li></ul><p>MAP(Mean AP)：对所有查询的AP求宏平均</p><p>整个IR系统的P-R曲线：</p><p>在每个召回率点上，对所有的查询在此点上的正确率进行算术平均，得到系统在该点上的正确率的平均值。</p><p>两个检索系统可以通过P-R曲线进行比较。位置在上面的曲线代表的系统性能占优。</p><p>MRR(Mean Reciprocal Rank): 对于某些IR系统(如问答系统或主页发现系统)，只关心第一个标准答案返回的位置(Rank)，越前越好，这个位置的倒数称为RR，对问题集合求平均，则得到MRR</p><p>Bpref：在相关性判断不完全的情况下，计算在进行了相关性判断的文档集合中，在判断到相关文档前，需要判断的不相关文档的篇数。</p><p>相关性判断完全的情况下，利用Bpref和MAP进行评价的结果很一致，但是相关性判断不完全的情况下，Bpref更鲁棒</p><p>GMAP：几何平均值</p><p>NDCG：对于返回结果，相关度级别越高的结果越多越好，相关度级别越高的结果越靠前越好。</p><p>优点：</p><ul><li>图形直观，易解释</li><li>支持非二值的相关度定义，比P-R曲线更精确</li><li>能够反映用户的行为特征(如：用户的持续性)</li></ul><p>缺点：</p><ul><li>相关度的定义难以一致</li><li>需要参数设定</li></ul><p>现有评价体系远没有达到完美程度</p><ul><li>对评价的评价研究</li><li>指标的相关属性(公正性、敏感性)的研究</li><li>新的指标的提出(新特点、新领域)</li><li>指标的计算(比如Pooling方法中如何降低人工代价？查询集或文档集合发生变化怎么办？)</li></ul><h2 id="相关评测">相关评测</h2><p>TREC</p><p>总目标：支持在信息检索领域的基础研究，提供对大规模文本检索方法的评估办法</p><ol><li>鼓励对基于大测试集合的信息检索方法的研究</li><li>提供一个可以用来交流研究思想的论坛，增进工业界、学术界和政府部门之间的互相了解；</li><li>示范信息检索理论在解决实际问题方面的重大进步，提高信息检索技术从理论走向商业应用的速度；</li><li>为工业界和学术界提高评估技术的可用性，并开发新的更为适用的评估技术。</li></ol><h2 id="实验设计">实验设计</h2>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战-用户画像</title>
    <link href="/2022/09/20/UCAS/machine-learning/machine-learning-competition-people/"/>
    <url>/2022/09/20/UCAS/machine-learning/machine-learning-competition-people/</url>
    
    <content type="html"><![CDATA[<p>机器学习算法竞赛实战-用户画像</p><span id="more"></span><h1>第7章 用户画像</h1><p>参考资料：<a href="https://blog.csdn.net/qq_37039382/article/details/124590609">《机器学习算法竞赛实战》整理 | 七、用户画像</a></p><p>用户：产品的使用者</p><p>数据收集方为了推广产品同时持续维护和改善用户体验需要对由用户操作而产生的数据进行挖掘，以期从中发现群体乃至个体的行为偏好，形成数据层面上的所谓画像。</p><h2 id="用户画像">用户画像</h2><p>用于商业分析和数据挖掘的用户画像。基于给定的数据对用户属性及行为进行描述，然后提取用户的个性化指标，再以此分析可能存在的群体共性，并落地应用到各种业务场景中。</p><h2 id="标签系统">标签系统</h2><p>核心就是给用户打标签，用来分析社会属性、社会习惯、生活习惯、消费行为。</p><h3 id="标签分类方式">标签分类方式</h3><p>通过分析一个用户的特征来展示标签分类方式：</p><p><a href="https://imgse.com/i/xiDaxH"><img src="https://s1.ax1x.com/2022/09/21/xiDaxH.md.png" alt="xiDaxH.md.png"></a></p><h3 id="多渠道获取标签">多渠道获取标签</h3><p>标签获取方式也可以看作特征获取方式</p><p>事实类：直接来自原始数据，比如性别、年龄、会员等级。也可以进行简单统计，比如用户行为次数、消费总额。</p><p>规则类：由运营人员和数据人员经过共同协商设定。例如，地域属性、家庭类型、年龄层等。所用技术知识：数理统计类，如基础统计、数值分层、概率分布、均值分析、方差分析等。</p><p>模型类：经过机器学习和深度学习等模型处理后，二次加工生成的洞察性标签。比如预测用户状态、预测用户信用分、划分兴趣人群和对评论文本进行分类。特点：综合程度高、复杂，依托数学建模，多种算法组合。</p><h3 id="标签体系框架">标签体系框架</h3><p><a href="https://imgse.com/i/xifcBF"><img src="https://s1.ax1x.com/2022/09/21/xifcBF.md.png" alt="xifcBF.md.png"></a></p><h2 id="用户画像数据特征">用户画像数据特征</h2><h3 id="常见的数据形式">常见的数据形式</h3><ul><li>数值型变量</li><li>类别型变量</li><li>多值型变量：用户在某个维度具有多个取值的变量</li><li>文本型变量：利用文本记录的变量。需要NLP知识，例如jieba中文分词工具</li></ul><h3 id="文本挖掘算法">文本挖掘算法</h3><p>LSA：非概率主题模型，与词向量有关，主要用于文档的话题分析。其核心思想是通过矩阵分解的方式发现文档和词之间基于话题的语义关系。</p><p>具体：将文档集表示为词-文档矩阵，对矩阵进行SVD（奇异值分解），从而得到话题向量以及文档在话题向量的表示。</p><p>举例：2020腾讯广告大赛，首先构造用户点击的广告素材id序列（creative_id），然后进行TF-IDF计算，最后经过SVD得到结果。</p><p>（代码与书中不同，未验证）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_extraction.text <span class="hljs-keyword">import</span> CountVectorizer, TfidfVectorizer<span class="hljs-comment"># 稀疏特征降维 TruncatedSVD</span><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> TruncatedSVD<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline<span class="hljs-comment"># 提取用户点击序列</span>docs = data_df.groupby([<span class="hljs-string">&#x27;user_id&#x27;</span>])[<span class="hljs-string">&#x27;creative_id&#x27;</span>].agg(<span class="hljs-keyword">lambda</span> x:<span class="hljs-string">&quot;&quot;</span>.join(x)).reset_index()[<span class="hljs-string">&#x27;creative_id&#x27;</span>]<span class="hljs-comment"># tf-idf</span>tfd = TfidfVectorizer()svd = TruncatedSVD(n_components=<span class="hljs-number">100</span>, n_iter=<span class="hljs-number">50</span>, random_state=<span class="hljs-number">2020</span>)</code></pre></div><p>PLSA：PLSA（概率潜在语义分析）模型是为了克服LSA模型潜在存在的一些缺点而提出的。通过一个生成模型来为LSA赋予概率意义上的解释。该模型假设每一篇文档都包含一系列可能的潜在话题，文档中的每一个词都不是凭空产生的，而是在潜在话题的指引下通过一定的概率生成的。</p><p>LDA：LDA（潜在狄利克雷分布）是一种概率主题模型，与词向量无关，可以将文档集中的每篇文档的主题以概率分布的形式给出。通过分析一批文档集，抽取出他们的主题分布，就可以根据主题进行聚类或分类。同时，它是一种典型的词袋模型，即一篇文档由一组相互独立的词构成，词和词之间没有先后顺序。</p><h3 id="神奇的嵌入表示">神奇的嵌入表示</h3><p>word2Vec：可调用gensim包，参数：窗口大小、模型类型选择、生成词向量长度</p><p>对于Skip-Gram和CBOW：</p><ul><li>CBOW在训练时比Skip-Gram快</li><li>CBOW可以更好地表示常见单词</li><li>Skip-Gram在少量的训练集中可以表示稀有单词或短语</li></ul><p>DeepWalk</p><p>对于Word2Vec的衍生Item2Vec以及更多图嵌入方法，比如LINE、Node2Vec和SDNE</p><h3 id="相似度计算方法">相似度计算方法</h3><ul><li>欧式距离</li><li>余弦相似度</li><li>Jaccard相似度</li></ul><h2 id="用户画像的应用">用户画像的应用</h2><h3 id="用户分析">用户分析</h3><ol><li>京东JDATA平台2019年的“用户对品类下店铺的购买预测”</li><li>腾讯广告“2020腾讯广告大赛”</li></ol><h3 id="精准营销">精准营销</h3><ol><li>2018科大讯飞AI营销算法大赛</li><li>2018腾讯广告算法大赛</li></ol><h3 id="风控领域">风控领域</h3><ul><li>DF竞赛平台的“消费者人群画像-信用智能评分”</li><li>拍拍贷“第四届魔镜杯大赛”</li></ul><p>特点：</p><ul><li>业务对模型解释性比较高，对时效性有一定要求，需要权衡模型复杂度和精度，并且适当优化算法内核</li><li>业务模型多样，需要紧密结合业务</li><li>负样本极少，均衡学习算法</li></ul><h1>第8章 实战案例</h1><p>参考资料：<a href="https://blog.csdn.net/qq_37039382/article/details/124648040">《机器学习算法竞赛实战》整理 | 八、实战案例：Elo Merchant Category Recommendation</a></p><h2 id="赛题理解">赛题理解</h2><p>Imagine being hungry in an unfamiliar part of town and getting restaurant recommendations served up, based on your personal preferences, at just the right moment. The recommendation comes with an attached discount from your credit card provider for a local place around the corner!</p><p>Right now, <a href="https://www.cartaoelo.com.br/">Elo</a>, one of the largest payment brands in Brazil, has built partnerships with merchants in order to offer promotions or discounts to cardholders. But do these promotions work for either the consumer or the merchant? Do customers enjoy their experience? Do merchants see repeat business? Personalization is key.</p><p>Elo has built machine learning models to understand the most important aspects and preferences in their customers’ lifecycle, from food to shopping. But so far none of them is specifically tailored for an individual or profile. This is where you come in.</p><p>In this competition, Kagglers will develop algorithms to identify and serve the most relevant opportunities to individuals, by uncovering signal in customer loyalty. Your input will improve customers’ lives and help Elo reduce unwanted campaigns, to create the right experience for customers.</p><h3 id="赛题数据">赛题数据</h3><ul><li><code>train.csv</code> 训练数据集，包括 <code>first_active_month,card_id,feature_1,feature_2,feature_3,target</code>字段</li><li><code>test.csv</code> 测试数据集，包括 <code>first_active_month,card_id,feature_1,feature_2,feature_3</code>字段</li></ul><p><code>first_active_month</code>表示的是信用卡产生第一笔交易的时间，<code>feature</code>是信用卡类型的脱敏特征。最后一列 <code>target</code>是要预测的数值</p><p><code>historical_transactions.csv</code> 信用卡在给定商家的历史交易记录，文件比较大，基本都是一些脱敏的特征</p><p><code>merchants.csv</code>所有商家的附加信息</p><p><code>new_merchant_transactions.csv</code> two months’ worth of data for each <code>card_id</code> containing ALL purchases that <code>card_id</code> made at <code>merchant_id</code>s that were  <em>not visited in the historical data</em> .（每张信用卡在新商家的购物数据）</p><p>评价指标使用RMSE<img src="https://math.now.sh?inline=%5Csqrt%7B%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi%3D1%7D%5En%28y_i-%5Chat%7By_i%7D%29%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战-基础篇</title>
    <link href="/2022/09/19/UCAS/machine-learning/machine-learning-competition-basic/"/>
    <url>/2022/09/19/UCAS/machine-learning/machine-learning-competition-basic/</url>
    
    <content type="html"><![CDATA[<p>机器学习算法竞赛实战-基础篇</p><span id="more"></span><h1>开始学习</h1><p>一直想学，前面看过觉得太难，这回一定要坚持看完！</p><h1>第1章 初见竞赛</h1><p>参考资料：<a href="https://blog.csdn.net/weixin_52205096/article/details/122885215">《机器学习算法竞赛实战》学习笔记1.竞赛简介</a></p><h2 id="竞赛流程">竞赛流程</h2><p><a href="https://imgse.com/i/x9y9YD"><img src="https://s1.ax1x.com/2022/09/19/x9y9YD.md.png" alt="x9y9YD.md.png"></a></p><h3 id="问题建模">问题建模</h3><p>分析数据进而抽象出建模目标和方案。自行利用主办方提供的数据构造训练集与测试集。</p><h3 id="数据探索">数据探索</h3><p>EDA（探索性数据分析），Exploratory Data Analysis。在大致了解问题建模方式后，需结合对赛题背景业务的理解去看数据长什么样子、数据是否和描述相符、包含哪些信息等。首先需要对数据有清晰认知，主要是宽表中各个字段的取值含义、范围和数据结构等。然后更深层次地结合标签分析特征的分布状态、训练集与测试集的同分布情况、特征之间的业务关联以及隐含信息表征等。</p><h3 id="特征工程">特征工程</h3><p>Feature Engineering。特征决定机器学习预测效果上限，算法不断逼近这个上限。最费时的模块。</p><h3 id="模型训练">模型训练</h3><p>选模型、调参数</p><h3 id="模型融合">模型融合</h3><p>找找队友，看看Code</p><h1>第2章 问题建模</h1><p>参考资料：<a href="https://blog.csdn.net/weixin_52205096/article/details/122888658">《机器学习算法竞赛实战》学习笔记2.问题建模</a></p><h2 id="赛题理解">赛题理解</h2><p>从直观上梳理问题，分析问题可解的方法、赛题背景等</p><p>业务理解：从个人生活的直观角度对业务进行分析</p><p>数据理解：在问题建模阶段，只需对数据做基本的分析。可以将数据理解分为数据基础层和数据描述层两个部分。主办方提供的原始数据质量良莠不齐，往往需要对原始数据进行清洗、加工和计算等处理。</p><ul><li>数据基础层：重点关注每个数据字段的来源、生产过程、取数逻辑、计算逻辑等，了解这些才能正确理解、选取并使用每一个原始字段，从而加工计算得出所需的更多衍生字段，数据最终通常以数据表格形式呈现。</li><li>数据描述层：主要是在处理好的数据基础层上进行统计分析和概括描述，该层重点在于尽可能地通过一些简单统计量（如均值、最值、分布、增幅、趋势等）来概括整体数据的状况。具体使用哪些统计量依据数据呈现的具体情况而定。例如，对于时间序列问题，可以统计其增幅、趋势和周期；对于常规的数值特征，则可以观察期均值、最值和方差等统计量；对于存在多类别的样本集合，则可以使用分布、分位点等进行描述。</li></ul><h3 id="评价指标">评价指标</h3><p>分类指标：</p><ol><li>错误率（error rate）与精度（accuracy）</li></ol><p>错误率：分类错误的样本数占样本总数的比例</p><p>精度：分类正确的样本数占样本总数的比例</p><p>精度=1-错误率</p><ol start="2"><li>查准率/准确率（precision）、查全率/召回率（recall）</li></ol><p>查准率P反映真实情况与预测结果都为正例的样例在预测结果为正例的样例中的占比</p><p>查全率R反映真实情况与预测结果都为正例的样例在真实情况为正例的样例中的占比</p><p><strong>（查准率与查全率是一对矛盾的度量，一般来讲，查准率高时，查全率偏低；查全率高时，查准率偏低）</strong></p><p><img src="https://math.now.sh?inline=F1_%7Bscore%7D%3D%5Cfrac%7B2PR%7D%7BP%2BR%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，在查准率与查全率之间取得一个平衡</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 构建一个计算准确率、召回率和F1-score的评价代码</span>y_train = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>])y_pred = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])precision = precision_score(y_train,y_pred) <span class="hljs-comment">#准确率</span>recall = recall_score(y_train,y_pred) <span class="hljs-comment">#召回率</span>f1 = f1_score(y_train,y_pred) <span class="hljs-comment">#f1度量</span><span class="hljs-built_in">print</span>(precision,recall,f1)</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">6</span> <span class="hljs-number">0</span>.<span class="hljs-number">5</span> <span class="hljs-number">0</span>.<span class="hljs-number">5454545454545454</span></code></pre></div><ol start="3"><li>ROC与AUC</li></ol><p>先根据学习器的预测结果对样例进行排序，按此顺序逐个把样例作为正例进行预测，每次计算出“真正例率”（True Positive Rate，简称TPR）和“假正例率”（False Positive Rate，简称FPR），分别以他们为纵、横轴作图，就得到了ROC曲线。</p><p><img src="https://math.now.sh?inline=TPR%3D%5Cfrac%7BTP%7D%7BTP%2BFN%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，真正例率TPR反映真正例在实际情况为正例的样例中的占比</p><p><img src="https://math.now.sh?inline=FPR%3D%5Cfrac%7BFP%7D%7BTN%2BFP%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，假正例率FPR反映假正例在实际情况为反例的样例中的占比</p><p><strong>ROC曲线对正负样本的数量和分布不敏感。</strong></p><p>AUC定义为ROC下方的面积，在互联网的搜索、推荐和广告的排序业务中都极为常见。AUC作为一个数值，其值越大就代表分类器的效果越好。</p><p>值得一提的还有AUC的排序特性。相对于准确率、召回率等指标，AUC指标本身和模型预测的概率绝对值无关，它只关注样本间的排序效果，因此特别适合用作排序相关问题建模的评价指标。AUC是一个概率值，我们随机挑选一个正样本与一个负样本，由当前分类算法根据计算出的分数将这个正样本排在负样本前面的概率就是AUC值。</p><p>为什么AUC与模型预测的分数值无关是个很好的特性？假设采用的是准确率等指标，而模型预测的分数是个概率值，那么必须选择一个阈值来决定把哪些样本预测为1，哪些预测为0。阈值的选择不同，准确率的值就会不同。而AUC可以直接使用模型预测分数本身，参考的是相对顺序。在竞赛中，省去了参赛者试探阈值的麻烦。</p><ol start="4"><li>对数损失</li></ol><p>对数损失可用于评价分类器的概率输出。对数损失通过惩罚错误的分类来实现对分类器的准确度的量化。最小化对数损失基本等价于最大化分类器的准确度。为了计算对数损失，分类器必须提供概率结果，即把输入样本喂入模型后，预测得到每个类别的概率值（0~1），而不只是预测最可能的类别。</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=logloss%20%3D%20%5Cfrac%7B1%7D%7BN%7D%5Csum_%7Bi%3D1%7D%28y_i%20log%7Bp_i%7D%2B(1-y_i%29log%7B(1-p_i)%7D)%0A" /></p><p><strong>AUC与对数损失的区别</strong></p><p><strong>对数损失主要评价模型预测的概率是否足够准确，更关注和观察数据的吻合程度</strong>；AUC评价的则是<strong>模型把正样本排列到前面的能力</strong>。两者侧重不同，故应用不同。对于广告CTR问题，如果考虑广告排序效果，则可以选择AUC，这样不会受极端值影响。此外，对数损失反映了评价偏差，更偏向于将样本数量多的那类划分准确。由于使用AUC或对数损失可以避免把预测概率转换成类别的麻烦，在各种数据竞赛的分类问题中，AUC和对数损失基本是最常见的模型评价指标。</p><p>回归指标：</p><ol><li>平均绝对误差<img src="https://math.now.sh?inline=MAE%28y%2Cy'%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5En%7Cy_i-y_i'%7C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，又称L1范数损失</li></ol><p>MAE不是二阶连续可微的，其二阶导数总为0。</p><ol start="2"><li>均方误差<img src="https://math.now.sh?inline=MSE%28y%2Cy'%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5En(y_i-y_i')%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，又称L2范数损失</li></ol><p>MSE的量纲与数据标签不一致，为了保证量纲的一致性，通常需要对均方误差进行开方（均方根误差RMSE）</p><p><strong>平均绝对误差MAE与均方误差MSE的区别</strong></p><p>均方误差对误差（真实值-预测值）取了平方，若误差＞1，则均方误差会进一步增大误差。如果数据中存在异常点，那误差值就会很大，而误差的平方则会远大于误差的绝对值。因此，相对于使用平均绝对误差计算损失，使用均方误差的模型会赋予异常点更大的权重。简而言之，<strong>均方误差对异常值更加敏感</strong>。</p><p><strong>为什么在XGBoost里通常选择Huber损失替换MAE？</strong></p><p>由于MAE不是连续可导的（0处不可导），所以需要使用可导目标函数来逼近平均绝对误差。而对于均方误差MSE，梯度又会随着损失的减小而减小，使预测结果更加精确。在这种情况下，Huber损失就非常有用，它会由于梯度的减小而落在最小值附近。比起均方误差MSE，Huber损失对异常点更加健壮。因此，Huber损失结合了MAE和MSE的优点。但是Huber损失可能需要我们不断调整超参数delta。</p><ol start="3"><li>平均绝对百分比误差<img src="https://math.now.sh?inline=MAPE%28y%2Cy'%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5En%5Cfrac%7B%7Cy_i-y_i'%7C%7D%7By_i'%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><p>MAPE与MAE一样，不存在二阶导数。但不用于MAE，平均绝对百分比误差MAPE除了考虑预测值与真实值的误差，还考虑了误差与真实值之间的比例。因此真实值越大，误差会越小。</p><h2 id="样本选择">样本选择</h2><p>主办方提供的数据往往令人脑壳疼，主要是以下四个原因：</p><ul><li>数据集过大严重影响了模型性能：过大的数据集会严重影响各种特征工程和建模方式的快速验证<ul><li>对数据进行采样处理，然后在小数据集上建模分析</li><li>特定业务场景下，可以过滤一些对建模没有意义的数据</li></ul></li><li>噪声和异常数据导致准确率不够<ul><li>采集数据时操作不当导致信息表征出现错误</li><li>数据本身的特性存在合理范围内的抖动导致噪声与异常-看是否能够解码出正确数据</li><li>数据噪声的存在具有两面性，噪声的存在会导致数据的质量变低，影响模型效果；另一方面，可以通过在训练集中引入噪声数据的方法使模型健壮性更强。</li><li>当处理噪声数据时，首先考虑是否为采集错误导致的，再去权衡模型的泛化性和当前效果。有时去噪会导致模型泛化性能变差。要去噪，首先要识别出噪声，然后采取直接过滤或者修改噪声数据等多种办法，噪声数据可能是特征值不对，比如特征值缺失、超出特征值域范围等；也可能是标注不对，比如二分类问题的正样本标注成了负样本。</li></ul></li><li>样本数据冗余或不相关数据没有给模型带来收益<ul><li>数据中存在的冗余不仅会影响模型性能，更会引入噪声与异常。数据冗余的一个典型解决方案就是进行特征选择。</li></ul></li><li>正负样本分布不均衡导致数据存在倾斜-进行数据采样</li></ul><p>问题1：在数据量非常大的情况下，为了降低成本，如何提高模型的训练速度？</p><ul><li>方法1：简单随机抽样，分为有放回与无放回</li><li>方法2：分层采样-按照规定的比例从不同类别中随机抽取样本</li></ul><p>问题2：针对正负样本分布不均衡的问题，如何通过数据采样解决这类问题？</p><ul><li>方法1：评分加权处理<ul><li>分布不均衡的问题包括欺诈交易识别和垃圾邮件识别等，其正负样本的数据分布差距极大。考虑正负样本的重要性，在模型训练以及评价的时候可以设计相应的得分权重，使得模型能够学习到需要获得关注的部分。</li><li>此方法的具体操作步骤是：首先遍历所有样本，根据样本是否满足某个要求来给予其权重。</li><li>加权的直观含义从业务上理解就是认为一个正样本的价值大于多个负样本的，因此希望模型在训练的时候能够更多地从正样本身上学到关键信息，当它学得不好的时候，就要对它加大惩罚力度。</li></ul></li><li>方法2：欠采样<ul><li>从数量较多的一类样本中随机选取一部分并剔除，使得最终样本的目标类别不太失衡。常用方法有随机欠采样和Tomek Links，其中Tomek Links先是找出两个各相指标都非常接近的相反类样本，然后删除这类样本中标签（label）占比高的，这类算法能够为分类器提供一个非常好的决策边界。</li></ul></li><li>方法3：过采样<ul><li>主要是对样本较少的类别进行重新组合，构造新样本。常用的方法有随机过采样和SMOTE算法。SMOTE算法并不是简单地复制已有的数据，而是在原有数据的基础上通过算法产生新生数据。</li></ul></li></ul><p>思考：在什么场景下需要处理样本的不均衡问题？</p><ul><li>如果竞赛任务对于召回有特别大的需求，即对每个正样本的预测都远远比负样本的预测更重要，那么这时候假如不做任何处理，对结果影响较大</li><li>如果竞赛的评价指标是AUC，那么在实战中会发现这时处理样本不均衡问题与否对于结果的差别不太大。（但细微提升也是好的）</li><li>如果在竞赛任务中正负样本同等重要，即预测正确一个正样本与预测准确一个负样本是同等重要的，那么不做处理问题也不大</li></ul><h2 id="线下评估">线下评估</h2><p>由于需要数据集对模型的效果进行线下验证，所以需要考虑如何对数据进行划分，构建合适的线下验证集。针对不同类型的问题，需要不同的线下验证方式。</p><p>书中将这些问题大致分为强时序性与弱时序性两类，然后以此确定线下验证方式。</p><ul><li>强时序性问题：对于含有明显时间序列因素的赛题，可看作强时序性问题，即线上数据的时间都在离线数据集之后。因此要将最接近测试集的数据作为验证集对模型的效果进行评估（采用时间上最接近测试集的数据做验证集，且验证集的时间分布在训练集之后）</li><li>弱时序性问题：这类问题的验证方式主要为K折交叉验证(K-fold Cross Validation)</li></ul><p>定义：先将总数据集D划分为k个大小相似的互斥子集，每个子集都尽可能保持数据分布的一致性（即从D中分层采样得到）。然后每次用K-1个子集的并集作为训练集，余下的自己作为测试集。这样可以获得K组训练/测试集，从而可进行k次训练和测试，最终返回这k个测试结果的均值。</p><p>注意：</p><ul><li>交叉验证法评估结果的稳定性和保真性很依赖K的取值，K通常取10，常用有5，20等</li><li>给定k值，仍有多种划分方式。故通常要随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉验证结果的均值，常见有10次10折交叉验证</li></ul><p>以下为交叉验证代码，其中参数NFOLDS用来控制折数**（未实际验证）**</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFoldNFOLDS = <span class="hljs-number">5</span> <span class="hljs-comment">#五折交叉验证</span>folds = KFold (n_split = NFOLDS,shuffle=<span class="hljs-literal">True</span>,random_state=<span class="hljs-number">2021</span>)<span class="hljs-comment">#random_state只要是一个固定的值就可以了，不一定是2021</span><span class="hljs-keyword">for</span> trn_idx,val_idx <span class="hljs-keyword">in</span> folds.split(X_train,y_train):train_df,train_label = X_train.iloc[trn_idx, :],y_train[trn_idx]valid_df,valid_label = X_train.iloc[val_idx, :],y_train[val_idx]</code></pre></div><p>参数random_state默认设置为None，这意为着每次进行KFold(…, shuffle=True)时，打散都是不同的。</p><p>为了保证结果的可重复性（在相同的平台上），应该给random_state设定一个固定的值。</p><h1>第3章 数据探索</h1><p>参考资料：<a href="https://blog.csdn.net/weixin_52205096/article/details/122917228">《机器学习算法竞赛实战》学习笔记3.数据探索</a></p><p>如何确保自己准备好竞赛使用的算法模型？如何为数据集选择最合适的算法？如何定义可用于算法模型的特征变量？数据探索可以帮助回答以上三点。</p><p>一般而言，数据探索可以分为三个部分：</p><ol><li>首先是赛前数据探索，帮助我们对数据有个整体性的认识，并发现数据中存在的问题，比如缺失值、异常值和数据冗余等</li><li>其次是竞赛中的数据探索，通过分析数据发现变量的特点，帮助提取有价值的特征，这里可以从单变量、多变量和变量分布进行分析</li><li>最后是模型的分析，可以分为重要性分析和结果误差分析，帮助我们从结果发现问题，并进一步优化</li></ol><h2 id="数据初探">数据初探</h2><p>赛前数据探索，主要包含分析思路、分析方法和明确目的。</p><ol><li>分析思路</li></ol><p>在实际竞赛中，最好使用多种探索思路和方法来探索每个变量并比较结果。在完全理解数据集后，就可以进入数据预处理阶段和特征提取阶段了，以便根据所期望的业务结果转换数据集。此步骤的目标是确信数据集已准备好应用于机器学习算法。</p><ol start="2"><li>分析方法</li></ol><p>数据探索的分析主要采用以下方法：</p><ul><li>单变量可视化分析：提供原始数据集中每个字段的摘要统计信息</li><li>多变量可视化分析：用来了解不同变量之间的交互关系</li><li>降维分析：有助于发现数据中特征变量之间方差最大的字段，并可以在保留最大信息量的同时减少数据维度。</li></ul><p>可以检查每个变量的分布，定义一些丢失值，最终找到替换它们的可能方法。</p><ol start="3"><li>明确目的</li></ol><p>在竞赛中跳过数据探索阶段可能会导致数据倾斜、出现异常值和过多的缺失值，产生以下糟糕结果：</p><ul><li>生成不准确的模型</li><li>在错误的数据上生成精确的模型</li><li>为模型选择错误的变量</li><li>资源的低效利用，包括模型的重建</li></ul><p>数据探索阶段必须要明确：</p><ol><li>数据集基本情况：比如数据有多大，每个字段各是什么类型</li><li>重复值、缺失值和异常值：去除重复值，缺失值是否严重，缺失值是否有特殊含义，如何发现异常值</li><li>特征之间是否冗余：可以通过特征间相似性特征来找出冗余特征</li><li>是否存在时间信息：当存在时间信息时，通常要进行相关性、趋势性、周期性和异常点的分析，同时有可能涉及潜在的数据穿越问题</li><li>标签分布：对于分类问题，是否存在类别分布不均衡。对于回归问题，是否存在异常值，整体分布如何，是否需要进行目标转换</li><li>训练集与测试集的分布：是否有很多在测试集中存在的特征字段在训练集中没有</li><li>单变量/多变量分布：熟悉特征的分布情况，以及特征和标签的关系</li></ol><p>数据探索最基本的步骤之一是获取对数据的基本描述，通过获取对数据的基本描述从而获得对数据的基本感觉。以下方法有助于我们认识数据：</p><ul><li><code>DataFrame.describe()</code>：查看数据的基本分布，具体是对每列数据进行统计，统计值包含频次、均值、方差、最小值、分位数、最大值等。</li><li><code>DataFrame.head(n)</code>：可以直接加载数据集的前n行,n默认为5</li><li><code>DataFrame.shape</code>：得到数据集的行列情况</li><li><code>DataFrame.info()</code>：可以快速获得对数据集的简单描述，比如每个变量的类型、数据集的大小和缺失值情况。</li></ul><p>下面通过一段代码展示nunique和缺失值的情况：</p><div class="code-wrapper"><pre><code class="hljs python">stats = []<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> train.columns:    stats.append((col, train[col].nunique(), train[col].isnull().<span class="hljs-built_in">sum</span>() * <span class="hljs-number">100</span> / train.shape[<span class="hljs-number">0</span>], train[col].value_counts(normalize=<span class="hljs-literal">True</span>, dropna=<span class="hljs-literal">False</span>).values[<span class="hljs-number">0</span>] * <span class="hljs-number">100</span>, train[col].dtype))stats_df = pd.DataFrame(stats, columns=[<span class="hljs-string">&#x27;Feature&#x27;</span>, <span class="hljs-string">&#x27;Unique_values&#x27;</span>, <span class="hljs-string">&#x27;Percentage of missing values&#x27;</span>, <span class="hljs-string">&#x27;Percentage of values in the biggest category&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>])stats_df.sort_values(<span class="hljs-string">&#x27;Percentage of missing values&#x27;</span>, ascending=<span class="hljs-literal">False</span>)[:<span class="hljs-number">10</span>]</code></pre></div><p><a href="https://imgse.com/i/xCG6L4"><img src="https://s1.ax1x.com/2022/09/20/xCG6L4.md.png" alt="xCG6L4.md.png"></a></p><p>上图展示了经过上述代码生成的数据基本信息，我们从中找到特殊变量进行细致分析，这里选择nunique值低和缺失值多的变量进行观察。一般而言，nunique为1是不具备任何意义的，表示所有值都一样，不存在区分性，需要进行删除。可以发现有些变量的缺失值很多，比如缺失比例达到95%以上，我们可以考虑将其删除。</p><p>用柱状图的形式可以更加直观地展示变量的缺失值分布情况，以下为变量缺失值可视化图的具体生成代码：</p><div class="code-wrapper"><pre><code class="hljs python">missing = train.isnull().<span class="hljs-built_in">sum</span>()missing = missing[missing &gt; <span class="hljs-number">0</span>]missing.sort_values(inplace=<span class="hljs-literal">True</span>)missing.plot.bar()</code></pre></div><h2 id="变量分析">变量分析</h2><h3 id="单变量分析">单变量分析</h3><p>单变量可以分为标签、连续型和类别型</p><ol><li>标签</li></ol><p>标签是最重要的变量，首先应当观察标签的分布情况。对于房屋价格预测，其标签SalePrice为连续型变量。</p><p>通过可视化的方式观察SalePrice的分布情况</p><div class="code-wrapper"><pre><code class="hljs python">sns.distplot(train[<span class="hljs-string">&#x27;SalePrice&#x27;</span>], color=<span class="hljs-string">&#x27;b&#x27;</span>, bins=<span class="hljs-number">100</span>, hist_kws=&#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: <span class="hljs-number">0.4</span>&#125;)</code></pre></div><p>可见，SalePrice呈偏离正态分布，属于向右倾斜类型，存在峰值状态，一些异常值在500000以上。我们最终会想办法去掉这些异常值，得出能够让算法模型很好学习的、符合正态分布的变量。</p><p><a href="https://imgse.com/i/xCJw0H"><img src="https://s1.ax1x.com/2022/09/20/xCJw0H.png" alt="xCJw0H.png"></a></p><p>下面对SalePrice进行对数转换，并生成可视化图</p><div class="code-wrapper"><pre><code class="hljs python">sns.distplot(np.log(train[<span class="hljs-string">&#x27;SalePrice&#x27;</span>]), color=<span class="hljs-string">&#x27;b&#x27;</span>, bins=<span class="hljs-number">100</span>, hist_kws=&#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: <span class="hljs-number">0.4</span>&#125;)</code></pre></div><p><a href="https://imgse.com/i/xCJsht"><img src="https://s1.ax1x.com/2022/09/20/xCJsht.png" alt="xCJsht.png"></a></p><p>可以看出 ，对数转换后的标签的分布为正态分布形式，比较适合算法模型学习。</p><ol start="2"><li>连续型</li></ol><p>类似于标签的查看方式，这里主要使用直方图这种可视化方式观察值的分布、每个值出现的频率等。以下为连续型变量的分布可视化的生成代码：</p><div class="code-wrapper"><pre><code class="hljs python">df_num = train.select_dtypes(include = [<span class="hljs-string">&#x27;float64&#x27;</span>, <span class="hljs-string">&#x27;int64&#x27;</span>])df_num.hist(figsize=(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>), bins=<span class="hljs-number">50</span>, xlabelsize=<span class="hljs-number">8</span>, ylabelsize=<span class="hljs-number">8</span>)</code></pre></div><p><a href="https://imgse.com/i/xCYZEd"><img src="https://s1.ax1x.com/2022/09/20/xCYZEd.md.png" alt="xCYZEd.md.png"></a></p><p>实际中要对全部的变量进行查看，分析每一个变量的分布情况。</p><p>接着进行更加科学的分析，首先是相关性分析。相关性分析只能比较数值间特征，所以对于字母或字符串特征，需要先进行编码，并将其转换为数值，然后再看有什么关联。在实际竞赛中，相关性分析可以很好地过滤掉与标签没有直接关系的特征。</p><p>正相关和负相关</p><ul><li>正相关：如果一个特征增加导致另一个特征增加，则它们呈正相关。值1表示完全正相关<ul><li>多重线性：现在假设特征A和特征B完全正相关，这意味着这两个特征值包含高度相似的信息，信息几乎没有或完全没有差异。这称为多重线性，因为两个特征包含几乎相同的信息。</li></ul></li><li>负相关：如果一个特征增加导致另一个特征减少，则它们呈负相关。值-1表示完全负相关</li></ul><p>在搭建或训练模型时，如果同时使用这两个特征，可能其中一个会是多余的。我们应尽量消除冗余特征，因为它会使训练时间变长，同时影响其他优势</p><p>以下代码为生成有关SalePrice的相似性矩阵图</p><div class="code-wrapper"><pre><code class="hljs python">corrmat = train.corr()f, ax = plt.subplots(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">9</span>))sns.heatmap(corrmat, vmax=<span class="hljs-number">0.8</span>, square=<span class="hljs-literal">True</span>)</code></pre></div><p><a href="https://imgse.com/i/xCY4KO"><img src="https://s1.ax1x.com/2022/09/20/xCY4KO.md.png" alt="xCY4KO.md.png"></a></p><p>从生成的相似性矩阵中，可以找出与房价相关性最强的变量，其中OverallQual（总评价）、GarageCars（车库）、TotalBsmtSF（地下室面积）、GrLivArea（生活面积）等特征与SalePrice呈正相关</p><p>从相似性矩阵中，我们还能发现变量之间的关系，如何利用相似性矩阵进行分析就成为了关键</p><ol start="3"><li>类别型</li></ol><p>数据探索的目的是为了帮助我们了解数据并且构建有效特征。</p><p>比如，我们找到了与标签有着强相关的特征，那么就可以围绕着这个强相关特征进行一系列的扩展，具体可以进行交叉组合，比如强相关加弱相关、强相关加强相关等组合，挖掘更高维度的潜在信息。</p><p>首先，观察类别型变量的基本分布情况，即观察每个属性的频次。根据频次，我们不仅可以发现热点属性和极少出现的属性，还可以进一步分析出现这些情况的原因，比如淘宝网的女性用户多于男性，主要是因为平台在服饰和美妆业务方面拥有强大的影响力。这是从业务角度考虑，自然也有可能是数据采样的原因。</p><p>对部分类别变量的分布进行可视化展示</p><div class="code-wrapper"><pre><code class="hljs python">df_not_num = train.select_dtypes(include = [<span class="hljs-string">&#x27;O&#x27;</span>])fig, axes = plt.subplots(<span class="hljs-built_in">round</span>(<span class="hljs-built_in">len</span>(df_not_num.columns) / <span class="hljs-number">3</span>), <span class="hljs-number">3</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">30</span>))<span class="hljs-keyword">for</span> i, ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fig.axes):    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(df_not_num.columns):        ax.set_xticklabels(ax.xaxis.get_majorticklabels(), rotation=<span class="hljs-number">45</span>)        sns.countplot(x=df_not_num.columns[i], alpha=<span class="hljs-number">0.7</span>, data=df_not_num, ax=ax)fig.tight_layout()</code></pre></div><p><a href="https://imgse.com/i/xCU8bD"><img src="https://s1.ax1x.com/2022/09/20/xCU8bD.md.png" alt="xCU8bD.md.png"></a></p><h3 id="多变量分析">多变量分析</h3><p>单变量分析太过于单一，不足以挖掘变量之间的内在联系，获取更加细粒度的信息，所以有必要进行多变量分析。分析特征变量与特征变量之间的关系有助于构建更好的特征，同时降低构建冗余特征的概率值。</p><p>此处选用本赛题中需要特别关注的特征变量进行分析</p><p>从相似性矩阵中，我们已知房屋评价与SalePrice呈正相关。进一步扩展分析，通过可视化来考虑房屋评价和房屋位置是否存在某种联系。</p><div class="code-wrapper"><pre><code class="hljs python">plt.style.use(<span class="hljs-string">&#x27;seaborn-white&#x27;</span>)type_cluster = train.groupby([<span class="hljs-string">&#x27;Neighborhood&#x27;</span>,<span class="hljs-string">&#x27;OverallQual&#x27;</span>]).size()type_cluster.unstack().plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>,stacked=<span class="hljs-literal">True</span>, colormap= <span class="hljs-string">&#x27;PuBu&#x27;</span>, figsize=(<span class="hljs-number">13</span>,<span class="hljs-number">11</span>),  grid=<span class="hljs-literal">False</span>)plt.xlabel(<span class="hljs-string">&#x27;OverallQual&#x27;</span>, fontsize=<span class="hljs-number">16</span>)plt.show()</code></pre></div><p><a href="https://imgse.com/i/xCaFJA"><img src="https://s1.ax1x.com/2022/09/20/xCaFJA.md.png" alt="xCaFJA.md.png"></a></p><p>上图为不同房屋位置的评价分布条状图，我们可发现颜色越深代表评价越高。NoRidge、NridgHt和StoneBr都有不错的评价</p><p>再进一步看看不同位置房屋的SalePrice</p><div class="code-wrapper"><pre><code class="hljs python">var = <span class="hljs-string">&#x27;Neighborhood&#x27;</span>data = pd.concat([train[<span class="hljs-string">&#x27;SalePrice&#x27;</span>], train[var]], axis=<span class="hljs-number">1</span>)f, ax = plt.subplots(figsize=(<span class="hljs-number">26</span>, <span class="hljs-number">12</span>))fig = sns.boxplot(x=var, y=<span class="hljs-string">&quot;SalePrice&quot;</span>, data=data)</code></pre></div><p><a href="https://imgse.com/i/xCalJs"><img src="https://s1.ax1x.com/2022/09/20/xCalJs.md.png" alt="xCalJs.md.png"></a></p><p>高评价位置对应高SalePrice，说明房屋位置评价与房屋售价有比较强的相关性。除了通过这样的分析证明原始特征与SalePrice强相关外，还可以通过分析来构建新的特征。</p><p>既然房屋位置和房屋评价的组合能够出现更高售价的房屋，那么我们可以构造这两个类别特征的交叉组合特征来进行更细致的描述，也可以构造这个组合特征下的房屋均价等。</p><h2 id="模型分析">模型分析</h2><h3 id="学习曲线">学习曲线</h3><p>学习曲线是机器学习中被广泛使用的效果评估工具，能够反映训练集和验证集在训练迭代中的分数变化情况，帮助我们快速了解模型的学习效果。我们可以通过学习曲线来观察模型是否过拟合，通过判断拟合程度来确定如何改进模型</p><p>学习曲线广泛应用于机器学习中的模型评估，模型会随着训练迭代逐步学习（优化其内部参数），例如神经网络模型。这时用于评估学习的指标可能会最大化（分类准确率）或者最小化（回归误差），这也意味着得分越高（低）表示学习到的信息越多（少）。</p><p>以下是学习曲线图中观察到的一些常见形状</p><ol><li>欠拟合学习模型</li></ol><p>欠拟合是指模型无法学习到训练集中数据所展现的信息，这里可以通过训练损失的学习曲线来确定是否发生欠拟合。在通常情况下，欠拟合学习曲线可能是一条平坦的线或者有着相对较高的损失，也就表明该模型根本无法学习训练集</p><ol start="2"><li>过拟合学习模型</li></ol><p>过拟合是指模型对训练集学习得很好，包括统计噪声或训练集中的随机波动。过拟合的问题在于，模型对于训练数据的专业化程度越高，对新数据的泛化能力就越差，这会导致泛化误差增加。泛化误差的增加可以通过模型在验证集上的表现来衡量。如果模型的容量超出了问题所需的容量，而灵活性又过多，则会经常发生这种情况。如果模型训练时间过长，也会发生过拟合。</p><h3 id="特征重要性分析">特征重要性分析</h3><p>通过模型训练可以得到特征重要性。对于树模型（如LightGBM和XGBoost），通过计算特征的信息增益或分裂次数得到特征的重要性得分。对于模型LR和SVM，则是使用特征系数作为特征重要性得分，例如LR（逻辑回归），每个特征各对应一个特征系数w，w越大，那么改特征对模型预测结果的影响就会越大，就可以认为该特征越重要。我们假定特征性得分和特征系数w都是在衡量特征在模型中的重要性，都可以起到特征选择的作用。</p><h3 id="误差分析">误差分析</h3><p>误差分析是通过模型预测结果来发现问题的关键。</p><p>一般而言，回归问题中看预测结果的分布，分类问题中看混淆矩阵等。</p><p>在真实问题中，误差分析会更加细致。比如，在进行一个用户违约预估的二分类任务中，验证集结果中有200个错误分类样本，进一步分析发现有70%的错误分类样本是由于大量特征缺失而导致的误判，这时就需要调整，既可以通过挖掘更多能够描述这些误判样本的特征信息帮助增强模型的预测能力，还可以在模型训练中赋予这些误判样本更高的权重。</p><h1>第4章 特征工程</h1><p>参考资料：<a href="https://blog.csdn.net/weixin_52205096/article/details/123194841">《机器学习算法竞赛实战》学习笔记4.特征工程</a></p><h2 id="数据预处理">数据预处理</h2><p>尽量得到标准、干净、连续的数据，供数据统计、数据挖掘等使用，视情况尝试对缺失值进行处理，比如是否要填充，填充什么。此外，有些竞赛提供的数据集以及对应的存储方式可能使得需要占用超过参赛者本身硬件条件的内存，故有必要进行一定的内存优化，这也有助于在有限的内存空间对更大的数据集进行操作。</p><h3 id="缺失值处理">缺失值处理</h3><p>除了XGBoost和LightGBM等算法在训练时可以直接处理缺失值以外，其他很多例如LR、DNN、CNN、RNN等都并不能对缺失值进行直接处理。故而在数据准备阶段，要比构建算法阶段花更多时间，因为像填补缺失值这样的操作需要细致处理。</p><ol><li>区分缺失值</li></ol><p>首先，需找到缺失值表现形式。除了None、NA和NaN外，还有例如-1或-999来填充的缺失值。还有一种看上去像缺失值，但实际上有实际意义的业务，此时需特殊对待。例如没有填“婚姻状态”的用户可能是对自己隐私比较敏感，应为其单独设为一个分类；没有“驾龄”可能是没有车，为其填充0比较合适。</p><ol start="2"><li>处理方法</li></ol><p>数据缺失可以分为类别特征的缺失和数值特征的缺失两种。</p><ul><li>对于类别特征，通常会填充一个新类别，如0,-1等。</li><li>对于数值特征，可以均值填充（但对异常值较为敏感），中位数填充（对异常值不敏感）。填充时一定要考虑所选择的填充方法会不会影响数据的准确性。</li></ul><p>填充方法总结如下：</p><ul><li>类别特征：可选择最常见的一类填充方法，即众数；或直接填一个新类别</li><li>数值特征：可填平均数、中位数、最大最小值等，具体情况具体分析</li><li>有序数据（如时间序列）：可填充相邻值next或previous</li><li>模型预测填充：普通的填充仅是一个结果的常态，并未考虑其他特征间相互作用的影响，可以对含有缺失值的那一列进行建模并预测其中缺失值的结果。方法虽然复杂但随后得到的结果直觉上比直接填充要好。</li></ul><h3 id="异常值处理">异常值处理</h3><p>实际数据中可能会发现某个或某些字段（特征）根据某个变量（如时间序列问题中的时间）排序后，经观察存在一些数值远高于或低于其一定范围内的其他数值。还有些不合理的存在，这些都可以视作异常值，他们可能会给算法性能带来负面影响。</p><ol><li>寻找异常值</li></ol><p>首先，找到异常值，总结了两种方法：</p><ul><li>通过可视化分析。简单使用散点图（Matplotlib），严重偏离密集区域的点都可当作异常值来处理</li><li>通过简单的统计分析，即根据基本的统计方法来判断数据是否异常，例如四分位数间距、极差、均差、标准差等，这种方法适合于挖掘单变量的数值型数据。（seaborn库的箱型图）</li></ul><ol start="2"><li>处理异常值</li></ol><ul><li>删除含有异常值的记录。优点：可消除含有异常值的样本带来的不确定性。缺点：减少了样本量</li><li>视为缺失值。优点：将异常值集中化为一类，增加了数据的可用性。缺点：将异常值和缺失值混为一谈，会影响数据的准确性、</li><li>平均值（中位数修正）。用对应同类别的数值使用平均值修正该异常值。优缺点同“视为缺失值”</li><li>不处理。直接在有异常值的数据集上进行数据挖掘。这就听天由命看异常值来源了。</li></ul><p><strong>离散型异常值（离散属性定义范围以外的所有值均为异常值）、知识型异常值（如大学生脱发情况：从无）等，都可以当做类别缺失值来处理。</strong></p><ol start="3"><li>优化内存</li></ol><p>数据集太大而自己的硬件条件有限就有可能会因为内存不够导致代码出现memory error，介绍Python的内存回收机制和数值类型优化这两种有助于优化内存的常见方法。</p><ul><li>内存回收机制：在Python的内存回收机制中，gc模块主要运用“引用计数”来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记清除”来解决容器对象可能产生的循坏引用问题，通过“隔代回收”以空间换取时间来进一步提高垃圾回收的效率。一般来讲，在我们删除一些变量时，使用gc.collect()来释放内存。（慎用）</li><li>数值类型优化。竞赛中常使用的数据保存格式是csv以及txt，在进行处理时，需要将其读取为表格型数据，即DataFrame格式。需要利用pandas进行操作。pandas可以在底层将数值型数据表示成NumPy数组，并使其在内存中连续存储。这种存储方式不仅消耗的空间较少，还使我们能够快速访问数据。</li></ul><p>我们可以用np.iinfo类来确认每一个int型子类型的最大值和最小值</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npnp.iinfo(np.int8).<span class="hljs-built_in">min</span>np.iinfo(np.int8).<span class="hljs-built_in">max</span></code></pre></div><ul><li>对于类别型的变量，若其编码ID的数字较大、极不连续且种类较少，则可以从0开始编码（自然数编码），这样可以减少变量的内存占用。</li><li>对于数值型的变量，常常由于存在浮点数使得内存占用过多，可以考虑先将其最小值和最大值归一化，然后再乘以100、1000等，再取整，节省内存空间。</li></ul><h2 id="特征变换">特征变换</h2><h3 id="连续变量无量纲化">连续变量无量纲化</h3><p>无量纲化指的是将不同规格的数据转换到同一规格。常见无量纲化方法有标准化和区间缩放法。标准化的前提是特征值服从正态分布，标准化后，特征值服从标准正态分布。区间缩放法利用了边界信息，将特征的取值区间缩放到某个特定的范围，例如[0,1]</p><p>单特征转换是构建一些模型（如线性回归、KNN、神经网络）的关键，对于决策树相关模型并无影响。还有些纯粹的工程原因，即在进行回归预测时，对目标取对数处理，不仅可以缩小数据范围，而且压缩变量尺度使数据更平稳。</p><p>然而，数据要求不仅是通过参数化方法施加的。如果特征没有被规范化，例如当一个特征的分布位于0附近且范围不超过（-1,1），而另一个特征的分布范围在数十万数量级时，会导致分布于0附近的特征变得完全无用。</p><ul><li>标准化：最简单的转换是标准化（零-均值规范化）。标准化需要计算特征的均值和标准差。</li><li>区间缩放：区间缩放思路有很多种，常见的一种使利用最大最小值进行缩放。<br>2.2 连续变量数据变换<br>1.log变换<br>进行log变换可以将倾斜数据变得接近正态分布，因为大多数机器学习模型不能很好地处理非正态分布数据，比如右倾数据。可以应用log(x+1)变换来修正倾斜，其中+1的目的是防止数据等于0，同时保证x都是正的。取对数不会改变数据的性质和相关关系，但是压缩了变量的尺度，不仅数据更加平稳，还削弱了模型的共线性、异方差性等。</li></ul><p>扩展：cbox-cox变换，一种自动寻找最佳正态分布变换函数的方法。</p><h3 id="连续变量数据变换">连续变量数据变换</h3><p>log变换可以将倾斜数据变得接近正态分布。</p><p>离散化后的特征对异常数据有很强的健壮性，更便于探索数据的相关性。常用的离散化分为无监督和有监督两种。</p><p>无监督的离散化分桶操作可以将连续变量离散化，同时使数据平滑，即降低噪声的影响。一般分为等频和等距两种分桶方式。</p><ul><li>等频：区间的边界值要经过选择，使得每个区间包含数量大致相等的变量实例。这种分桶方式可以将数据变成均匀分布。</li><li>等距：将实例从最小到最大值，均分为N等份，每份的间距是相等的。这里只考虑边界，每等份的实例数量可能不等。等距可以保持数据原有的分布，并且区间越多，对数据原貌保持得越好。</li></ul><p>有监督的离散化对目标有很好的区分能力，常用的是使用树模型返回叶子节点来进行离散化。如在GBDT+LR经典模型中，就是先使用GBDT来将连续值转化为离散值。具体方法：用训练集中的所有连续值和标签输出来训练LightGBM，共训练两棵决策树，第一棵有4个叶子节点，第二棵树有3个叶子节点。如果某一个样本落在第一棵树的第三个叶子节点上，落在第二棵树的第一个叶子节点上，那么它的编码就是0010100，一共7个离散特征，其中会有两个取值为1的位置，分别对应每棵树中样本落点的位置。最终我们会获得num_trees*num_leaves维特征。</p><h3 id="类别特征转换">类别特征转换</h3><p>在实际数据中，特征并不总是数值，还有可能是类别。对于离散型的类别特征进行编码，一般分为两种情况：自然数编码（特征有意义）和独热（one-hot）编码（特征无意义）。</p><p>自然数编码：一列有意义的类别特征（即有顺序关系）可以使用自然数进行编码，利用自然数的大小关系可以保留其顺序关系。以下是两种自然数编码的常用方式：</p><p>①调用sklearn中函数：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing<span class="hljs-keyword">from</span> f <span class="hljs-keyword">in</span> columns:le = preprocessing.LableEncoder()le.fit(data[f&#125;)</code></pre></div><p>②自定义实现（速度快）</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> columns:data[f] = data[f].fillna(-<span class="hljs-number">999</span>)data[f] = data[f].<span class="hljs-built_in">map</span>(<span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(data[f].unique(),<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,data[f].nunique()))))</code></pre></div><p>独热编码：当类别特征没有意义（即无顺序关系）时，需要使用独热编码。例如，红&gt;蓝&gt;绿不代表任何东西，进行独热编码后，每个特征的取值对应一维特征，最后得到一个样本数×类别数大小的0~1矩阵。可直接调用sklearn中API进行生成（或者是使用哑变量的方式）</p><h3 id="不规则特征变换">不规则特征变换</h3><p>不规则特征可能包含样本的很多信息，比如身份证号，各段表示不同的信息。一般不会提供这种比较敏感的信息。</p><h2 id="特征提取">特征提取</h2><p>机器学习模型很难识别复杂的模式，特别是很难学习到不同特征组合交叉的信息，所以我们可以基于对数据集的直觉分析和业务理解创建一些特征来帮助模型有效学习。下面我们将介绍结构化数据的特征提取方式。</p><p>（结构化数据由明确定义的数据类型组成，非结构化数据由音频、视频和图片等不容易搜索的数据组成。）</p><h3 id="类别相关的统计特征">类别相关的统计特征</h3><p>类别特征又可以称为离散特征，除了每个类别属性的特定含义外，还可以构造连续型的统计特征，以挖掘更多有价值的信息，比如构造目标编码、count、nunique和ratio等特征。另外，也可以通过类别特征间的交叉组合构造更加细粒度的特征。</p><ol><li>目标编码</li></ol><p>目标编码可以理解为用目标变量（标签）的统计量对类别特征进行编码，即根据目标变量进行有监督的特征构造。如果是分类问题，可以统计目标均值、中位数和最值。目标编码的方式可以很好地替代类别特征，或者作为新特征。</p><p>使用目标变量时，非常重要的一点是不能泄露任何验证集的信息。所有基于目标编码的特征都应该在训练集上计算，测试集则由完整的训练集来构造。更严格一点，我们在统计训练集的特征时，需要采用K折交叉统计法构造目标编码特征，从而最大限度地防止信息泄露。如用五折交叉统计构造特征时，我们将样本划分为五份，对于其中每一份数据，我们都将用另外四份来计算每个类别取值对应目标变量的频次、比例或者均值，简单来说就是未知的数据（一份）在已知的数据（四份）里面取特征。</p><p>目标编码方法对于基数较低的类别特征通常很有效，但对于基数较高的类别特征，可能会有过拟合的风险。因为会存在一些类别出现频次非常低，统计出来的结果不具有代表性。一般会加入平滑性来降低过拟合风险。在处置妥当的情况下，无论是线性模型，还是非线性模型，目标编程都是最佳的编码方式和特征构造方式。</p><ol start="2"><li>count nunique ratio</li></ol><p>count：计数特征，用于统计类别特征的出现频次</p><p>nunique和ratio常常会涉及多个类别特征的联合构造。例如在广告点击率预测问题中，对于用户ID和广告ID，使用nunique可以反映用户对广告的兴趣宽度，也就是统计用户ID看过几种广告ID；使用ratio可以反映用户对某类广告的偏好程度，即统计用户ID点击某类广告ID的频次占用户点击所有广告ID频次的比例。</p><ol start="3"><li>类别特征之间交叉组合</li></ol><p>交叉组合能够描述更细粒度的内容。对类别特征进行交叉组合在竞赛中是一项非常重要的工作，这样可以进行很好的非线性特征拟合。如用户年龄和用户性别可以组合成“年龄_性别”这样的新特征。一般我们可以对两个类别或三个类别特征进行组合，也称作二阶组合或三阶组合。简单来讲，就是对两个类别特征进行笛卡尔积的操作，产生新的类别特征。</p><p>并非所有组合都是需要考虑的，我们会从两个方面进行分析。</p><ul><li>业务逻辑方面：比如用户操作系统版本与用户所在城市的组合是没有实际意义的。</li><li>类别特征的基数：如果基数过大，那么可能导致很多类别只会出现一次，在一轮训练中，每个类别只会被训练一次，显然特征对应权重的置信度是很低的。</li></ul><h3 id="数值相关的统计特征">数值相关的统计特征</h3><p>这里所说的数值特征，我们认为是连续的。数值特征的大小是有意义的，通常不需要处理就可以直接“喂”给模型进行训练。除了之前对数值特征进行各种变换外，还存在一些其他常见的数值特征构造方式。</p><ul><li>数值特征之间的交叉组合：一般对数值特征进行加减乘除等算术操作类的交叉组合。这需要我们结合业务理解和数据分析进行构造。</li><li>类别特征和数值特征之间的交叉组合：除了类别特征之间和数值特征之间的交叉组合外，还可以构造类别特征与数值特征之间的交叉组合。这类特征通常是在类别特征的某个类别中计算数值特征的一些统计量，比如均值、中位数和最值等。</li><li>按行统计相关特征：行统计在构造时会包含更多的列，直接对多列进行统计。</li></ul><h3 id="时间特征">时间特征</h3><p>在实际数据中，通常给出的时间特征是时间戳属性，所以首先需要将其分离成多个维度，比如年月日小时分钟秒钟。如果你的数据源来自于不同的地理数据源，还需要利用时区将数据标准化。除了分离出来的基本时间特征外，还可以构造时间差特征，即计算出各个样本的时间与未来某一个时间的数值差距，这样这个差距是UTC的时间差，从而将时间特征转换为连续值，比如用户首次行为日期与用户注册日期的时间差、用户当前行为与用户上次行为的时间差等。</p><h3 id="多值特征">多值特征</h3><p>在竞赛中，可能会遇到某一列特征中每行都包含多个属性的情况，这就是多值特征。例如广告大赛中的兴趣类目，其中包含5个兴趣特征组，每个兴趣特征组都包含若干个兴趣ID。对于多值特征，通常可以进行稀疏化或者向量化的处理，这种操作一般出现在自然语言处理中，比如文本分词后使用TF-IDF（词频-逆文档频率）、LDA（隐含狄利克雷分布）、NMF（非负矩阵分解）等方式进行处理，这里则可以将多值特征看作文本分词后的结果，然后做相同的处理。</p><p>对多值特征最基本的处理办法是完全展开，即把这列特征所包含的n个属性展开成n维稀疏矩阵。使用sklearn中的CountVectorizer函数，可以方便地将多值特征展开，只考虑每个属性在这个特征的出现频次。</p><p>还有一种情况，比如在广告算法大赛中，需要根据用户的历史点击行为预测用户的属性标签。这时候用户的点击序列尤为重要，当我们构造好用户对应的历史点击序列后，除了使用上述的TF-IDF等方法外，还可以提取点击序列中商品或广告的嵌入表示，比如用Word2Vec、DeepWalk等方法获取embedding向量表示。因为要提取用户单个特征，所以可以对序列中的嵌入向量进行聚合统计，这种方法本质上是假设用户点击过的商品或广告等同重要，是一种比较粗糙的处理方式。我们可以引入时间衰减因素，或者使用序列模型，如RNN、LSTN、GRU，套用NLP的方法进行求解。</p><h2 id="特征选择">特征选择</h2><p>当我们添加新特征时，需要验证它是否确实能够提高模型预测的准确度，以确定不是加入了无用的特征，因为这样只会增加算法运算的复杂度，这时候就要通过特征选择算法自动选择出特征集中的最优子集，帮助模型提供更好的性能。特征选择算法用于从数据中识别并删除不需要、不相关以及冗余特征。这些特征可能会降低模型的准确度和性能，特征选择的方法主要有先验的特征关联性分析以及后验的特征重要性分析。、</p><h3 id="特征关联性分析">特征关联性分析</h3><p>特征关联性分析是使用统计量来为特征之间的相关性进行评分。特征按照分数进行排序，要么保留，要么从数据集中删除。关联性分析方法通常是针对单变量的，并独立考虑特征或者因变量。常见的特征关联性分析方法有皮尔逊相关系数、卡方检验、互信息法和信息增益等。这些方法速度快、使用方便，但是忽略了特征之间的关系，以及特征和模型之间的关系。</p><ol><li>皮尔逊相关系数</li></ol><p>不仅可以衡量变量之间的线性相关性，解决共线变量问题，还可以衡量特征与标签的相关性。共线变量是指变量之间存在高度相关关系，这会降低模型的学习可用性，可解释性以及测试集的泛化性能。但这三个特性都是我们想增加的，所以删除共线变量是一个有价值的步骤。我们将为删除共线变量建立一个基本的阈值（根据想要保留的特征数量决定）。</p><p>下面代码用于解决特征与标签不具有相关性的问题，根据皮尔逊相关系数的计算提取top300的相似特征：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">feature_select_pearson</span>(<span class="hljs-params">train,features</span>):featureSelect = features[:]<span class="hljs-comment">#进行皮尔逊相关性计算</span>corr=[]<span class="hljs-keyword">for</span> feat <span class="hljs-keyword">in</span> featureSelect:corr.append(<span class="hljs-built_in">abs</span>(train[[feat,<span class="hljs-string">&#x27;target&#x27;</span>]].fillna(<span class="hljs-number">0</span>).corr().values[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))se = pd.Series(corr,index=featureSelect).sort_values(ascending=<span class="hljs-literal">False</span>)feature_select = se[:<span class="hljs-number">300</span>&#125;.index.tolist()<span class="hljs-comment">#返回特征选择后的训练集</span><span class="hljs-keyword">return</span> train[feature_select]</code></pre></div><ol start="2"><li>卡方检验</li></ol><p>用于检验特征变量与因变量的相关性。对于分类问题，一般假设与标签独立的特征为无关特征，而卡方检验恰好可以进行独立性检验，所以使用与特征选择。如果检验结果是某个特征与标签独立，则可以去除该特征。</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=%5Cchi%5E2%3D%5Csum%5Cfrac%7B%28A-E%29%5E2%7D%7BE%7D%0A" /></p><ol start="3"><li>互信息法</li></ol><p>互信息是对一个联合分布中两个变量之间相互影响关系的度量，也可以用于评价两个变量之间的相关性。互信息法之所以能够用于特征选择，可以从两个角度进行解释：基于KL散度和基于信息增益。互信息越大说明两个变量相关性越高。</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=MI%28x_i%2Cy%29%20%3D%20%20%5Csum_%7Bx_i%20%20%5Cin%20%5C%7B0%2C1%5C%7D%7D%5Csum_%7By%5Cin%5C%7B0%2C1%5C%7D%7Dp(x_i%2Cy)log%7B(%5Cfrac%7Bp(x_i%2Cy)%7D%7Bp(x_i)p(y)%7D)%7D%0A" /></p><p>但是想把互信息直接用于特征选择其实不太方便，由于：</p><ul><li>它不属于度量方式，也没有办法归一化，无法对不同数据集上的结果进行比较</li><li>对于连续变量的计算不是很方便（X和Y都是集合，xi和y都是离散的取值），通常连续变量需要先离散化，而互信息的结果对离散化的方式很敏感。</li></ul><h3 id="特征重要性分析-2">特征重要性分析</h3><p>在实际竞赛中，经常用到的一种特征选择方法是基于树模型评估特征的重要性分数。特征的重要性分数越高，说明特征在模型中被用来构建决策树的次数越多。这里我们以XGBoost为例来介绍树模型评估特征重要性的三种计算方法（weight、gain和cover）。（LightGBM也可以返回特征重要性）</p><ul><li>weight计算方式：该方式比较简单，计算特征在所有树中被选为分裂特征的次数，并将以此作为评估特征重要性的依据</li></ul><div class="code-wrapper"><pre><code class="hljs python">params =&#123;<span class="hljs-string">&#x27;max_depth&#x27;</span>:<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;subsample&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;verbose_eval&#x27;</span>:<span class="hljs-literal">True</span>,<span class="hljs-string">&#x27;seed&#x27;</span>:<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;objective&#x27;</span>:<span class="hljs-string">&#x27;binary:logistic&#x27;</span>&#125;xgtrain = xgb.DMatrix(x,label=y)bst = xgb.train(params,xgtrain,numm_boost_round=<span class="hljs-number">10</span>)importance = bst.get_score(fmap=<span class="hljs-string">&#x27;&#x27;</span>,importance_type=<span class="hljs-string">&#x27;weight&#x27;</span>)</code></pre></div><ul><li>gain计算方式：gain表示平均增益。在进行特征重要性评估时，使用gain表示特征在所有树中作为分裂节点的信息增益之和再除以该特征出现的频次。</li></ul><div class="code-wrapper"><pre><code class="hljs python">importance =bst.get_score(fmap=<span class="hljs-string">&#x27;&#x27;</span>,importance_type=<span class="hljs-string">&#x27;gain&#x27;</span>)</code></pre></div><ul><li>cover计算方式：cover是特征对每棵树的覆盖率，即特征被分到该节点的样本的二阶导数之和，而特征度量的标准就是平均覆盖率值。</li></ul><div class="code-wrapper"><pre><code class="hljs python">importance = bst.get_score(fmap=<span class="hljs-string">&#x27;&#x27;</span>,importance_type=<span class="hljs-string">&#x27;cover&#x27;</span>)</code></pre></div><p><strong>技巧：虽然特征重要性可以帮助我们快速分析特征在模型训练过程中的重要性，但不能将其当做绝对的参考依据。一般而言，只要特征不会导致过拟合，我们就可以选择重要性高的特征进行分析和扩展，对于重要性低的特征，可以考虑将之从特征集中移除，然后观察线下效果，再做进一步判断。</strong></p><h3 id="封装方法">封装方法</h3><p>可以将一组特征的选择视作一个搜索问题，在这个问题中，通过准备、评估不同的组合并对这些组合进行比较，从而找出最优的特征子集，搜索过程可以是系统性的，比如最佳优先搜索；也可以是随机的，比如随机爬山算法，或者启发式方法，比如通过向前和向后搜索来添加和删除特征（类似前剪枝和后剪枝算法）。这种方法比较耗时。</p><ul><li>启发式方法：分为前向搜索和后向搜索。前向搜索是每次增量地从剩余未选中的特征中选出一个并将其加入特征集中，待特征集中的特征数量达到初设阈值时，意味着贪心选出了错误率最小的特征子集。既然有增量加，就会有增量减，后者称为后向搜索，即从特征全集开始，每次删除其中的一个特征并评价，知道特征集中的特征数量达到初设阈值，就选出了最佳的特征子集<ul><li>因为启发式方法会导致局部最优，所以加入模拟退火方式进行改善，这种方式不会因为新加入的特征不能改善效果而舍弃该特征，而是对其添加权重后放入已选特征集。这种启发式方法是很耗时间耗资源的。</li></ul></li><li>递归消除特征法：用一个基模型来进行多轮训练，每轮训练都会先消除若干权值系数的特征，再基于新特征集进行下一轮训练。可以使用feature_selection库的RFE类来进行特征选择</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> RFE<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<span class="hljs-comment">#递归消除特征法，返回特征选择后的数据</span><span class="hljs-comment">#参数estimator为基模型</span><span class="hljs-comment">#参数n_feature_to_select 为选择的特征个数</span>RFE(estimator=LogisticRegression(),n_features_to_select=<span class="hljs-number">2</span>).fit_transform(data,target)</code></pre></div><p>技巧：在使用封装方法进行特征选择时，用全量数据训练并不是最明智的选择。应先对大数据进行采样，再对小数据使用封装方法</p><p>以上三种特征选择方法按需使用或组合使用，建议优先考虑特征重要性，其次是特征关联性。</p><p>此外还有null importance。其思想：将构建好的特征和正确的标签喂给树模型得到一个特征重要性分数，再将特征和打乱后的标签喂给树模型得到一个特征重要性分数，然后对比两个分数，如果前者没有超过后者，那么这个特征就是一个无用的特征。</p><h1>第5章  模型训练</h1><p>参考资料 ：<a href="https://blog.csdn.net/qq_37039382/article/details/124541131">《机器学习算法竞赛实战》整理 | 五、模型训练</a></p><h2 id="线性模型">线性模型</h2><h3 id="Lasso回归">Lasso回归</h3><p>Lasso回归是对普通的线性回归采用L1正则化进行优化，通过惩罚或限制估计值的绝对值之和，可以使某些系数为零，从而达到特征稀疏化和特征选择的效果。当我们需要一些自动的特征、变量选择，或者处理高度相关的预测因素时，很方便。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Lassolasso_model = Lasso(alpha = <span class="hljs-number">0.1</span>, normalize = <span class="hljs-literal">True</span>)</code></pre></div><p>只保留不相关的特征，其他为0，可能会导致信息损失</p><h3 id="Ridge回归">Ridge回归</h3><p>Ridge回归是对普通的线性回归采用L2正则化进行优化，对特征的权重系数设置了惩罚项。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridgeridge_model = Ridge(alpha = <span class="hljs-number">0.05</span>, normalize = <span class="hljs-literal">True</span>)</code></pre></div><p>不会减少特征数量，不利于特征缩减。</p><p>两者合并：Elastic Net Regression</p><h2 id="树模型">树模型</h2><p>本节将介绍竞赛中常见的树模型，这些模型简单易用，能够带来高收益。</p><p>可将树模型分为随机森林(Random Forest, RF)和梯度提升树(GBDT)， 这两者最大的差异是前者并行、后者串行。在梯度提升树部分我们将介绍如今竞赛中大火的三种树模型: XGBoost、 LightGBM 和CatBoost。能够灵活运用这三种模型是竞赛中的必备技能。接下来将详细介绍各种树模型的数学形式、优缺点、使用细节和应用场景。</p><h3 id="随机森林">随机森林</h3><p>随机森林就是通过集成学习的思想将多个决策树集成在一起，各个决策树之间没有任何关联。随机森林算法对多个决策树的结果进行投票得到最终结果，也是最简单的bagging思想 。</p><p>随机森林的优点：</p><ul><li>不仅可以解决分类和回归问题，还可以同时处理类别特征和数值特征;</li><li>不容易过拟合，通过平均决策树的方式，降低过拟合的风险;</li><li>非常稳定，即使数据集中出现了一个新的数据点，整个算法也不会受到过多影响，新的数据点只会影响到一棵决策树，很难对所有决策树都产生影响。</li></ul><p>很多缺点都是相对而言的：</p><ul><li>随机森林算法虽然比决策树算法更复杂，计算成本更高，但是其拥有天然的并行特性，在分布式环境下可以很快地训练。</li><li>梯度提升树需要不断地训练残差，进行所以结果准确度更高，但是随机森林更不容易过拟合，更加稳定，这也是因为其Bagging的特性。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifierrf = RandomForestClassifier(max_ features=<span class="hljs-string">&#x27; auto&#x27;</span>, oob_ score=<span class="hljs-literal">True</span>, random state=<span class="hljs-number">1</span>, n_ jobs=-<span class="hljs-number">1</span>)</code></pre></div><h3 id="梯度提升树">梯度提升树</h3><p>梯度提升树(GBDT)是基于Boosting改进而得的，在Boosting算法中，一系列基学习器都需要串行生成，每次学习一棵树，学习目标是上棵树的残差。和AdaBoost 一样，梯度提升树也是基于梯度下降函数。梯度提升树算法已被证明是Boosting算法集合中最成熟的算法之一，它的特点是估计方差增加，对数据中的噪声更敏感(这两个问题都可以通过使用子采样来减弱)，以及由于非并行操作而导致计算成本显著，因此要比随机森林慢很多。</p><p><strong>梯度提升树是XGBoost、LightGBM和CatBoost的基础。</strong></p><h3 id="XGBoost">XGBoost</h3><ul><li>采用稀疏感知算法，XGBoost可以利用稀疏矩阵，节省内存（不需要密集矩阵）和节省计算时间（零值以特殊方式处理）。</li><li>近似树学习（加权分位数略图），这类学习方式能得到近似的结果，但比完整的分支切割探索要省很多时间。</li><li>在一台机器上进行并行计算（在搜索最佳分割阶段使用多线程），在多台机器上进行类似的分布式计算。</li><li>利用名为核外计算的优化方法，解决在磁盘读取数据时间过长的问题。将数据集分成多个块存放在磁盘中，使用一个独立的线程专门从磁盘读取数据并加载到内存中，这样一来，从磁盘读取数据和在内存中完成数据计算就能并行运行。</li><li>XGBoost还可以有效地处理缺失值，训练时对缺失值自动学习切分方向。基本思路是在每次的切分中，让缺失值分别被切分到决策树的左节点和右节点，然后通过计算增益得分选择增益大的切分方向进行分裂，最后针对每个特征的缺失值，都会学习到一个最优的默认切分方向。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xgboost <span class="hljs-keyword">as</span> xgbparams = &#123;<span class="hljs-string">&#x27;eta&#x27;</span>: <span class="hljs-number">0.01</span>, <span class="hljs-string">&#x27; max depth&#x27;</span>: <span class="hljs-number">11</span>, <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;reg:linear&#x27;</span>, <span class="hljs-string">&#x27;eval_ metric&#x27;</span>: <span class="hljs-string">&#x27;rmse&#x27;</span> &#125;dtrain = xgb.DMatrix(data=X_train, label=y_train)dtest = xgb.DMatrix(data=X_valid, label=y_valid)watchlist = [(train.data, <span class="hljs-string">&#x27;train&#x27;</span>), (valid_data, <span class="hljs-string">&#x27;valid_ data&#x27;</span>)]model=xgb. train(params, train_data,num_boost_round=<span class="hljs-number">20000</span>,evals=watchlist,early_stopping_rounds=<span class="hljs-number">200</span>,verbose_eval=<span class="hljs-number">500</span>)y_pred = model. predict(xgb .DMatrix(X_test), ntree_limit=model.best_ntree_limit)</code></pre></div><h3 id="LightGBM">LightGBM</h3><p>LightGBM是微软的一个团队在Github上开发的一个开源项目，高性能的LightGBM算法具有分布式和可以快速处理大量数据的特点。LightGBM虽然基于决策树和XGBoost而生，但它还遵循其他不同的策略。</p><p>XGBoost使用决策树对一个变量进行拆分，并在该变量上探索不同的切割点（按级别划分的树生长策略），而LightGBM则专注于按叶子节点进行拆分，以便获得更好的拟合（这是按叶划分的树生长策略）。这使得LightGBM能够快速获得很好的数据拟合，并生成能够替代XGBoost的解决方案。从算法上讲，XGBoost将决策树所进行的分割结构作为一个图来计算，使用广度优先搜索（BFS），而LightGBM使用的是深度优先搜索（DFS）。</p><p>主要特点</p><ul><li>比XGBoost准确性更高，训练时间更短。</li><li>支持并行树增强，即使在大型数据集上也能提供比 XGBoost更好的训练速度。</li><li>通过使用直方图算法将连续特征提取为离散特征，实现了惊人的快速训练速度和较低的内存使用率。</li><li>通过使用按叶分割而不是按级别分割来获得更高精度，加快目标函数收敛过程，并在非常复杂的树中捕获训练数据的底层模式。使用num_leaves和max_depth超参数控制过拟合。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgbparams = &#123;<span class="hljs-string">&#x27;num_leaves&#x27;</span>: <span class="hljs-number">54</span>, <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;regression&#x27;</span>, <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">18</span>,<span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.01</span>, <span class="hljs-string">&#x27;boosting&#x27;</span>: <span class="hljs-string">&#x27;gbdt&#x27;</span>, <span class="hljs-string">&#x27;metric&#x27;</span>: <span class="hljs-string">&#x27;rmse&#x27;</span>, <span class="hljs-string">&#x27;lambda_11&#x27;</span>: <span class="hljs-number">0.1</span>&#125;model = lgb.LGBMRegressor(**params, n_estimators = <span class="hljs-number">20000</span>, nthread = <span class="hljs-number">4</span>, n_jobs = -<span class="hljs-number">1</span>)model.fit(x_train, y_train, eval_set=[(X_train, y_train), (X_valid, y_valid)], eval_metric=<span class="hljs-string">&#x27;rmse&#x27;</span>, verbose=<span class="hljs-number">1000</span>, early_stopping_rounds=<span class="hljs-number">200</span>)y_pred= model.predict(X_test, num_iteration=model.best_iteration_)</code></pre></div><h3 id="CatBoost">CatBoost</h3><p>CatBoost是由俄罗斯搜索引擎Yandex在2017年7月开源的一个GBM算法，它最强大的点是能够采用将独热编码和平均编码混合的策略来处理类别特征。</p><p>CatBoost用来对类别特征进行编码的方法并不是新方法，是均值编码，该方法已经成为一种特征工程方法，被广泛应用于各种数据科学竞赛中，如Kaggle。</p><p>均值编码，也称为似然编码、影响编码或目标编码，可将标签转换为基于它们的数字，并与目标变量相关联。如果是回归问题，则基于级别典型的平均目标值转换标签；如果是分类问题，则仅给定标签的目标分类概率（目标概率取决于每个类别值）。均值编码可能看起来只是一个简单而聪明的特征工程技巧，但实际上它也有副作用，主要是过拟合，因为会把目标信息带入预测中。</p><p>主要特点</p><ul><li>支持类别特征，因此我们不需要预处理类别特征（例如通过label encoding或独热编码）。事实上，CatBoost文档中讲到不要在预处理期间使用独热编码，因为“这会影响训练速度和结果质量”。</li><li>提出了一种全新的梯度提升机制（Ordered Boosting），不仅可以减少过拟合的风险，也大大提高了准确性。</li><li>支持开箱即用的GPU训练（只需设置task_type=“GPU”）。</li><li>训练中使用了组合类别特征，利用了特征之间的联系，极大丰富了特征维度。</li><li>在树分裂选择节点的时候能够将所有类别特征之间的组合考虑进来，即能够对两个类别特征进行组合。</li><li>目前还支持输入文本特征，因此不需要像以前那样先进行烦琐的操作获得标准化输入，再喂给模型。</li></ul><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> catboost <span class="hljs-keyword">import</span> CatBoostRegressorparams = &#123;<span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.02</span>, <span class="hljs-string">&#x27;depth&#x27;</span>: <span class="hljs-number">13</span>,<span class="hljs-string">&#x27;bootstrap_type&#x27;</span>: <span class="hljs-string">&#x27;Bernoulli&#x27;</span>, <span class="hljs-string">&#x27;od_type&#x27;</span>: <span class="hljs-string">&#x27;Iter&#x27;</span>, <span class="hljs-string">&#x27;od_wait&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;random_seed&#x27;</span>: <span class="hljs-number">11</span>&#125;model = CatBoostRegressor(iterations=<span class="hljs-number">20000</span>, eval_metric=<span class="hljs-string">&#x27;RMSE&#x27;</span>, **params)model.fit(X_train, y_train, eval_set=(X_valid, y_valid), cat_features=[], use_best_model=<span class="hljs-literal">True</span>, verbose=<span class="hljs-literal">False</span>)y_pred = model.predict(X_test)</code></pre></div><h3 id="模型深入对比">模型深入对比</h3><p>每类树模型都其与众不同的地方，接下来将从决策树的生长策略、梯度偏差、类别特征处理和参数对比四个方面深入理解这些树模型，帮助参赛者更好地将它们应用到竞赛中。<br>XGBoost，LightGBM 和 CatBoost是三个非常核心的树模型，本节将对它们进行分析，因为三者之间有着千丝万缕的关系，只有厘清其中的关系，才能更好地运用这三个模型。</p><ol><li>决策树生长策略</li></ol><ul><li>XGBoost使用的是Level-wise按层生长，可以同时分裂同一层的叶子，从而进行多线程优化，不容易过拟合，但很多叶子节点的分裂增益较低，会影响性能。</li><li>LightGBM使用的是Leaf-wise分裂方式，每次都从当前叶子中选择增益最大的结点进行分裂，循环迭代，但会生长出非常深的决策树，从而导致过拟合，这时可以调整参数max_depth来防止过拟合。</li><li>CatBoost 使用的是oblivious-tree（对称树），这种方式使得节点是镜像生长的。相对于传统的生长策略，oblivious-tree能够简单拟合方案，快速生成模型，这种树结构起到了正则化的作用，因此并不容易过拟合。</li></ul><ol start="2"><li>梯度偏差（Gradient bias）</li></ol><ul><li>XGBoost和LightGBM中的提升树算法都是有偏梯度估计，在梯度估计中使用的数据与目前建立的模型所使用的数据是相同的，这样会导致数据发生泄漏，从而产生过拟合。</li><li>CatBoost改进了提升树算法，将原来的有偏梯度估计转换为了无偏梯度估计。具体做法是利用所有训练集（除第i条）建立模型<img src="https://math.now.sh?inline=M_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，然后使用第1条到第i-1条数据来建一个修正树M，累加到原来的模型<img src="https://math.now.sh?inline=M_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上。</li></ul><ol start="3"><li>类别特征处理</li></ol><ul><li>XGBoost并不能处理类别特征，因此需要我们根据数据实际情况进行独热编码、count编码和目标编码。</li><li>LightGBM 直接支持类别特征，不需要独热展开。这里使用many-vs-many的切分方式来处理类别特征，并且可以把搜索最佳分割点的时间复杂度控制在线性级别，和原来one-vs-other方式的时间复杂度几乎一致。该算法先按照每个类别对应的标签均值（即avg（y）=Sum（y）/Count（y））进行排序，然后根据排序结果依次枚举最优分割点。和数值型特征的切分方式不同，它是将某一类别当作一类，然后将其余所有类别作为一类。</li><li>CatBoost在处理类别特征方面做了更细致的操作。或许在使用LightGBM时，还需要对类别特征进行更多的编码方式，但对于CatBoost，则可以选择不进行多余的编码方式。具体实现流程是首先对输入的样本集随机排序，然后针对类别特征中的某个取值，在将每个样本的该特征转换为数值型时，都基于排在该样本之前的类别标签取均值。对所有的类别特征值结果都进行如式（5-10）所示的运算，使之转化为数值结果，</li></ul><ol start="4"><li>参数对比</li></ol><p><a href="https://imgse.com/i/xPuQVP"><img src="https://s1.ax1x.com/2022/09/20/xPuQVP.png" alt="xPuQVP.png"></a></p><h2 id="神经网络">神经网络</h2><p>随着拥有数据量的增加，神经网络战胜传统机器学习模型的可能性也会加大。</p><ul><li>多层感知机：含有多个隐藏层的神经网络</li><li>卷积神经网络 ：广泛应用于计算机视觉领域</li><li>循环神经网络：更擅长对序列数据进行建模处理</li></ul><h2 id="实战案例（未实际运行）">实战案例（未实际运行）</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#接第5章实战案例代码，构造训练集和测试集</span>x_train = data[:ntrain][all_cols]x_test = data[ntrain:][all_cols]<span class="hljs-comment">#对售价进行log处理</span>y_train = np.log1p(data[data.SalePrice.notnull()][<span class="hljs-string">&#x27;SalePrice&#x27;</span>].values)</code></pre></div><p>XGBoost：使用比较常规的五折交叉验证</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> xgboost <span class="hljs-keyword">as</span> xgb<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFoldkf = KFold(n_splits=<span class="hljs-number">5</span>,shuffle=<span class="hljs-literal">True</span>,random_state=<span class="hljs-number">2020</span>)<span class="hljs-keyword">for</span> i,(train_index,valid_index)<span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(x_train,y_train)):    trn_x,trn_y,val_x,val_y = x_train.iloc[train_index],y_train[train_index],x_train.iloc[valid_index],y_train[valid_index]    params =&#123;<span class="hljs-string">&#x27;eta&#x27;</span>:<span class="hljs-number">0.01</span>,<span class="hljs-string">&#x27;max_depth&#x27;</span>:<span class="hljs-number">11</span>,<span class="hljs-string">&#x27;objective&#x27;</span>:<span class="hljs-string">&#x27;reg:linear&#x27;</span>,<span class="hljs-string">&#x27;eval_metric&#x27;</span>:<span class="hljs-string">&#x27;mae&#x27;</span>&#125;    dtrain = xgb.DMatrix(data=trn_x,label=trn_y)    dtest = xgb.DMatrix(data=val_x,label=val_y)    watchlist =[(dtrain,<span class="hljs-string">&#x27;train&#x27;</span>),(dtest,<span class="hljs-string">&#x27;valid_data&#x27;</span>)]    model=xgb.train(params,dtrain,num_boost_round=<span class="hljs-number">20000</span>,evals=watchlist,early_stopping_rounds=<span class="hljs-number">200</span>,verbose_eval=<span class="hljs-number">500</span>)</code></pre></div><p>多层感知机：要确保数据中没有缺失值，并且要对数据进行归一化处理。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn. model_selection <span class="hljs-keyword">import</span> train_test_split<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScalerx_train = x_train. fillna(<span class="hljs-number">0</span>)x_train = StandardScaler(). fit_transform(x_train)trn_x, val_x, trny, val_y = train_test_split(x_train, y_train, random_state=<span class="hljs-number">2020</span>)<span class="hljs-keyword">def</span> <span class="hljs-title function_">create_mlp</span>(<span class="hljs-params">shape</span>):    x_input = Input((shape, ))    X = Dropout(<span class="hljs-number">0.2</span>)(BatchNormalization()(        Dense(<span class="hljs-number">256</span>, activation=<span class="hljs-string">&#x27; relu&#x27;</span>)(X_input)))    X = Dropout(<span class="hljs-number">0.2</span>)(BatchNormalization()(Dense(<span class="hljs-number">128</span>, activation=<span class="hljs-string">&#x27; relu&#x27;</span>)(X)))    X = Dropout(<span class="hljs-number">0.2</span>)(BatchNormalization()(Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">&#x27; relu&#x27;</span>)(X)))    X = Dense(<span class="hljs-number">1</span>)(X)    model = Model(inputs=X_input, outputs=X)    model. <span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27; adam&#x27;</span>, loss=<span class="hljs-string">&#x27; mse&#x27;</span>, metrics=[<span class="hljs-string">&#x27; mae&#x27;</span>])    <span class="hljs-keyword">return</span> modelmlp_model = create_mlp(trn_x. shape[<span class="hljs-number">1</span>])mlp_model.fit(x=trn_x, y=trn_y, validation_data=(val_x, val_y), epochs=<span class="hljs-number">30</span>, batch_size=<span class="hljs-number">16</span>)</code></pre></div><h1>第6章 模型融合</h1><p>参考资料：<a href="https://blog.csdn.net/qq_37039382/article/details/124546492">《机器学习算法竞赛实战》整理 | 六、模型融合</a></p><p>本章将向大家介绍在算法竞赛中提分的关键步骤，这也是最后阶段的惯用方法，即模型融合（或者集成学习），通过结合不同子模型的长处进行模型融合，当然这是在理想状态下。</p><p>本章主要分为构建多样性、训练过程融合和训练结果融合三部分。</p><p>模型融合常常是竞赛取得胜利的关键，相比之下具有差异性的模型融合往往能给结果带来很大提升。了解的模型融合方法越多，最后取胜的概率就会越高。</p><p>本章从这三个部分介绍不同模型融合方法的应用场景，同时给出使用技巧和应用代码。</p><h2 id="构建多样性">构建多样性</h2><p>介绍三种模型融合中构建多样性的方式，分别是特征多样性、样本多样性和模型多样性。其中多样性是指子模型之间存在着差异，可以通过降低子模型融合的同质性来构建多样性，好的多样性有助于模型融合效果的提升。</p><h3 id="特征多样性">特征多样性</h3><p>构建多个有差异的特征集并分别建立模型，可使特征存在于不同的超空间（hyperspace），从而建立的多个模型有不同的泛化误差，最终模型融合时可以起到互补的效果。在竞赛中，队友之间的特征集往往是不一样的，在分数差异不大的情况下，直接进行模型融合基本会获得不错的收益。</p><p>另外，像随机森林中的max_features，XGBoost中的colsample_bytree 和LightGBM中的feature_fraction都是用来对训练集中的特征进行采样的，其实本质上就是构建特征的多样性。</p><h3 id="样本多样性">样本多样性</h3><p>样本多样性也是竞赛中常见的一种模型融合方式，这里的多样性主要来自不同的样本集。</p><p>具体做法是将数据集切分成多份，然后分别建立模型。我们知道很多树模型在训练的时候会进行采样（sampling），主要目的是防止过拟合，从而提升预测的准确性。</p><p>有时候将数据集切分成多份并不是随机进行的，而是根据具体的赛题数据进行切分，需要考虑如何切分可以构建最大限度的数据差异性，并用切分后的数据分别训练模型。</p><p>例如，在天池“全球城市计算AI挑战赛”中，竞赛训练集包含从2019年1月1日到1月25日共25天的地铁刷卡数据记录，要求预测1月26日每个地铁站点每十分钟的平均出入客流量（2019年1月26日是周六）。显然，工作日和周末的客流量分布具有很大差异，这时会面临一个问题，若只保留周末的数据进行训练，则会浪费掉很多数据；若一周的数据全部保留，则会对工作日的数据产生一定影响。这时候就可以尝试构建两组有差异性的样本分别训练模型，即整体数据保留为一组，周末数据为一组。当然，模型融合后的分数会有很大提升。</p><h3 id="模型多样性">模型多样性</h3><p>不同模型对数据的表达能力是不同的，比如FM能够学习到特征之间的交叉信息，并且记忆性较强；树模型可以很好地处理连续特征和离散特征（如LightGBM 和CatBoost），并且对异常值也具有很好的健壮性。把这两类在数据假设、表征能力方面有差异的模型融合起来肯定会达到一定的效果。</p><p>对于竞赛而言，传统的树模型（XGBoost，LightGBM、CatBoost）和神经网络都需要尝试一遍，然后将尝试过的模型作为具有差异性的模型融合在一起。</p><p>还有很多其他构建多样性的方法，比如训练目标多样性、参数多样性和损失函数选择的多样性等，这些都能产生非常好的效果。</p><h2 id="训练过程融合">训练过程融合</h2><p>模型融合的方式有两种，第一种是训练过程融合，比如我们了解到的随机森林和XGBoost，基于这两种模型在训练中构造多个决策树进行融合，这里的多个决策树可以看作多个弱学习器。其中随机森林通过Bagging的方式进行融合，XGBoost通过Boosting的方式进行融合。</p><h3 id="Bagging">Bagging</h3><p>Bagging的思想很简单，即从训练集中有放回地取出数据（Bootstrapping），这些数据构成样本集，这也保证了训练集的规模不变，然后用样本集训练弱分类器。重复上述过程多次，取平均值或者采用投票机制得到模型融合的最终结果。</p><p>当在不同的样本集上训练模型时，Bagging通过减小误差之间的差来减少分类器的方差，因此Bagging可以降低过拟合的风险。Bagging算法的效率在于训练数据的不同，各模型之间存在着很大的差异，并且在加权融合的过程中可以使训练数据的错误相互抵消。</p><h3 id="Boosting">Boosting</h3><p>Boosting的思想其实并不难理解，首先训练一个弱分类器，并把这个弱分类器分错类的样本记录下来，同时给予这个弱分类器一定的权重；然后建立一个新的弱分类器，新的弱分类器基于前面记录的错误样本进行训练，同样，我们也给予这个分类器一个权重。重复上面的过程，直到弱分类器的性能达到某一指标，例如当再建立的新弱分类器并不会使准确率显著提升时，就停止选代。最后，把这些弱分类器各自乘上相应的权重并全部加起来，就得到了最后的强分类器。其实，基于Boosting的算法是比较多的，有Adaboost、LightGBM、XGBoost和CatBoost等。</p><h2 id="训练结果融合">训练结果融合</h2><p>模型融合的第二种方式是训练结果融合，主要分为加权法、Stacking和Blending，这些方法都可以有效地提高模型的整体预测能力，在竞赛中也是参赛者必须要掌握的方法。</p><h3 id="加权法">加权法</h3><p>加权法对于一系列任务（比如分类和回归）和评价指标（如AUC，MSE 或 Logloss）都是很有效的，比如我们有10个算法模型并都预测到了结果，直接对这10个结果取平均值或者给予每个算法不同的权重，即得到了融合结果。加权法通常还能减少过拟合，因为每个模型的结果可能存在一定的噪声，加权法能够平滑噪声，提高模型的泛化性。</p><ol><li><p>分类问题：对于分类问题，需要注意不同分类器的输出结果范围一致，因为输出的预测结果可以是0/1值，也可以是介于0和1之间的概率。另外，投票法（Voting）也是一种特殊的加权法。</p></li><li><p>回归问题：对于回归问题，使用加权法会非常简单。这里主要介绍算术平均和几何平均。</p></li></ol><ul><li>在2019腾讯广告算法大赛中，选择几何平均的效果远远好于选择算术平均，这是由于评分规则是平均绝对百分比误差（SMAPE），此时如果选择算术平均则会使模型融合的结果偏大，这不符合平均绝对百分比误差的直觉，越小的值对评分影响越大，算术平均会导致出现更大的误差，所以选择几何平均，能够使结果偏向小值。</li></ul><p>算术平均：基于算术平均数的集成方法在算法中是用得最多的，因为它不仅简单，而且基本每次使用该算法都有较大概率能获得很好的效果。</p><p>几何平均：根据很多参赛选手的分享，基于几何平均数的加权法在算法中使用得还不是很多，但在实际情况中，有时候基于几何平均数的模型融合效果要稍好于基于算术平均数的效果。</p><ol start="3"><li>排序问题</li></ol><p>一般推荐问题中的主要任务是对推荐结果进行排序，常见的评价指标有mAP（mean Average Precision），NDCG（Normalized Discounted Cumulative Gain），MRR（Mean Reciprocal Rank）和AUC，这里主要介绍MRR和AUC。</p><p>MRR：给定推荐结果q，如果q在推荐序列中的位置是r，那么MRR（q）就是1/r。可以看出，如果向用户推荐的产品在推荐序列中命中，那么命中的位置越靠前，得分也就越高。显然，排序结果在前在后的重要性是不一样的，因此我们不仅要进行加权融合，还需要让结果偏向小值。这时候就要对结果进行转换，然后再用加权法进行融合，一般而言使用的转换方式是log变换。<br>其基本思路如下：首先，输人三个预测结果文件，每个预测结果文件都包含M条记录，每条记录各对应N个预测结果，最终输出三个预测结果文件的整合结果。统计三个预测结果文件中记录的所有推荐商品（共N个商品）出现的位置，例如商品A，在第一份文件中的推荐位置是1，在第二个文件的推荐位置是3，在第三个文件中未出现，此时我们计算商品A的得分为log1+log3+log（N+1），此处我们用N+1来表示未出现，即在N个推荐商品中是找不到商品A的，所以只能是N+1。对每条记录中的商品按计算得分由小到大排序，取前N个作为这条记录的最终推荐结果。</p><p>AUC：作为排序指标，一般使用排序均值的融合思路，使用相对顺序来代替原先的概率值。很多以AUC为指标的比赛均取得了非常不错的成绩。使用过程如下：对每个分类器中分类的概率进行排序，然后用每个样本排序之后得到的排名值（rank）作为新的结果。对每个分类器的排名值求算术平均值作为最终结果。</p><h3 id="Stacking-融合">Stacking 融合</h3><p>使用加权法进行融合虽然简单，但需要人工来确定权重，因此可以考虑更加智能的方式，通过新的模型来学习每个分类器的权重。这里我们假设有两层分类器，如果在第一层中某个特定的基分类器错误地学习了特征空间的某个区域，则这种错误的学习行为可能会被第二层分类器检测到，这与其他分类器的学习行为一样，可以纠正不恰当的训练。上述过程便是Stacking融合的基本思想。</p><p>这里需要注意两点：第一，构建的新模型一般是简单模型，比如逻辑回归这样的线性模型；第二，使用多个模型进行Stacking融合会有比较好的结果。</p><p>Stacking融合使用基模型的预测结果作为第二层模型的输入。然而，我们不能简单地使用完整的训练集数据来训练基模型，这会产生基分类器在预测时就已经“看到”测试集的风险，因此在提供预测结果时出现过度拟合问题。所以我们应该使用Out-of-Fold的方式进行预测，也就是通过K折交叉验证的方式来预测结果。这里我们将Stacking融合分为训练阶段和测试阶段两部分，将并以流程图的形式展示每部分的具体操作。如图6.2所示为训练阶段。</p><p>特征加权的线性堆叠，可参考相应论文“Feature-Weighted Linear Stacking two layer stacking&quot;，其实就是对传统的Stacking融合方法在深度上进行扩展。通过传统的Stacking融合方法得到概率值，再将此值与基础特征集进行拼接，重新组成新的特征集，进行新一轮训练。</p><h3 id="Blending-融合">Blending 融合</h3><p>不同于Stacking融合使用K折交叉验证方式得到预测结果，Blending融合是建立一个Holdout集，将不相交的数据集用于不同层的训练，这样可以在很大程度上降低过拟合的风险。</p><p>假设构造两层Blending，训练集等分为两部分（train_one和train_two），测试集为test。第一层用train_one训练多个模型，将train_two和test的预测结果合并到原始特征集合中，作为第二层的特征集。第二层用train_two的特征集和标签训练新的模型，然后对test预测得到最终的融合结果。</p><h2 id="实战案例">实战案例</h2><p>以stacking为例。选择ExtraTreesRegressor、RandomForestRegressor、Ridge、Lasso作为基学习器，Ridge为最终分类器。</p><p>依然采用5折交叉验证</p><div class="code-wrapper"><pre><code class="hljs python">kf = KFold(n_splits=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">2020</span>)</code></pre></div><p>然后构建一个sklearn中模型的功能类，初始化参数然后训练和预测。<strong>这段代码可复用性很高，建议完善、储存。</strong></p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SklearnWrapper</span>(<span class="hljs-title class_ inherited__">object</span>):    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clf, seed=<span class="hljs-number">0</span>, params=<span class="hljs-literal">None</span></span>):        params[<span class="hljs-string">&#x27;random_state&#x27;</span>] = seed        <span class="hljs-variable language_">self</span>.clf = clf(**params)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, x_train, y_train</span>):        <span class="hljs-variable language_">self</span>.clf.fit(x_train, y_train)    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, x</span>):        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.clf.predict(x)</code></pre></div><p>封装交叉验证函数。可复用性也很高。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_oof</span>(<span class="hljs-params">clf</span>):    oof_train = np.zeros((x_train.shape[<span class="hljs-number">0</span>],))    oof_test = np.zeros((x_test.shape[<span class="hljs-number">0</span>],))    oof_test_skf = np.empty((<span class="hljs-number">5</span>, x_test.shape[<span class="hljs-number">0</span>]))      <span class="hljs-keyword">for</span> i, (train_index, valid_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(x_train, y_train)):        trn_x, trn_y, val_x, val_y = x_train.iloc[train_index], y_train[train_index],\            x_train.iloc[valid_index], y_train[valid_index]        clf.train(trn_x, trn_y)        oof_train[valid_index] = clf.predict(val_x)        oof_test_skf[i, :] = clf.predict(x_test)    oof_test[:] = oof_test_skf.mean(axis=<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> oof_train.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), oof_test.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</code></pre></div><p>预测四个模型的验证集结果和测试集结果。并辅助最后一步的stacking融合操作：</p><div class="code-wrapper"><pre><code class="hljs python">et_params = &#123;   <span class="hljs-string">&#x27;n_estimators&#x27;</span>: <span class="hljs-number">100</span>,    <span class="hljs-string">&#x27;max_features&#x27;</span>: <span class="hljs-number">0.5</span>,    <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">12</span>,    <span class="hljs-string">&#x27;min_samples_leaf&#x27;</span>: <span class="hljs-number">2</span>,&#125;rf_params = &#123;    <span class="hljs-string">&#x27;n_estimators&#x27;</span>: <span class="hljs-number">100</span>,    <span class="hljs-string">&#x27;max_features&#x27;</span>: <span class="hljs-number">0.2</span>,    <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">12</span>,    <span class="hljs-string">&#x27;min_samples_leaf&#x27;</span>: <span class="hljs-number">2</span>,&#125;rd_params=&#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: <span class="hljs-number">10</span>&#125;ls_params=&#123; <span class="hljs-string">&#x27;alpha&#x27;</span>: <span class="hljs-number">0.005</span>&#125;et = SklearnWrapper(clf=ExtraTreesRegressor, seed=<span class="hljs-number">2020</span>, params=et_params)rf = SklearnWrapper(clf=RandomForestRegressor, seed=<span class="hljs-number">2020</span>, params=rf_params)rd = SklearnWrapper(clf=Ridge, seed=<span class="hljs-number">2020</span>, params=rd_params)ls = SklearnWrapper(clf=Lasso, seed=<span class="hljs-number">2020</span>, params=ls_params)et_oof_train, et_oof_test = get_oof(et)rf_oof_train, rf_oof_test = get_oof(rf)rd_oof_train, rd_oof_test = get_oof(rd)ls_oof_train, ls_oof_test = get_oof(ls)</code></pre></div><p>最后就是stacking部分，使用ridge模型。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">stack_model</span>(<span class="hljs-params">oof_1, oof_2, oof_3, oof_4, predictions_1, predictions_2, predictions_3, predictions_4, y</span>):    train_stack = np.hstack([oof_1, oof_2, oof_3, oof_4])    test_stack = np.hstack([predictions_1, predictions_2, predictions_3, predictions_4])      oof = np.zeros((train_stack.shape[<span class="hljs-number">0</span>],))    predictions = np.zeros((test_stack.shape[<span class="hljs-number">0</span>],))    scores = []    <span class="hljs-keyword">for</span> fold_, (trn_idx, val_idx) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(train_stack, y)):         trn_data, trn_y = train_stack[trn_idx], y[trn_idx]        val_data, val_y = train_stack[val_idx], y[val_idx]              clf = Ridge(random_state=<span class="hljs-number">2020</span>)        clf.fit(trn_data, trn_y)        oof[val_idx] = clf.predict(val_data)        predictions += clf.predict(test_stack) / <span class="hljs-number">5</span>              score_single = sqrt(mean_squared_error(val_y, oof[val_idx]))        scores.append(score_single)        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;fold_+<span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;<span class="hljs-number">5</span>&#125;</span>&#x27;</span>, score_single)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mean: &#x27;</span>,np.mean(scores))       <span class="hljs-keyword">return</span> oof, predictionsoof_stack , predictions_stack  = stack_model(et_oof_train, rf_oof_train, rd_oof_train, ls_oof_train, et_oof_test, rf_oof_test, rd_oof_test,ls_oof_test, y_train)</code></pre></div><p>实际运行后发现，基分类器的分类效果差别很大，且最终融合后的模型效果确实要比基分类器的模型效果好很多。</p><iframe src="https://nbviewer.org/github/zhangzhao219/zhangzhao219.github.io/blob/main/file/Machine-Learning-Competition/basic.ipynb" width="100%" height="2000"></iframe>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：模式识别与机器学习-第4章 特征选择和提取</title>
    <link href="/2022/09/18/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-4/"/>
    <url>/2022/09/18/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-4/</url>
    
    <content type="html"><![CDATA[<p>《模式识别与机器学习》课程笔记：第4章 特征选择和提取</p><span id="more"></span><h1>第4章 特征选择和提取</h1><p>特征选择和提取是模式识别中的一个关键问题，前面讨论分类器设计的时候，一直假定已给出了特征向量维数确定的样本集，其中各样本的每一维都是该样本的一个特征；这些特征的选择是很重要的，它强烈地影响到分类器的设计及其性能；假若对不同的类别，这些特征的差别很大，则比较容易设计出具有较好性能的分类器。</p><p>例如，描述人可以用好多特征，如肤色，体重，身高等，但是如果要判断软件工程师，显然编程这个特征比较有判别性；如果要判断是不是篮球员，则体重、身高有很强的判别性。</p><p>特征选择和提取是构造模式识别系统时的一个重要课题。在很多实际问题中，往往不容易找到那些最重要的特征，或受客观条件的限制，不能对它们进行有效的测量；因此在测量时，由于人们心理上的作用，只要条件许可总希望把特征取得多一些；另外，由于客观上的需要，为了突出某些有用信息，抑制无用信息，有意加上一些比值、指数或对数等组合计算特征；如果将数目很多的测量值不做分析，全部直接用作分类特征，不但耗时，而且会影响到分类的效果，产生“特征维数灾难”问题。</p><p>为了设计出效果好的分类器，通常需要对原始的测量值集合进行分析，经过选择或变换处理，组成有效的识别特征；在保证一定分类精度的前提下，减少特征维数，即进行“降维”处理，使分类器实现快速、准确和高效的分类。为达到上述目的，关键是所提供的识别特征应具有很好的可分性，使分类器容易判别。为此，需对特征进行选择：</p><ul><li>应去掉模棱两可、不易判别的特征；</li><li>所提供的特征不要重复，即去掉那些相关性强且没有增加更多分类信息的特征。</li></ul><p>特征选择和提取这一任务应在设计分类器之前进行；</p><p><a href="https://imgse.com/i/xpsWjI"><img src="https://s1.ax1x.com/2022/09/18/xpsWjI.png" alt="xpsWjI.png"></a></p><p>所谓特征选择，就是从<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个度量值集合<img src="https://math.now.sh?inline=%5C%7Bx_1%2C%20x_2%2C%E2%80%A6%2C%20x_n%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中，按某一准则选取出供分类用的子集，作为降维（<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维，<img src="https://math.now.sh?inline=m%3Cn" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>）的分类特征；</p><p>所谓特征提取，就是使<img src="https://math.now.sh?inline=%5C%7Bx_1%2C%20x_2%2C%E2%80%A6%2C%20x_n%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>通过某种变换，产生<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征<img src="https://math.now.sh?inline=%5C%7By_1%2C%20y_2%2C%E2%80%A6%2C%20y_m%5C%7D%20%28m%3Cn%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，作为新的分类特征（或称为二次特征）；</p><p>其目的都是为了在尽可能保留识别信息的前提下，降低特征空间的维数，以达到有效的分类效果。</p><h2 id="模式类别可分性的测度">模式类别可分性的测度</h2><p>距离和散布矩阵：</p><ul><li>点到点之间的距离：<img src="https://math.now.sh?inline=D%5E2%28%5Cboldsymbol%7Ba%7D%2C%20%5Cboldsymbol%7Bb%7D%29%3D(%5Cboldsymbol%7Ba%7D-%5Cboldsymbol%7Bb%7D)%5ET(%5Cboldsymbol%7Ba%7D-%5Cboldsymbol%7Bb%7D)%3D%5Csum_%7Bk%3D1%7D%5En%5Cleft(a_k-b_k%5Cright)%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中, <img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bb%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 为 <img src="https://math.now.sh?inline=%5Cmathrm%7Bn%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 维向量, 其第 <img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 个分量分别是 <img src="https://math.now.sh?inline=a_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=b_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>点到点集之间的距离：点<img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到点集<img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cboldsymbol%7Bx%7D%5Ei%5Cright%5C%7D_%7Bi%3D1%2C2%2C%20%5Cldots%2C%20K%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>之间的距离为<img src="https://math.now.sh?inline=%5Coverline%7BD%5E2%5Cleft%28%5Cboldsymbol%7Ba%7D%2C%5Cleft%5C%7B%5Cboldsymbol%7Bx%7D%5Ei%5Cright%5C%7D%5Cright%29%7D%3D%5Cfrac%7B1%7D%7BK%7D%20%5Csum_%7Bi%3D1%7D%5EK%20D%5E2%5Cleft(%5Cboldsymbol%7Ba%7D%2C%20%5Cboldsymbol%7Bx%7D%5Ei%5Cright)%3D%5Cfrac%7B1%7D%7BK%7D%20%5Csum_%7Bi%3D1%7D%5EK%5Cleft%5C%7B%5Csum_%7Bk%3D1%7D%5En%5Cleft(a_k-x_k%5Ei%5Cright)%5E2%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>类内距离：<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维空间中同一类内各模式样本点集<img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cboldsymbol%7Bx%7D%5Ei%5Cright%5C%7D_%7Bi%3D1%2C2%2C%20%5Cldots%2C%20K%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其内部各点的均方距离为<img src="https://math.now.sh?inline=%5Coverline%7BD%5E2%5Cleft%28%5Cleft%5C%7B%5Cboldsymbol%7Bx%7D%5Ej%5Cright%5C%7D%2C%5Cleft%5C%7B%5Cboldsymbol%7Bx%7D%5Ei%5Cright%5C%7D%5Cright%29%7D%3D%5Cfrac%7B1%7D%7BK%7D%20%5Csum_%7Bj%3D1%7D%5EK%5Cleft%5B%5Cfrac%7B1%7D%7BK-1%7D%20%5Csum_%7B%5Csubstack%7Bi%3D1%20%5C%5C%20i%20%5Cneq%20j%7D%7D%5EK%20%5Csum_%7Bk%3D1%7D%5En%5Cleft(x_k%5Ej-x_k%5Ei%5Cright)%5E2%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=i%2C%20j%3D1%2C2%2C%20%5Cldots%2C%20K%2C%20i%20%5Cneq%20j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>类内散布矩阵：考虑一类内模式点集<img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cboldsymbol%7Bx%7D%5Ei%5Cright%5C%7D_%7Bi%3D1%2C2%2C%20%5Cldots%2C%20K%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其类内散布矩阵为：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D%3D%5Csum_%7Bi%3D1%7D%5EK%5Cleft%5C%7B%5Cleft%28%5Cboldsymbol%7Bx%7D%5Ei-%5Cboldsymbol%7Bm%7D%5Cright%29%5Cleft(%5Cboldsymbol%7Bx%7D%5Ei-%5Cboldsymbol%7Bm%7D%5Cright)%5ET%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D%3D%5Cfrac%7B1%7D%7BK%7D%20%5Csum_%7Bi%3D1%7D%5EK%20%5Cboldsymbol%7Bx%7D%5Ei" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>对属于同一类的模式样本，类内散布矩阵表示各样本点围绕其均值周围的散布情况。</strong></p><p>在考虑有两个以上的类别，如集合<img src="https://math.now.sh?inline=%5C%7B%5Cboldsymbol%7Ba%7D%5Ei%5C%7D%2C%5C%7B%5Cboldsymbol%7Bb%7D%5Ej%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，类间距离对类别的可分性起着重要作用，此时应计算<img src="https://math.now.sh?inline=%5Coverline%7BD%5E2%5Cleft%28%5Cleft%5C%7B%5Cboldsymbol%7Ba%7D%5Ei%5Cright%5C%7D%2C%5Cleft%5C%7B%5Cboldsymbol%7Bb%7D%5Ej%5Cright%5C%7D%5Cright%29%7D_%7Bi%3D1%2C2%2C%20%5Cldots%2C%20K_a%20%3B%20j%3D1%2C2%2C%20%5Cldots%2C%20K_b%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>为简化起见，常用两类样本各自质心间的距离作为类间距离，并假设两类样本出现的概率相等，则<img src="https://math.now.sh?inline=D%5E2%3D%5Csum_%7Bk%3D1%7D%5En%5Cleft%28m_%7B1_k%7D-m_%7B2_k%7D%5Cright%29%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为两类模式样本集各自的均值向量，<img src="https://math.now.sh?inline=m_%7B1_k%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 和<img src="https://math.now.sh?inline=m_%7B2_k%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 为<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个分量，<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为维数。</p><p>两类模式的类间散布矩阵：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_%7Bb%202%7D%3D%5Cleft%28%5Cboldsymbol%7Bm%7D_1-%5Cboldsymbol%7Bm%7D_2%5Cright%29%5Cleft(%5Cboldsymbol%7Bm%7D_1-%5Cboldsymbol%7Bm%7D_2%5Cright)%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>对三个以上的类别，类间散布矩阵常写成<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_b%3D%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5EM%20P%5Cleft%28%5Comega_i%5Cright%29%20%5Csum_%7Bj%3D1%7D%5EM%20P%5Cleft(%5Comega_j%5Cright)%5Cleft(%5Cboldsymbol%7Bm%7D_i-%5Cboldsymbol%7Bm%7D_j%5Cright)%5Cleft(%5Cboldsymbol%7Bm%7D_i-%5Cboldsymbol%7Bm%7D_j%5Cright)%5ET%3D%5Csum_%7Bi%3D1%7D%5EM%20P%5Cleft(%5Comega_i%5Cright)%5Cleft(%5Cboldsymbol%7Bm%7D_i-%5Cboldsymbol%7Bm%7D_0%5Cright)%5Cleft(%5Cboldsymbol%7Bm%7D_i-%5Cboldsymbol%7Bm%7D_0%5Cright)%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中，<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为多类模式（如共有<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类）分布的总体均值向量，即<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_0%3DE%5C%7B%5Cboldsymbol%7Bx%7D%5C%7D%3D%5Csum_%7Bi%3D1%7D%5Ec%20P%5Cleft%28%5Comega_i%5Cright%29%20%5Cboldsymbol%7Bm%7D_i%2C%20%5Cquad%20%5Cforall%20%5Comega_i%2C%20i%3D1%2C2%2C%20%5Cldots%2C%20M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>多类情况的类内散布矩阵可写成各类的类内散布矩阵的先验概率的加权和，即<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_w%3D%5Csum_%7Bi%3D1%7D%5EM%20P%5Cleft%28%5Comega_i%5Cright%29%20E%5Cleft%5C%7B%5Cleft(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5Cleft(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5ET%20%5Cmid%20%5Comega_i%5Cright%5C%7D%3D%5Csum_%7Bi%3D1%7D%5EM%20P%5Cleft(%5Comega_i%5Cright)%20%5Cboldsymbol%7BC%7D_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7BC%7D_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的协方差矩阵。</p><p>有时，用多类模式总体分布的散布矩阵来反映其可分性，即：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_t%3DE%5Cleft%5C%7B%5Cleft%28%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bm%7D_0%5Cright%29%5Cleft(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bm%7D_0%5Cright)%5ET%5Cright%5C%7D%2C%20%5Cquad%20%5Cboldsymbol%7Bx%7D%20%5Cin%20%5Cforall%20%5Comega_i%2C%20i%3D1%2C2%2C%20%5Cldots%2C%20M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为多类模式分布的总体均值向量。</p><p><img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_t%3D%5Cboldsymbol%7BS%7D_w%2B%5Cboldsymbol%7BS%7D_b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即总体散布矩阵是各类类内散布矩阵与类间散布矩阵之和。</p><h2 id="特征选择">特征选择</h2><p>设有<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个可用作分类的测量值，为了在不降低（或尽量不降低）分类精度的前提下，减小特征空间的维数以减少计算量，需从中直接选出<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个作为分类的特征。</p><p>从<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个测量值中选出<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征，一共有<img src="https://math.now.sh?inline=C_n%5Em" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>种可能的选法，需寻找一种简便的可分性准则，间接判断每一种子集的优劣。</p><p>对于独立特征的选择准则：类别可分性准则应具有这样的特点，即不同类别模式特征的均值向量之间的距离应最大，而属于同一类的模式特征，其方差之和应最小。<strong>假设各原始特征测量值是统计独立的</strong>，此时，只需对训练样本的<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个测量值独立地进行分析，从中选出<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个最好的作为分类特征即可。</p><p>对于 <img src="https://math.now.sh?inline=%5Comega_%7B%5Cmathrm%7Bi%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Comega_%7B%5Cmathrm%7Bj%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 两类训练样本，假设其均值向量为 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维方向的分量为 <img src="https://math.now.sh?inline=m_%7Bi%20k%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=m_%7Bj%20k%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，方差为 <img src="https://math.now.sh?inline=%5Csigma_%7B%5Cmathrm%7Bik%7D%7D%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Csigma_%7B%5Cmathrm%7Bjk%7D%7D%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，定义可分性准则函数<img src="https://math.now.sh?inline=G_k%3D%5Cfrac%7B%5Cleft%28m_%7Bi%20k%7D-m_%7Bj%20k%7D%5Cright%29%5E2%7D%7B%5Csigma_%7Bi%20k%7D%5E2%2B%5Csigma_%7Bj%20k%7D%5E2%7D%2C%20k%3D1%2C2%2C%20%5Cldots%2C%20n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=G_K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为正值。 <img src="https://math.now.sh?inline=G_K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>值越大，表示测度值的第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个分量对分离 <img src="https://math.now.sh?inline=%5Comega_%7B%5Cmathrm%7Bi%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=%5Comega_%7B%5Cmathrm%7Bj%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类越有效。将<img src="https://math.now.sh?inline=%5Cleft%5C%7BG_K%2C%20k%3D1%2C2%2C%20%5Cldots%2C%20%5Cmathrm%7Bn%7D%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>按大小排队, 选出最大的<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个对应测度值作为分类特征，即达到特征选择的目的。</p><p>上述基于距离测度的可分性准则，其适用范围与模式特征的分布有关。假若类概率密度函数不是或不近似正态分布，均值和方差就不足以用来估计类别的可分性，此时该准则函数不完全适用。</p><p>一般特征的散布矩阵准则：</p><ul><li>类内：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_w%3D%5Csum_%7Bi%3D1%7D%5Ec%20P%5Cleft%28%5Comega_i%5Cright%29%20E%5Cleft%5C%7B%5Cleft(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5Cleft(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5ET%20%5Cmid%20%5Comega_i%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>类间：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_b%3D%5Csum_%7Bi%3D1%7D%5Ec%20P%5Cleft%28%5Comega_i%5Cright%29%5Cleft(%5Cboldsymbol%7Bm%7D_i-%5Cboldsymbol%7Bm%7D_0%5Cright)%5Cleft(%5Cboldsymbol%7Bm%7D_i-%5Cboldsymbol%7Bm%7D_0%5Cright)%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>直观上，类间离散度越大且类内离散度越小，则可分性越好。因此，可推导出散布矩阵准则采用如下形式：</p><ul><li>行列式形式：<img src="https://math.now.sh?inline=J_1%3D%5Coperatorname%7Bdet%7D%5Cleft%28%5Cboldsymbol%7BS%7D_w%5E%7B-1%7D%20%5Cboldsymbol%7BS%7D_b%5Cright%29%3D%5Cprod_i%20%5Clambda_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>迹形式：<img src="https://math.now.sh?inline=J_2%3D%5Coperatorname%7Btr%7D%5Cleft%28%5Cboldsymbol%7BS%7D_w%5E%7B-1%7D%20%5Cboldsymbol%7BS%7D_b%5Cright%29%3D%5Csum_i%20%5Clambda_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>其中，<img src="https://math.now.sh?inline=%5Clambda_%7B%5Cmathrm%7Bi%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 是矩阵 <img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_w%5E%7B-1%7D%20%5Cboldsymbol%7BS%7D_b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的特征值。使 <img src="https://math.now.sh?inline=%5Cmathrm%7BJ%7D_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 或 <img src="https://math.now.sh?inline=%5Cmathrm%7BJ%7D_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 最大的子集可作为选择的分类特征。</p><h2 id="离散K-L变换（Karhunen-Loeve变换（卡洛南-洛伊变换））">离散K-L变换（Karhunen-Loeve变换（卡洛南-洛伊变换））</h2><p>前面讨论的特征选择是在一定准则下，从<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征中选出<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个来反映原有模式。这种简单删掉某<img src="https://math.now.sh?inline=n-k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征的做法并不十分理想，因为一般来说，原来的<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个数据各自在不同程度上反映了识别对象的某些特征，简单地删去某些特征可能会丢失较多的有用信息。如果将原来的特征做正交变换，获得的每个数据都是原来<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个数据的线性组合，然后从新的数据中选出少数几个，使其尽可能多地反映各类模式之间的差异，而这些特征间又尽可能相互独立，则比单纯的选择方法更灵活、更有效。</p><p>K-L变换就是一种适用于任意概率密度函数的正交变换。</p><h3 id="离散的有限K-L展开">离散的有限K-L展开</h3><p>离散的有限K-L展开式的形式：</p><p>设一连续的随机实函数<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%28t%29%2C%20T_1%20%E2%89%A4t%E2%89%A4T_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%28t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 可用已知的正交函数集 <img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cvarphi_%7B%5Cmathrm%7Bj%7D%7D%28%5Cunderline%7Bt%7D%29%2C%20%5Cmathrm%7Bj%7D%3D1%2C2%2C%20%5Cldots%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的线性组合来展开，即：<img src="https://math.now.sh?inline=x%28t%29%3Da_1%20%5Cvarphi_1(t)%2Ba_2%20%5Cvarphi_2(t)%2B%5Ccdots%2Ba_j%20%5Cvarphi_j(t)%2B%5Ccdots%3D%5Csum_%7Bj%3D1%7D%5E%7B%5Cinfty%7D%20a_j%20%5Cvarphi_j(t)%2C%20%5Cquad%20T_1%20%5Cleq%20t%20%5Cleq%20T_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。式中，<img src="https://math.now.sh?inline=a_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为展开式的随机系数，<img src="https://math.now.sh?inline=%CF%86_j%28t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为一连续的正交函数，它应满足：<img src="https://math.now.sh?inline=%5Cint_%7BT_%7B1%7D%7D%5E%7BT_%7B2%7D%7D%20%5Cvarphi_%7Bn%7D%5E%7B%28t%29%7D%20%5Ctilde%7B%5Cvarphi%7D_%7Bm%7D(t)%20d%20t%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D1%2C%20%26%20%5Ctext%20%7B%20if%20%7D%20m%3Dn%20%5C%5C%200%20%26%20%5Ctext%20%7B%20if%20%7D%20m%20%5Cneq%20n%20%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>,其中<img src="https://math.now.sh?inline=%5Ctilde%7B%5Cvarphi%7D_%7Bm%7D%28t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为<img src="https://math.now.sh?inline=%CF%86_m%28t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的共轭复数式。</p><p>将上式写成离散的正交函数形式，使连续随机函数<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%28t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和连续正交函数<img src="https://math.now.sh?inline=%CF%86_j%28t%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在区间<img src="https://math.now.sh?inline=T_1%20%5Cleq%20t%20%5Cleq%20T_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>内被等间隔采样为<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个离散点，即：</p><p><img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%28t%29%20%5Crightarrow%20%5C%7Bx(1)%2Cx(2)%2C%5Ccdots%2Cx(n)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%CF%86_j%28t%29%5Crightarrow%20%5C%7B%CF%86_j(1)%2C%CF%86_j(2)%2C%5Ccdots%2C%CF%86_j(n)%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>写成向量形式：<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%3D%28x(1%29%2Cx(2)%2C%5Ccdots%2Cx(n))%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%CF%86%7D_j%20%3D%20%28%CF%86_j(1%29%2C%CF%86_j(2)%2C%5Ccdots%2C%CF%86_j(n))%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>将展开式写成离散形式：<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%3D%5Csum_%7Bj%3D1%7D%5Ena_j%5C%20%5Cboldsymbol%7B%5Cvarphi%7D_j%3D%5Cboldsymbol%7B%5CPhi%20a%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为展开式中随机系数的向量形式<img src="https://math.now.sh?inline=%28a_1%2Ca_2%2C%5Ccdots%2Ca_j%2C%5Ccdots%2Ca_n%29%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5CPhi%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为<img src="https://math.now.sh?inline=n*n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维矩阵，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5CPhi%7D%3D%5Cleft%28%5Cvarphi_%7B1%7D%2C%20%5Cvarphi_%7B2%7D%2C%20%5Ccdots%2C%20%5Cvarphi_%7Bn%7D%5Cright%29%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%5Cvarphi_%7B1%7D(1)%20%26%20%5Cvarphi_%7B2%7D(1)%20%26%20%5Ccdots%20%26%20%5Cvarphi_%7Bn%7D(1)%20%5C%5C%20%5Cvarphi_%7B1%7D(2)%20%26%20%5Cvarphi_%7B2%7D(2)%20%26%20%5Ccdots%20%26%20%5Cvarphi_%7Bn%7D(2)%20%5C%5C%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%26%20%5Ccdots%20%5C%5C%20%5Cvarphi_%7B1%7D(n)%20%26%20%5Cvarphi_%7B2%7D(n)%20%26%20%5Ccdots%20%26%20%5Cvarphi_%7Bn%7D(n)%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>其中，每一列为正交函数集中的一个函数，小括号内的序号为正交函数的采样点次序。因此，<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5CPhi%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>实质上是由<img src="https://math.now.sh?inline=%CF%86_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>向量组成的正交变换矩阵，<br>它将<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>变换成<img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>对各个模式类别，正交函数都是相同的，但其展开系数向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>则因类别的不同模式分布而异。</p><p>K-L展开式的根本性质是将随机向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>展开为另一组正交向量<img src="https://math.now.sh?inline=%5Cvarphi_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的线性和，且其展开式系数<img src="https://math.now.sh?inline=a_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（即系数向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的各个分量）具有不同的性质。</p><p>正交向量集<img src="https://math.now.sh?inline=%7B%5Cboldsymbol%7B%CF%86%7D_j%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的确定：</p><p>设随机向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的总体自相关矩阵为<img src="https://math.now.sh?inline=R%20%3D%20E%5C%7B%5Cboldsymbol%7Bxx%7D%5ET%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=R%3D%5Cboldsymbol%7B%5CPhi%7D%28E%5C%7B%5Cboldsymbol%7Baa%5ET%7D%5C%7D%29%5Cboldsymbol%7B%5CPhi%7D%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，要求系数向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的各个不同分量应统计独立，则应使<img src="https://math.now.sh?inline=E%5C%7B%5Cboldsymbol%7Baa%5ET%7D%5C%7D%3D%5Cboldsymbol%7BD_%5Clambda%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7BD_%5Clambda%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为对角形矩阵，其互相关成分均为0</p><p>因为<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是实对称矩阵，其不同特征值对应的特征向量应正交，即：<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5Cvarphi%7D_%7Bj%7D%5E%7BT%7D%20%5Cboldsymbol%7B%5Cvarphi%7D_%7Bk%7D%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D1%20%26%20%5Ctext%20%7B%20if%20%7D%20j%3Dk%20%5C%5C%200%20%26%20%5Ctext%20%7B%20if%20%7D%20j%20%5Cneq%20k%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>K-L展开式系数的计算步骤：</p><ol><li>求随机向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的自相关矩阵：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BR%7D%20%3D%20E%5C%7B%5Cboldsymbol%7Bxx%7D%5ET%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>求出矩阵<img src="https://math.now.sh?inline=%5Cboldsymbol%7BR%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的特征值<img src="https://math.now.sh?inline=%CE%BB_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和对应的特征向量<img src="https://math.now.sh?inline=%CF%86_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=j%20%3D%201%2C2%2C%E2%80%A6%2Cn" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，得矩阵：<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5CPhi%7D%3D%28%5Cvarphi_%7B1%7D%2C%20%5Cvarphi_%7B2%7D%2C%20%5Ccdots%2C%20%5Cvarphi_%7Bn%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>计算展开式系数：<img src="https://math.now.sh?inline=%5Cboldsymbol%7Ba%7D%20%3D%20%5Cboldsymbol%7B%CE%A6%5ETx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><h3 id="按K-L展开式选择特征">按K-L展开式选择特征</h3><p>K-L展开式用于特征选择相当于一种线性变换。若从<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征向量中取出<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个组成变换矩阵<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5CPhi%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5CPhi%7D%3D%28%5Cvarphi_%7B1%7D%2C%20%5Cvarphi_%7B2%7D%2C%20%5Ccdots%2C%20%5Cvarphi_%7Bn%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，此时<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5CPhi%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是一个<img src="https://math.now.sh?inline=n*m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维矩阵，<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维向量，经过<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%CE%A6%5ETx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>变换，即得到降维为<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的新向量。</p><h3 id="结论">结论</h3><p>从K-L展开式的性质和按最小均方差的准则来选择特征，应使<img src="https://math.now.sh?inline=E%5Ba_j%5D%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。由于<img src="https://math.now.sh?inline=E%5B%5Cboldsymbol%7Ba%7D%5D%3DE%5B%5CPhi%5E%7BT%7D%20%5Cboldsymbol%7Bx%7D%5D%3D%5CPhi%5ETE%5B%5Cboldsymbol%7Bx%7D%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，故应使<img src="https://math.now.sh?inline=E%5B%5Cboldsymbol%7Bx%7D%5D%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。基于这一条件，在将整体模式进行K-L变换之前，<strong>应先将其均值作为新坐标轴的原点，采用协方差矩阵<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>或自相关矩阵<img src="https://math.now.sh?inline=R" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来计算特征值</strong>。如果<img src="https://math.now.sh?inline=E%5B%5Cboldsymbol%7Bx%7D%5D%20%E2%89%A00" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则只能得到“次最佳”的结果。</p><p>将K-L展开式系数<img src="https://math.now.sh?inline=a_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（亦即变换后的特征）用<img src="https://math.now.sh?inline=y_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示，写成向量形式：<img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D%3D%5CPhi%5E%7BT%7D%20%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，此时变换矩阵<img src="https://math.now.sh?inline=%5CPhi" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>用<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征向量组成。为使误差最小，不采用的特征向量，其对应的特征值应尽可能小。因此，将特征值按大小次序标号，即<img src="https://math.now.sh?inline=%5Clambda_1%3E%5Clambda_2%3E%5Ccdots%3E%5Clambda_m%3E%5Ccdots%3E%5Clambda_n%E2%89%A50" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。若首先采用前面的<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征向量，便可使变换误差最小。此时的变换矩阵为<img src="https://math.now.sh?inline=%5Cboldsymbol%7B%5CPhi%7D%3D%28%5Cvarphi_%7B1%7D%2C%20%5Cvarphi_%7B2%7D%2C%20%5Ccdots%2C%20%5Cvarphi_%7Bn%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>K-L变换是在均方误差最小的意义下获得数据压缩（降维）的最佳变换，且不受模式分布的限制。对于一种类别的模式特征提取，它不存在特征分类问题，只是实现用低维的<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征来表示原来高维的<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征，使其误差最小，亦即使其整个模式分布结构尽可能保持不变。</p><p>通过K-L变换能获得互不相关的新特征。若采用较大特征值对应的特征向量组成变换矩阵，则能对应地保留原模式中方差最大的特征成分，所以K-L变换起到了减小相关性、突出差异性的效果。在此情况下，K-L变换也称为主成分变换（PCA变换）。</p><p>需要指出的是，采用K-L变换作为模式分类的特征提取时，要特别注意保留不同类别的模式分类鉴别信息，仅单纯考虑尽可能代表原来模式的主成分，有时并不一定有利于分类的鉴别。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Pattern Recognition and Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第16章 复杂数据结构</title>
    <link href="/2022/09/18/Leetcode/Leetcode-101/Leetcode-101-16/"/>
    <url>/2022/09/18/Leetcode/Leetcode-101/Leetcode-101-16/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第16章 复杂数据结构</p><span id="more"></span><h1>复杂数据结构</h1><h2 id="并查集">并查集</h2><p>并查集（union-find, 或disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。假设存在n个节点，我们先将所有节点的父亲标为自己；每次要连接节点i和j时，我们可以将i的父亲标为j；每次要查询两个节点是否相连时，我们可以查找i和j的祖先是否最终为同一个人。</p><h3 id="Leetcode-684">Leetcode 684</h3><p>在无向图找出一条边，移除它之后该图能够成为一棵树（即无向无环图）。如果有多个解，返回在原数组中位置最靠后的那条边。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; parent, <span class="hljs-type">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">if</span> (parent[index] != index) &#123;            parent[index] = <span class="hljs-built_in">Find</span>(parent, parent[index]);        &#125;        <span class="hljs-keyword">return</span> parent[index];    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; parent, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span> </span>&#123;        parent[<span class="hljs-built_in">Find</span>(parent, index1)] = <span class="hljs-built_in">Find</span>(parent, index2);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findRedundantConnection</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;        <span class="hljs-type">int</span> n = edges.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">parent</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;            parent[i] = i;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; edge: edges) &#123;            <span class="hljs-type">int</span> node1 = edge[<span class="hljs-number">0</span>], node2 = edge[<span class="hljs-number">1</span>];            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Find</span>(parent, node1) != <span class="hljs-built_in">Find</span>(parent, node2)) &#123;                <span class="hljs-built_in">Union</span>(parent, node1, node2);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> edge;            &#125;        &#125;        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;&#125;;    &#125;&#125;;</code></pre></div><p>分析：在一棵树中，边的数量比节点的数量少1。如果一棵树有n个节点，则这棵树有n−1条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是n。树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</p><p>错误：不知道怎么使用并查集</p><h2 id="复合数据结构">复合数据结构</h2><h3 id="Leetcode-146">Leetcode 146</h3><p>请你设计并实现一个满足 LRU (最近最少使用) 缓存约束的数据结构。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">//定义双链表</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;        <span class="hljs-type">int</span> key,value;        Node* left ,*right;        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key,<span class="hljs-type">int</span> _value): <span class="hljs-built_in">key</span>(_key),<span class="hljs-built_in">value</span>(_value),<span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;    &#125;*L,*R;<span class="hljs-comment">//双链表的最左和最右节点，不存贮值。</span>    <span class="hljs-type">int</span> n;    unordered_map&lt;<span class="hljs-type">int</span>,Node*&gt;hash;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node* p)</span></span><span class="hljs-function">    </span>&#123;        p-&gt;right-&gt;left = p-&gt;left;        p-&gt;left-&gt;right = p-&gt;right;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node *p)</span></span><span class="hljs-function">    </span>&#123;        p-&gt;right = L-&gt;right;        p-&gt;left = L;        L-&gt;right-&gt;left = p;        L-&gt;right = p;    &#125;    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;        n = capacity;        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>),R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>);        L-&gt;right = R;        R-&gt;left = L;      &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//不存在关键字 key </span>        <span class="hljs-keyword">auto</span> p = hash[key];        <span class="hljs-built_in">remove</span>(p);        <span class="hljs-built_in">insert</span>(p);<span class="hljs-comment">//将当前节点放在双链表的第一位</span>        <span class="hljs-keyword">return</span> p-&gt;value;    &#125;      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(key)) <span class="hljs-comment">//如果key存在，则修改对应的value</span>        &#123;            <span class="hljs-keyword">auto</span> p = hash[key];            p-&gt;value = value;            <span class="hljs-built_in">remove</span>(p);            <span class="hljs-built_in">insert</span>(p);        &#125;        <span class="hljs-keyword">else</span>         &#123;            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">size</span>() == n) <span class="hljs-comment">//如果缓存已满，则删除双链表最右侧的节点</span>            &#123;                <span class="hljs-keyword">auto</span>  p = R-&gt;left;                <span class="hljs-built_in">remove</span>(p);                hash.<span class="hljs-built_in">erase</span>(p-&gt;key); <span class="hljs-comment">//更新哈希表</span>                <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//释放内存</span>            &#125;            <span class="hljs-comment">//否则，插入(key, value)</span>            <span class="hljs-keyword">auto</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key,value);            hash[key] = p;            <span class="hljs-built_in">insert</span>(p);        &#125;    &#125;&#125;;</code></pre></div><p>分析：采用一个链表 <code>list&lt;pair&lt;int, int&gt;&gt;</code>来储存信息的 <code>key</code>和 <code>value</code>，链表的链接顺序即为最近使用的新旧顺序，最新的信息在链表头节点。同时我们需要一个嵌套着链表的迭代器的 <code>unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;</code>进行快速搜索，存迭代器的原因是方便调用链表的 <code>splice</code>函数来直接更新查找成功（cash hit）时的信息，即把迭代器对应的节点移动为链表的头节点。</p><p>错误：不明白</p><h2 id="练习">练习</h2><h3 id="Leetcode-1135">Leetcode 1135</h3><p>付费题目</p><h3 id="Leetcode-380">Leetcode 380</h3><p>设计一个插入、删除和随机取值均为<img src="https://math.now.sh?inline=O%281%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时间复杂度的数据结构</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<span class="hljs-keyword">private</span>:    vector&lt;<span class="hljs-type">int</span>&gt; nums;    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; indices;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">RandomizedSet</span>() &#123;        <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));    &#125;      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (indices.<span class="hljs-built_in">count</span>(val)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-type">int</span> index = nums.<span class="hljs-built_in">size</span>();        nums.<span class="hljs-built_in">emplace_back</span>(val);        indices[val] = index;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!indices.<span class="hljs-built_in">count</span>(val)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-type">int</span> index = indices[val];        <span class="hljs-type">int</span> last = nums.<span class="hljs-built_in">back</span>();        nums[index] = last;        indices[last] = index;        nums.<span class="hljs-built_in">pop_back</span>();        indices.<span class="hljs-built_in">erase</span>(val);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;         <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">rand</span>()%nums.<span class="hljs-built_in">size</span>()];    &#125;&#125;;</code></pre></div><p>分析：变长数组 + 哈希表可以实现</p><p>错误：随机数不太会，剩下的自己实现了</p><h3 id="Leetcode-432">Leetcode 432</h3><p>设计一个increaseKey，decreaseKey，getMaxKey，getMinKey 均为<img src="https://math.now.sh?inline=O%281%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时间复杂度的数据结构。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AllOne</span> &#123;    list&lt;pair&lt;unordered_set&lt;string&gt;, <span class="hljs-type">int</span>&gt;&gt; lst;    unordered_map&lt;string, list&lt;pair&lt;unordered_set&lt;string&gt;, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; nodes;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">AllOne</span>() &#123;&#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(string key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (nodes.<span class="hljs-built_in">count</span>(key)) &#123;            <span class="hljs-keyword">auto</span> cur = nodes[key], nxt = <span class="hljs-built_in">next</span>(cur);            <span class="hljs-keyword">if</span> (nxt == lst.<span class="hljs-built_in">end</span>() || nxt-&gt;second &gt; cur-&gt;second + <span class="hljs-number">1</span>) &#123;                <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(&#123;key&#125;)</span></span>;                nodes[key] = lst.<span class="hljs-built_in">emplace</span>(nxt, s, cur-&gt;second + <span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                nxt-&gt;first.<span class="hljs-built_in">emplace</span>(key);                nodes[key] = nxt;            &#125;            cur-&gt;first.<span class="hljs-built_in">erase</span>(key);            <span class="hljs-keyword">if</span> (cur-&gt;first.<span class="hljs-built_in">empty</span>()) &#123;                lst.<span class="hljs-built_in">erase</span>(cur);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// key 不在链表中</span>            <span class="hljs-keyword">if</span> (lst.<span class="hljs-built_in">empty</span>() || lst.<span class="hljs-built_in">begin</span>()-&gt;second &gt; <span class="hljs-number">1</span>) &#123;                unordered_set&lt;string&gt; <span class="hljs-built_in">s</span>(&#123;key&#125;);                lst.<span class="hljs-built_in">emplace_front</span>(s, <span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                lst.<span class="hljs-built_in">begin</span>()-&gt;first.<span class="hljs-built_in">emplace</span>(key);            &#125;            nodes[key] = lst.<span class="hljs-built_in">begin</span>();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dec</span><span class="hljs-params">(string key)</span> </span>&#123;        <span class="hljs-keyword">auto</span> cur = nodes[key];        <span class="hljs-keyword">if</span> (cur-&gt;second == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// key 仅出现一次，将其移出 nodes</span>            nodes.<span class="hljs-built_in">erase</span>(key);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">auto</span> pre = <span class="hljs-built_in">prev</span>(cur);            <span class="hljs-keyword">if</span> (cur == lst.<span class="hljs-built_in">begin</span>() || pre-&gt;second &lt; cur-&gt;second - <span class="hljs-number">1</span>) &#123;                <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">s</span><span class="hljs-params">(&#123;key&#125;)</span></span>;                nodes[key] = lst.<span class="hljs-built_in">emplace</span>(cur, s, cur-&gt;second - <span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                pre-&gt;first.<span class="hljs-built_in">emplace</span>(key);                nodes[key] = pre;            &#125;        &#125;        cur-&gt;first.<span class="hljs-built_in">erase</span>(key);        <span class="hljs-keyword">if</span> (cur-&gt;first.<span class="hljs-built_in">empty</span>()) &#123;            lst.<span class="hljs-built_in">erase</span>(cur);        &#125;    &#125;    <span class="hljs-function">string <span class="hljs-title">getMaxKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> lst.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;&quot;</span> : *lst.<span class="hljs-built_in">rbegin</span>()-&gt;first.<span class="hljs-built_in">begin</span>();    &#125;    <span class="hljs-function">string <span class="hljs-title">getMinKey</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> lst.<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;&quot;</span> : *lst.<span class="hljs-built_in">begin</span>()-&gt;first.<span class="hljs-built_in">begin</span>();    &#125;&#125;;</code></pre></div><p>分析：双向链表+哈希表</p><p>错误：好难</p><h3 id="Leetcode-716">Leetcode 716</h3><p>付费题目</p><h2 id="总结">总结</h2><p>基本上都是要自己写数据结构的题目，应该也不是很常见了。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第15章 图</title>
    <link href="/2022/09/17/Leetcode/Leetcode-101/Leetcode-101-15/"/>
    <url>/2022/09/17/Leetcode/Leetcode-101/Leetcode-101-15/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第15章 图</p><span id="more"></span><h1>图</h1><h2 id="二分图">二分图</h2><p>二分图算法也称为染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分。</p><h3 id="Leetcode-785">Leetcode 785</h3><p>判断一个图是不是二分图</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">private</span>:    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> UNCOLORED = <span class="hljs-number">0</span>;    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> RED = <span class="hljs-number">1</span>;    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> GREEN = <span class="hljs-number">2</span>;    vector&lt;<span class="hljs-type">int</span>&gt; color;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">color</span><span class="hljs-params">(n, UNCOLORED)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">if</span> (color[i] == UNCOLORED) &#123;                queue&lt;<span class="hljs-type">int</span>&gt; q;                q.<span class="hljs-built_in">push</span>(i);                color[i] = RED;                <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;                    <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();                    <span class="hljs-type">int</span> cNei = (color[node] == RED ? GREEN : RED);                    q.<span class="hljs-built_in">pop</span>();                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor: graph[node]) &#123;                        <span class="hljs-keyword">if</span> (color[neighbor] == UNCOLORED) &#123;                            q.<span class="hljs-built_in">push</span>(neighbor);                            color[neighbor] = cNei;                        &#125;                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (color[neighbor] != cNei) &#123;                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre></div><p>分析：广度优先遍历，需要判断</p><p>错误：想简单了</p><h2 id="拓扑排序">拓扑排序</h2><p>拓扑排序（topological sort）是一种常见的，对有向无环图排序的算法。给定有向无环图中的N个节点，我们把它们排序成一个线性序列；若原图中节点i指向节点j，则排序结果中i一定在j之前。拓扑排序的结果不是唯一的，只要满足以上条件即可。</p><h3 id="Leetcode-210">Leetcode 210</h3><p>给定N个课程和这些课程的前置必修课，求可以一次性上完所有课的顺序。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">indegree</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">graph</span>(numCourses,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(numCourses,<span class="hljs-number">0</span>));        <span class="hljs-type">int</span> m = prerequisites.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            graph[prerequisites[i][<span class="hljs-number">1</span>]][prerequisites[i][<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>;            ++indegree[prerequisites[i][<span class="hljs-number">0</span>]];        &#125;        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">size</span>() == numCourses)&#123;                <span class="hljs-keyword">return</span> result;            &#125;            <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;++i)&#123;                <span class="hljs-keyword">if</span>(indegree[i] == <span class="hljs-number">0</span>)&#123;                    indegree[i] = <span class="hljs-number">-1</span>;                    result.<span class="hljs-built_in">push_back</span>(i);                    sign = <span class="hljs-number">1</span>;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;numCourses;++j)&#123;                        <span class="hljs-keyword">if</span>(graph[i][j] == <span class="hljs-number">1</span>)&#123;                            graph[i][j] = <span class="hljs-number">0</span>;                            --indegree[j];                        &#125;                    &#125;                &#125;            &#125;            <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        result.<span class="hljs-built_in">clear</span>();        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：经典拓扑排序</p><p>错误：有一点小错误，基本一遍AC</p><h2 id="练习">练习</h2><h3 id="Leetcode-1059">Leetcode 1059</h3><p>付费题目</p><h3 id="Leetcode-1135">Leetcode 1135</h3><p>付费题目</p><h3 id="Leetcode-882">Leetcode 882</h3><p>经典的节点最短距离问题</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reachableNodes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges, <span class="hljs-type">int</span> maxMoves, <span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-comment">// 先构建图</span>        vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">graph</span>(n);        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges)        &#123;            <span class="hljs-type">int</span> s = edge[<span class="hljs-number">0</span>];            <span class="hljs-type">int</span> e = edge[<span class="hljs-number">1</span>];            <span class="hljs-type">int</span> cnt = edge[<span class="hljs-number">2</span>];            graph[s].<span class="hljs-built_in">emplace_back</span>(e, cnt);            graph[e].<span class="hljs-built_in">emplace_back</span>(s, cnt);        &#125;        <span class="hljs-comment">// 保持一个从起点到当前点的距离</span>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; distances;        distances[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)        &#123;            distances[i] = maxMoves + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 点到点的“额外扩展距离”，最大是cnt</span>        <span class="hljs-comment">// 二维变一维 int&lt;&lt;32 + int</span>        unordered_map&lt;<span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; extras;        <span class="hljs-comment">// 结果记录</span>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 从起点到改点的距离的小顶堆</span>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; q;        q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>())        &#123;            <span class="hljs-type">int</span> dist = q.<span class="hljs-built_in">top</span>().first;            <span class="hljs-type">int</span> curr = q.<span class="hljs-built_in">top</span>().second;            q.<span class="hljs-built_in">pop</span>();                      <span class="hljs-comment">// 忽略更大的距离</span>            <span class="hljs-keyword">if</span> (dist &gt; distances[curr])            &#123;                <span class="hljs-keyword">continue</span>;            &#125;            distances[curr] = dist;            ++res;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : graph[curr])            &#123;                <span class="hljs-type">int</span> next = pair.first;                <span class="hljs-type">int</span> cnt = pair.second;                <span class="hljs-comment">// 这里取最小的距离, 取（cnt和 maxMoves-dist）的最小值</span>                extras[((<span class="hljs-type">long</span>)curr &lt;&lt; <span class="hljs-number">32</span>) + next] = <span class="hljs-built_in">min</span>(cnt, maxMoves - dist);                <span class="hljs-comment">// 计算基于当前点到下一个结点的距离,额外走一步，如果找到更小，则插入队列里</span>                <span class="hljs-type">int</span> dist2 = dist + cnt + <span class="hljs-number">1</span>;                <span class="hljs-keyword">if</span> (dist2 &lt; distances[next])                &#123;                    q.<span class="hljs-built_in">emplace</span>(dist2, next);                    distances[next] = dist2;                &#125;            &#125;        &#125;        <span class="hljs-comment">// 最后加上“额外扩展距离”</span>        <span class="hljs-keyword">for</span> (vector&lt;<span class="hljs-type">int</span>&gt;&amp; edge : edges)        &#123;            <span class="hljs-type">int</span> s = edge[<span class="hljs-number">0</span>];            <span class="hljs-type">int</span> e = edge[<span class="hljs-number">1</span>];            res += <span class="hljs-built_in">min</span>(edge[<span class="hljs-number">2</span>], extras[((<span class="hljs-type">long</span>)s&lt;&lt; <span class="hljs-number">32</span>) +e] + extras[((<span class="hljs-type">long</span>)e&lt;&lt;<span class="hljs-number">32</span>) +s]);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;&#125;;</code></pre></div><h2 id="总结">总结</h2><p>各种高级用法，还比较简单，但是应该不是很常见</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第7讲 基于语言建模的IR模型</title>
    <link href="/2022/09/17/UCAS/information-retrieval/information-retrieval-7/"/>
    <url>/2022/09/17/UCAS/information-retrieval/information-retrieval-7/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第7讲 基于语言建模的IR模型</p><span id="more"></span><h1>第7讲 基于语言建模的IR模型</h1><h2 id="语言模型">语言模型</h2><p>统计语言模型(Statistical Language Modeling，SLM)</p><p>SLM广泛使用于语音识别和统计机器翻译领域，利用概率统计理论研究语言。</p><p>规则方法：词、句、篇章的生成比如满足某些规则，不满足该规则就不应存在。</p><p>统计方法：任何语言片断都有存在的可能，只是可能性大小不同</p><p>对于n-gram，n越大，则模型越复杂，估计的参数(即估计的概率)也越多。当然，当数据量足够大的情况下，模型阶数越高越对片段概率的计算也越准确。</p><p>理论上说，在数据充足的情况下，利用更多的历史高阶的模型更准确，但是总计算量也越大</p><p>数据规模总是有限的，即用于训练模型参数的语料存在稀疏性 (Data Sparseness ，即某参数在训练语料中没有出现问题。</p><p>数据稀疏性导致零概率问题，但是训练集上不出现的事件并不代表在新的语料上不出现。</p><p>SLM的一个重要工作就是进行平滑重新分配概率，即使没出现的事件也会赋予一个概率。</p><h2 id="基于统计建模的IR模型">基于统计建模的IR模型</h2><ul><li>查询似然模型：把相关度看成是每篇文档对应的语言下生成该查询的可能性</li><li>翻译模型：假设查询经过某个噪声信道变形成某篇文章，则由文档还原成该查询的概率翻译模型可以视为相关度</li><li>KL距离模型 ：查询对应某种语言，每篇文档对应某种语言，查询语言和文档语言的KL距离作为相关度度量</li></ul><p>总体分布&amp;抽样</p><p>文档的模型风格实际上是某种总体分布</p><p>（待评分）文档和查询都是该总体分布下的一个抽样样本实例</p><p>根据文档，估计文档的模型，即求出该总体分布（一般假设某种总体分布，然后求出其参数），然后计算该总体分布下抽样出查询的概率</p><p>查询似然模型（Query Likelihood Model）</p><p>文本生成的多项式模型</p><p>数据平滑的一般形式</p><p>其它SLMIR 模型</p><ul><li>查询似然类：文档建模、计算查询的似然、基本QLM 模型、翻译模型等</li><li>文档似然类：查询建模、计算文档的似然、BIM模型、相关性模型等</li><li>模型比较类：文档建模、查询建模，计算两个模型的距离，KL距离模型</li></ul><p>基于翻译模型的IR模型：</p><p>基本的QLM模型不能解决词语失配(word mismatch)问题，即查询中的用词和文档中的用词不一致</p><p>翻译概率P(qi|wj)在计算时可以将词项之间的关系融入。</p><ul><li>基于词典来计算(人工或者自动构造的同义词/近义词/翻译词典)</li><li>基于语料库来计算(标题、摘要vs. 文本；文档锚文本vs. 文档)</li></ul><p>KL距离(相对熵)模型</p><p>统计语言建模IR模型优缺点</p><p>优点：</p><ul><li>理论上具有解释性，有扩展空间</li><li>有些模型虽然计算上仍然依赖于term 独立性假设，</li><li>但是模型本身并不依赖于 term 独立性假设。</li></ul><p>缺点：数据稀疏性，需要参数估计</p><h2 id="SLMIR模型讨论">SLMIR模型讨论</h2><ul><li>SLMIR中有一些东西和VSM一样</li><li>词项频率直接在模型中使用<ul><li>但是在SLMIR 中没有进行放缩变化</li></ul></li><li>本质上概率表示已经进行了长度归一化<ul><li>VSM中的余弦归一化也做了类似工作</li></ul></li><li>文档中的词项频率和文档集频率混合以后和idf的效果相当<ul><li>那些文档集中比较罕见，但是某些文档中比较普遍的词项将对排序起更重要的影响。</li></ul></li></ul><p>SLMIR vs. VSM ：</p><p>共性：</p><ul><li>模型中都直接使用了词项频率</li><li>本质上概率表示已经进行了长度归一化</li><li>文档中词项频率和文档集频率混合以后和idf的效果相当</li></ul><p>不同：</p><ul><li>SLMIR：基于概率论</li><li>VSM：基于相似度，一个线性代数中的概念</li><li>文档集频率、文档概率、词项频率、归一化等计算细节</li></ul><p>基于统计建模的IR模型 : 假设</p><ul><li>简化假设：查询和文档是同一类对象，与实际并不相符<ul><li>已经出现了一些不采用上述假设的SLMIR模型</li><li>VSM也基于同一假设</li></ul></li><li>简化假设：词项之间是独立的<ul><li>VSM 中也采用了词项独立性假设</li></ul></li><li>比向量空间中的假设表述更清晰</li><li>SLMIR比VSM 具有更好的理论基础，但是纯语言模型的效果会大大低于经过精心调参的向量模型的效果。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第14章 树</title>
    <link href="/2022/09/16/Leetcode/Leetcode-101/Leetcode-101-14/"/>
    <url>/2022/09/16/Leetcode/Leetcode-101/Leetcode-101-14/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第14章 树</p><span id="more"></span><h1>树</h1><h2 id="树的递归">树的递归</h2><h3 id="Leetcode-104">Leetcode 104</h3><p>给定一个二叉树，找出其最大深度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* &amp;root,<span class="hljs-type">int</span> sum)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> sum;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">DFS</span>(root-&gt;left,sum<span class="hljs-number">+1</span>),<span class="hljs-built_in">DFS</span>(root-&gt;right,sum<span class="hljs-number">+1</span>));    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DFS</span>(root,<span class="hljs-number">0</span>);    &#125;&#125;;</code></pre></div><p>分析：递归计算最大高度即可</p><p>错误：开始递归写的有问题，变成引用传参了，后面改对后调通。</p><h3 id="Leetcode-110">Leetcode 110</h3><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* &amp;root)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-type">int</span> left = <span class="hljs-built_in">DFS</span>(root-&gt;left);        <span class="hljs-type">int</span> right = <span class="hljs-built_in">DFS</span>(root-&gt;right);        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">-1</span> || right == <span class="hljs-number">-1</span> || <span class="hljs-built_in">abs</span>(left - right) &gt; <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)<span class="hljs-number">+1</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DFS</span>(root) != <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre></div><p>分析：解法类似于求树的最大深度，但有两个不同的地方：一是我们需要先处理子树的深度再进行比较，二是如果我们在处理子树时发现其已经不平衡了，则可以返回一个-1，使得所有其长辈节点可以避免多余的判断</p><p>错误：思路不对，看了解析</p><h3 id="Leetcode-543">Leetcode 543</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* &amp;root,<span class="hljs-type">int</span> &amp;maxsum)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-type">int</span> left = <span class="hljs-built_in">DFS</span>(root-&gt;left,maxsum);        <span class="hljs-type">int</span> right = <span class="hljs-built_in">DFS</span>(root-&gt;right,maxsum);        maxsum = <span class="hljs-built_in">max</span>(maxsum,left+right<span class="hljs-number">+1</span>);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left,right)<span class="hljs-number">+1</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-type">int</span> maxsum = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> a = <span class="hljs-built_in">DFS</span>(root,maxsum);        <span class="hljs-keyword">return</span> maxsum<span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre></div><p>分析：还是递归，要留两个变量进行记录</p><p>错误：没看解析调通，但是自己想的挺艰难的。</p><h3 id="Leetcode-437">Leetcode 437</h3><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。<strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-type">long</span> <span class="hljs-type">long</span> count;        <span class="hljs-keyword">if</span>(root-&gt;val == sum)&#123;            count = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            count = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> count + <span class="hljs-built_in">DFS</span>(root-&gt;left,sum-root-&gt;val) + <span class="hljs-built_in">DFS</span>(root-&gt;right,sum-root-&gt;val);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DFS</span>(root,targetSum)+<span class="hljs-built_in">pathSum</span>(root-&gt;left,targetSum)+<span class="hljs-built_in">pathSum</span>(root-&gt;right,targetSum);    &#125;&#125;;</code></pre></div><p>分析：递归每个节点时，需要分情况考虑：（1）如果选取该节点加入路径，则之后必须继续加入连续节点，或停止加入节点（2）如果不选取该节点加入路径，则对其左右节点进行重新进行考虑。因此一个方便的方法是我们创建一个辅函数，专门用来计算连续加入节点的路径。</p><p>错误：两层的递归有点做不了</p><h3 id="Leetcode-101">Leetcode 101</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* &amp;left,TreeNode* &amp;right)</span></span>&#123;        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right != <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">nullptr</span> &amp;&amp; right == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DFS</span>(left-&gt;left,right-&gt;right) &amp;&amp; <span class="hljs-built_in">DFS</span>(left-&gt;right,right-&gt;left);    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">DFS</span>(root-&gt;left,root-&gt;right);    &#125;&#125;;</code></pre></div><p>分析：判断一个树是否对称等价于判断左右子树是否对称。笔者一般习惯将判断两个子树是否相等或对称类型的题的解法叫做“四步法”：（1）如果两个子树都为空指针，则它们相等或对称（2）如果两个子树只有一个为空指针，则它们不相等或不对称（3）如果两个子树根节点的值不相等，则它们不相等或不对称（4）根据相等或对称要求，进行递归处理。</p><p>错误：不明白</p><h3 id="Leetcode-1110">Leetcode 1110</h3><p>给出二叉树的根节点 <code>root</code>，树上每个节点都有一个不同的值。如果节点值在 <code>to_delete</code> 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* &amp;root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; to_delete,vector&lt;TreeNode*&gt;&amp; result)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">DFS</span>(root-&gt;left,to_delete,result);        <span class="hljs-built_in">DFS</span>(root-&gt;right,to_delete,result);        <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(to_delete.<span class="hljs-built_in">begin</span>(),to_delete.<span class="hljs-built_in">end</span>(),root-&gt;val);        <span class="hljs-keyword">if</span>(it != to_delete.<span class="hljs-built_in">end</span>())&#123;            <span class="hljs-keyword">if</span>(root-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;                result.<span class="hljs-built_in">push_back</span>(root-&gt;left);            &#125;            <span class="hljs-keyword">if</span>(root-&gt;right != <span class="hljs-literal">nullptr</span>)&#123;                result.<span class="hljs-built_in">push_back</span>(root-&gt;right);            &#125;            root-&gt;left = <span class="hljs-literal">nullptr</span>;            root-&gt;right = <span class="hljs-literal">nullptr</span>;            root = <span class="hljs-literal">nullptr</span>;        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">delNodes</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; to_delete)</span> </span>&#123;        vector&lt;TreeNode*&gt; result;        <span class="hljs-built_in">DFS</span>(root,to_delete,result);        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>)&#123;            result.<span class="hljs-built_in">push_back</span>(root);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：遍历，然后置为空指针就好</p><p>错误：开始的判断条件不太够，后来自己调通。</p><h2 id="层次遍历">层次遍历</h2><h3 id="Leetcode-637">Leetcode 637</h3><p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10&lt;sup&gt;-5&lt;/sup&gt;</code> 以内的答案可以被接受。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        vector&lt;<span class="hljs-type">double</span>&gt; result;        queue&lt;TreeNode*&gt; q;        q.<span class="hljs-built_in">push</span>(root);        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;            <span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;            <span class="hljs-type">int</span> nowsize = q.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span>(nowsize--)&#123;                TreeNode* t = q.<span class="hljs-built_in">front</span>();                q.<span class="hljs-built_in">pop</span>();                num += <span class="hljs-number">1</span>;                sum += t-&gt;val;                <span class="hljs-keyword">if</span>(t-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;                    q.<span class="hljs-built_in">push</span>(t-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(t-&gt;right != <span class="hljs-literal">nullptr</span>)&#123;                    q.<span class="hljs-built_in">push</span>(t-&gt;right);                &#125;            &#125;            result.<span class="hljs-built_in">push_back</span>(sum/num);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：层序遍历即可</p><p>一遍AC</p><h2 id="前中后序遍历">前中后序遍历</h2><h3 id="Leetcode-105">Leetcode 105</h3><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的 <strong>先序遍历</strong> ， <code>inorder</code> 是同一棵树的 <strong>中序遍历</strong> ，请构造二叉树并返回其根节点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">private</span>:    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; index;<span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">myBuildTree</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> preorder_left, <span class="hljs-type">int</span> preorder_right, <span class="hljs-type">int</span> inorder_left, <span class="hljs-type">int</span> inorder_right)</span> </span>&#123;        <span class="hljs-keyword">if</span> (preorder_left &gt; preorder_right) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;          <span class="hljs-comment">// 前序遍历中的第一个节点就是根节点</span>        <span class="hljs-type">int</span> preorder_root = preorder_left;        <span class="hljs-comment">// 在中序遍历中定位根节点</span>        <span class="hljs-type">int</span> inorder_root = index[preorder[preorder_root]];          <span class="hljs-comment">// 先把根节点建立出来</span>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[preorder_root]);        <span class="hljs-comment">// 得到左子树中的节点数目</span>        <span class="hljs-type">int</span> size_left_subtree = inorder_root - inorder_left;        <span class="hljs-comment">// 递归地构造左子树，并连接到根节点</span>        <span class="hljs-comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span>        root-&gt;left = <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="hljs-number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 递归地构造右子树，并连接到根节点</span>        <span class="hljs-comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span>        root-&gt;right = <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, preorder_left + size_left_subtree + <span class="hljs-number">1</span>, preorder_right, inorder_root + <span class="hljs-number">1</span>, inorder_right);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;        <span class="hljs-type">int</span> n = preorder.<span class="hljs-built_in">size</span>();        <span class="hljs-comment">// 构造哈希映射，帮助我们快速定位根节点</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            index[inorder[i]] = i;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">myBuildTree</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);    &#125;&#125;;</code></pre></div><p>分析：很老的题，好好判断，数据结构设计对即可</p><p>错误：太久远了忘记怎么判断了</p><h3 id="Leetcode-144">Leetcode 144</h3><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* &amp;root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;result)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);        <span class="hljs-built_in">dfs</span>(root-&gt;left,result);        <span class="hljs-built_in">dfs</span>(root-&gt;right,result);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-built_in">dfs</span>(root,result);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：递归遍历即可</p><p>一遍AC</p><h2 id="二叉查找树">二叉查找树</h2><h3 id="Leetcode-99">Leetcode 99</h3><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。 请在不改变其结构的情况下，恢复这棵树。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, TreeNode*&amp; mistake1, TreeNode*&amp; mistake2, TreeNode*&amp; prev)</span> </span>&#123;        <span class="hljs-keyword">if</span> (!root) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;            <span class="hljs-built_in">inorder</span>(root-&gt;left, mistake1, mistake2, prev);        &#125;        <span class="hljs-keyword">if</span> (prev &amp;&amp; root-&gt;val &lt; prev-&gt;val) &#123;            <span class="hljs-keyword">if</span> (!mistake1) &#123;                mistake1 = prev;                mistake2 = root;            &#125;            <span class="hljs-keyword">else</span> &#123;                mistake2 = root;            &#125;            cout &lt;&lt; mistake1-&gt;val;            cout &lt;&lt; mistake2-&gt;val;        &#125;        prev = root;        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;            <span class="hljs-built_in">inorder</span>(root-&gt;right, mistake1, mistake2, prev);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        TreeNode *mistake1 = <span class="hljs-literal">nullptr</span>, *mistake2 = <span class="hljs-literal">nullptr</span>, *prev = <span class="hljs-literal">nullptr</span>;        <span class="hljs-built_in">inorder</span>(root, mistake1, mistake2, prev);        <span class="hljs-keyword">if</span> (mistake1 &amp;&amp; mistake2) &#123;            <span class="hljs-type">int</span> temp = mistake1-&gt;val;            mistake1-&gt;val = mistake2-&gt;val;            mistake2-&gt;val = temp;        &#125;    &#125;&#125;;</code></pre></div><p>分析：我们可以使用中序遍历这个二叉查找树，同时设置一个prev 指针，记录当前节点中序遍历时的前节点。如果当前节点大于prev 节点的值，说明需要调整次序。有一个技巧是如果遍历整个序列过程中只出现了一次次序错误，说明就是这两个相邻节点需要被交换；如果出现了两次次序错误，那就需要交换这两个节点。</p><p>错误：没有思路</p><h3 id="Leetcode-669">Leetcode 669</h3><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界 <code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在 <code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;val &gt; high)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left,low,high);        &#125;        <span class="hljs-keyword">if</span>(root-&gt;val &lt; low)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right,low,high);        &#125;        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre></div><p>分析：利用二叉查找树的大小关系递归进行树的处理。</p><p>错误：看了解析</p><h2 id="字典树">字典树</h2><h3 id="Leetcode-208">Leetcode 208</h3><p>尝试建立一个字典树，支持快速插入单词、查找单词、查找单词前缀的功能。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<span class="hljs-keyword">private</span>:    vector&lt;Trie*&gt; children;    <span class="hljs-type">bool</span> isEnd;    <span class="hljs-function">Trie* <span class="hljs-title">searchPrefix</span><span class="hljs-params">(string prefix)</span> </span>&#123;        Trie* node = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : prefix) &#123;            ch -= <span class="hljs-string">&#x27;a&#x27;</span>;            <span class="hljs-keyword">if</span> (node-&gt;children[ch] == <span class="hljs-literal">nullptr</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;            &#125;            node = node-&gt;children[ch];        &#125;        <span class="hljs-keyword">return</span> node;    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Trie</span>() : <span class="hljs-built_in">children</span>(<span class="hljs-number">26</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;        Trie* node = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word) &#123;            ch -= <span class="hljs-string">&#x27;a&#x27;</span>;            <span class="hljs-keyword">if</span> (node-&gt;children[ch] == <span class="hljs-literal">nullptr</span>) &#123;                node-&gt;children[ch] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();            &#125;            node = node-&gt;children[ch];        &#125;        node-&gt;isEnd = <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;        Trie* node = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">searchPrefix</span>(word);        <span class="hljs-keyword">return</span> node != <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;isEnd;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">searchPrefix</span>(prefix) != <span class="hljs-literal">nullptr</span>;    &#125;&#125;;</code></pre></div><p>分析：字典树的典型实现方法</p><p>错误：没做过，尝试理解</p><h2 id="练习">练习</h2><h3 id="Leetcode-226">Leetcode 226</h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;        TreeNode* left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);        TreeNode* right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);        root-&gt;left = right;        root-&gt;right = left;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre></div><p>分析：递归反转即可</p><p>错误：翻转值是不对的，需要反转结点</p><h3 id="Leetcode-617">Leetcode 617</h3><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。返回合并后的二叉树。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">nullptr</span>) &#123;            <span class="hljs-keyword">return</span> t2;        &#125;        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">nullptr</span>) &#123;            <span class="hljs-keyword">return</span> t1;        &#125;        <span class="hljs-keyword">auto</span> merged = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);        merged-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);        merged-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);        <span class="hljs-keyword">return</span> merged;    &#125;&#125;;</code></pre></div><p>分析：递归处理即可</p><p>错误：自己尝试的方法有问题，不太明白错在哪</p><h3 id="Leetcode-572">Leetcode 572</h3><p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span> &amp;&amp; subRoot == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span> &amp;&amp; subRoot != <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span> &amp;&amp; subRoot == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">if</span>(root-&gt;val != subRoot-&gt;val)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root-&gt;left,subRoot-&gt;left) &amp;&amp; <span class="hljs-built_in">check</span>(root-&gt;right,subRoot-&gt;right);    &#125;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root,subRoot) || <span class="hljs-built_in">DFS</span>(root-&gt;left,subRoot) || <span class="hljs-built_in">DFS</span>(root-&gt;right,subRoot);    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;        <span class="hljs-type">bool</span> judge = <span class="hljs-built_in">DFS</span>(root,subRoot);        <span class="hljs-keyword">return</span> judge;    &#125;&#125;;</code></pre></div><p>分析：递归判断即可</p><p>错误：自己写了前半部分，看了一眼后写了后半部分</p><h3 id="Leetcode-404">Leetcode 404</h3><p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isLeafNode</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;        <span class="hljs-keyword">return</span> !node-&gt;left &amp;&amp; !node-&gt;right;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (node-&gt;left) &#123;            ans += <span class="hljs-built_in">isLeafNode</span>(node-&gt;left) ? node-&gt;left-&gt;val : <span class="hljs-built_in">dfs</span>(node-&gt;left);        &#125;        <span class="hljs-keyword">if</span> (node-&gt;right &amp;&amp; !<span class="hljs-built_in">isLeafNode</span>(node-&gt;right)) &#123;            ans += <span class="hljs-built_in">dfs</span>(node-&gt;right);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root);    &#125;&#125;;</code></pre></div><p>分析：递归判断结点</p><p>错误：没有思路</p><h3 id="Leetcode-513">Leetcode 513</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的最底层最左边节点的值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        queue&lt;TreeNode*&gt; q;        q.<span class="hljs-built_in">push</span>(root);        <span class="hljs-type">int</span> result = root-&gt;val;        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> tempsize = q.<span class="hljs-built_in">size</span>();            <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(tempsize--)&#123;                TreeNode* t = q.<span class="hljs-built_in">front</span>();                q.<span class="hljs-built_in">pop</span>();                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>)&#123;                    result = t-&gt;val;                    sign = <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">if</span>(t-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;                    q.<span class="hljs-built_in">push</span>(t-&gt;left);                &#125;                <span class="hljs-keyword">if</span>(t-&gt;right != <span class="hljs-literal">nullptr</span>)&#123;                    q.<span class="hljs-built_in">push</span>(t-&gt;right);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：广度优先遍历即可</p><p>一遍AC</p><h3 id="Leetcode-538">Leetcode 538</h3><p>给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> &amp;sum)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">DFS</span>(root-&gt;right,sum);        root-&gt;val = root-&gt;val + sum;        sum = root-&gt;val;        <span class="hljs-built_in">DFS</span>(root-&gt;left,sum);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-built_in">DFS</span>(root,sum);        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre></div><p>分析：反向的中序遍历</p><p>错误：开始顺序弄反，后面修正了</p><h3 id="Leetcode-235">Leetcode 235</h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">getPath</span><span class="hljs-params">(TreeNode* root, TreeNode* target)</span> </span>&#123;        vector&lt;TreeNode*&gt; path;        TreeNode* node = root;        <span class="hljs-keyword">while</span> (node != target) &#123;            path.<span class="hljs-built_in">push_back</span>(node);            <span class="hljs-keyword">if</span> (target-&gt;val &lt; node-&gt;val) &#123;                node = node-&gt;left;            &#125;            <span class="hljs-keyword">else</span> &#123;                node = node-&gt;right;            &#125;        &#125;        path.<span class="hljs-built_in">push_back</span>(node);        <span class="hljs-keyword">return</span> path;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        vector&lt;TreeNode*&gt; path_p = <span class="hljs-built_in">getPath</span>(root, p);        vector&lt;TreeNode*&gt; path_q = <span class="hljs-built_in">getPath</span>(root, q);        TreeNode* ancestor;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path_p.<span class="hljs-built_in">size</span>() &amp;&amp; i &lt; path_q.<span class="hljs-built_in">size</span>(); ++i) &#123;            <span class="hljs-keyword">if</span> (path_p[i] == path_q[i]) &#123;                ancestor = path_p[i];            &#125;            <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> ancestor;    &#125;&#125;;</code></pre></div><p>分析：从根节点开始遍历；如果当前节点就是p，那么成功地找到了节点；如果当前节点的值大于p的值，说明p应该在当前节点的左子树，因此将当前节点移动到它的左子节点；如果当前节点的值小于p的值，说明p应该在当前节点的右子树，因此将当前节点移动到它的右子节点。对于节点q同理。在寻找节点的过程中，我们可以顺便记录经过的节点，这样就得到了从根节点到被寻找节点的路径。</p><p>错误：没有思路</p><h3 id="Leetcode-530">Leetcode 530</h3><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* &amp;root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; result)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">DFS</span>(root-&gt;left,result);        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);        <span class="hljs-built_in">DFS</span>(root-&gt;right,result);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-built_in">DFS</span>(root,result);        <span class="hljs-type">int</span> minval = <span class="hljs-number">100000</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;result.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)&#123;            <span class="hljs-keyword">if</span>(result[i<span class="hljs-number">+1</span>]-result[i] &lt; minval)&#123;                minval = result[i<span class="hljs-number">+1</span>]-result[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> minval;    &#125;&#125;;</code></pre></div><p>分析：中序遍历存在数组内部，然后遍历判断即可</p><p>一遍AC</p><h3 id="Leetcode-889">Leetcode 889</h3><p>给定两个整数数组，<code>preorder</code> 和 <code>postorder</code> ，其中 <code>preorder</code> 是一个具有 <strong>无重复</strong> 值的二叉树的前序遍历，<code>postorder</code> 是同一棵树的后序遍历，重构并返回二叉树。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-type">int</span> preIdx = <span class="hljs-number">0</span>, postIdx = <span class="hljs-number">0</span>;<span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;        TreeNode *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[preIdx++]);        <span class="hljs-keyword">if</span>(node-&gt;val != postorder[postIdx])&#123;            node-&gt;left = <span class="hljs-built_in">constructFromPrePost</span>(preorder, postorder);        &#125;        <span class="hljs-keyword">if</span>(node-&gt;val != postorder[postIdx])&#123;            node-&gt;right = <span class="hljs-built_in">constructFromPrePost</span>(preorder, postorder);        &#125;        postIdx++;        <span class="hljs-keyword">return</span> node;    &#125;&#125;;</code></pre></div><p>分析：<strong>利用前序遍历来构建Tree，然后通过后续遍历来检验当前树是否构建完毕</strong> 。</p><p>错误：思路不对</p><h3 id="Leetcode-106">Leetcode 106</h3><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inleft,<span class="hljs-type">int</span> inright,vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder,<span class="hljs-type">int</span> postleft,<span class="hljs-type">int</span> postright)</span></span>&#123;        <span class="hljs-keyword">if</span>(inleft &gt; inright)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(postorder[postright]);        <span class="hljs-type">int</span> k;        <span class="hljs-keyword">for</span>(k=inleft;k&lt;=inright;++k)&#123;            <span class="hljs-keyword">if</span>(inorder[k] == postorder[postright])&#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-type">int</span> rightsize = inright - k;        root-&gt;left = <span class="hljs-built_in">DFS</span>(inorder,inleft,k<span class="hljs-number">-1</span>,postorder,postleft,postright-rightsize<span class="hljs-number">-1</span>);        root-&gt;right = <span class="hljs-built_in">DFS</span>(inorder,k<span class="hljs-number">+1</span>,inright,postorder,postright-rightsize,postright<span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();        TreeNode* root = <span class="hljs-built_in">DFS</span>(inorder,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,postorder,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre></div><p>分析：与前面的题目相同</p><p>一遍AC</p><h3 id="Leetcode-94">Leetcode 94</h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 它的 <strong>中序</strong> 遍历 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* &amp;root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;result)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">dfs</span>(root-&gt;left,result);        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);        <span class="hljs-built_in">dfs</span>(root-&gt;right,result);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-built_in">dfs</span>(root,result);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：普通递归</p><p>一遍AC</p><h3 id="Leetcode-145">Leetcode 145</h3><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的后序遍历。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* &amp;root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;result)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">dfs</span>(root-&gt;left,result);        <span class="hljs-built_in">dfs</span>(root-&gt;right,result);        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-built_in">dfs</span>(root,result);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：普通递归</p><p>一遍AC</p><h3 id="Leetcode-236">Leetcode 236</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    TreeNode* ans;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-type">bool</span> lson = <span class="hljs-built_in">dfs</span>(root-&gt;left, p, q);        <span class="hljs-type">bool</span> rson = <span class="hljs-built_in">dfs</span>(root-&gt;right, p, q);        <span class="hljs-keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;            ans = root;        &#125;         <span class="hljs-keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-built_in">dfs</span>(root, p, q);        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：不太明白</p><p>错误：不太明白</p><h3 id="Leetcode-109">Leetcode 109</h3><p>给定一个单链表的头节点  <code>head</code> ，其中的元素 <strong>按升序排序</strong> ，将其转换为高度平衡的二叉搜索树。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">getMedian</span><span class="hljs-params">(ListNode* left, ListNode* right)</span> </span>&#123;        ListNode* fast = left;        ListNode* slow = left;        <span class="hljs-keyword">while</span> (fast != right &amp;&amp; fast-&gt;next != right) &#123;            fast = fast-&gt;next;            fast = fast-&gt;next;            slow = slow-&gt;next;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(ListNode* left, ListNode* right)</span> </span>&#123;        <span class="hljs-keyword">if</span> (left == right) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;        ListNode* mid = <span class="hljs-built_in">getMedian</span>(left, right);        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(mid-&gt;val);        root-&gt;left = <span class="hljs-built_in">buildTree</span>(left, mid);        root-&gt;right = <span class="hljs-built_in">buildTree</span>(mid-&gt;next, right);        <span class="hljs-keyword">return</span> root;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTree</span>(head, <span class="hljs-literal">nullptr</span>);    &#125;&#125;;</code></pre></div><p>分析：每一次找中位数，然后递归构造两边就可以了</p><p>错误：以为要调整平衡，没有思路</p><h3 id="Leetcode-897">Leetcode 897</h3><p>给你一棵二叉搜索树的 <code>root</code> ，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode *node, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span> </span>&#123;        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) &#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">inorder</span>(node-&gt;left, res);        res.<span class="hljs-built_in">push_back</span>(node-&gt;val);        <span class="hljs-built_in">inorder</span>(node-&gt;right, res);    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; res;        <span class="hljs-built_in">inorder</span>(root, res);        TreeNode *dummyNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);        TreeNode *currNode = dummyNode;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : res) &#123;            currNode-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(value);            currNode = currNode-&gt;right;        &#125;        <span class="hljs-keyword">return</span> dummyNode-&gt;right;    &#125;&#125;;</code></pre></div><p>分析：遍历建树就可以，注意不要在函数中建树，原因没明白</p><p>错误：在函数中建树不行</p><h3 id="Leetcode-653">Leetcode 653</h3><p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果二叉搜索树中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt; &amp;result)</span></span>&#123;        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-built_in">DFS</span>(root-&gt;left,result);        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);        <span class="hljs-built_in">DFS</span>(root-&gt;right,result);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-built_in">DFS</span>(root,result);        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = result.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-keyword">if</span>(result[left] + result[right] == k)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result[left] + result[right] &lt; k)&#123;                ++left;            &#125;            <span class="hljs-keyword">else</span>&#123;                --right;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;   &#125;;</code></pre></div><p>分析：读出来二分就可以了</p><p>一遍AC</p><h3 id="Leetcode-450">Leetcode 450</h3><p>给定一个二叉搜索树的根节点root和一个值key，删除二叉搜索树中的key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;        <span class="hljs-keyword">if</span> (root-&gt;val &gt; key) &#123;            root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-keyword">if</span> (root-&gt;val &lt; key) &#123;            root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;            <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;            &#125;            <span class="hljs-keyword">if</span> (!root-&gt;right) &#123;                <span class="hljs-keyword">return</span> root-&gt;left;            &#125;            <span class="hljs-keyword">if</span> (!root-&gt;left) &#123;                <span class="hljs-keyword">return</span> root-&gt;right;            &#125;            TreeNode *successor = root-&gt;right;            <span class="hljs-keyword">while</span> (successor-&gt;left) &#123;                successor = successor-&gt;left;            &#125;            root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, successor-&gt;val);            successor-&gt;right = root-&gt;right;            successor-&gt;left = root-&gt;left;            <span class="hljs-keyword">return</span> successor;        &#125;        <span class="hljs-keyword">return</span> root;    &#125;&#125;;</code></pre></div><p>分析：解析</p><p>错误：不明白应该怎么调整</p><h2 id="总结">总结</h2><p>看起来树的题目并没有特别复杂的。主要的难度在于递归的思路，想明白后就简单了。另外就是各种边界条件的判断，也要多想多练。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第3章 线性分类</title>
    <link href="/2022/09/15/UCAS/machine-learning/machine-learning-3/"/>
    <url>/2022/09/15/UCAS/machine-learning/machine-learning-3/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第3章 线性分类</p><span id="more"></span><h1>第3章 线性分类</h1><h2 id="基础知识">基础知识</h2><p><img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个数组成的有序数组, 称为一个<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维向量<img src="https://math.now.sh?inline=a%3D%28a_1%2Ca_2%2C%5Ccdots%2Ca_n%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>向量空间：所有分量为实数的<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维向量构成的集合<img src="https://math.now.sh?inline=R%5En%3D%5Cleft%5C%7B%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7Da_1%20%5C%5C%20a_2%20%5C%5C%20%5Cvdots%20%5C%5C%20a_n%5Cend%7Barray%7D%5Cright%29%20a_i%20%5Cin%20R%2C%20i%3D1%2C2%2C%20%5Ccdots%2C%20n%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>称为一个<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维向量空间，又称线性空间。</p><p>超平面表达式：<img src="https://math.now.sh?inline=g%28%5Cboldsymbol%7Bx%7D%29%3D%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%2Bw_0%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>线性判别函数表达式：<img src="https://math.now.sh?inline=g%28%5Cboldsymbol%7Bx%7D%29%3D%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%2Bw_0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>线性函数刻画了样本到超平面的距离</p><p>相似性测度：</p><ul><li>Minkovski Metric 闵氏距离（p-范数）<img src="https://math.now.sh?inline=D%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D%5Cleft%5B%5Csum_i%5Cleft%7Cx_i-y_i%5Cright%7C%5Ep%5Cright%5D%5E%7B1%20%2F%20p%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>欧氏距离（p=2）（2-范数）<img src="https://math.now.sh?inline=D%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D%5Cleft%5B(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7By%7D)%5ET(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7By%7D)%5Cright%5D%5E%7B1%20%2F%202%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>城市块(p=1)、曼哈顿距离（1-范数）<img src="https://math.now.sh?inline=D%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D%5Csum_i%20%7Cx_i-y_i%7C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>Chobychev 距离(p=inf)<img src="https://math.now.sh?inline=D%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D%5Cmax%20_i%5Cleft%7Cx_i-y_i%5Cright%7C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>平方距离\马氏距离<img src="https://math.now.sh?inline=D%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7By%7D%29%3D(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7By%7D)%5ET%20%5Cboldsymbol%7BQ%7D(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7By%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>余弦相似性<img src="https://math.now.sh?inline=%5Ccos%20%5Cvarphi%3D%5Cboldsymbol%7Ba%7D%5ET%20%5Cboldsymbol%7Bb%7D%20%2F%7C%5Cboldsymbol%7Ba%7D%20%5C%7C%20%5Cboldsymbol%7Bb%7D%7C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>常用的统计量：</p><ul><li>类均值向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_i%3D%5Cfrac%7B1%7D%7Bn_i%7D%20%5Csum_%7Bk%3D1%7D%5E%7Bn_i%7D%20%5Cboldsymbol%7Bx%7D_k%5E%7B%28i%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>总均值向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D%3D%5Csum_%7Bi%3D1%7D%5Ec%20P_i%20%5Cboldsymbol%7Bm%7D_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D%3D%5Cfrac%7B1%7D%7Bc%7D%20%5Csum_%7Bi%3D1%7D%5Ec%20%5Cboldsymbol%7Bm%7D_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>类内散度矩阵<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_i%3D%5Cfrac%7B1%7D%7Bn_i%7D%20%5Csum_%7Bk%3D1%7D%5E%7Bn_i%7D%5Cleft%28%5Cboldsymbol%7Bx%7D_k%5E%7B(i%29%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5Cleft(%5Cboldsymbol%7Bx%7D_k%5E%7B(i)%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>总类内离散度矩阵<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_w%3D%5Csum_%7Bi%3D1%7D%5Ec%20P_i%20%5Cboldsymbol%7BS%7D_i%3D%5Csum_%7Bi%3D1%7D%5Ec%20P_i%20%5Cfrac%7B1%7D%7B%5Cmathrm%7Bn%7D_%7B%5Cmathrm%7Bi%7D%7D%7D%20%5Csum_%7Bk%3D1%7D%5E%7Bn_i%7D%5Cleft%28%5Cboldsymbol%7Bx%7D_k%5E%7B(i%29%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5Cleft(%5Cboldsymbol%7Bx%7D_k%5E%7B(i)%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>类间散度矩阵<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_b%3D%5Csum_%7Bi%3D1%7D%5Ec%5Cleft%28%5Cboldsymbol%7Bm%7D_i-%5Cboldsymbol%7Bm%7D%5Cright%29%5Cleft(%5Cboldsymbol%7Bm%7D_i-%5Cboldsymbol%7Bm%7D%5Cright)%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>分类问题</p><ol><li>定义：根据给定的训练集<img src="https://math.now.sh?inline=T%3D%5Cleft%5C%7B%5Cleft%28%5Cboldsymbol%7Bx%7D_1%2C%20y_1%5Cright%29%2C%20%5Ccdots%2C%5Cleft(%5Cboldsymbol%7Bx%7D_l%2C%20y_l%5Cright)%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D_i%20%5Cin%20C%3DR%5En%2C%20%5Cquad%20y_i%20%5Cin%20Y%3D%5C%7B1%2C2%2C%20%5Cldots%2C%20m%5C%7D%2Ci%3D1%2C2%2C%5Cldots%2Cl" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，要求寻找<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的决策函数<img src="https://math.now.sh?inline=g%28%5Cboldsymbol%7Bx%7D%29%3A%20C%20%5Crightarrow%20Y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>评估方法<ol><li>留出法数据集分成两类，交叉验证。</li><li>交叉验证法数据集分成<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类，其中<img src="https://math.now.sh?inline=1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类做测试，<img src="https://math.now.sh?inline=k-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类做训练；进行<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次实验取平均。</li><li>自助法<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次随机取一个样本, 共<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个样本，放入<img src="https://math.now.sh?inline=D%5E%7B'%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中；由<img src="https://math.now.sh?inline=D%5E%7B'%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>训练，<img src="https://math.now.sh?inline=D%2FD%5E%7B'%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>测试。</li></ol></li><li>性能评价<ol><li>错误率与精度：<img src="https://math.now.sh?inline=E%28f%20%3B%20D%29%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5Em%20%5Coperatorname%7BII%7D%5Cleft(f%5Cleft(%5Cboldsymbol%7Bx%7D_i%5Cright)%20%5Cneq%20y_i%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Coperatorname%7Bacc%7D%28f%20%3B%20D%29%3D%5Cfrac%7B1%7D%7Bm%7D%20%5Csum_%7Bi%3D1%7D%5Em%20%5CPi%5Cleft(f%5Cleft(%5Cboldsymbol%7Bx%7D_i%5Cright)%3Dy_i%5Cright)%3D1-E(f%20%3B%20D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>查准率、查全率与F1</li><li>ROC 与AUC</li><li>代价敏感错误率与代价曲线</li></ol></li><li>比较检验<ol><li>假设检验</li><li>交叉验证<img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>检验</li><li>McNemar检验</li><li>Friedman检验与Nemenyi检验</li></ol></li></ol><p>线性分类问题</p><ol><li>线性分类器描述：<ol><li>线性判别函数：<img src="https://math.now.sh?inline=g%28%5Cboldsymbol%7Bx%7D%29%3D%5Csum_i%20%5Cboldsymbol%7Bw%7D_i%20%5Cboldsymbol%7Bx%7D_i%2Bw_0%3D%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%2Bw_0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>分类界为超平面：<img src="https://math.now.sh?inline=g%28%5Cboldsymbol%7Bx%7D%29%3D%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%2Bw_0%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol></li><li>线性分类器的任务：通过已知的训练样本集, 构造线性判别函数</li><li>线性可分性</li></ol><p>线性决策的多分类问题：</p><p><img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类问题，需要至少预先训练多少个二分类器？</p><p>需要训练好<img src="https://math.now.sh?inline=%5Cfrac%7Bk%28k-1%29%7D%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个分类器（所有可能的分类器），然后采用二叉树比对测试。</p><p>根据最大相似性决定类别。</p><h2 id="感知机">感知机</h2><p>基本知识：</p><ol><li>神经网络形成阶段（1943-1958），开拓性的贡献</li><li>线性分类：<ol><li>决策函数：<img src="https://math.now.sh?inline=g%28%5Cboldsymbol%7Bx%7D%29%3D%5Csum_%7Bi%3D1%7D%5Em%20%5Cboldsymbol%7Bw%7D_i%20%5Cboldsymbol%7Bx%7D_i%2Bw_0%3D%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%2Bw_0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>增广表示：<img src="https://math.now.sh?inline=g%28x%29%3D%5Csum_%7Bi%3D0%7D%5Em%20w_i%20x_i%3D%5Cdot%7B%5Cboldsymbol%7Bw%7D%7D%5ET%20%5Cdot%7B%5Cboldsymbol%7Bx%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cdot%7B%5Cboldsymbol%7Bw%7D%7D%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%5Cboldsymbol%7Bw%7D%20%5C%5C%20b%5Cend%7Barray%7D%5Cright%29%2C%20%5Cdot%7B%5Cboldsymbol%7Bx%7D%7D%3D%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%5Cboldsymbol%7Bx%7D%20%5C%5C%201%5Cend%7Barray%7D%5Cright)%2C%20%5Cquad%20%5Cdot%7B%5Cboldsymbol%7Bw%7D%7D%2C%20%5Cdot%7B%5Cboldsymbol%7Bx%7D%7D%20%5Cin%20R%5E%7B(m%2B1)%20%5Ctimes%201%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>决策超平面：<img src="https://math.now.sh?inline=g%28x%29%3D%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%2Bw_0%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>分类判别：根据是否大于0进行判断</li><li>决策函数几何含义：刻画了样本到超平面的距离</li><li>验证函数：<img src="https://math.now.sh?inline=y_i%5Cleft%28%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D_i%2Bw_0%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol></li><li>优化方法：梯度下降<img src="https://math.now.sh?inline=%5Cmin%20_w%20J%28w%29%3D%5Csum_i%20J_i(w)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/><ol><li>随机梯度下降：<img src="https://math.now.sh?inline=w%3Dw-%5Ceta%20%5Cfrac%7B%5Cpartial%20J_i%28w%29%7D%7B%5Cpartial%20w%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol></li></ol><p>感知机结构</p><p><a href="https://imgse.com/i/vz4erd"><img src="https://s1.ax1x.com/2022/09/16/vz4erd.md.png" alt="vz4erd.md.png"></a></p><p>感知机学习准则：目标：最小化<strong>错分样本</strong>的误差代价。</p><p>代价函数（错分样本的误差函数）：<img src="https://math.now.sh?inline=J%28%5Cboldsymbol%7Bw%7D%29%3D%5Csum_%7B%5Cboldsymbol%7Bx%7D(n)%20%5Cin%20E%7D-%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D(n)%20d(n)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（只统计错分的样本，是错分的样本到超平面的距离之和）</p><p><img src="https://math.now.sh?inline=J%28%5Cboldsymbol%7Bw%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的含义：错分样本到分类超平面误差距离的总和</p><p>感知机优化：Batch Perception和Online Perception</p><p>误差修正基本规则：</p><ol><li>固定增量的感知机修正：若训练样本是线性可分，则感知器训练算法在有限次迭代后可以收敛到正确的解向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</li><li>增量自适应调整：当错分样本的正确标签为<img src="https://math.now.sh?inline=d%3D%2B1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，修正<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28n%2B1%29%3D%5Cboldsymbol%7Bw%7D(n)%2B%5Ceta(n)%20%5Cboldsymbol%7Bx%7D(n)_%7B%5Cmid%20x%20%5Cin%20E%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；当错分样本的正确标签为<img src="https://math.now.sh?inline=d%3D-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，修正<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28n%2B1%29%3D%5Cboldsymbol%7Bw%7D(n)-%5Ceta(n)%20%5Cboldsymbol%7Bx%7D(n)_%7B%5Cmid%20x%20%5Cin%20E%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><h2 id="线性鉴别分析">线性鉴别分析</h2><p>基本思想：求线性变换<img src="https://math.now.sh?inline=y%3D%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，使得样本集${x_i} <img src="https://math.now.sh?inline=%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%E6%88%90%E4%B8%80%E7%BB%B4%E5%8F%98%E9%87%8F" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>{y_i} $后，类别间距大，类内间距小。</p><p>目标函数：<img src="https://math.now.sh?inline=%5Cmax%20J%28%5Cboldsymbol%7Bw%7D%29%3D%5Cfrac%7B%5Cleft(%5Cboldsymbol%7Bm%7D_1-%5Cboldsymbol%7Bm%7D_2%5Cright)%5E2%7D%7B%5Cboldsymbol%7BS%7D_1%5E2%2B%5Cboldsymbol%7BS%7D_2%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（<img src="https://math.now.sh?inline=%5Cboldsymbol%7BJ%7D%3D%5Cfrac%7B%E7%B1%BB%E5%88%AB%E9%97%B4%E8%B7%9D%7D%7B%E7%B1%BB%E5%86%85%E7%9A%84%E5%B9%B3%E5%9D%87%E8%B7%9D%E7%A6%BB%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>）</p><p>样本投影后的类别间距离：<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bm%7D_1-%5Cboldsymbol%7Bm%7D_2%29%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ； 其中， <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_%7B%5Cmathrm%7Bi%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 表示第 <img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 类样本投影后的均值</p><p>样本投影后的类别内距离：投影后的各类样本方差<img src="https://math.now.sh?inline=S_1%5E2%2BS_2%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>计算：<img src="https://math.now.sh?inline=%5Cmax%20%5Cmathrm%7BJ%7D%28%5Cboldsymbol%7Bw%7D%29%3D%5Cfrac%7B%5Cleft(%5Cboldsymbol%7Bm%7D_1-%5Cboldsymbol%7Bm%7D_2%5Cright)%5E2%7D%7BS_1%5E2%2BS_2%5E2%7D%3D%5Cfrac%7B%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7BS%7D_b%20%5Cboldsymbol%7Bw%7D%7D%7B%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7BS%7D_w%20%5Cboldsymbol%7Bw%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="logistic-模型">logistic 模型</h2><p>基本思想：假设likelihood ratio的对数为线性判别函数</p><p><img src="https://math.now.sh?inline=%5Clog%20%5Cleft%28%5Cfrac%7Bp%5Cleft(%5Comega_i%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright%29%7D%7Bp%5Cleft(%5Comega_M%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright)%7D%5Cright)%3Dw_%7Bi%2C%200%7D%2B%5Cboldsymbol%7Bw%7D_i%5ET%20%5Cboldsymbol%7Bx%7D%2C%20%5Cquad%20i%3D1%2C2%2C%20%5Cldots%2C%20M-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>两类问题：</p><p><img src="https://math.now.sh?inline=p%5Cleft%28%5Comega_1%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B1%2B%5Cexp(-%5Cleft(w_0%2B%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%5Cright))%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=p%5Cleft%28%5Comega_2%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B1%2B%5Cexp%20%5Cleft(w_0%2B%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%5Cright)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>学习目标：</p><p>标签 <img src="https://math.now.sh?inline=%5Comega_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 类, <img src="https://math.now.sh?inline=p%5Cleft%28%5Comega_1%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 越大, <img src="https://math.now.sh?inline=p%5Cleft%28%5Comega_2%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 越小，标签 <img src="https://math.now.sh?inline=%5Comega_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 类, <img src="https://math.now.sh?inline=p%5Cleft%28%5Comega_2%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 越大, <img src="https://math.now.sh?inline=p%5Cleft%28%5Comega_1%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 越小。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第4章 非线性分类</title>
    <link href="/2022/09/15/UCAS/machine-learning/machine-learning-4/"/>
    <url>/2022/09/15/UCAS/machine-learning/machine-learning-4/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第4章 非线性分类</p><span id="more"></span><h1>第4章 非线性分类</h1><h2 id="概述">概述</h2><p>非线性问题：对于线性不可分数据，采用非线性决策的方法</p><p>线性扩展的思想：线性扩展模型<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bg%28x%29%7D%3D%5Cboldsymbol%7Bw%5ET%5Cvarphi(x)%7D%2Bb" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，核函数方法<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bg%28x%29%7D%3D%5Cboldsymbol%7Bk(x%2Cx_i)%7D%2Bb" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>非线性的思想：最近邻、决策树、神经网络、集成学习</p><h2 id="决策树">决策树</h2><p>决策问题一定是一个二判决问题</p><p>样本根据问题一定可以分成两部分，两部分之间没有交集，两部分的并集包括所有的情况</p><p>决策树的目标：在树结构上，根据节点的判断，搜索类别。</p><p>树结构的优点：可以不必测试所有特征和区域。</p><h3 id="问题数">问题数</h3><ol><li>离散值情况：以特征或特征的可能离散值作为问题：</li></ol><p>设属性<img src="https://math.now.sh?inline=A_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的可能离散取值个数为<img src="https://math.now.sh?inline=n_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li>方法1：每个特征可以作为候选问题，例如ID3、C4.5，属性<img src="https://math.now.sh?inline=A_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>产生的候选问题数为<img src="https://math.now.sh?inline=N_i%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（切分太快，容易过拟合）</li><li>方法2：每个特征的每个离散值作为候选问题，例如CART，属性<img src="https://math.now.sh?inline=A_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>产生的候选问题数为<img src="https://math.now.sh?inline=N_i%3Dn_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><ol start="2"><li>连续值情况：以每个维度的样本特征值作为问题</li></ol><p>属性<img src="https://math.now.sh?inline=A_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上出现的样本特征值个数为<img src="https://math.now.sh?inline=n_%7Bs_i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>方法：每个特征上的样本特征值作为候选问题，属性<img src="https://math.now.sh?inline=A_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>产生的候选问题数为<img src="https://math.now.sh?inline=N_i%3Dn_%7Bs_i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>无论特征值是连续还是离散，确定每个属性所产生的候选问题，候选的问题总数为<img src="https://math.now.sh?inline=N%20%3D%20%5Csum%20N_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="划分（问题）选择">划分（问题）选择</h3><p>非纯度（Impurity Measure）需要满足两条性质：</p><ul><li>IM最大值时，各类别概率相等</li><li>IM最小时为0，只有一类（期望的目标）</li></ul><p>非纯度的熵度量（C4.5）：<img src="https://math.now.sh?inline=I%28D%29%3D-%5Csum_%7Bi%3D1%7D%5E%7Bk%7Dp_ilog(p_i)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>非纯度的基尼度量（CART）：<img src="https://math.now.sh?inline=I%28D%29%3D1-%5Csum_%7Bi%3D1%7D%5E%7Bk%7Dp_i%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>划分目标：选择最大减少类别非纯度的问题作为划分节点。</p><p><img src="https://math.now.sh?inline=%5CDelta%20I%28t%29%3DI(t)-%5Cfrac%7BN_%7BtY%7D%7D%7BN_t%7DI(tY)-%5Cfrac%7BN_%7BtN%7D%7D%7BN_t%7DI(tN)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>基于非纯度变化量的三个指标：</p><ul><li>信息增益（ID3）：越大越好</li><li>增益率（C4.5）：越大越好</li><li>基尼指数：越小越好</li></ul><p>信息增益（熵度量）：<img src="https://math.now.sh?inline=Gain%28D%2Ca%29%3DEntropy(D)-%5Csum_%7Bv%20%5Cin%20Values(A)%7D%20%5Cfrac%7B%7CD%5Ev%7C%7D%7B%7CD%7C%7DEntropy(D%5Ev)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=v" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是问题<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>导致的决策划分数目</p><p><img src="https://math.now.sh?inline=Gain%28D%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>倾向于选择划分集合个数<img src="https://math.now.sh?inline=v" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>多的节点。区间划分的越细，区间内纯度越高，极端情况每个区间只有一个样本，则熵为0。</p><p>增益率（信息增益与数据集<img src="https://math.now.sh?inline=D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>关于问题<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的熵值之比）</p><p><img src="https://math.now.sh?inline=Gini%5C_ratio%28D%2Ca%29%3D%5Cfrac%7BGain(D%2Ca)%7D%7BIV(a)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，<img src="https://math.now.sh?inline=IV%28a%29%3D-%5Csum_%7Bv%3D1%7D%5E%7BV%7D%5Cfrac%7B%7CD%5Ev%7C%7D%7B%7CD%7C%7Dlog(%5Cfrac%7B%7CD%5Ev%7C%7D%7B%7CD%7C%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>增益率改善信息增益：<img src="https://math.now.sh?inline=IV%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对划分集合个数<img src="https://math.now.sh?inline=v" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>少的属性有所偏好，<img src="https://math.now.sh?inline=v" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>越小则<img src="https://math.now.sh?inline=IV%28a%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>越小</p><p>基尼指数（基尼度量）：<img src="https://math.now.sh?inline=Gini%5C_index%28D%2Ca%29%3D%5Csum_%7Bv%3D1%7D%5E%7BV%7D%5Cfrac%7B%7CD%5Ev%7C%7D%7B%7CD%7C%7DGini(D%5Ev)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>节点类别设置：叶子节点纯度达到预设阈值后，停止划分，并对叶子节点进行类别设置。（按概率最大的类别设定）</p><h3 id="决策树生成">决策树生成</h3><p>决策树生成过程</p><p>从顶向下（不断增加一个节点）</p><ul><li>准则：所有划分中选择一个使<img src="https://math.now.sh?inline=%5CDelta%7BI%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（非纯度减少量）最大的划分为节点，加入决策树。</li><li>贪婪学习：根据划分准则，在问题集上进行划分，直到Impurity不能再改善，或达到较小的改善。</li><li>停止规则：设定阈值</li></ul><p>ID3 决策树：属性特征作为结点问题，划分选择实际是特征选择过程，最大化信息增益作为划分选择依据</p><p>C4.5 决策树：属性特征作为结点问题，划分选择实际是特征选择过程，最大化信息增益率作为划分选择依据</p><p>CART 决策树：属性特征离散值作为结点问题，本质是二叉树，最小化基尼指数作为划分选择依据</p><p>连续值二叉决策树</p><h3 id="剪枝处理">剪枝处理</h3><p>ID3、C4.5决策树剪枝</p><ul><li>代价函数</li><li>剪枝算法</li></ul><p>泛化性能评估法</p><h2 id="最近邻方法">最近邻方法</h2><h3 id="最近邻法">最近邻法</h3><p>原理：将样本分类为离之最近的样本类别</p><p><img src="https://math.now.sh?inline=%5Comega_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类判别函数：<img src="https://math.now.sh?inline=g_i%28x%29%3Dmin_%7Bk%7D%7C%7Cx-x_i%5Ek%7C%7C%2Cx_i%5Ek%20%5Cin%20%5Comega_i%2Ck%3D1%2C2%2C%5Ccdots%2CN_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>决策规则：<img src="https://math.now.sh?inline=if%20%5Cquad%20g_j%28x%29%3Dmin_%7Bi%3D1%2C%5Ccdots%2Cc%7Dg_i(x)%2Cthen%20%5Cquad%20x%20%5Cin%20%5Comega_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最近邻分类隐含的决策边界是非线性的</p><h3 id="k-近邻法">k-近邻法</h3><p>原理：将样本分给<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个近邻中类别样本个数最多的类</p><p><img src="https://math.now.sh?inline=k_i%2Ci%3D1%2C%5Ccdots%2Cc" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个近邻中属于<img src="https://math.now.sh?inline=%5Comega_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的样本数</p><p>判别函数：<img src="https://math.now.sh?inline=g_i%28x%29%3Dk_i%2Ci%3D1%2C2%2C%5Ccdots%2Cc" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>决策规则：<img src="https://math.now.sh?inline=if%20%5Cquad%20g_j%28x%29%3Dmax_%7Bi%3D1%2C%5Ccdots%2Cc%7Dk_i%2Cthen%20%5Cquad%20x%20%5Cin%20%5Comega_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>误差讨论</p><p>近邻法的缺点：</p><ul><li>存储量大：训练样本需要存到内存</li><li>计算量大：每次决策都要计算所有样本的相似性</li></ul><h3 id="近邻法的快速算法">近邻法的快速算法</h3><h4 id="快速算法一：快速搜索近邻法（不减少的情况下怎么样才能更快）">快速算法一：快速搜索近邻法（不减少的情况下怎么样才能更快）</h4><p>原理：将样本分成不相交的子集，基于子集的搜索</p><ol><li>样本分级分层为多个子集</li><li>逐层搜出一个最优子集</li><li>在最后的子集中局部找最近样本点</li></ol><p>规则1-找最近子集：如果<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到<img src="https://math.now.sh?inline=S_p" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的距离 &gt; 当前最近子集距离<img src="https://math.now.sh?inline=B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=S_p" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>被忽略。</p><p>规则2-找最近样本：如果<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的距离&gt;已存在的最近点，则样本<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>被忽略。</p><p>k 近邻快速搜索推广：子集搜索过程与最近邻一致，样本搜索时，<img src="https://math.now.sh?inline=B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>存有<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个最近距离值。</p><h4 id="快速算法二：剪辑近邻法">快速算法二：剪辑近邻法</h4><p>原理：通过剪掉边界样本（错误分类样本），缩减样本规模</p><p>剪辑规则：两分剪辑近邻法</p><ul><li>将训练样本集，分成两个子集<img src="https://math.now.sh?inline=A" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li><img src="https://math.now.sh?inline=A" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>做分类参考，对<img src="https://math.now.sh?inline=B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>进行剪辑（错分样本被剪掉）</li><li>剪辑后的<img src="https://math.now.sh?inline=B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>作为最终的训练集训练近邻分类器</li></ul><h4 id="快速算法三：压缩近邻法">快速算法三：压缩近邻法</h4><p>原理：去掉中心附近样本，保留错误样本，<strong>在剪辑基础上进行压缩</strong></p><p>基本思想：分类中通常被正确分类的样本，较少支持决策，将常分误的样本保留。</p><p>压缩规则：</p><ol><li>初始化，训练集分为<img src="https://math.now.sh?inline=S" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=S" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中仅<img src="https://math.now.sh?inline=1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个样本；<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中<img src="https://math.now.sh?inline=N-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个</li><li><img src="https://math.now.sh?inline=S" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>作为训练，分类<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个样本；如果错误，将该样本放入<img src="https://math.now.sh?inline=S" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中</li><li>对每一个样本重复2</li><li>直到<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>无错分样本，或<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为空</li><li>将<img src="https://math.now.sh?inline=G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中样本放弃，<img src="https://math.now.sh?inline=S" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是最终压缩样本集</li></ol><h3 id="拒绝决策近邻法">拒绝决策近邻法</h3><p>原理：对于与各类别相似度较低的样本，不做判断</p><p>优点：在样本压缩时，给<strong>可是可非</strong>的样本机会。</p><ul><li>算法1：可拒绝的k近邻法（分类决策）-k近邻中，各类样本的个数小于<img src="https://math.now.sh?inline=k_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> , 拒绝分类</li><li>算法2：可拒绝的编辑近邻法（样本压缩）-与编辑近邻法比较的不同之处：除保留正确分类样本外，还保留了拒绝样本。</li></ul><h2 id="集成学习">集成学习</h2><h3 id="结合策略">结合策略</h3><p>原理：不同的分类器对样本有不同的鉴别力；综合优势，使错误率最小。</p><p>问题描述：已知一组训练分类器，分类器的类别后验为<img src="https://math.now.sh?inline=P_j%28%5Comega_i%7Cx%29%2Ci%3D1%2C2%2C%5Ccdots%2CM%2Cj%3D1%2C2%2C%5Ccdots%2CL" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为索引类别，<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为索引分类器.</p><p>目标是对<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>进行分类，求<img src="https://math.now.sh?inline=P%28%5Comega_i%7Cx%29%2Ci%3D1%2C2%2C%5Ccdots%2CM" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>概率分布相似性的计算：</p><ol><li>期望之间的相似度：<img src="https://math.now.sh?inline=%5Csum_i%5Csqrt%7C%7Cp_i-q_i%7C%7C%5EP" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>在每个维度上的log比值：<img src="https://math.now.sh?inline=%5Csum_iq_iln%5Cfrac%7Bp_i%7D%7Bq_i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5Csum_iq_iln%5Cfrac%7Bq_i%7D%7Bp_i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>内积运算：<img src="https://math.now.sh?inline=%5Csum_ip_iq_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><h3 id="几种集成学习准则">几种集成学习准则</h3><p>Geometric Average Rule</p><ul><li>目标函数：最小化KL平均</li><li>集成方法：<img src="https://math.now.sh?inline=P%28%5Comega_i%7Cx%29%3D%5CPi_%7Bj%3D1%7D%5EL(P_j(%5Comega_i%7Cx))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>决策规则：<img src="https://math.now.sh?inline=max_%7B%5Comega_i%7D%5CPi_%7Bj%3D1%7D%5ELP_j%28%5Comega_i%7Cx%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>Arithmetic Average Rule</p><ul><li>目标函数：最小化Alternative KL平均</li><li>集成方法：<img src="https://math.now.sh?inline=P%28%5Comega_i%7Cx%29%3D%5Csum_%7Bj%3D1%7D%5EL(P_j(%5Comega_i%7Cx))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>决策规则：<img src="https://math.now.sh?inline=max_%7B%5Comega_i%7D%5Csum_%7Bj%3D1%7D%5ELP_j%28%5Comega_i%7Cx%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>Majority Voting Rule</p><ul><li>原理：对两类问题，多个分类器进行决策投票，票数过半的类别为样本最终标签。</li><li>基分类器要求相互独立且正确率p&gt;50%，且最好具有多样性</li></ul><h3 id="Bagging和随机森林">Bagging和随机森林</h3><p>Bagging：通过随机采样，训练分类器，保证分类器的差异。从训练集中不断随机抽取样本构造分类器，分类时通过投票进行类别判断。</p><p>随机森林：多决策树的Bagging；决策树随机属性选择；从训练集中不断随机构造决策树分类器，分类时通过投票进行类别判断。</p><p>随机森林较一般Bagging效果好</p><h3 id="Boosting-AdaBoost">Boosting: AdaBoost</h3><p>Boosting原理：一系列弱分类器，在不同子集上学习，得到增强分类器。</p><p>AdaBoost加权分类器</p><p>AdaBoost 目标函数</p><h2 id="非线性SVM">非线性SVM</h2><h3 id="SVM-原理">SVM 原理</h3><p>两个核心思想</p><ul><li>最大间隔：找到最大间隔分类超平面；</li><li>核函数方法：样本升维映射到高维空间后，采用线性决策。升维映射由核技巧实现。</li></ul><h4 id="数学问题">数学问题</h4><p>KKT：任何目标函数有解的充要条件</p><p>一个原始问题总有它的对偶问题</p><p>对于特殊的凸优化来说，原始问题<img src="https://math.now.sh?inline=f%28w%2Cb%2Cx%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的对偶问题是<img src="https://math.now.sh?inline=g%28%5Calpha%2Cx%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，两个函数的极值相等，也就是最优解是相等的</p><p>如果原始问题和它的对偶问题都满足KKT条件，对于条件好的凸优化，可以构造<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=w%2Cb" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的关系，从而将不好求解的原始问题转化为好求的对偶问题</p><h3 id="最大间隔">最大间隔</h3><p>目标：找到最大间隔分类超平面（类别集合到分类超平面的最小距离最大化）</p><p>函数间隔：给定的训练数据集<img src="https://math.now.sh?inline=%5Cboldsymbol%7BT%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和超平面<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bw%7D%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li>超平面<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bw%7D%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>关于样本<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bx_i%7D%2Cy_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的函数间隔定义为<img src="https://math.now.sh?inline=%5Chat%7B%5Cgamma_i%7D%3Dy_i%28%5Cboldsymbol%7Bw%20%5Ccdot%20x_i%7D%2Bb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>超平面<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bw%7D%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>关于训练数据集<img src="https://math.now.sh?inline=%5Cboldsymbol%7BT%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的函数间隔定义为<img src="https://math.now.sh?inline=%5Chat%7B%5Cgamma%7D%3Dmin_%7Bi%3D1%2C%5Ccdots%2CN%7D%5Cgamma_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即所有样本点<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bx_i%7D%2Cy_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的函数间隔的最小值。</li><li>存在问题：只要成比例的改变<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，函数间隔会相应变化。</li></ul><p>几何间隔：给定的训练数据集<img src="https://math.now.sh?inline=%5Cboldsymbol%7BT%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和超平面<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bw%7D%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li>超平面<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bw%7D%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>关于样本<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bx_i%7D%2Cy_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的几何间隔定义为<img src="https://math.now.sh?inline=%5Cgamma_i%3Dy_i%28%5Cboldsymbol%7B%5Cfrac%7Bw%7D%7B%7C%7Cw%7C%7C%7D%20%5Ccdot%20x_i%7D%2B%5Cfrac%7Bb%7D%7B%7C%7C%5Cboldsymbol%7Bw%7D%7C%7C%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>超平面<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bw%7D%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>关于训练数据集<img src="https://math.now.sh?inline=%5Cboldsymbol%7BT%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的几何间隔定义为<img src="https://math.now.sh?inline=%5Cgamma%3Dmin_%7Bi%3D1%2C%5Ccdots%2CN%7D%5Cgamma_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即所有样本点<img src="https://math.now.sh?inline=%28%5Cboldsymbol%7Bx_i%7D%2Cy_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的几何间隔的最小值。</li><li>成比例的改变<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，几何间隔不会相应变化。</li></ul><p>最大几何间隔等价的问题：<img src="https://math.now.sh?inline=min_%7Bw%2Cb%7D%5Cfrac%7B1%7D%7B2%7D%7C%7C%5Cboldsymbol%7Bw%7D%7C%7C%5E2%2C%20s.t.%5Cquad%20y_i%28%5Cboldsymbol%7Bw%20%5Ccdot%20x_i%7D%2Bb%29-1%E2%89%A50%2Ci%3D1%2C2%2C%5Ccdots%2CN" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>函数间隔<img src="https://math.now.sh?inline=%5Chat%7B%5Cgamma%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的取值并不影响最优化问题的解。</p><p>支撑向量（SV）：支撑最小距离最大化的样本</p><p>支撑超平面：通过支持向量，平行于分类面的超平面</p><p>间隔：支撑向量到分类面的距离</p><p>支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。</p><h3 id="对偶问题">对偶问题</h3><p><img src="https://math.now.sh?inline=min_%7Bw%2Cb%7DL%28w%2Cb%2C%5Calpha%29%3D-%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5EN%5Csum_%7Bj%3D1%7D%5EN%5Calpha_i%5Calpha_jy_iy_j(x_i%5Ccdot%20x_j)%2B%5Csum_%7Bi%3D1%7D%5EN%5Calpha_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="问题的求解">问题的求解</h3><p>根据KKT条件成立求解</p><h3 id="核函数方法">核函数方法</h3><p>避免直接求非线性映射，由核函数替代内积运算</p><h3 id="SVM-算法">SVM 算法</h3><p>硬间隔SVM</p><p>软间隔SVM</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第13章 链表</title>
    <link href="/2022/09/14/Leetcode/Leetcode-101/Leetcode-101-13/"/>
    <url>/2022/09/14/Leetcode/Leetcode-101/Leetcode-101-13/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第13章 链表</p><span id="more"></span><h1>链表</h1><p>（单）链表是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。</p><h2 id="链表的基本操作">链表的基本操作</h2><h3 id="Leetcode-206">Leetcode 206</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        ListNode* p = <span class="hljs-literal">nullptr</span>;        ListNode* q = head;        <span class="hljs-keyword">while</span>(q)&#123;            ListNode* r = q-&gt;next;            q-&gt;next = p;            p = q;            q = r;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;;</code></pre></div><p>分析：两种方式，迭代法和递归法反转链表。</p><p>错误：算法忘记了，稍稍看了一眼后明白了</p><h3 id="Leetcode-21">Leetcode 21</h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;        ListNode* result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);        ListNode* head = result;        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">if</span>(list1-&gt;val &gt; list2-&gt;val)&#123;                              head-&gt;next = list2;                list2 = list2-&gt;next;            &#125;            <span class="hljs-keyword">else</span>&#123;                head-&gt;next = list1;                list1 = list1-&gt;next;            &#125;            head = head-&gt;next;        &#125;        <span class="hljs-keyword">if</span>(list1 != <span class="hljs-literal">nullptr</span>)&#123;            head-&gt;next = list1;        &#125;        <span class="hljs-keyword">else</span>&#123;            head-&gt;next = list2;        &#125;        <span class="hljs-keyword">return</span> result-&gt;next;    &#125;&#125;;</code></pre></div><p>分析：按照顺序一点一点合并即可，前面设置一个头结点，后面把它扔掉返回。</p><p>错误：链表操作忘记了</p><h3 id="Leetcode-24">Leetcode 24</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);        pre-&gt;next = head;        head = pre;        <span class="hljs-keyword">while</span>(pre-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; pre-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;            ListNode* p = pre-&gt;next;            ListNode* q = p-&gt;next;            pre-&gt;next = q;            p-&gt;next = q-&gt;next;            q-&gt;next = p;            pre = p;        &#125;        <span class="hljs-keyword">return</span> head-&gt;next;    &#125;&#125;;</code></pre></div><p>分析：链表操作</p><p>错误：已经不熟练了，不知道什么时候加结点什么的。</p><h2 id="其它链表技巧">其它链表技巧</h2><h3 id="Leetcode-160">Leetcode 160</h3><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;        <span class="hljs-keyword">if</span>(headA == <span class="hljs-literal">nullptr</span> || headB == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;        ListNode* pa = headA;        ListNode* pb = headB;        <span class="hljs-keyword">while</span>(pa != pb)&#123;            <span class="hljs-keyword">if</span>(pa == <span class="hljs-literal">nullptr</span>)&#123;                pa = headB;                pb = pb-&gt;next;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pb == <span class="hljs-literal">nullptr</span>)&#123;                pb = headA;                pa = pa-&gt;next;            &#125;            <span class="hljs-keyword">else</span>&#123;                pa = pa-&gt;next;                pb = pb-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">return</span> pa;    &#125;&#125;;</code></pre></div><p>分析：当链表headA和headB都不为空时，创建两个指针pA和pB，初始时分别指向两个链表的头节点headA和headB，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：每步操作需要同时更新指针pA和pB。如果指针pA不为空，则将指针pA移到下一个节点；如果指针 pB不为空，则将指针pB移到下一个节点。如果指针pA为空，则将指针pA移到链表headB的头节点；如果指针pB为空，则将指针pB移到链表headA的头节点。当指针pA和pB指向同一个节点或者都为空时，返回它们指向的节点或者null。</p><p>错误：不会做</p><h3 id="Leetcode-234">Leetcode 234</h3><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; vt;        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">nullptr</span>)&#123;            vt.<span class="hljs-built_in">push_back</span>(head-&gt;val);            head = head-&gt;next;        &#125;        <span class="hljs-type">int</span> n = vt.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n/<span class="hljs-number">2</span>;++i)&#123;            <span class="hljs-keyword">if</span>(vt[i] != vt[n-i<span class="hljs-number">-1</span>])&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre></div><p>分析：复制到数组中判断</p><p>一遍AC</p><h2 id="练习">练习</h2><h3 id="Leetcode-83">Leetcode 83</h3><p>给定一个已排序的链表的头 <code>head</code> ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        ListNode* p = head;        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;        <span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;            ListNode* q = p-&gt;next;            <span class="hljs-keyword">if</span>(p-&gt;val == q-&gt;val)&#123;                p-&gt;next = q-&gt;next;                q = p-&gt;next;            &#125;            <span class="hljs-keyword">else</span>&#123;                q = q-&gt;next;                p = p-&gt;next;            &#125;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;&#125;;</code></pre></div><p>分析：遍历判断即可</p><p>错误：没有考虑链表中没有结点的情况。</p><h3 id="Leetcode-328">Leetcode 328</h3><p>给定单链表的头节点 <code>head</code> ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        ListNode* odd = head;        ListNode* even = head-&gt;next;        ListNode* evenhead = even;        <span class="hljs-keyword">while</span>(even != <span class="hljs-literal">nullptr</span> &amp;&amp; even-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;            odd-&gt;next = even-&gt;next;            even-&gt;next = even-&gt;next-&gt;next;            odd = odd-&gt;next;            even = even-&gt;next;        &#125;        odd-&gt;next = evenhead;        <span class="hljs-keyword">return</span> head;    &#125;&#125;;</code></pre></div><p>分析：单独存储奇偶结点即可。</p><p>错误：还是不熟练</p><h3 id="Leetcode-19">Leetcode 19</h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;        ListNode* p = head;        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">nullptr</span>)&#123;            ++sum;            p = p-&gt;next;        &#125;        p = head;        <span class="hljs-type">int</span> num = sum - n;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> head-&gt;next;        &#125;        ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);        pre-&gt;next = p;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;++i)&#123;            pre = p;            p = p-&gt;next;        &#125;        pre-&gt;next = p-&gt;next;        <span class="hljs-keyword">return</span> head;    &#125;&#125;;</code></pre></div><p>分析：先数一遍一共有多少个结点，然后再遍历一遍删掉即可。</p><p>一遍AC</p><h3 id="Leetcode-148">Leetcode 148</h3><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>)&#123;            <span class="hljs-keyword">return</span> head;        &#125;        vector&lt;<span class="hljs-type">int</span>&gt; result;        ListNode* p = head;        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">nullptr</span>)&#123;            result.<span class="hljs-built_in">push_back</span>(head-&gt;val);            head = head-&gt;next;        &#125;        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(),result.<span class="hljs-built_in">end</span>());        head = p;        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">nullptr</span>)&#123;            head-&gt;val = result[index++];            head = head-&gt;next;        &#125;        <span class="hljs-keyword">return</span> p;    &#125;&#125;;</code></pre></div><p>分析：可以用一些比较高大上的链表排序方法，也可以耍赖，直接读入数组中排序即可。</p><p>一遍AC</p><h2 id="总结">总结</h2><p>链表不难，就是太容易忘记了，后面要经常复习。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第6讲 概率检索模型</title>
    <link href="/2022/09/14/UCAS/information-retrieval/information-retrieval-6/"/>
    <url>/2022/09/14/UCAS/information-retrieval/information-retrieval-6/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第6讲 概率检索模型</p><span id="more"></span><h1>第6讲 概率检索模型</h1><p>向量空间模型的优缺点</p><p>优点：</p><ul><li>简洁直观，可以应用到很多其他领域(文本分类、生物信息学)。</li><li>支持部分匹配和近似匹配，结果可以排序</li><li>检索效果不错</li></ul><p>缺点：</p><ul><li>理论上不够严谨，往往基于直觉的经验性公式</li><li>词项之间的独立性假设与实际不符：实际上，词项的出现之间是有关系的，并不是完全独立的。</li></ul><h2 id="基本概率统计知识">基本概率统计知识</h2><p>检索系统中，给定查询，计算每个文档的相关度</p><p>检索系统对用户查询的理解是非确定的(uncertain)，对返回结果的猜测也是<strong>非确定的</strong></p><p>而概率理论为非确定推理提供了坚实的理论基础，可以计算文档和查询相关的可能性</p><p>概率检索模型是<strong>通过概率的方法将查询和文档联系起来</strong></p><p>定义3个随机变量R、Q、D：相关度R={0,1}，查询Q可以是q1,q2,…中的一个查询，文档D可以是d1,d2,…中的一篇文档，则可以通过计算条件概率P(R=1|Q=q,D=d)来度量文档和查询的相关度。</p><p>概率排序原理(PRP)：</p><ul><li>如果文档按照与查询的相关概率大小返回，那么该返回结果是所有可能获得结果中效果最好的。</li><li>如果文档按照与查询的相关概率大小返回，而这些相关概率又能够基于已知数据进行尽可能精确的估计，那么该返回结果是所有基于已知数据获得的可能的结果中效果最好的。</li></ul><h2 id="Logistic回归模型">Logistic回归模型</h2><p>回归分析：回归分析是处理变量之间相关关系的一种工具，回归的结果可以用于预测或者分类</p><p>一元线性回归：根据观测点，拟合出一条直线，使得某种损失 (如离差平方和)最小</p><p>Logistic回归是一种非线性回归，可以转化成线性回归来实现。</p><p>基本思想：为了求Q和D相关的概率P(R=1|Q,D)，通过定义多个特征函数fi(Q,D)，认为P(R=1|Q,D)是这些函数的组合。</p><p>求解和使用过程：通过训练集合拟和得到相应系数 ，对于新的文档，代入公式计算得到概率P</p><p>优缺点：</p><ul><li>优点：直接引入数学工具，形式简洁。</li><li>缺点：特征选择非常困难，实验中效果一般。<ul><li>以文档为样本(Pointwise)训练模型，无法解决不同查询之间的差异</li></ul></li></ul><h2 id="BIM模型">BIM模型</h2><p>二值独立概率模型</p><p>BIM模型通过贝叶斯公式对所求条件概率P(R=1|Q,D)展开进行计算，是一种生成式(generative)模型</p><p>对每个Q定义排序(Ranking)函数RSV(Q,D)</p><p>其中，P(D|R=1)、P(D|R=0)分别表示在相关和不相关情况下生成文档D的概率。Ranking函数显然是随着P(R=1|D)的增长而增长。</p><p>两种常用的文档生成的总体分布：多元贝努利分布和多项式分布</p><p>BIM中P(D|R=1)或P(D|R=0)的计算：类比M次独立试验</p><p>BIM模型公式的推导：pi qi参数的计算，RSJ权重</p><p>BIM计算过程：目标是求排序函数P(D|R=1)/P(D|R=0)</p><ul><li>首先估计或计算每个term分别在相关文档和不相关文档中的出现概率pi=P(t|R=1)及qi=P(t|R=0)</li><li>然后根据独立性假设，将P(D|R=1)/P(D|R=0) 转化为pi和qi的某种组合，将pi和qi代入即可求解。</li></ul><p>优点：</p><ul><li>BIM模型建立在数学基础上，理论性较强</li></ul><p>缺点：</p><ul><li>需要估计参数</li><li>原始的BIM没有考虑TF、文档长度因素</li><li>BIM中同样存在词项独立性假设</li><li>BIM实质上是一个idf权重公式，仅考虑了全局信息，缺少局部信息。因此需要和TF权重配合使用</li></ul><h2 id="BM25模型">BM25模型</h2><p>二重泊松分布</p><p>泊松分布是一个经典的随机分布：分布公式参数：均值 λ，分布形式随参数取值变化</p><p>关于文本中词频分布的一个经典结论：在高质量精英文档集(Elite Set)中：均值较高，接近正态分布；在整个语料中：均值低，接近指数分布</p><p>优点：</p><ul><li>一定程度上的理论化模型</li><li>基于二重泊松假设——适用于绝大多数文本语料上的IR检索应用</li><li>实验证明有效</li></ul><p>缺点：</p><ul><li>待调参数多且参数敏感性高</li><li>必须去停用词</li></ul><p>BM25被视为现实应用中最好的IR模型之一。即便现在基于BERT预训练语言模型的方法可以获得更好的效果，仍然需要使用BM25进行无监督过滤来保证检索精度。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第3讲 人工神经网络</title>
    <link href="/2022/09/13/UCAS/advanced-ai/advanced-ai-3/"/>
    <url>/2022/09/13/UCAS/advanced-ai/advanced-ai-3/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第3讲 人工神经网络</p><span id="more"></span><h1>第3讲 人工神经网络</h1><p>联结主义学派：又称仿生学派或生理学派</p><ul><li>认为人的思维基元是神经元，而不是符号处理过程</li><li>认为人脑不同于电脑</li></ul><p>核心：智能的本质是联接机制。</p><p>原理：神经网络及神经网络间的连接机制和学习算法</p><h2 id="什么是神经网络">什么是神经网络</h2><ul><li>所谓的人工神经网络就是基于模仿生物大脑的结构和功能而构成的一种信息处理系统（计算机）。</li><li>个体单元相互连接形成多种类型结构的图<ul><li>循环、非循环</li><li>有向、无向</li></ul></li><li>自底向上（Bottom-Up）AI<ul><li>起源于生物神经系统</li><li>从结构模拟到功能模拟</li></ul></li></ul><h2 id="发展历史">发展历史</h2><ul><li>1940年代<ul><li>心理学家McCulloch和数学家Pitts建立了阈值加权和模型(1943)</li><li>心理学家Hebb提出神经元之间突触联系是可变(可学习)的假说——Hebb学习律(1949)</li></ul></li><li>1950年代、1960年代<ul><li>提出并完善了单级感知器(Perceptron)</li><li>代表性人物：Marvin Minsky，Frank Rosenblatt，Bernard Widrow</li></ul></li><li>1980年代<ul><li>J.Hopfield提出Hopfield网络(1984)</li><li>Hinton、Sejnowsky、Rumelhart等人提出了著名的Boltzmann机(1985)</li><li>Rumelhart等提出多层网络的学习算法—BP算法(1986)</li></ul></li><li>2000年代<ul><li>Hinton et al. Deep Neural Networks (2007)</li></ul></li></ul><h2 id="生物学启示">生物学启示</h2><p>生物神经元</p><ul><li>神经元组成：细胞体，轴突，树突，突触</li><li>神经元之间通过突触两两相连。信息的传递发生在突触。</li><li>突触记录了神经元间联系的强弱。</li><li>只有达到一定的兴奋程度，神经元才向外界传输信息。</li></ul><p>神经元特性</p><ul><li>信息以预知的确定方向传递：一个神经元的树突－细胞体－轴突－突触－另一个神经元树突</li><li>时空整合性<ul><li>对不同时间通过同一突触传入的信息具有时间整合功能</li><li>对同一时间通过不同突触传入的信息具有空间整合功能</li></ul></li></ul><p>工作状态</p><ul><li>兴奋状态，对输入信息整合后使细胞膜电位升高，当高于动作电位的阈值时，产生神经冲动，并由轴突输出。</li><li>抑制状态，对输入信息整合后使细胞膜电位降低，当低于动作电位的阈值时，无神经冲动产生。</li></ul><p>结构的可塑性：神经元之间的柔性连接：突触的信息传递特性是可变的——<strong>学习记忆的基础</strong></p><h3 id="神经元模型">神经元模型</h3><p>从生物学结构到数学模型</p><p>人工神经元</p><p><a href="https://imgse.com/i/vxtgc4"><img src="https://s1.ax1x.com/2022/09/15/vxtgc4.md.png" alt="vxtgc4.md.png"></a></p><p><img src="https://math.now.sh?inline=y%3Df%28%5Cxi%29%3Df(g(X))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=f" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为激活函数，<img src="https://math.now.sh?inline=g" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为组合函数</p><p>组合函数：</p><p>权重和：<img src="https://math.now.sh?inline=%5Cxi%3Dg%28X%29%3D%5Csum_%7Bi%3D1%7D%5En%20%5Comega_i%20x_i-%5Ctheta" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=y%3Df%28%5Cxi%29%3Df(%5Csum_%7Bi%3D1%7D%5En%20%5Comega_i%20x_i-%5Ctheta)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>➡<img src="https://math.now.sh?inline=y%3Df%28%5Cxi%29%3Df(%5Csum_%7Bi%3D0%7D%5En%20%5Comega_i%20x_i)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>径向距离：<img src="https://math.now.sh?inline=%5Cxi%3D%5C%7C%5Cboldsymbol%7BX%7D-%5Cboldsymbol%7BC%7D%5C%7C%3D%5Csqrt%7B%5Csum_%7Bi%3D1%7D%5En%5Cleft%28x_i-c_i%5Cright%29%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=y%3Df%28%5Cxi%29%3Df%5Cleft(%5Csqrt%7B%5Csum_%7Bi%3D1%7D%5En%5Cleft(x_i-c%5Cright)%5E2%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>激活函数</p><p><a href="https://imgse.com/i/vxtH3D"><img src="https://s1.ax1x.com/2022/09/15/vxtH3D.md.png" alt="vxtH3D.md.png"></a></p><h2 id="人工神经网络（ANN）">人工神经网络（ANN）</h2><ul><li>多个人工神经元按照特定的网络结构联接在一起，就构成了一个人工神经网络。</li><li>神经网络的目标就是将输入转换成有意义的输出。</li></ul><p>生物系统中的学习：</p><ul><li>自适应学习：适应的目标是基于对环境信息的响应获得更好的状态</li><li>在神经层面上，通过突触强度的改变实现学习：消除某些突触，建立一些新的突触</li><li>Hebb学习律：神经元同时激活，突触强度增加，异步激活，突触强度减弱</li><li>学习律符合能量最小原则：保持突触强度需要能量，所以在需要的地方保持，在不需要的地方不保持。</li></ul><p>ANN的学习规则：<strong>能量最小</strong></p><p>对人工神经网络，需要确定合适的能量定义；可以使用数学上的优化技术来发现如何改变神经元间的联接权重。</p><p><strong>两个主要问题：结构和学习方法</strong></p><p>ANN结构</p><ul><li>前馈结构：没有循环，静态的</li><li>反馈/循环结构：有循环，动态的</li></ul><p>ANN的学习方法：通过神经网络所在环境的模拟过程，调整网络中的自由参数。</p><p>学习策略：Error Correction：最小化实际输出与期望输出之间的误差，属于监督学习。</p><h2 id="多层感知机">多层感知机</h2><p><a href="https://imgse.com/i/vzp70x"><img src="https://s1.ax1x.com/2022/09/15/vzp70x.md.png" alt="vzp70x.md.png"></a></p><p>感知机实质上是一种神经元模型</p><p>阈值激活函数：<img src="https://math.now.sh?inline=v%3D%5Csum_i%7B%5Comega_i%5Ccdot%20x_i%7D%2Cy%3Df%28v%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>判别规则：</p><p>输入空间中</p><ul><li>样本是空间中的一个点</li><li>权向量是一个超平面</li><li>超平面一边对应<img src="https://math.now.sh?inline=Y%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，另一边对应<img src="https://math.now.sh?inline=Y%3D-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>单层感知机学习：用现在的权重进行分类，如果分类正确，权重不改变；如果分类错误，用分类错误的样本调整权重<img src="https://math.now.sh?inline=%5Comega%3D%5Comega%2By%5E*%20%5Ccdot%20x%2Cy%5E*%20%5Cin%20%5C%7B-1%2C1%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>感知机收敛定理：若训练数据集是线性可分的，则感知机模型收敛。</p><p>感知机存在的问题：如果存在噪声，或样本不是线性可分的，不会收敛。（例如不能处理异或操作），且泛化性比较差。</p><p>多层感知机：三层可以学习全部连续的函数，四层就可以学习全部的函数。层间神经元全连接，层内神经元不连接。</p><p>学习方法：反向传播</p><ul><li>输入数据从输入层经过隐藏层传递到输出层<img src="https://math.now.sh?inline=y_j%5E%7B'%7D%3D%5Csigma%7B%28%5Csum%5Comega_%7Bkj%7Dx_k%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>误差信息从输出层反向传播，通过隐藏层传递到输入层<img src="https://math.now.sh?inline=y_j%3D%5Csigma%7B%28%5Csum%5Comega_%7Bji%7Dy_j%5E%7B'%7D%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>全局误差度量：（最小平方误差）<img src="https://math.now.sh?inline=e%28%5Comega%29%3D%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%5Bd_%7Bi%7D-y_%7Bi%7D%5E%7B%5Cprime%7D%5Cright%5D%5E%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>权值更新规则采用梯度下降的方法：<img src="https://math.now.sh?inline=%5Comega%3D%5Comega-%5Ceta%20%5Cfrac%7B%5Cpartial%20e%7D%7B%5Cpartial%20%5Comega%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><a href="https://imgse.com/i/vzCYi8"><img src="https://s1.ax1x.com/2022/09/15/vzCYi8.md.png" alt="vzCYi8.md.png"></a></p><p><a href="https://imgse.com/i/vzCtJS"><img src="https://s1.ax1x.com/2022/09/15/vzCtJS.md.png" alt="vzCtJS.md.png"></a></p><p><a href="https://imgse.com/i/vzCdMj"><img src="https://s1.ax1x.com/2022/09/15/vzCdMj.md.png" alt="vzCdMj.md.png"></a></p><p><a href="https://imgse.com/i/vzCwss"><img src="https://s1.ax1x.com/2022/09/15/vzCwss.md.png" alt="vzCwss.md.png"></a></p><p>误差反向传播：</p><p><a href="https://imgse.com/i/vzC0Ln"><img src="https://s1.ax1x.com/2022/09/15/vzC0Ln.md.png" alt="vzC0Ln.md.png"></a></p><p>实际应用中要对数据进行归一化，并且选择合适的学习率</p><p>优点：</p><ul><li>很强的表达能力</li><li>容易执行</li></ul><p>缺点：</p><ul><li>收敛速度慢（采用Newton法）</li><li>过拟合（Over-fitting）（加正则化项，约束权值的平滑性；采用更少（但足够数量）的隐层神经元）</li><li>局部极小（尝试不同的初始化，增加扰动）</li></ul><p>多层感知机解决了一般性学习问题，并且与生物系统相联系。</p><p>层数增加使用BP算法会存在<strong>梯度消失</strong>的问题：在后面的几层，误差反向传播后可能变得非常小，权重不太好更新。</p><p>采用sigmoid函数，多个相乘使得传递过来的残差会越来越小。</p><h2 id="深度学习">深度学习</h2><p>时代背景：数据爆炸、计算性能提升</p><p>传统机器学习解决问题的思路：</p><ul><li>良好的特征表达，对最终算法的准确性起了非常关键的作用，而且系统主要的计算和测试工作都耗在这一大部分。</li><li>但实际中一般都是人工完成的。</li></ul><p>使用深度学习去自动学习特征！</p><p>人脑视觉机理</p><ul><li>“视觉系统的信息处理”：可视皮层是分级的</li><li>神经-中枢-大脑的工作过程，或许是一个不断迭代、不断抽象的过程。</li><li><strong>关键词：一个是抽象，一个是迭代。</strong></li><li>从原始信号，做低级抽象，逐渐向高级抽象迭代。人类的逻辑思维，经常使用高度抽象的概念。</li></ul><p>为什么使用深度学习？</p><ul><li>深层结构能够有效被表达<ul><li>对相同的函数需要更少的计算单元</li><li>深层网络结构中，高层可以综合应用低层信息</li></ul></li><li>深层结构可产生层次化特征表达<ul><li>可解释性，更具有语义化信息</li></ul></li><li>多层隐变量允许统计上的组合共享</li><li>深层结构有效（vision, audio, NLP等）！</li></ul><p>深层 vs 浅层神经网络</p><ul><li>多隐层的人工神经网络具有优异的特征学习能力，学习得到的特征对数据有更本质的刻画，从而有利于可视化或分类<ul><li>深层网络结构中，高层可以综合应用低层信息</li><li>低层关注“局部”，高层关注“全局”、更具有语义化</li></ul></li><li>“深度模型”是手段，“特征学习”是目的。<ul><li>强调了模型结构的深度，通常有5层、6层，甚至10多层的隐层节点；</li><li>明确突出了特征学习的重要性，也就是说，通过逐层特征变换，将样本在原空间的特征表示变换到一个新特征空间，从而使分类或预测更加容易。</li></ul></li><li>与人工规则构造特征的方法相比，利用大数据来学习特征，更能够刻画数据的丰富内在信息。</li></ul><p>BP算法的问题：</p><ul><li>需要带标签训练数据<ul><li>几乎所有的数据是无标签的</li><li>人脑可以从无标签数据中学习</li></ul></li><li>局部极小<ul><li>对深层网络远离了最优解</li></ul></li><li>梯度消失</li></ul><p>Deep learning训练：</p><p>自下向上的非监督学习（greedy layer-wise training）</p><ul><li>把网络逐层进行预训练，或者找一个足够好的初始权重。</li></ul><p>自顶向下的监督学习</p><ul><li>就是通过带标签的数据去训练，误差自顶向下传输，对网络进行微调</li><li>微调特征（中间层），使得与问题更相关。</li></ul><p>对输入的结构建模：建立产生输入的生成式模型，调整参数使得生成式模型的概率最大。</p><h2 id="Deep-Learning的常用模型">Deep Learning的常用模型</h2><h3 id="AutoEncoder自动编码器">AutoEncoder自动编码器</h3><p>学习过程：无标签数据，用非监督学习学习特征</p><ul><li>将input输入一个encoder编码器，就会得到一个code，这个code也就是输入的一个表示</li><li>增加一个decoder解码器</li><li>通过调整encoder和decoder的参数，使得重构误差最小，这样就得到输入input信号的一个表示了，也就是编码code。</li><li>输入无标签数据，误差的来源就是直接重构后与原输入相比得到。</li></ul><p>利用人工神经网络本身的层次结构特点</p><ul><li>如果给定一个神经网络，假设其输出与输入是相同的，然后训练调整其参数，得到每一层中的权重。</li><li>自然地，就得到了输入I的几种不同表示（每一层代表一种表示），这些表示就是特征。</li></ul><p>自动编码器就是一种尽可能复现输入信号的神经网络。</p><p>为了实现这种复现，自动编码器就必须捕捉可以代表输入数据的最重要的因素</p><p>网络结构</p><ul><li>三层结构：输入层，隐藏层，输出层</li><li>限定神经元的数量<ul><li>输入层神经元数=输出层神经元数</li><li>隐层神经元数量&lt;输入层神经元数量</li><li>意义：迫使隐藏层节点学习得到输入数据的压缩表示方法</li></ul></li></ul><p>自动编码器可以只训练单组参数，不需要关心另一半的参数。</p><p>Deep结构——逐层训练</p><ul><li>自编码器“栈化”</li><li>通过编码器产生特征，然后训练下一层。得到第一层的code，重构误差最小让我们相信这个code就是原输入信号的良好表达了，或者牵<br>强点说，它和原信号是一模一样的（表达不一样，反映的是一个东西）。将第一层输出的code当成第二层的输入信号，同样最小化重构误差，就会得到第二层的参数，并且得到第二层输入的code，也就是原输入信息的第二个表达了。其他层也以同样的方法进行。</li></ul><p>监督学习</p><ul><li>Deep结构，每一层都会得到原始输入的不同层次的表达。</li><li>有监督微调<ul><li>为了实现分类，可以在AutoEncoder的最顶的编码层添加一个分类器（例如Logistic回归、SVM等），然后通过标准的多层神经网络的监督训练方法（梯度下降法）去训练。</li></ul></li><li>最后层的特征code输入到分类器中，基于有标签样本，通过监督学习对网络进行微调<ul><li>只调整分类器</li><li>通过有标签样本，微调整个系统</li></ul></li></ul><p>两隐层自编码网络MNIST手写数字识别：</p><p>训练一个包含两个隐含层的栈式自编码网络，用来进行MNIST手写数字分类</p><ol><li>用原始输入<img src="https://math.now.sh?inline=x%28k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>训练第一个自编码器，学习得到原始输入的一阶特征表示<img src="https://math.now.sh?inline=h%281%29(k)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>把上一层的一阶特征作为另一个稀疏自编码器的输入，使用它们来学习二阶特征<img src="https://math.now.sh?inline=h%282%29(k)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>将二阶特征作为softmax分类器的输入，训练得到一个能将二阶特征映射到数字标签的模型</li><li>将这三层结合起来构成一个栈式自编码网络，通过反向传播算法(BP)同时调整所有层的参数以改善学习结果(称为整体微调finetuning)</li></ol><p>栈式自编码器神经网络</p><ul><li>栈式自编码神经网络具有强大的表达能力及深度神经网络的所有优点。</li><li>通常能够获取到输入的“层次型分组”或者“部分-整体分解”结构。<ul><li>学习方式：前层的输出作为下一层输入的方式依次训练。</li><li>如果网络的输入数据是图像，网络的第一层会学习如何去识别边，第二层一般会学习如何去组合边，从而构成轮廓、角等。更高层会学习如何去组合更形象且有意义的特征。</li><li>如果输入数据集包含人脸图像，更高层会学习如何识别或组合眼睛、鼻子、嘴等人脸器官。</li></ul></li></ul><h3 id="Deep-Belief-Networks-DBN-和Deep-Boltzmann-Machine-DBM">Deep Belief Networks(DBN)和Deep Boltzmann Machine(DBM)</h3><p>Hopfield Network</p><p>结构：</p><ul><li>单层全互连、对称权值的反馈网络</li><li>状态：-1(0)，+1</li></ul><p><a href="https://imgse.com/i/vzFHYV"><img src="https://s1.ax1x.com/2022/09/15/vzFHYV.png" alt="vzFHYV.png"></a></p><p>Hopfield网络按动力学方式运行，其工作过程为状态的演化过程，即从初始状态按能量减小的方向进行演化，直到达到稳定状态。稳定状态即为网络的输出。</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=E%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Csum_%7Bi%3D0%7D%5E%7Bn%7D%20%5Csum_%7Bj%3D0%7D%5E%7Bn%7D%20%5Comega_%7Bi%20j%7D%20s_%7Bi%7D%20s_%7Bj%7D%3D-%5Cfrac%7B1%7D%7B2%7D%20%5Cboldsymbol%7BS%7D%5E%7BT%7D%20%5Cboldsymbol%7B%5Comega%7D%20%5Cboldsymbol%7BS%7D%0A" /></p><p>二值随机神经元(Bernoulli variables)：以一定的概率产生1</p><p style="transform:box-shadow:unset;border-radius:0px;"><img src="https://math.now.sh?from=p%5Cleft%28s_%7Bi%7D%3D1%5Cright%29%3D%5Cfrac%7B1%7D%7B1%2B%5Cexp%20%5Cleft(%5Cleft(-b_%7Bi%7D-%5Csum_%7Bj%7D%20s_%7Bj%7D%20w_%7Bj%20i%7D%5Cright)%20%2F%20T%5Cright)%7D%0A" /></p><p>波尔兹曼机(Boltzmann Machine)：</p><ul><li>结构类似于Hopfield 网络，但它是具有隐单元的反馈互联网络</li><li>遵循波尔兹曼分布，学习数据的固有内在表示。</li><li>结构：一个可见层+一个隐层，<strong>层内有连接</strong></li></ul><p>BM基本原理：<img src="https://math.now.sh?inline=%5Cfrac%7BP_%7B%5Calpha%7D%7D%7BP_%7B%5Cbeta%7D%7D%3D%5Cexp%20%5Cleft%28-%5Cleft(E%5Cleft(S%5E%7B%5Calpha%7D%5Cright%29-E%5Cleft(S%5E%7B%5Cbeta%7D%5Cright)%5Cright)%20%2F%20T%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ol><li>Hopfield网络的神经元的结构功能及其在网络中的地位是一样的。但BM中一部分神经元与外部相连,可以起到网络的输入、输出功能,或者严格地说可以受到外部条件的约束。另一部分神经元则不与外部相连，因而属于隐单元</li><li>每个神经元只取1或0这两种状态：状态1代表该神经元处于接通状态，状态0代表该神经元处于断开状态</li></ol><p>缺点：网络结构复杂、训练代价大、局部极小</p><p>受限波尔兹曼机(Restricted Boltzmann Machines)：</p><ul><li>通过输入数据集学习概率分布的随机生成神经网络</li><li>结构：一个可见层+一个隐层，<strong>层内无连接</strong></li><li>RBM中，隐单元在给定可视单元情况下，条件独立</li></ul><p>Deep Belief Networks：</p><ul><li>概率生成模型</li><li>深层结构——多层</li><li>非监督的预学习提供了网络好的初始化</li><li>监督微调(fine-tuning)</li></ul><p>Deep Boltzmann Machines：</p><ul><li>所有层间无向连接<ul><li>同层神经元间无连接</li></ul></li><li>高层表示由无标注数据建立</li><li>标注数据仅用来微调网络</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第12章 字符串</title>
    <link href="/2022/09/13/Leetcode/Leetcode-101/Leetcode-101-12/"/>
    <url>/2022/09/13/Leetcode/Leetcode-101/Leetcode-101-12/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第12章 字符串</p><span id="more"></span><h1>字符串</h1><h2 id="字符串比较">字符串比较</h2><h3 id="Leetcode-242">Leetcode 242</h3><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。<strong>注意：</strong> 若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code>互为字母异位词。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());        <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(),t.<span class="hljs-built_in">end</span>());        <span class="hljs-keyword">if</span>(s == t)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>分析：哈希表或者直接排序</p><p>一遍AC</p><h3 id="Leetcode-205">Leetcode 205</h3><p>给定两个字符串 <code>s</code> 和 <code>t</code> ，判断它们是否是同构的。如果 <code>s</code> 中的字符可以按某种映射关系替换得到 <code>t</code> ，那么这两个字符串是同构的。每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(string s, string t)</span> </span>&#123;        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; mp1;        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; mp2;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)&#123;            <span class="hljs-keyword">if</span>(mp<span class="hljs-number">1.f</span>ind(s[i]) == mp<span class="hljs-number">1.</span><span class="hljs-built_in">cend</span>())&#123;                mp1[s[i]] = t[i];            &#125;            <span class="hljs-keyword">if</span>(mp<span class="hljs-number">2.f</span>ind(t[i]) == mp<span class="hljs-number">2.</span><span class="hljs-built_in">cend</span>())&#123;                mp2[t[i]] = s[i];            &#125;            <span class="hljs-keyword">if</span>(mp1[s[i]] != t[i] || mp2[t[i]] != s[i])&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre></div><p>分析：通过字典比较即可</p><p>错误：开始想用统计的方法去做，后面用字符字典的方式也有一些小错误，应该是比较两遍的。</p><h3 id="Leetcode-647">Leetcode 647</h3><p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。<strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。<strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countSubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">int</span> countsum = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            countsum += <span class="hljs-number">1</span>;            <span class="hljs-type">int</span> leftindex = i<span class="hljs-number">-1</span>;            <span class="hljs-type">int</span> rightindex = i<span class="hljs-number">+1</span>;            <span class="hljs-keyword">while</span>(leftindex &gt;= <span class="hljs-number">0</span> &amp;&amp; rightindex &lt; n &amp;&amp; s[leftindex] == s[rightindex])&#123;                ++countsum;                --leftindex;                ++rightindex;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)&#123;            <span class="hljs-keyword">if</span>(s[i] == s[i<span class="hljs-number">+1</span>])&#123;                ++countsum;                <span class="hljs-type">int</span> leftindex = i<span class="hljs-number">-1</span>;                <span class="hljs-type">int</span> rightindex = i<span class="hljs-number">+2</span>;                <span class="hljs-keyword">while</span>(leftindex &gt;= <span class="hljs-number">0</span> &amp;&amp; rightindex &lt; n &amp;&amp; s[leftindex] == s[rightindex])&#123;                    ++countsum;                    --leftindex;                    ++rightindex;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> countsum;    &#125;&#125;;</code></pre></div><p>分析：遍历扩展即可，注意分两种情况讨论一下</p><p>一遍AC</p><h3 id="Leetcode-696">Leetcode 696</h3><p>给定一个字符串 <code>s</code>，统计并返回具有相同数量 <code>0</code> 和 <code>1</code> 的非空（连续）子字符串的数量，并且这些子字符串中的所有 <code>0</code> 和所有 <code>1</code> 都是成组连续的。重复出现（不同位置）的子串也要统计它们出现的次数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countBinarySubstrings</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> countsum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)&#123;            <span class="hljs-keyword">if</span>(s[i] != s[i<span class="hljs-number">+1</span>])&#123;                ++countsum;                <span class="hljs-type">int</span> leftindex = i<span class="hljs-number">-1</span>;                <span class="hljs-type">int</span> rightindex = i<span class="hljs-number">+2</span>;                <span class="hljs-keyword">while</span>(leftindex &gt;= <span class="hljs-number">0</span> &amp;&amp; rightindex &lt; n &amp;&amp; s[leftindex] == s[leftindex<span class="hljs-number">+1</span>] &amp;&amp; s[rightindex] == s[rightindex<span class="hljs-number">-1</span>])&#123;                    ++countsum;                    --leftindex;                    ++rightindex;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> countsum;    &#125;&#125;;</code></pre></div><p>分析：和上一道题目相同，甚至只考虑一种情况就可以了，比上一道题目还要简单一点。</p><p>一遍AC</p><h2 id="字符串理解">字符串理解</h2><h3 id="Leetcode-227">Leetcode 227</h3><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; stk;        <span class="hljs-type">char</span> preSign = <span class="hljs-string">&#x27;+&#x27;</span>;        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) &#123;                num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);            &#125;            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span> || i == n - <span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">switch</span> (preSign) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:                        stk.<span class="hljs-built_in">push_back</span>(num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:                        stk.<span class="hljs-built_in">push_back</span>(-num);                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:                        stk.<span class="hljs-built_in">back</span>() *= num;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:                        stk.<span class="hljs-built_in">back</span>() /= num;                &#125;                preSign = s[i];                num = <span class="hljs-number">0</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);    &#125;&#125;;</code></pre></div><p>分析：栈和字符串的应用</p><p>错误：最后的运算顺序有问题，没有能自己实现。</p><h2 id="字符串匹配">字符串匹配</h2><h3 id="Leetcode-28">Leetcode 28</h3><p>给你两个字符串 <code>haystack</code>和 <code>needle</code>，请你在 <code>haystack</code>字符串中找出 <code>needle</code>字符串的第一个匹配项的下标（下标从 <code>0</code>开始）。如果 <code>needle</code>不是 <code>haystack</code>的一部分，则返回 <code>-1</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;        <span class="hljs-type">int</span> m = haystack.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = needle.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m-n<span class="hljs-number">+1</span>;++i)&#123;            <span class="hljs-keyword">if</span>(haystack.<span class="hljs-built_in">substr</span>(i,n) == needle)&#123;                <span class="hljs-keyword">return</span> i;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    &#125;&#125;;</code></pre></div><p>分析：可以使用KMP算法，但是不会，简单一点就直接字符串匹配即可。</p><p>一遍AC</p><h2 id="练习">练习</h2><h3 id="Leetcode-409">Leetcode 409</h3><p>给定一个包含大写字母和小写字母的字符串 <code>s</code> ，返回通过这些字母构造成的<strong>最长的回文串</strong>。在构造过程中，请注意<strong>区分大小写</strong> 。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)&#123;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(s[i]) == mp.<span class="hljs-built_in">cend</span>())&#123;                mp[s[i]] = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                ++mp[s[i]];            &#125;        &#125;        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : mp)&#123;            <span class="hljs-keyword">if</span>(it.second % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                ans += it.second;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>)&#123;                    ans += it.second;                    sign = <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span>&#123;                    ans = ans + it.second / <span class="hljs-number">2</span> * <span class="hljs-number">2</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：统计数数即可</p><p>一遍AC</p><h3 id="Leetcode-3">Leetcode 3</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的最长子串的长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(left &lt; n)&#123;            <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; (mp.<span class="hljs-built_in">find</span>(s[right]) == mp.<span class="hljs-built_in">cend</span>() || mp[s[right]] == <span class="hljs-number">0</span>))&#123;                ++mp[s[right]];                ++right;            &#125;            maxlen = <span class="hljs-built_in">max</span>(maxlen,right-left);            --mp[s[left]];            ++left;        &#125;        <span class="hljs-keyword">return</span> maxlen;    &#125;&#125;;</code></pre></div><p>分析：滑动窗口经典算法</p><p>错误：与或非的括号忘记添加了</p><h3 id="Leetcode-772">Leetcode 772</h3><p>付费题目</p><h3 id="Leetcode-5">Leetcode 5</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">int</span> countsum = <span class="hljs-number">1</span>;        string result = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-type">int</span> temp = <span class="hljs-number">1</span>;            <span class="hljs-type">int</span> leftindex = i<span class="hljs-number">-1</span>;            <span class="hljs-type">int</span> rightindex = i<span class="hljs-number">+1</span>;            <span class="hljs-keyword">while</span>(leftindex &gt;= <span class="hljs-number">0</span> &amp;&amp; rightindex &lt; n &amp;&amp; s[leftindex] == s[rightindex])&#123;                temp += <span class="hljs-number">2</span>;                --leftindex;                ++rightindex;            &#125;            <span class="hljs-keyword">if</span>(temp &gt; countsum)&#123;                countsum = temp;                result = s.<span class="hljs-built_in">substr</span>(leftindex<span class="hljs-number">+1</span>,rightindex<span class="hljs-number">-1</span>-(leftindex<span class="hljs-number">+1</span>)<span class="hljs-number">+1</span>);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;++i)&#123;            <span class="hljs-keyword">if</span>(s[i] == s[i<span class="hljs-number">+1</span>])&#123;                <span class="hljs-type">int</span> temp = <span class="hljs-number">2</span>;                <span class="hljs-type">int</span> leftindex = i<span class="hljs-number">-1</span>;                <span class="hljs-type">int</span> rightindex = i<span class="hljs-number">+2</span>;                <span class="hljs-keyword">while</span>(leftindex &gt;= <span class="hljs-number">0</span> &amp;&amp; rightindex &lt; n &amp;&amp; s[leftindex] == s[rightindex])&#123;                    temp += <span class="hljs-number">2</span>;                    --leftindex;                    ++rightindex;                &#125;                <span class="hljs-keyword">if</span>(temp &gt; countsum)&#123;                    countsum = temp;                    result = s.<span class="hljs-built_in">substr</span>(leftindex<span class="hljs-number">+1</span>,rightindex<span class="hljs-number">-1</span>-(leftindex<span class="hljs-number">+1</span>)<span class="hljs-number">+1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：还是这种题，都第三道了</p><p>错误：开始有些索引没考虑好错了一些，后来调通了。</p><h2 id="总结">总结</h2><p>字符串还可以，主要是熟悉一下字符串的处理过程，其余的知识点其他的数据结构中都有。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第5讲 文档评分、词项权重计算及向量空间模型</title>
    <link href="/2022/09/12/UCAS/information-retrieval/information-retrieval-5/"/>
    <url>/2022/09/12/UCAS/information-retrieval/information-retrieval-5/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第5讲 文档评分、词项权重计算及向量空间模型</p><span id="more"></span><h1>第5讲 文档评分、词项权重计算及向量空间模型</h1><h2 id="布尔检索">布尔检索</h2><p>布尔检索的优点：</p><ul><li>对自身需求和文档集性质非常了解的专家而言，布尔查询是不错的选择</li><li>对应用开发来说也非常简单，很容易就可以返回1000多条结果</li></ul><p>布尔检索的不足：</p><ul><li>对大多数用户来说不方便</li><li>大部分用户不能撰写布尔查询或者他们认为需要大量训练才能撰写出合适的布尔查询</li><li>大部分用户不愿意逐条浏览1000多条结果，特别是对Web搜索</li><li>布尔查询常常会导致过少(=0)或者过多(&gt;1000)的结果</li></ul><p>在布尔检索中，需要大量技巧来生成一个可以获得合适规模结果的查询</p><h2 id="排序式检索">排序式检索</h2><p>排序式检索会对查询和文档的匹配程度进行排序，即给出一个查询和文档匹配评分</p><p>自由文本查询：与布尔查询不同，在排序式检索应用中，用户查询通常都是一个或几个关键字</p><p>排序式检索可以解决返回结果过少或过多的问题，可以把相关的结果排在前面</p><p>希望文档集中相关度高的文档排名高于相关度低的文档：对每个查询-文档对赋一个[0, 1]之间的分值，度量了文档和查询的匹配程度</p><p>Jaccard系数：计算两个集合重合度的常用方法，也就是计算查询文档之间的词项重合度——交集/并集</p><p>Jaccard系数的不足：</p><ul><li>不考虑词项频率 ，即词项在文档中的出现次数</li><li>一般而言，罕见词比高频词的信息量更大，Jaccard系数没有考虑这个信息</li><li>没有仔细考虑文档的长度因素</li></ul><h2 id="词项频率">词项频率</h2><p>查询-文档匹配评分计算：</p><p>从单词项查询(查询只包含一个词项)开始，若该词项不出现在文档当中，该文档得分应该为0，该词项在文档中出现越多，则得分越高。</p><p>即为词项频率 (term frequency，TF)评分</p><p>词袋(Bag of words)模型：不考虑词在文档中出现的顺序</p><p>利用tf来计算文档评分的方法：采用原始的tf值(raw tf)</p><p>但是原始tf不太合适：某个词项在A文档中出现十次，即tf = 10，在B文档中tf = 1，那么A比B更相关，但是相关度不会相差10倍。</p><p>替代原始tf的方法：对数词频</p><h2 id="tf-idf权重计算">tf-idf权重计算</h2><p>罕见词项比常见词所蕴含的信息更多</p><p>考虑查询中某个词项，它在整个文档集中非常罕见，但是某篇包含该词项的文档很可能相关，因此需要提高权重</p><p>常见词项的信息量不如罕见词，一篇包含该词项的文档当然比不包含该词项的文档的相关度要高，但是，这些词对于相关度而言并不是非常强的指示词。</p><p>文档频率(Document frequency, df)：出现词项的文档数目</p><ul><li>对于罕见词项我们希望赋予高权重</li><li>对于常见词我们希望赋予正的低权重</li></ul><p>idf 权重</p><p><img src="https://math.now.sh?inline=df_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是出现词项<img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的文档数目</p><p><img src="https://math.now.sh?inline=df_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是和词项<img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的信息量成反比的一个值</p><p>于是可以定义词项t的idf权重(逆文档频率)：<img src="https://math.now.sh?inline=idf_t%3Dlog_%7B10%7D%5Cfrac%7BN%7D%7Bdf_t%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是文档集中文档的数目</p><p><img src="https://math.now.sh?inline=idf_t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是反映词项<img src="https://math.now.sh?inline=t" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的信息量的一个指标，是一种全局性指标，反应的是词项在全局的区别性。</p><p>对于单词项查询,idf对文档排序没有任何影响，idf 会影响至少包含2个词项的查询的文档排序结果</p><p>词项的tf-idf权重是tf权重和idf权重的乘积：<img src="https://math.now.sh?inline=W_%7Bt%2Cd%7D%3D%281%2Blogtf_%7Bt%2Cd%7D%29log%5Cfrac%7BN%7D%7Bdf_t%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>tf-idf权重：</p><ul><li>随着词项频率的增大而增大（局部信息）</li><li>随着词项罕见度的增加而增大（全局信息）</li></ul><h2 id="向量空间模型">向量空间模型</h2><p>二值-tfidf矩阵</p><p>文档表示成向量：每篇文档表示成一个基于tfidf权重的实值向量 ∈ R|V|。有一个|V|维实值空间，空间的每一维都对应词项，文档都是该空间下的一个点或者向量。</p><p>查询看成向量：</p><ul><li>关键思路1：对于查询做同样的处理，即将查询表示成同一高维空间的向量</li><li>关键思路2：按照文档对查询的邻近程度排序，邻近度 = 相似度，邻近度≈ 距离的反面</li></ul><p><strong>向量空间下相似度：利用余弦相似度</strong></p><p>文档长度归一化：一个向量可以通过除以它的长度进行归一化处理（防止长度影响）</p><p>问题：</p><p>余弦归一化倾向于短文档，即对短文档产生的归一化因子太大，而平均而言对长文档产生的归一化因子太小，因此余弦归一化对长文档的惩罚过重，实际上长文档中虽然词频较高，但也会包含较多的信息。</p><p>可以先找到一个支点(pivot，平衡点)，然后通过这个支点对余弦归一化操作进行线性调整。因此短文档的相似度降低，而长文档的相似度增大，可以去除原来余弦归一化偏向短文档的问题</p><p>回转归一化：基本思想是旋转归一化曲线，使得两条曲线尽量重合</p><p>向量空间模型小结：</p><ul><li>将查询表示成tf-idf权重向量</li><li>将每篇文档表示成同一空间下的 tf-idf权重向量</li><li>计算两个向量之间的某种相似度(如余弦相似度)</li><li>按照相似度大小将文档排序</li><li>将前K（如K =10）篇文档返回给用户</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：模式识别与机器学习-第3章 判别函数</title>
    <link href="/2022/09/11/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-3/"/>
    <url>/2022/09/11/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-3/</url>
    
    <content type="html"><![CDATA[<p>《模式识别与机器学习》课程笔记：第3章 判别函数</p><span id="more"></span><h1>第3章 判别函数</h1><h2 id="线性判别函数">线性判别函数</h2><p><strong>模式识别系统的主要作用：判别各个模式（也称样本）所属的类别</strong></p><p>模式分类若可用任一个线性函数来划分，则这些模式就称为线性可分的，否则就是非线性可分的。</p><p>一旦线性函数的系数<img src="https://math.now.sh?inline=w_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>被确定，这些函数就可用作模式分类的基础。</p><p>对一个两类问题的判别，就是将模式<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>划分成<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>两类</p><p><a href="https://imgse.com/i/vOaAmt"><img src="https://s1.ax1x.com/2022/09/11/vOaAmt.md.png" alt="vOaAmt.md.png"></a></p><p>这两类可以通过一个直线方程<img src="https://math.now.sh?inline=d%28x%29%3D%5Comega_1x_1%2B%5Comega_2x_2%2B%5Comega_3%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来划分</p><p>若<img src="https://math.now.sh?inline=d%28x%29%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%5Cin%5Comega_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，若<img src="https://math.now.sh?inline=d%28x%29%3C0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%5Cin%5Comega_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=d%28x%29%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>称为决策面/判别界面方程**（判别函数和判别界面是否等于0要注意）**</p><p>用判别函数进行模式分类依赖的两个因素：</p><ul><li>判别函数的几何性质：线性的（一条直线）和非线性的函数（曲线、折线等）。<ul><li>线性判别函数建立起来比较简单（实际应用较多）；</li><li>非线性判别函数建立起来比较复杂。</li></ul></li><li>判别函数的形式确定后，主要就是确定判别函数的系数问题，只要被研究的模式是可分的，就能用给定的模式样本集来确定判别函数的系数。</li></ul><p>一个<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维线性判别函数的一般形式：</p><p><img src="https://math.now.sh?inline=d%28%5Cboldsymbol%7Bx%7D%29%3Dw_1%20x_1%2Bw_2%20x_2%2B%5Ccdots%2Bw_n%20x_n%2Bw_%7Bn%2B1%7D%3D%5Cboldsymbol%7Bw%7D_0%5ET%20%5Cboldsymbol%7Bx%7D%2Bw_%7Bn%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>权向量（参数向量）：<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_0%3D%5Cleft%28w_1%2C%20w_2%2C%20%5Cldots%2C%20w_%7B%5Cmathrm%7Bn%7D%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维线性判别函数也可以表示为<img src="https://math.now.sh?inline=d%28%5Cboldsymbol%7Bx%7D%29%3D%5Cboldsymbol%7Bw%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>增广模式向量：<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%3D%5Cleft%28x_1%2C%20x_2%2C%20%5Cldots%2C%20x_n%2C%201%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，增广权向量：<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%3D%5Cleft%28w_1%2C%20w_2%2C%20%5Cldots%2C%20w_%7B%5Cmathrm%7Bn%2B1%7D%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>多类情况1：用线性判别函数将属于<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的模式与不属于<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的模式分开，称为 <img src="https://math.now.sh?inline=%5Comega_i%2F%20%5Cbar%7B%5Comega_i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>两分法，即把<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类多类问题分成<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个两类问题，因此共有<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个判别函数。会存在分类失败的问题：</p><p><a href="https://imgse.com/i/vOdk34"><img src="https://s1.ax1x.com/2022/09/11/vOdk34.png" alt="vOdk34.png"></a></p><p>多类情况2：采用每对划分，即 <img src="https://math.now.sh?inline=%CF%89_i%2F%CF%89_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>两分法，此时一个判别界面只能分开两种类别，但不能把它与其余所有的界面分开。</p><p>判别函数为<img src="https://math.now.sh?inline=d_%7Bi%20j%7D%28%5Cboldsymbol%7Bx%7D%29%3D%5Cboldsymbol%7Bw%7D_%7Bi%20j%7D%5ET%20%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，若<img src="https://math.now.sh?inline=d_%7B%5Cmathrm%7Bij%7D%7D%28%5Cboldsymbol%7Bx%7D%29%3E0%2C%20%5Cforall%20j%20%5Cneq%20i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，则 <img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%20%5Cin%20%5Comega_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此要分开<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类模式，共需<img src="https://math.now.sh?inline=%5Cfrac%7BM%28M-1%29%7D%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个判别函数。也会存在不确定区域，即分类失败。</p><p>多类情况1和多类情况2的比较</p><ul><li>对于<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类模式的分类，多类情况1需要<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个判别函数，而多类情况2需<img src="https://math.now.sh?inline=%5Cfrac%7BM%28M-1%29%7D%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个判别函数，当<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>较大时，后者需要更多的判别式</li><li>采用多类情况1时，每一个判别函数都要把一种类别的模式与其余<img src="https://math.now.sh?inline=M-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>种类别的模式分开，而不是将一种类别的模式仅与另一种类别的模式分开。</li><li>由于一种模式的分布要比<img src="https://math.now.sh?inline=M-1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>种模式的分布更为聚集，因此多类情况2对模式是线性可分的可能性比多类情况1更大一些。</li></ul><p>多类情况3：没有不确定区域的 <img src="https://math.now.sh?inline=%CF%89_i%2F%CF%89_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>两分法</p><p><img src="https://math.now.sh?inline=d_%7B%5Cmathrm%7Bij%7D%7D%28%5Cboldsymbol%7Bx%7D%29%3Dd_%7B%5Cmathrm%7Bi%7D%7D(%5Cboldsymbol%7Bx%7D)-d_%7B%5Cmathrm%7Bj%7D%7D(%5Cboldsymbol%7Bx%7D)%3D%5Cleft(%5Cboldsymbol%7Bw%7D_%7B%5Cmathrm%7Bi%7D%7D-%5Cboldsymbol%7Bw%7D_%7B%5Cmathrm%7Bj%7D%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，此时，对<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类情况应有<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个判别函数。</p><h2 id="广义线性判别函数">广义线性判别函数</h2><p>线性判别函数简单，容易实现，而非线性判别函数复杂，不容易实现。</p><p>若能将非线性判别函数转换为线性判别函数，则有利于模式分类的实现。</p><p>设有一个训练用的模式集<img src="https://math.now.sh?inline=%5C%7Bx%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，在模式空间<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中线性不可分，但在模式空间<img src="https://math.now.sh?inline=x%5E*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中线性可分，其中<img src="https://math.now.sh?inline=x%5E*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的各个分量是<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的单值实函数，<img src="https://math.now.sh?inline=x%5E*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的维数<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>高于<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的维数<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即若取<img src="https://math.now.sh?inline=x%5E*%20%3D%20%28f_1(x%29%2Cf_2(x)%2C%5Ccdots%2Cf_k(x))%2Ck%3En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则分类界面在<img src="https://math.now.sh?inline=x%5E*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中是线性的，在<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中是非线性的，此时只要将模式<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>进行非线性变换，使之变换后得到维数更高的模式<img src="https://math.now.sh?inline=x%5E*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，就可以用线性判别函数来进行分类。</p><p>一个非线性判别函数可如下表示：<img src="https://math.now.sh?inline=d%28%5Cboldsymbol%7Bx%7D%29%3Dw_%7B1%7D%20f_%7B1%7D(%5Cboldsymbol%7Bx%7D)%2Bw_%7B2%7D%20f_%7B2%7D(%5Cboldsymbol%7Bx%7D)%2B%5Ccdots%2Bw_%7Bk%7D%20f_%7Bk%7D(%5Cboldsymbol%7Bx%7D)%2Bw_%7Bk%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=f_i%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是模式<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的单值实函数。</p><p>若定义成广义形式：<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5E%7B*%7D%3D%5Cleft%28f_%7B1%7D(%5Cboldsymbol%7Bx%7D%29%2C%20f_%7B2%7D(%5Cboldsymbol%7Bx%7D)%2C%20%5Cldots%2C%20f_%7B%5Cmathrm%7Bk%7D%7D(%5Cboldsymbol%7Bx%7D)%2C%201%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>此时有：<img src="https://math.now.sh?inline=d%5Cleft%28%5Cboldsymbol%7Bx%7D%5E%7B*%7D%5Cright%29%3D%5Cboldsymbol%7Bw%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7Bx%7D%5E%7B*%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%3D%5Cleft%28w_%7B1%7D%2C%20w_%7B2%7D%2C%20%5Cldots%2C%20w_%7B%5Cmathrm%7Bk%7D%7D%2C%20w_%7B%5Cmathrm%7Bk%7D%2B1%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>非线性判别函数已被变换成广义线性，因此只讨论线性判别函数不会失去一般性意义。</p><p>当<img src="https://math.now.sh?inline=f_i%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是模式<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的二次多项式函数时：</p><p><img src="https://math.now.sh?inline=d%28%5Cboldsymbol%7Bx%7D%29%3D%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20w_%7Bj%20j%7D%20x_%7Bj%7D%5E%7B2%7D%2B%5Csum_%7Bj%3D1%7D%5E%7Bn-1%7D%20%5Csum_%7Bk%3Dj%2B1%7D%5E%7Bn%7D%20w_%7Bj%20k%7D%20x_%7Bj%7D%20x_%7Bk%7D%2B%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%20w_%7Bj%7D%20x_%7Bj%7D%2Bw_%7Bn%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>式中各项的组成应包含<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的各个分量的二次项、一次项和常数项，其中平方项<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个，二次项<img src="https://math.now.sh?inline=%5Cfrac%7Bn%28n-1%29%7D%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个，一次项<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个，常数项1个，其总项数为：<br><img src="https://math.now.sh?inline=n%20%2B%20%5Cfrac%7Bn%28n-1%29%7D%7B2%7D%2B%20n%20%2B%201%20%3D%20%5Cfrac%7B(n%2B1)(n%2B2)%7D%7B2%7D%3E%20n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>若<img src="https://math.now.sh?inline=f_i%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是模式<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的<img src="https://math.now.sh?inline=r" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次多项式函数，总项数为<img src="https://math.now.sh?inline=N_%7Bw%7D%3DC_%7Bn%2Br%7D%5E%7Br%7D%3D%5Cfrac%7B%28n%2Br%29%20!%7D%7Br%20!%20n%20!%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="分段线性判别函数">分段线性判别函数</h2><ul><li>线性判别函数在进行分类决策时是最简单有效的，但在实际应用中，常常会出现不能用线性判别函数直接进行分类的情况。</li><li>采用广义线性判别函数的概念，可以通过增加维数来得到线性判别，但维数的大量增加会使在低维空间里在解析和计算上行得通的方法在高维空间遇到困难，增加计算的复杂性。</li><li>引入分段线性判别函数的判别过程，它比一般的线性判别函数的错误率小，但又比非线性判别函数简单。</li></ul><p>也就是说，可以使用一个二次判别函数进行分类的地方，也可以使用一个分段线性判别函数来逼近这个二次曲线。</p><p>可以采用最小距离分类的方法，只有在类别密集地分布在其均值附近时才有效。</p><p>对于各类交错分布的情况，若再用每类一个均值代表点产生最小距离分类器，就会产生很明显的错误率。在这种情况下，可以运用聚类方法将一些类分解成若干个子类，再用最小距离分类。</p><ul><li>寻找交遇区—找到互为最小距离的原型对，组成“交遇区”。</li><li>用局部训练模式产生分段线性判别函数并迭代优化决策面。</li><li>撤走已分类正确的样本，从剩下的样本集合中，寻找交遇区，产生分段线性判别函数。</li></ul><h2 id="模式空间和权空间">模式空间和权空间</h2><p>模式空间：</p><p>对一个线性方程<img src="https://math.now.sh?inline=w_1x_1%2Bw_2x_2%2Bw_3x_3%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，它在三维空间<img src="https://math.now.sh?inline=%28x_1%20%2Cx_2%20%2Cx_3%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中是一个平面方程式，<img src="https://math.now.sh?inline=w%3D%28w_1%2Cw_2%2Cw_3%29%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是方程的系数。</p><p>把<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>向量作为该平面的法线向量，则该线性方程决定的平面通过原点且与<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>垂直</p><p>若<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是二维的增广向量，<img src="https://math.now.sh?inline=w%20%3D%28w_1%2Cw_2%29%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为非增广的权向量，它与直线AB垂直</p><p>模式空间即为增广向量决定的平面或非增广向量决定的直线。</p><p>权空间：</p><p>若将方程<img src="https://math.now.sh?inline=x_1w_1%2Bx_2w_2%2Bw_3%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>绘在权向量<img src="https://math.now.sh?inline=w%3D%28w_1%2Cw_2%2Cw_3%29%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的三维空间中，则<img src="https://math.now.sh?inline=x%3D%28x_1%2Cx_2%2C1%29%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为方程的系数</p><h2 id="Fisher线性判别">Fisher线性判别</h2><ul><li>应用统计方法解决模式识别问题时，一再碰到的问题之一就是维数问题。</li><li>在低维空间里解析上或计算上行得通的方法，在高维空间里往往行不通。</li><li>因此，降低维数有时就会成为处理实际问题的关键。</li></ul><p>问题描述：</p><ul><li>考虑把<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维空间的样本投影到一条直线上，形成一维空间，即把维数压缩到一维。</li><li>然而，即使样本在<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维空间里形成若干紧凑的互相分得开的集群，当把它们投影到一条直线上时，也可能会是几类样本混在一起而变得无法识别。</li><li>但是，在一般情况下，总可以找到某个方向，使在这个方向的直线上，样本的投影能分得开。</li></ul><p>Fisher判别方法所要解决的基本问题：如何根据实际情况找到一条最好的、最易于分类的投影线。</p><p>从<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维空间到一维空间的一般数学变换方法：</p><p>假设有一集合<img src="https://math.now.sh?inline=%5CGamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>包含<img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维样本<img src="https://math.now.sh?inline=x%5E1%2Cx%5E2%2C%E2%80%A6%2C%20x%5EN" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=N_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个属于<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的样本记为子集<img src="https://math.now.sh?inline=%5CGamma_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=N_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个属于<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的样本记为子集<img src="https://math.now.sh?inline=%5CGamma_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，若对<img src="https://math.now.sh?inline=x%5En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的分量做线性组合可得标量：<img src="https://math.now.sh?inline=y_n%3Dw%5ETx%5En%2C%20n%3D1%2C2%2C%E2%80%A6%2CN" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，这样便得到<img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个一维样本<img src="https://math.now.sh?inline=y_n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>组成的集合，并可分为两个子集<img src="https://math.now.sh?inline=%5CGamma_1'" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5CGamma_2'" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>实际上，<img src="https://math.now.sh?inline=%7Cw%7C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的值是无关紧要的，它仅是<img src="https://math.now.sh?inline=y_n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>乘上一个比例因子，重要的是选择<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的方向。<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的方向不同，将使样本投影后的可分离程度不同，从而直接影响分类效果。因此，上述寻找最佳投影方向的问题，在数学上就是寻找最好的变换向量<img src="https://math.now.sh?inline=w%5E*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的问题。</p><p>Fisher准则函数中的基本参量：</p><p>在<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维<img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>空间：</p><p>各类样本的均值向量<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bm%7D_i%3D%5Cfrac%7B1%7D%7BN_i%7D%20%5Csum_%7Bx%20%5Cin%20%5CGamma_i%7D%20%5Cboldsymbol%7Bx%7D%2C%20i%3D1%2C2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>样本类内离散度矩阵：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_i%3D%5Csum_%7B%5Cboldsymbol%7Bx%7D%20%5Cin%20%5CGamma_i%7D%5Cleft%28%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bm%7D_i%5Cright%29%5Cleft(%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bm%7D_i%5Cright)%5ET%2C%20i%3D1%2C2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>总样本类内离散度矩阵：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS_w%7D%3D%5Cboldsymbol%7BS_1%7D%2B%5Cboldsymbol%7BS_2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（对称半正定矩阵）</p><p>样本类间离散度矩阵：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_b%3D%5Cleft%28%5Cboldsymbol%7Bm%7D_1-%5Cboldsymbol%7Bm%7D_2%5Cright%29%5Cleft(%5Cboldsymbol%7Bm%7D_1-%5Cboldsymbol%7Bm%7D_2%5Cright)%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（对称半正定矩阵）</p><p>在一维<img src="https://math.now.sh?inline=Y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>空间：</p><p>各类样本的均值：<img src="https://math.now.sh?inline=%5Ctilde%7Bm%7D_i%3D%5Cfrac%7B1%7D%7BN_i%7D%20%5Csum_%7By%20%5Cin%20%5CGamma_i%5E%7B%5Cprime%7D%7D%20y%2C%20i%3D1%2C2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>样本类内离散度：<img src="https://math.now.sh?inline=%5Ctilde%7BS%7D_i%5E2%3D%5Csum_%7By%20%5Cin%20%5CGamma_i%5E%7B%5Cprime%7D%7D%5Cleft%28y-%5Ctilde%7Bm%7D_i%5Cright%29%5E2%2C%20i%3D1%2C2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>总样本类内离散度：<img src="https://math.now.sh?inline=%5Ctilde%7BS%7D_w%3D%5Ctilde%7BS%7D_1%5E2%2B%5Ctilde%7BS%7D_2%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>我们希望投影后，在一维<img src="https://math.now.sh?inline=Y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>空间中各类样本尽可能分得开些，即希望两类均值之差越大越好，同时希望各类样本内部尽量密集，即希望类内离散度越小越好。</p><p>Fisher准则函数：<img src="https://math.now.sh?inline=J_F%28w%29%3D%5Cfrac%7B%5Cleft(%5Ctilde%7Bm%7D_1-%5Ctilde%7Bm%7D_2%5Cright)%5E2%7D%7B%5Ctilde%7BS%7D_1%5E2%2B%5Ctilde%7BS%7D_2%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>将其推导为<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的显函数：<img src="https://math.now.sh?inline=J_%7B%5Cmathrm%7BF%7D%7D%28%5Cboldsymbol%7Bw%7D%29%3D%5Cfrac%7B%5Cboldsymbol%7Bw%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BS%7D_b%20%5Cboldsymbol%7Bw%7D%7D%7B%5Cboldsymbol%7Bw%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cboldsymbol%7BS%7D_w%20%5Cboldsymbol%7Bw%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>然后使用Lagrange乘数法求解，最终解得<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%5E*%3D%5Cboldsymbol%7BS%7D_w%5E%7B-1%7D%5Cleft%28%5Cboldsymbol%7Bm%7D_1-%5Cboldsymbol%7Bm%7D_2%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>事实上，Fisher的降维就相当于找一个线性判别函数。投影后的<img src="https://math.now.sh?inline=y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<img src="https://math.now.sh?inline=w%5ETx%5En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>变化得来的，就相当于线性判别。</p><p>多类情形：</p><p>类间散度矩阵与两类情形略有不同：原来度量的是两个均值点的散列情况，现在度量的是每类均值点相对于样本中心的散列情况</p><p>推导可得：<img src="https://math.now.sh?inline=%5Cboldsymbol%7BS%7D_w%5E%7B-1%7D%20%5Cboldsymbol%7BS%7D_b%20W%5E*%3D%5Clambda%20W%5E*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="感知器算法">感知器算法</h2><p>一旦判别函数的形式确定下来，不管它是线性的还是非线性的，剩下的问题就是如何确定它的系数。在模式识别中，系数确定的一个主要方法就是通过对已知样本的训练和学习来得到。感知器算法就是通过训练样本模式的迭代和学习，产生线性（或广义线性）可分的模式判别函数。</p><p>基本思想：采用感知器算法能通过对训练模式样本集的“学习”得到判别函数的系数。不需要对各类别中模式的统计性质做任何假设，因此称为确定性的方法。</p><p>感知器作为人工神经网络中最基本的单元，由多个输入和一个输出组成。</p><p>已知两个训练模式集分别属于<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类和<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类，权向量的初始值为<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%281%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，可任意取值。</p><p>若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5Ek%20%5Cin%20%5Comega_1%2C%20%5Cboldsymbol%7Bw%7D%5ET%28k%29%20%5Cboldsymbol%7Bx%7D%5Ek%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5Ek%20%5Cin%20%5Comega_2%2C%20%5Cboldsymbol%7Bw%7D%5ET%28k%29%20%5Cboldsymbol%7Bx%7D%5Ek%3C0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次的训练步骤为：</p><p>若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5Ek%20%5Cin%20%5Comega_1%2C%20%5Cboldsymbol%7Bw%7D%5ET%28k%29%20%5Cboldsymbol%7Bx%7D%5Ek%E2%89%A40" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则分类器对第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个模式<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%5Ek%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>做了错误分类，此时应校正权向量，使得<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28%5Cmathrm%7Bk%7D%2B1%29%3D%5Cboldsymbol%7Bw%7D(%5Cmathrm%7Bk%7D)%2BC%20%5Cboldsymbol%7Bx%7D%5Ek" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为一个校正增量。</p><p>若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5Ek%20%5Cin%20%5Comega_2%2C%20%5Cboldsymbol%7Bw%7D%5ET%28k%29%20%5Cboldsymbol%7Bx%7D%5Ek%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则分类器对第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个模式<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%5Ek%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>做了错误分类，此时应校正权向量，使得<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28%5Cmathrm%7Bk%7D%2B1%29%3D%5Cboldsymbol%7Bw%7D(%5Cmathrm%7Bk%7D)-C%20%5Cboldsymbol%7Bx%7D%5Ek" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为一个校正增量。</p><p>若以上情况不符合，则表明该模式样本在第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次中分类正确，因此权向量不变<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28%5Cmathrm%7Bk%7D%2B1%29%3D%5Cboldsymbol%7Bw%7D(%5Cmathrm%7Bk%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ul><li>对正确分类的模式则“赏”，实际上是“不罚”，即权向量不变。</li><li>对错误分类的模式则“罚”，使<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28%5Cmathrm%7Bk%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>加上一个正比于<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5Ek" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的分量。</li><li>当用全部模式样本训练过一轮以后，只要有一个模式是判别错误的，则需要进行下一轮迭代，即用全部模式样本再训练一次。</li><li>如此不断反复直到全部模式样本进行训练都能得到正确的分类结果为止。</li></ul><p>感知器算法的收敛性：只要模式类别是线性可分的，就可以在有限的迭代步数里求出权向量。</p><h2 id="采用感知器算法的多类模式的分类">采用感知器算法的多类模式的分类</h2><p>采用多类情况3，将感知器算法推广到多类模式。</p><p>多类情况3：对<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类模式存在<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个判别函数<img src="https://math.now.sh?inline=%5C%7Bd_i%2C%20i%20%3D%201%2C2%2C%E2%80%A6%2CM%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D_k%20%5Cin%20%5Comega_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>, 则 <img src="https://math.now.sh?inline=d_i%3Ed_j%2C%20%5Cforall%20j%20%5Cneq%20i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>设有<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>种模式类别<img src="https://math.now.sh?inline=%CF%89_1%EF%BC%8C%CF%89_2%EF%BC%8C%E2%80%A6%EF%BC%8C%CF%89_M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，若在训练过程的第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次迭代时，一个属于<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的模式样本<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>送入分类器，则应先计算出<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个判别函数：<img src="https://math.now.sh?inline=d_j%28k%29%3D%5Cboldsymbol%7Bw%7D_j(k)%20%5Cboldsymbol%7Bx%7D%2C%20j%3D1%2C2%2C%20%5Ccdots%2C%20%5Cmathrm%7BM%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。若<img src="https://math.now.sh?inline=d_i%28k%29%3Ed_j(k)%2C%20j%3D1%2C2%2C%20%5Cldots%2C%20M%2C%20%5Cforall%20j%20%5Cneq%20i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件成立，则权向量不变，即<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_j%28k%2B1%29%3D%5Cboldsymbol%7Bw%7D_j(k)%2C%20j%3D1%2C2%2C%20%5Ccdots%2C%20M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>若其中第<img src="https://math.now.sh?inline=l" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个权向量使得<img src="https://math.now.sh?inline=d_i%28k%29%E2%89%A4d_j(k)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则相应的权向量应做调整，即</p><p><img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_i%28k%2B1%29%3D%5Cboldsymbol%7Bw%7D_i(k)%2BCx" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_l%28k%2B1%29%3D%5Cboldsymbol%7Bw%7D_l(k)-C%20x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D_j%28k%2B1%29%3D%5Cboldsymbol%7Bw%7D_j(k)%2C%20j%3D1%2C2%2C%20%5Ccdots%2C%20M%2C%20j%20%5Cneq%20i%2C%20j%20%5Cneq%20l" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是一个正常数。权向量的初始值<img src="https://math.now.sh?inline=w_i%28l%29%EF%BC%8Ci%20%3D%201%2C2%2C%E2%80%A6%2CM" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可视情况任意选择。</p><p>这里的分类算法都是通过模式样本来确定判别函数的系数，但一个分类器的判断性能最终要受并未用于训练的那些未知样本来检验。要使一个分类器设计完善，必须采用有代表性的训练数据，它能够合理反映模式数据的整体。</p><p>要获得一个判别性能好的线性分类器，直观上训练样本越多越好，但实际上能收集到的样本数目会受到客观条件的限制，且过多的训练样本在训练阶段会使计算机需要较长的运算时间。一般来说，合适的样本数目可如下估计：若<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是模式的维数，令<img src="https://math.now.sh?inline=C%3D2%28k%2B1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则通常选用的训练样本数目约为<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的10~20倍。</p><p>感知器算法的解与初值的选择和迭代过程中误分类点的选择顺序有关。</p><h2 id="可训练的确定性分类器的迭代算法">可训练的确定性分类器的迭代算法</h2><h3 id="梯度法">梯度法</h3><p>设函数<img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7By%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 是向量 <img src="https://math.now.sh?inline=%5Cboldsymbol%7By%7D%3D%5Cleft%28y_1%2C%20y_2%2C%20%5Cldots%2C%20y_%7B%5Cmathrm%7Bn%7D%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的函数, 则 <img src="https://math.now.sh?inline=f%28%5Cboldsymbol%7By%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 的梯度定义为</p><p><img src="https://math.now.sh?inline=%5Cnabla%20f%28%5Cboldsymbol%7By%7D%29%3D%5Cfrac%7Bd%7D%7Bd%20%5Cboldsymbol%7By%7D%7D%20f(%5Cboldsymbol%7By%7D)%3D%5Cleft(%5Cbegin%7Barray%7D%7Bllll%7D%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20y_1%7D%20%26%20%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20y_2%7D%20%26%20%5Ccdots%20%26%20%5Cfrac%7B%5Cpartial%20f%7D%7B%5Cpartial%20y_n%7D%5Cend%7Barray%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>从<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>导出<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28k%2B1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的一般关系式<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28k%2B1%29%3D%5Cboldsymbol%7Bw%7D(k)-C%5Cleft%5C%7B%5Cfrac%7B%5Cpartial%20J(%5Cboldsymbol%7Bw%7D%2C%20%5Cboldsymbol%7Bx%7D)%7D%7B%5Cpartial%20%5Cboldsymbol%7Bw%7D%7D%5Cright%5C%7D_%7Bw%3D%5Cboldsymbol%7Bw%7D(k)%7D%3D%5Cboldsymbol%7Bw%7D(k)-C%20%5Ccdot%20%5Cnabla%20J" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是一个正的比例因子（步长）</p><p>梯度是一个向量，它的最重要性质就是指出了函数<img src="https://math.now.sh?inline=f" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在其自变量增加时最大增长率的方向。负梯度指出<img src="https://math.now.sh?inline=f" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的最陡下降方向，利用这个性质可以设计一个迭代方案来寻找函数的最小值。</p><p>定义一个对错误分类敏感的准则函数<img src="https://math.now.sh?inline=J%28w%2C%20x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。先任选一个初始权向量<img src="https://math.now.sh?inline=w%281%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，计算准则函数<img src="https://math.now.sh?inline=J" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的梯度，然后从<img src="https://math.now.sh?inline=w%281%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>出发，在最陡方向（梯度方向）上移动某一距离得到下一个权向量<img src="https://math.now.sh?inline=w%282%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>C值的选择是很重要的。若C值太小，则收敛太慢；若C值太大，则搜索可能过头，引起发散。</p><h3 id="固定增量的逐次调整算法">固定增量的逐次调整算法</h3><p>设取准则函数为：<img src="https://math.now.sh?inline=J%28%5Cboldsymbol%7Bw%7D%2C%20%5Cboldsymbol%7Bx%7D%29%3D%5Cfrac%7B%5Cleft%7C%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%5Cright%7C-%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%7D%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>则<img src="https://math.now.sh?inline=J" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的微分式：<img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20%5Cboldsymbol%7Bw%7D%7D%3D%5Cfrac%7B1%7D%7B2%7D%5Cleft%5B%5Cboldsymbol%7Bx%7D%20%5Ccdot%20%5Coperatorname%7Bsign%7D%5Cleft%28%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%5Cright%29-%5Cboldsymbol%7Bx%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Coperatorname%7Bsign%7D%5Cleft%28%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%5Cright%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bll%7D%2B1%20%26%20%5Ctext%20%7B%20if%20%7D%20%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%3E0%20%5C%5C%20-1%20%26%20%5Ctext%20%7B%20if%20%7D%20%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%20%5Cleq%200%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>则由梯度法中<img src="https://math.now.sh?inline=w%28k%2B1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=w%28k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的关系有：<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28k%2B1%29%3D%5Cboldsymbol%7Bw%7D(k)%2B%5Cfrac%7BC%7D%7B2%7D%5Cleft%5B%5Cboldsymbol%7Bx%7D%5Ek-%5Cboldsymbol%7Bx%7D%5Ek%20%5Ccdot%20%5Coperatorname%7Bsign%7D%5Cleft(%5Cboldsymbol%7Bw%7D%5ET(k)%20%5Cboldsymbol%7Bx%7D%5Ek%5Cright)%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bx%7D%5Ek" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是训练模式样本，<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是指第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次迭代。<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%28k%2B1%29%3D%5Cboldsymbol%7Bw%7D(k)%2BC%20%5Ccdot%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bcl%7D0%20%26%20%5Ctext%20%7B%20if%20%7D%20%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%5Ek%3E0%20%5C%5C%20%5Cboldsymbol%7Bx%7D%5Ek%20%26%20%5Ctext%20%7B%20if%20%7D%20%5Cboldsymbol%7Bw%7D%5ET%20%5Cboldsymbol%7Bx%7D%5Ek%20%5Cleq%200%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>若模式是线性可分的，选择合适的准则函数<img src="https://math.now.sh?inline=J%28w%2Cx%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，算法就能给出解。若模式不是线性可分的，算法的结果就会来回摆动，得不到收敛。</p><h3 id="最小平方误差-LMSE-算法">最小平方误差(LMSE)算法</h3><p>感知器算法只是当被分模式可用一个特定的判别界面分开时才收敛，在不可分情况下，只要计算程序不终止，它就始终不收敛。即使在模式可分的情况下，也很难事先算出达到收敛时所需要的迭代次数。这样，在模式分类过程中，有时候会出现一次又一次迭代却不见收敛的情况，白白浪费时间。为此需要知道：发生迟迟不见收敛的情况时，到底是由于收敛速度过慢造成的呢，还是由于所给的训练样本集不是线性可分造成的呢？</p><p>最小平方误差(LMSE)算法，除了对可分模式是收敛的以外，对于类别不可分的情况也能指出来。</p><p>求两类问题的解相当于求一组线性不等式的解，因此，若给出分别属于<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的两个模式样本的训练样本集，即可求出其权向量<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的解。</p><p>设两类模式的训练样本总数为<img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，写成增广形式，则有不等式组<img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%20w%7D_%7B%5Cmathbf%7Bw%7D%7D%3E%5Cmathbf%7B0%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=X%3D%5Cleft%28%5Cbegin%7Barray%7D%7Bc%7D%5Cleft(x%5E1%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cleft(%5Cboldsymbol%7Bx%7D%5Ei%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%20-%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7Bi%2B1%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%20%5Cvdots%20%5C%5C%20-%5Cleft(%5Cboldsymbol%7Bx%7D%5EN%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%5Cend%7Barray%7D%5Cright)%2C%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E1%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cleft(%5Cboldsymbol%7Bx%7D%5Ei%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%5Cend%7Barray%7D%5Cright)%20%5Cin%20%5Comega_1%2C%5Cleft(%5Cbegin%7Barray%7D%7Bc%7D%5Cleft(%5Cboldsymbol%7Bx%7D%5E%7Bi%2B1%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%5C%5C%20%5Cvdots%20%5C%5C%20%5Cleft(%5Cboldsymbol%7Bx%7D%5EN%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%5Cend%7Barray%7D%5Cright)%20%5Cin%20%5Comega_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cboldsymbol%7Bw%7D%3D%5Cleft%28w_1%2C%20w_2%2C%20%5Cldots%2C%20w_n%2C%20w_%7Bn%2B1%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>H-K算法：</p><p>模式类别可分性的判别：</p><p>当不等式组<img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D%7B%5Cmathbf%7Bw%7D%7D%3E%5Cmathbf%7B0%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>有解时，该算法对<img src="https://math.now.sh?inline=0%3CC%E2%89%A41" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>收敛，可求得解<img src="https://math.now.sh?inline=%5Cmathbf%7Bw%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><ul><li>若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Be%7D%28k%29%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即<img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7Bw%7D%28k%29%3D%5Cboldsymbol%7Bb%7D(k)%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，有解。</li><li>若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Be%7D%28k%29%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，此时隐含<img src="https://math.now.sh?inline=%5Cboldsymbol%7BX%7D%20%5Cboldsymbol%7Bw%7D%28k%29%20%5Cgeq%20%5Cboldsymbol%7Bb%7D(k)%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件，有解。若继续进行迭代，可使<img src="https://math.now.sh?inline=%5Cboldsymbol%7Be%7D%28k%29%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</li><li>若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Be%7D%28k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的全部分量停止变为正值（但不是全部为零），表明该模式类别线性不可分。因此，若<img src="https://math.now.sh?inline=%5Cboldsymbol%7Be%7D%28k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>没有一个分量为正值，则<img src="https://math.now.sh?inline=%5Cboldsymbol%7Bb%7D%28k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>不会再变化，所以不能求得解。</li></ul><p>固定增量算法与LMSE算法的比较：</p><ul><li>固定增量算法：实现相对简单，可直接引伸到多类模式的分类情况，但未提供模式线性可分的测试特征；</li><li>LMSE算法：相对复杂，需要对<img src="https://math.now.sh?inline=X%5ETX" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>求逆（维数高时求逆比较困难），但对两类情况，提供了线性可分的测试特征。</li></ul><h2 id="势函数法-一种确定性的非线性分类算法">势函数法-一种确定性的非线性分类算法</h2><p>用势函数的概念来<strong>确定判别函数</strong>和<strong>划分类别界面</strong></p><p>基本思想：</p><ul><li>假设要划分属于两种类别<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的模式样本，这些样本可看成是分布在<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维模式空间中的点<img src="https://math.now.sh?inline=x_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</li><li>把属于<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的点比拟为某种能源点，在点上，电位达到峰值。</li><li>随着与该点距离的增大，电位分布迅速减小，即把样本<img src="https://math.now.sh?inline=x_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>附近空间<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>点上的电位分布，看成是一个势函数<img src="https://math.now.sh?inline=K%28x%2C%20x_k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</li><li>对于属于<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的样本集群，其附近空间会形成一个“高地”，这些样本点所处的位置就是“山头”。</li><li>同理，用电位的几何分布来看待属于<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的模式样本，在其附近空间就形成“凹地”。</li><li>只要在两类电位分布之间选择合适的等高线，就可以认为是模式分类的判别函数。</li></ul><h3 id="判别函数的产生">判别函数的产生</h3><p>模式分类的判别函数可由分布在模式空间中的许多样本向量<img src="https://math.now.sh?inline=%5C%7Bx_k%2C%20k%3D1%2C2%2C%5Ccdots%5C%7D%20x_k%20%5Cin%5Cleft%28%5Comega_1%20%5Ccup%20%5Comega_2%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的势函数产生。任意一个样本所产生的势函数以<img src="https://math.now.sh?inline=K%28x%2Cx_k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表征，则判别函数<img src="https://math.now.sh?inline=d%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可由势函数序列<img src="https://math.now.sh?inline=K%28x%2C%20x_1%29%EF%BC%8C%20K(x%2C%20x_2)%EF%BC%8C%E2%80%A6" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来构成，序列中的这些势函数相应于在训练过程中输入机器的训练模式样本<img src="https://math.now.sh?inline=x_1%EF%BC%8Cx_2%EF%BC%8C%E2%80%A6" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。在训练状态，模式样本逐个输入分类器，分类器就连续计算相应的势函数，在第<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>步迭代时的积累位势决定于在该步前所有的单独势函数的累加。以<img src="https://math.now.sh?inline=K%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示积累位势函数，若加入的训练样本<img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是错误分类，则积累函数需要修改，若是正确分类，则不变。</p><p>从势函数可以看出，积累位势起着判别函数的作用：</p><ul><li>当<img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>属于<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，<img src="https://math.now.sh?inline=K_k%28x_%7Bk%2B1%7D%29%3E0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</li><li>当<img src="https://math.now.sh?inline=x_%7Bk%2B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>属于<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，<img src="https://math.now.sh?inline=K_k%28x_%7Bk%2B1%7D%29%3C0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则积累位势不做任何修改就可用作判别函数。</li></ul><p>由于一个模式样本的错误分类可造成积累位势在训练时的变化，因此势函数算法提供了确定<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>两类判别函数的迭代过程。</p><p>判别函数表达式：取<img src="https://math.now.sh?inline=d%28x%29%3DK%20(x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则有<img src="https://math.now.sh?inline=d_%7Bk%2B1%7D%28x%29%3D%20d_k(x)%2Br_%7Bk%2B1%7DK(x%2Cx_%7Bk%2B1%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="势函数的选择">势函数的选择</h3><p>选择势函数的条件：一般来说，若两个<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维向量<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=x_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的函数<img src="https://math.now.sh?inline=K%28x%2C%20x_k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>同时满足下列三个条件，则可作为势函数。</p><ul><li><img src="https://math.now.sh?inline=K%28x%2Cx_k%29%3DK(x_k%2C%20x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，并且当且仅当<img src="https://math.now.sh?inline=x%3Dx_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时达到最大值；</li><li>当向量<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=x_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的距离趋于无穷时，<img src="https://math.now.sh?inline=K%28x%2C%20x_k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>趋于零；</li><li><img src="https://math.now.sh?inline=K%28x%2Cx_k%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是光滑函数，且是<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=x_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>之间距离的单调下降函数。</li></ul><p>第一类势函数：可用对称的有限多项式展开：</p><p><img src="https://math.now.sh?inline=K%5Cleft%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7Bx%7D_k%5Cright%29%3D%5Csum_%7Bi%3D1%7D%5Em%20%5Cvarphi_i(%5Cboldsymbol%7Bx%7D)%20%5Cvarphi_i%5Cleft(%5Cboldsymbol%7Bx%7D_k%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cvarphi_i%28%5Cboldsymbol%7Bx%7D%29%5Cright%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在模式定义域内为正交函数集。</p><p>将这类势函数代入判别函数：<img src="https://math.now.sh?inline=d_%7Bk%2B1%7D%28%5Cboldsymbol%7Bx%7D%29%3D%5Csum_%7Bi%3D1%7D%5Em%20%5Cboldsymbol%7BC%7D_i(k%2B1)%20%5Cvarphi_i(%5Cboldsymbol%7Bx%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cboldsymbol%7BC%7D_i%28k%2B1%29%3D%5Cboldsymbol%7BC%7D_i(k)%2B%5Cmathrm%7Br%7D_%7Bk%2B1%7D%20%5Cvarphi_i%5Cleft(%5Cboldsymbol%7Bx%7D_%7Bk%2B1%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此，积累位势可写成<img src="https://math.now.sh?inline=K_%7Bk%2B1%7D%28%5Cboldsymbol%7Bx%7D%29%3D%5Csum_%7Bi%3D1%7D%5Em%20%5Cboldsymbol%7BC%7D_i(k%2B1)%20%5Cvarphi_i(%5Cboldsymbol%7Bx%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cboldsymbol%7BC%7D_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可用迭代式求得。</p><p>第二类势函数：选择双变量<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=x_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的对称函数作为势函数，即<img src="https://math.now.sh?inline=K%28x%2C%20x_k%29%3DK(x_k%2C%20x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，并且它可展开成无穷级数。</p><p>例如：</p><p><img src="https://math.now.sh?inline=K%5Cleft%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7Bx%7D_k%5Cright%29%3De%5E%7B-%5Calpha%5Cleft%5C%7C%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bx%7D_k%5Cright%5C%7C%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=K%5Cleft%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7Bx%7D_k%5Cright%29%3D%5Cfrac%7B1%7D%7B1%2B%5Calpha%5Cleft%5C%7C%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bx%7D_k%5Cright%5C%7C%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是正常数</p><p><img src="https://math.now.sh?inline=K%5Cleft%28%5Cboldsymbol%7Bx%7D%2C%20%5Cboldsymbol%7Bx%7D_k%5Cright%29%3D%5Cfrac%7B%5Csin%20%5Calpha%5Cleft%5C%7C%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bx%7D_k%5Cright%5C%7C%5E2%7D%7B%5Calpha%5Cleft%5C%7C%5Cboldsymbol%7Bx%7D-%5Cboldsymbol%7Bx%7D_k%5Cright%5C%7C%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>用第二类势函数，当训练样本维数和数目都较高时，需要计算和存储的指数项较多。</p><p>因为势函数由许多新项组成，因此有很强的分类能力。</p><h2 id="决策树简介">决策树简介</h2><p>决策树，或称多级分类器，是模式识别中进行分类的一种有效方法，对于多类或多峰分布问题，这种方法尤为方便。利用树分类器可以把一个复杂的多类别分类问题，转化为若干个简单的分类问题来解决。它不是企图用一种算法、一个决策规则去把多个类别一次分开，而是采用分级的形式，使分类问题逐步得到解决。</p><p>一般来讲，一个决策树由一个根节点<img src="https://math.now.sh?inline=n_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，一组非终止节点<img src="https://math.now.sh?inline=n_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和一些终止节点<img src="https://math.now.sh?inline=t_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>组成，可对<img src="https://math.now.sh?inline=t_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>标以各种类别标签，有时不同的终止节点上可以出现相同的类别标签。</p><p>如果用<img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示决策树，则一个决策树<img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对应于特征空间的一种划分，它把特征空间分成若干个区域，在每个区域中，某类的样本占优势，因此可以标出该类样本的类别标签。</p><p>决策树的一种简单形式是二叉树，它是指除叶结点外，树的每个节点仅分为两个分支，即每个非终止节点<img src="https://math.now.sh?inline=n_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>都有且仅有两个子节点<img src="https://math.now.sh?inline=n_%7Bil%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=n%7Bir%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>二叉树结构分类器可以把一个复杂的多类别分类问题转化为多级多个两类问题来解决，在每个非终止节点<img src="https://math.now.sh?inline=n_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>都把样本集分成左右两个子集。分成的每一部分仍然可能包含多个类别的样本，可以把每一部分再分成两个子集，如此下去，直至分成的每一部分只包含同一类别的样本，或某一类样本占优势为止。</p><p>二叉树结构分类器概念简单、直观、便于解释，而且在各个节点上可以选择不同的特征和采用不同的决策规则，因此设计方法灵活多样，便于利用先验知识来获得一个较好的分类器。</p><p>在设计一个决策树时，主要应解决以下几个问题：</p><ul><li>选择一个合适的树结构，即合理安排树的节点和分支；</li><li>确定在每个非终止节点上要使用的特征；</li><li>在每个非终止节点上选择合适的决策规则。</li></ul><p>把一个多类别分类问题转化为两类问题的形式是多种多样的，因此，对应的二叉树的结构也是各不相同的。通常的目的是要找一个最优的决策树。一个性能良好的决策树结构应该具有小的错误率和低的决策代价。但是由于很难把错误率的解析表达式和树的结构联系起来，而且在每个节点上所采用的决策规则也仅仅是在该节点上所采用的特征观测值的函数，因此，即使每个节点上的性能都达到最优，也不能说整个决策树的性能达到最优。在实际问题中，人们往往提出其它一些优化准则，例如极小化整个树的节点数目，或从根节点到叶结点的最大路经长度，或从根节点到叶结点的平均路经长度等，然后采用动态规划的方法，力争设计出能满足某种准则的“最优”决策树。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Pattern Recognition and Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第2讲 搜索</title>
    <link href="/2022/09/08/UCAS/advanced-ai/advanced-ai-2/"/>
    <url>/2022/09/08/UCAS/advanced-ai/advanced-ai-2/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第2讲 搜索</p><span id="more"></span><h1>第2讲 搜索</h1><h2 id="搜索问题：有策略有规律的探索">搜索问题：有策略有规律的探索</h2><p>搜索问题是对原问题的建模</p><p>搜索问题的构成：状态空间➡后继函数（状态转化为另一个状态，采取的动作，付出的代价）➡初始状态和目标测试</p><p><strong>解是一个行动序列，将初始状态转换成目标状态</strong></p><p>例1：罗马尼亚旅行：</p><p><a href="https://imgse.com/i/vqG77Q"><img src="https://s1.ax1x.com/2022/09/08/vqG77Q.md.png" alt="vqG77Q.md.png"></a></p><ul><li>①状态空间：所有城市</li><li>②后继函数：沿着道路从一个城市到达另外一个城市，损失函数是距离</li><li>③初始状态：这个人现在在Arad</li><li>④目标测试：目前是否到达了Bucharest</li></ul><p>解：从Arad到Bucharest的最短路径</p><p>例2：吃豆子游戏</p><p><a href="https://imgse.com/i/vqJwNj"><img src="https://s1.ax1x.com/2022/09/08/vqJwNj.png" alt="vqJwNj.png"></a></p><p>状态空间包含了环境中的每一个细节：Agent，Ghost，大的豆子和小的豆子</p><p>搜索状态只保留行动需要的细节：</p><p>对于走到终点来说：</p><ul><li>①状态空间：Agent的位置信息</li><li>②后继函数：四个方向进行行走，更新位置信息</li><li>③目标测试：是否到达了终点</li></ul><p>对于吃掉所有豆子来说：</p><ul><li>①状态空间：Agent的位置信息和<strong>每一个点的状态（豆子吃没吃掉）</strong></li><li>②后继函数：四个方向进行行走，<strong>更新位置信息，更新豆子的信息</strong></li><li>③目标测试：<strong>全部豆子是否都被吃光</strong></li></ul><p>状态数量计算：</p><ul><li>Agent的状态：120</li><li>食物数量：30</li><li>鬼魂的位置：12*12</li><li>朝向：4</li><li>世界状态：<img src="https://math.now.sh?inline=120*2%5E%7B30%7D*12%5E2*4" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>路线规划状态：120</li><li>“吃光豆子”状态：<img src="https://math.now.sh?inline=120*2%5E%7B30%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ul><p>例3：三个传教士和三个野人</p><p>状态空间：{(M, C, B)}，表示河左岸的传教士数量、野人数量和船目前的方位</p><p>后继函数：{P01, P10, P02, P20, P11, Q01, Q10, Q02, Q20, Q11}，P表示现在是从左岸到右岸，后面两个数字表示船上的传教士数量和野人数量</p><p>初始状态：(3, 3, 1)</p><p>目标状态：(0, 0, 0)</p><p>状态空间图：搜索问题的数学表示，在状态空间图中，每个状态只出现一次</p><p>搜索树：</p><ul><li>根节点对应了初始状态</li><li>子节点对应了父节点的后继</li><li>节点显示状态，但对应的是到达这些状态的行动</li><li>对大多数问题，实际上不会构建整个树，一般都会剪枝</li></ul><p>状态空间图的每一个结点表示每一个状态</p><p>搜索树的每一个结点不表示状态，而是从初始状态到这个状态的一个路径（因此要尽量少构建搜索树的结点）</p><h2 id="无信息搜索">无信息搜索</h2><p>基于搜索树的搜索：</p><ul><li>扩展出潜在的行动 (tree nodes)</li><li>维护所考虑行动的边缘(fringe)节点</li><li>试图扩展尽可能少的树节点</li></ul><p>搜索算法特性：</p><ul><li>完备性: 当问题有解时，保证能找到一个解?</li><li>最优性: 保证能找到最优解（最小耗散路径）?</li><li>时间复杂度和空间复杂度？</li></ul><p>所有搜索算法都是相同的，除了对边缘的处理策略</p><h3 id="深度优先搜索">深度优先搜索</h3><ul><li>在找到目标之前，搜索到整个树左侧的一些子树</li><li>可以遍历整个树</li><li>分支因子为<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，最大深度为<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<strong>时间复杂度为<img src="https://math.now.sh?inline=O%28b%5Em%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></strong>，<strong>空间复杂度为<img src="https://math.now.sh?inline=O%28bm%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></strong>（因为只保留了路径上的结点）</li><li>完备性：<strong>不完备</strong>。如果<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>无穷大，无法在可以接受的时间内找到解</li><li><strong>不是最优的</strong>：只去找最左边的结点</li></ul><h3 id="广度优先搜索">广度优先搜索</h3><ul><li>在找到目标之前，搜索到全部更浅的结点</li><li>分支因子为<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，最大深度为<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，解的深度为<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<strong>时间复杂度为<img src="https://math.now.sh?inline=O%28b%5Ed%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></strong>，<strong>空间复杂度为<img src="https://math.now.sh?inline=O%28b%5Ed%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></strong></li><li>完备性：<strong>完备</strong>。因为如果解存在，<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>一定是有限的</li><li>只有所有的路径代价都相同时才是<strong>最优的</strong></li></ul><h3 id="迭代深入搜索（Iterative-Deepening）">迭代深入搜索（Iterative Deepening）</h3><p>结合DFS的空间优势与BFS的时间优势</p><p>深度优先按照层数进行约束，不要搜索到<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>层</p><p>通常绝大多数的节点都在底层，所以上层的节点生成多次影响不是很大</p><h3 id="代价敏感搜索（Cost-Sensitive-Search）">代价敏感搜索（Cost-Sensitive Search）</h3><p>代价一致搜索(Uniform Cost Search)：将之前的走过的路径的代价进行一个累加，然后寻找其代价最低的路径。</p><p>可以看成代价敏感搜索的一种实现。</p><ul><li>在找到目标之前，搜索到比代价最小的方式更小代价的结点</li><li>解的代价为<img src="https://math.now.sh?inline=C%5E*" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，每条结点间连线的代价大概为<img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<strong>时间复杂度为<img src="https://math.now.sh?inline=O%28b%5E%7B%5Cfrac%7BC%5E*%7D%7B%5Cepsilon%7D%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，空间复杂度为<img src="https://math.now.sh?inline=O%28b%5E%7B%5Cfrac%7BC%5E*%7D%7B%5Cepsilon%7D%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></strong></li><li>完备性：<strong>完备</strong>。前提是代价都是有限且都为正数。</li><li><strong>最优的</strong></li></ul><h2 id="启发式搜索">启发式搜索</h2><p>启发策略：<strong>估计一个状态到目标距离的函数</strong>，问题给予算法的额外信息，为特定搜索问题而设计。</p><h3 id="贪婪搜索">贪婪搜索</h3><p>策略：扩展你认为最接近目标状态的节点</p><p>启发式：对每个状态估计到最近目标的距离（曼哈顿距离或者欧氏距离），只使用启发函数<img src="https://math.now.sh?inline=f%28n%29%3Dh(n)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来评价节点</p><p>通常情况下最佳优先使你直接（或很快）到达目标，最坏情况类似DFS</p><h3 id="A-搜索">A* 搜索</h3><p>结合代价一致搜索和贪婪搜索</p><p>重点搜索评价函数：<img src="https://math.now.sh?inline=f%28n%29%20%3D%20g(n)%20%2B%20h(n)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g%28n%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示路径的代价，或者称为后向的代价</p><p><img src="https://math.now.sh?inline=h%28n%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示前方距离目标的距离，或者称为前向的代价</p><p>A* 搜索将两个代价进行组合</p><p>A* 搜索结束条件是目标出列的时候，而不是目标入列的时候，因为目标入列的时候可能路径并不是最优的。</p><p>A*搜索不一定是最优的，启发函数要好好选择</p><p>启发函数<img src="https://math.now.sh?inline=h" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<strong>可采纳的</strong>，那么<img src="https://math.now.sh?inline=0%E2%89%A4h%28n%29%E2%89%A4h%5E*(n)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=h%5E*%28n%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是到最近目标的真实耗散。（例如曼哈顿距离）</p><p>前提：启发函数<img src="https://math.now.sh?inline=h" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<strong>可采纳的</strong>，那么A* 树搜索是最优的。</p><ul><li>代价一致搜索在所有“方向”上等可能的扩展</li><li>A*搜索主要朝着目标扩展，而且能够保证最优性</li></ul><p>对于解决难的搜索问题，大部分工作就是想出可采纳的启发函数。通常可采纳启发函数是松弛问题的解的耗散</p><p><strong>A*图搜索与树搜索的区别在于图搜索不允许访问相同结点</strong></p><p>图搜索中，如果启发函数是一致的，A* 搜索是最优的。</p><p>一致的：启发函数不仅仅要是可采纳的，同时在每一个局部的位置也要合理。</p><p><img src="https://math.now.sh?inline=h%28A%29%20%E2%80%93%20h(C)%20%E2%89%A4%20cost(A%20to%20C)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>也就是：如果沿路径的节点估计耗散<img src="https://math.now.sh?inline=f" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>值单调递增，即<img src="https://math.now.sh?inline=h%28A%29%20%E2%89%A4%20cost(A%20to%20C)%20%2B%20h(C)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，那么A*图搜索具备最优性。</p><p>通常，天然的可采纳启发函数是倾向于一致的，特别是从松弛问题中获得的启发函数</p><h2 id="局部搜索">局部搜索</h2><p>树搜索在边缘集合中保留未探索的替代路径（确保完备性）</p><p>局部搜索: 改进单一选项直到不能再改善为止</p><p>爬山法搜索</p><p>模拟退火搜索：避免局部极大（允许向山下移动）</p><p>遗传算法——自然选择</p><ul><li>基于适应度函数，在每步中保留N个最好状态</li><li>配对杂交操作</li><li>产生可选的变异</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第4讲 通配查询与拼写矫正</title>
    <link href="/2022/09/08/UCAS/information-retrieval/information-retrieval-4/"/>
    <url>/2022/09/08/UCAS/information-retrieval/information-retrieval-4/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第4讲 通配查询与拼写矫正</p><span id="more"></span><h1>第4讲 通配查询与拼写矫正</h1><h2 id="词典">词典</h2><p>词典是指存储词项词汇表的数据结构：<strong>作用：存储词项以及定位词项</strong></p><p>词项词汇表指的是具体数据，而词典指的是数据结构</p><p>采用定长数组的词典结构对每个词项需要存储文档频率和指向倒排记录表的指针</p><p>词项定位（查词典）：在词典中查找给定关键字</p><p>用于词项定位的数据结构：主要是哈希表和树</p><p>有些IR系统用哈希表，有些系统用树结构</p><p>采用哈希表或树的准则：</p><ul><li>词项数目是否固定（词项数目是否持续增长）<strong>（固定采用哈希表更好，因为快，但是动态更新的代价比较高）</strong></li><li>词项的相对访问频率如何</li><li>词项的数目有多少</li></ul><p>哈希函数：输入词项，输出正整数（通常是地址）</p><ul><li>每个词项通过哈希函数映射成一个整数</li><li>尽可能避免冲突</li><li>查询处理时： 对查询词项进行哈希，如果有冲突，则解决冲突，最后在定长数组中定位</li><li>优点：<ul><li>在哈希表中的定位速度快于树中的定位速度</li><li>查询时间是常数</li></ul></li><li>缺点：<ul><li>无法处理词项的微小变形</li><li>不支持前缀搜索</li><li>如果词汇表不断增大，需要定期对所有词项重新哈希</li></ul></li></ul><p>树</p><p>树可以支持前缀查找(相当于对词典再建一层索引)</p><p>最简单的树结构：二叉树，搜索速度略低于哈希表方式，时间复杂度为<img src="https://math.now.sh?inline=O%28logM%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>, 其中<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是词汇表大小，即所有词项的数目</p><p>且<img src="https://math.now.sh?inline=O%28logM%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>仅仅对平衡树成立，使二叉树重新保持平衡开销很大</p><p>B-树：每个内部节点的子节点数目在<img src="https://math.now.sh?inline=%5Ba%2C%20b%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>之间，其中<img src="https://math.now.sh?inline=a%2C%20b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为合适的正整数</p><h2 id="通配查询">通配查询</h2><p>通配查询：包含通配符的查询</p><p>mon*: 找出所有包含以mon开头的词项的文档</p><p>如果采用B-树词典结构，那么实现起来非常容易，只需要返回区间mon ≤ t &lt; moo上的词项t</p><p>*mon: 找出所有包含以mon结尾的词项的文档</p><p>将所有的词项倒转过来，然后基于它们建一棵附加的树，返回区间nom ≤ t &lt; non上的词项t</p><p>词项中间的*号处理：mnchen</p><ul><li>在B-树中分别查找满足m*和 *nchen的词项集合，然后求交集（开销很大）</li></ul><p>轮排索引：<strong>（主要思想：让星号出现在词汇的末尾）</strong></p><ul><li>将每个通配查询旋转，使*出现在末尾</li><li>将每个旋转后的结果存放在词典中，即B-树中</li></ul><p>轮排索引的查找过程：</p><ul><li>将查询进行旋转，将通配符旋转到右部</li><li>同以往一样查找B-树，得到匹配的所有词项，将这些词项对应的倒排记录表取出</li></ul><p>相对于通常的B-树，轮排索引(轮排树)的空间要大4倍以上 (经验值)</p><p>k-gram索引：枚举一个词项中所有连读的k个字符构成k-gram</p><ul><li>构建一个倒排索引，此时词典部分是所有的k-gram，倒排记录表部分是包含某个k-gram的所有词项</li><li>相当于对词项再构建一个倒排索引（二级索引）</li><li>比轮排索引空间开销要小</li><li>但是可能返回一些伪正例，需要进行后过滤</li></ul><p>k-gram存在两个倒排索引：</p><ul><li>词典-文档的倒排索引基于词项返回文档</li><li>k-gram索引用于查找词项，即基于查询所包含的k-gram来查找所有的词项</li></ul><p>k-gram索引 vs. 轮排索引</p><ul><li>k-gram索引的空间消耗小</li><li>轮排索引不需要进行后过滤</li></ul><h2 id="拼写矫正">拼写矫正</h2><p>涉及的任务：拼写错误检测和拼写错误矫正（并不是先后的关系）</p><p>错误种类：非词汇错误（纠正的时候不需要考虑上下文）和真实词汇错误（纠正的时候需要考虑上下文）</p><p>两个主要用途</p><ul><li>纠正待索引文档</li><li>纠正用户的查询</li></ul><p>非词汇拼写错误检测：词典中不存在的词均视为错误</p><ul><li>一般来说，词典越大越好</li><li>Web很大，但是充满了拼写错误，因此并不是一个很好的词典</li></ul><p>非词汇拼写错误矫正：</p><ul><li>产生候选：与错误书写的单词相似的真实词汇</li><li>选择最好的候选词：最短加权编辑距离和最高噪声通道概率</li><li>候选集：找到发音相似的候选词、找到拼写相似的候选词、将 w 也包括在候选集里</li></ul><p>词独立法：</p><ul><li>词典中不存在的词均视为错误</li><li>只检查每个单词本身的拼写错误</li><li>但是如果某个单词拼写错误后变成另外一个单词，则无法查出</li></ul><p>采用拼写噪声通道模型：通过贝叶斯定理求解：</p><p>正确拼写为<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，错误拼写为<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=w%3Dargmax%20P%28w%7Cx%29%3Dargmax%20P(x%7Cw)P(w)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=P%28w%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可以通过文档进行估计</p><ul><li>拼写相近的词：Damerau-Levenshtein编辑距离（插入、删除、替换、两个相邻字母的替换）<ul><li>80% 的拼写错误到正确拼写的编辑距离 = 1，几乎所有拼写错误到正确拼写的编辑距离 &lt;= 2</li></ul></li></ul><p>产生候选词的方法：</p><ol><li>遍历词典，计算每一个词的编辑距离</li><li>生成所有编辑距离 ≤ k (例如, k = 1 或 2)的词，然后与词典取交集</li><li>建立一个字符k-gram索引，从词典中找到共享最多k-grams的词项（例如，基于Jaccard系数计算）</li><li>使用Levenshtein 有限状态转换机快速计算</li><li>预先计算一个词项到可能的 正确词项/拼写错误的映射表</li></ol><p>语言模型</p><p>若有包含<img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个词条的大文本语料，则<img src="https://math.now.sh?inline=P%28w%29%3D%5Cfrac%7BC(w)%7D%7BT%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=C%28w%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是词频。（一元先验概率）</p><p>通道模型概率-计算错误概率<img src="https://math.now.sh?inline=P%28x%7Cw%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：混淆“矩阵”（计算一个字符变为另一个字符的概率如何）</p><ul><li>混淆矩阵构建也可以考虑键盘的邻近型</li></ul><p>然后可以计算噪声通道模型</p><p>计算的过程中可以添加加一概率平滑：上述混淆矩阵的例子很难避免某种操作样本数为0，要避免这种概率为0的情况</p><p><strong>真实词汇错误的纠正通常需要考虑上下文</strong></p><p>上下文敏感法：</p><ul><li>纠错时要考虑周围的单词</li><li>产生候选：与错误书写的单词相似的真实词汇<ul><li>找到发音相似的候选词</li><li>找到拼写相似的候选词</li><li>选择最好的候选词：最短加权编辑距离、最高噪声通道概率</li></ul></li></ul><p>真实词汇拼写矫正的噪声通道：二元语言模型，将一元模型与二元模型插值</p><ul><li>给定句子，为每个词产生一个候选词集合，最后选择序列使得概率最大</li></ul><p>通道模型的改进：</p><ul><li>为概率增加一个权重</li><li>允许更丰富的编辑操作</li><li>将发音融入到通道模型中</li><li>将设备融入到通道模型中</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第11章 数据结构</title>
    <link href="/2022/09/07/Leetcode/Leetcode-101/Leetcode-101-11/"/>
    <url>/2022/09/07/Leetcode/Leetcode-101/Leetcode-101-11/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第11章 数据结构</p><span id="more"></span><h1>数据结构</h1><h2 id="数组">数组</h2><h3 id="Leetcode-448">Leetcode 448</h3><p>给你一个含 <code>n</code> 个整数的数组 <code>nums</code> ，其中 <code>nums[i]</code> 在区间 <code>[1, n]</code> 内。请你找出所有在 <code>[1, n]</code> 范围内但没有出现在 <code>nums</code> 中的数字，并以数组的形式返回结果。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vt</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            vt[nums[i]] = <span class="hljs-literal">true</span>;        &#125;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">if</span>(vt[i] == <span class="hljs-literal">false</span>)&#123;                result.<span class="hljs-built_in">push_back</span>(i);            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：扫一遍确认一下，再扫一遍找出结果。</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-48">Leetcode 48</h3><p>给定一个  n × n 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像原地顺时针旋转 90 度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;        <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>, n = matrix.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n / <span class="hljs-number">2</span>; ++i) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n - i; ++j) &#123;                temp = matrix[j][n-i];                matrix[j][n-i] = matrix[i][j];                matrix[i][j] = matrix[n-j][i];                matrix[n-j][i] = matrix[n-i][n-j];                matrix[n-i][n-j] = temp;            &#125;        &#125;    &#125;&#125;;</code></pre></div><p>分析：转转转</p><p>错误：没想到原地旋转的思路。</p><h3 id="Leetcode-240">Leetcode 240</h3><p>编写一个高效的算法来搜索 <code>m x n</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：每行的元素从左到右升序排列，每列的元素从上到下升序排列。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> y = n<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n)&#123;            <span class="hljs-keyword">if</span>(matrix[x][y] == target)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; matrix[x][y])&#123;                y -= <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                x += <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>分析：从右上角开始查找，若当前值大于待搜索值，我们向左移动一位；若当前值小于待搜索值，我们向下移动一位。如果最终移动到左下角时仍不等于待搜索值，则说明待搜索值不存在于矩阵中。</p><p>错误：找到思路后一遍AC</p><h3 id="Leetcode-769">Leetcode 769</h3><p>给定一个长度为 <code>n</code> 的整数数组 <code>arr</code> ，它表示在 <code>[0, n - 1]</code> 范围内的整数的排列。我们将 <code>arr</code> 分割成若干 <strong>块</strong> (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。返回数组能分成的最多块数量。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxChunksToSorted</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;        <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> maxnum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            maxnum = <span class="hljs-built_in">max</span>(maxnum,arr[i]);            <span class="hljs-keyword">if</span>(maxnum == i)&#123;                ++result;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，我们可以多一次分割。</p><p>错误：看了思路后实现的</p><h2 id="栈和队列">栈和队列</h2><h3 id="Leetcode-232">Leetcode 232</h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;    stack&lt;<span class="hljs-type">int</span>&gt; st1;    stack&lt;<span class="hljs-type">int</span>&gt; st2;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MyQueue</span>() &#123;    &#125;      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;        st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(x);    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>())&#123;            st<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>());            st<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-type">int</span> a = st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>();        st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;            st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>());            st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-keyword">return</span> a;    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>())&#123;            st<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>());            st<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-type">int</span> a = st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>();        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;            st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>());            st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-keyword">return</span> a;    &#125;      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>();    &#125;&#125;;</code></pre></div><p>分析：比较简单，也没有算法</p><p>错误：全局变量没定义好，返回值漏掉了，调通了。</p><h3 id="Leetcode-155">Leetcode 155</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;    stack&lt;<span class="hljs-type">int</span>&gt; s1;    stack&lt;<span class="hljs-type">int</span>&gt; mins;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MinStack</span>() &#123;    &#125;      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;        <span class="hljs-keyword">if</span>(mins.<span class="hljs-built_in">empty</span>() || val &lt;= mins.<span class="hljs-built_in">top</span>())&#123;            mins.<span class="hljs-built_in">push</span>(val);        &#125;        s<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(val);    &#125;      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-type">int</span> a = s<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>();        s<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">if</span>(mins.<span class="hljs-built_in">top</span>() == a)&#123;            mins.<span class="hljs-built_in">pop</span>();        &#125;    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> s<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>();    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> mins.<span class="hljs-built_in">top</span>();    &#125;&#125;;</code></pre></div><p>分析：可以额外建立一个新栈，栈顶表示原栈里所有值的最小值。每当在原栈里插入一个数字时，若该数字小于等于新栈栈顶，则表示这个数字在原栈里是最小值，我们将其同时插入新栈内。每当从原栈里取出一个数字时，若该数字等于新栈栈顶，则表示这个数是原栈里的最小值之一，我们同时取出新栈栈顶的值。</p><p>错误：没有思路</p><h3 id="Leetcode-20">Leetcode 20</h3><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;        stack&lt;<span class="hljs-type">char</span>&gt; st;        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span>)&#123;                st.<span class="hljs-built_in">push</span>(s[i]);            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;                    st.<span class="hljs-built_in">pop</span>();                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;                    st.<span class="hljs-built_in">pop</span>();                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; s[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;                    st.<span class="hljs-built_in">pop</span>();                &#125;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>分析：用栈进行匹配即可</p><p>错误：没有考虑只有一个左括号的情况，改正后调通了</p><h2 id="单调栈">单调栈</h2><h3 id="Leetcode-739">Leetcode 739</h3><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;        <span class="hljs-type">int</span> n = temperatures.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(n)</span></span>;        stack&lt;<span class="hljs-type">int</span>&gt; s;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;                <span class="hljs-type">int</span> pre_index = s.<span class="hljs-built_in">top</span>();                <span class="hljs-keyword">if</span> (temperatures[i] &lt;= temperatures[pre_index]) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                s.<span class="hljs-built_in">pop</span>();                answer[pre_index] = i - pre_index;            &#125;            s.<span class="hljs-built_in">push</span>(i);        &#125;        <span class="hljs-keyword">return</span> answer;    &#125;&#125;;</code></pre></div><p>分析：我们可以维持一个单调递减的栈，表示每天的温度；为了方便计算天数差，我们这里存放位置（即日期）而非温度本身。我们从左向右遍历温度数组，对于每个日期p，如果p的温度比栈顶存储位置q的温度高，则我们取出q，并记录q需要等待的天数为p-q；我们重复这一过程，直到p的温度小于等于栈顶存储位置的温度（或空栈）时，我们将p插入栈顶，然后考虑下一天。在这个过程中，栈内数组永远保持单调递减，避免了使用排序进行比较。最后若栈内剩余一些日期，则说明它们之后都没有出现更暖和的日期。</p><p>错误：感觉并不是非常理解。</p><h2 id="优先队列">优先队列</h2><h3 id="Leetcode-23">Leetcode 23</h3><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Comp</span>&#123;        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(ListNode* l1,ListNode* l2)</span></span>&#123;            <span class="hljs-keyword">return</span> l1-&gt;val &gt; l2-&gt;val;        &#125;    &#125;;    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;        &#125;        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,Comp&gt; q;        <span class="hljs-keyword">for</span>(ListNode* list:lists)&#123;            <span class="hljs-keyword">if</span>(list)&#123;                q.<span class="hljs-built_in">push</span>(list);            &#125;        &#125;        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), *cur = dummy;        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;            cur-&gt;next = q.<span class="hljs-built_in">top</span>();            q.<span class="hljs-built_in">pop</span>();            cur = cur-&gt;next;            <span class="hljs-keyword">if</span> (cur-&gt;next) &#123;                q.<span class="hljs-built_in">push</span>(cur-&gt;next);            &#125;        &#125;        <span class="hljs-keyword">return</span> dummy-&gt;next;    &#125;&#125;;</code></pre></div><p>分析：即把所有的链表存储在一个优先队列中，每次提取所有链表头部节点值最小的那个节点，直到所有链表都被提取完为止。</p><p>错误：优先队列不是很熟悉</p><h3 id="Leetcode-218">Leetcode 218</h3><p>给定建筑物的起止位置和高度，返回建筑物轮廓（天际线）的拐点。</p><p>Hard难度，想不太明白，暂时不做了</p><p>分析：使用优先队列储存每个建筑物的高度和右端（这里使用pair，其默认比较函数是先比较第一个值，如果相等则再比较第二个值），从而获取目前会拔高天际线、且妨碍到前一个建筑物（的右端端点）的下一个建筑物。</p><p>错误：没有思路</p><h2 id="双端队列">双端队列</h2><h3 id="Leetcode-239">Leetcode 239</h3><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        deque&lt;<span class="hljs-type">int</span>&gt; dq;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[dq.<span class="hljs-built_in">back</span>()])&#123;                <span class="hljs-keyword">while</span>(!dq.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[dq.<span class="hljs-built_in">back</span>()] &lt; nums[i])&#123;                    dq.<span class="hljs-built_in">pop_back</span>();                &#125;            &#125;            dq.<span class="hljs-built_in">push_back</span>(i);            <span class="hljs-keyword">if</span>(i &gt;= k<span class="hljs-number">-1</span>)&#123;                result.<span class="hljs-built_in">push_back</span>(nums[dq.<span class="hljs-built_in">front</span>()]);                <span class="hljs-keyword">if</span>(nums[i-k<span class="hljs-number">+1</span>] == nums[dq.<span class="hljs-built_in">front</span>()])&#123;                    dq.<span class="hljs-built_in">pop_front</span>();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：利用双端队列进行操作：每当向右移动时，把窗口左端的值从队列左端剔除，把队列右边小于窗口右端的值全部剔除。这样双端队列的最左端永远是当前窗口内的最大值。</p><p>错误：理解了思路后调通了。</p><h2 id="哈希表">哈希表</h2><h3 id="Leetcode-1">Leetcode 1</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出和为目标值 <code>target</code>的那<strong>两个</strong>整数，并返回它们的数组下标。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">count</span>(target - nums[i]))&#123;                result.<span class="hljs-built_in">push_back</span>(hash[target - nums[i]]);                result.<span class="hljs-built_in">push_back</span>(i);                <span class="hljs-keyword">break</span>;            &#125;            hash[nums[i]] = i;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：利用哈希表存储遍历过的值以及它们的位置，每次遍历到位置i 的时候，查找哈希表里是否存在target - nums[i]，若存在，则说明这两个值的和为target。</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-128">Leetcode 128</h3><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        unordered_set&lt;<span class="hljs-type">int</span>&gt; hash;        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; num:nums)&#123;            hash.<span class="hljs-built_in">insert</span>(num);        &#125;        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(!hash.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> cnt = *(hash.<span class="hljs-built_in">begin</span>());            hash.<span class="hljs-built_in">erase</span>(cnt);            <span class="hljs-type">int</span> pre = cnt - <span class="hljs-number">1</span>;            <span class="hljs-type">int</span> next = cnt + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(!hash.<span class="hljs-built_in">empty</span>() &amp;&amp; hash.<span class="hljs-built_in">count</span>(pre))&#123;                hash.<span class="hljs-built_in">erase</span>(pre);                --pre;            &#125;            <span class="hljs-keyword">while</span>(!hash.<span class="hljs-built_in">empty</span>() &amp;&amp; hash.<span class="hljs-built_in">count</span>(next))&#123;                hash.<span class="hljs-built_in">erase</span>(next);                ++next;            &#125;            ans = <span class="hljs-built_in">max</span>(ans,next-pre<span class="hljs-number">-1</span>);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：把所有数字放到一个哈希表，然后不断地从哈希表中任意取一个值，并删除掉其之前之后的所有连续数字，然后更新目前的最长连续序列长度。重复这一过程，我们就可以找到所有的连续数字序列。</p><p>错误：看了思路后实现了</p><h3 id="Leetcode-149">Leetcode 149</h3><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;        unordered_map&lt;<span class="hljs-type">double</span>, <span class="hljs-type">int</span>&gt; hash; <span class="hljs-comment">// &lt;斜率, 点个数&gt;</span>        <span class="hljs-type">int</span> max_count = <span class="hljs-number">0</span>, same = <span class="hljs-number">1</span>, same_y = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; points.<span class="hljs-built_in">size</span>(); ++i) &#123;            same = <span class="hljs-number">1</span>, same_y = <span class="hljs-number">1</span>;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; points.<span class="hljs-built_in">size</span>(); ++j) &#123;                <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">1</span>] == points[j][<span class="hljs-number">1</span>]) &#123;                    ++same_y;                    <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] == points[j][<span class="hljs-number">0</span>]) &#123;                        ++same;                    &#125;                &#125;                <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-type">double</span> dx = points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>], dy = points[i][<span class="hljs-number">1</span>] -                    points[j][<span class="hljs-number">1</span>];                    ++hash[dx/dy];                &#125;            &#125;            max_count = <span class="hljs-built_in">max</span>(max_count, same_y);            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : hash) &#123;                max_count = <span class="hljs-built_in">max</span>(max_count, same + item.second);            &#125;            hash.<span class="hljs-built_in">clear</span>();        &#125;        <span class="hljs-keyword">return</span> max_count;    &#125;&#125;;</code></pre></div><p>分析：对于每个点，我们对其它点建立哈希表，统计同一斜率的点一共有多少个。这里利用的原理是，一条线可以由一个点和斜率而唯一确定。另外也要考虑斜率不存在和重复坐标的情况。</p><p>错误：好麻烦先算了</p><h2 id="多重集合和映射">多重集合和映射</h2><h3 id="Leetcode-332">Leetcode 332</h3><p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [from&lt;sub&gt;i&lt;/sub&gt;, to&lt;sub&gt;i&lt;/sub&gt;]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">findItinerary</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt;&amp; tickets)</span> </span>&#123;        vector&lt;string&gt; ans;        <span class="hljs-keyword">if</span> (tickets.<span class="hljs-built_in">empty</span>()) &#123;            <span class="hljs-keyword">return</span> ans;        &#125;        unordered_map&lt;string, multiset&lt;string&gt;&gt; hash;        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; ticket: tickets) &#123;            hash[ticket[<span class="hljs-number">0</span>]].<span class="hljs-built_in">insert</span>(ticket[<span class="hljs-number">1</span>]);        &#125;        stack&lt;string&gt; s;        s.<span class="hljs-built_in">push</span>(<span class="hljs-string">&quot;JFK&quot;</span>);        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;            string next = s.<span class="hljs-built_in">top</span>();            <span class="hljs-keyword">if</span> (hash[next].<span class="hljs-built_in">empty</span>()) &#123;                ans.<span class="hljs-built_in">push_back</span>(next);                s.<span class="hljs-built_in">pop</span>();            &#125;             <span class="hljs-keyword">else</span> &#123;                s.<span class="hljs-built_in">push</span>(*hash[next].<span class="hljs-built_in">begin</span>());                hash[next].<span class="hljs-built_in">erase</span>(hash[next].<span class="hljs-built_in">begin</span>());            &#125;        &#125;        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：本题可以先用哈希表记录起止机场，其中键是起始机场，值是一个多重集合，表示对应的终止机场。因为一个人可能坐过重复的线路，所以我们需要使用多重集合储存重复值。储存完成之后，我们可以利用栈来恢复从终点到起点飞行的顺序，再将结果逆序得到从起点到终点的顺序。</p><p>错误：多重集合的第一道题，也是唯一一道题，不是很明白</p><h2 id="前缀和和积分图">前缀和和积分图</h2><h3 id="Leetcode-303">Leetcode 303</h3><p>设计一个数据结构，使得其能够快速查询给定数组中，任意两个位置间所有数字的和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumArray</span> &#123;    vector&lt;<span class="hljs-type">int</span>&gt; frontsum;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">NumArray</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;                frontsum.<span class="hljs-built_in">push_back</span>(nums[i]);            &#125;            <span class="hljs-keyword">else</span>&#123;                frontsum.<span class="hljs-built_in">push_back</span>(nums[i] + frontsum[i<span class="hljs-number">-1</span>]);            &#125;        &#125;    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRange</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> frontsum[right];        &#125;        <span class="hljs-keyword">return</span> frontsum[right] - frontsum[left<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre></div><p>分析：前缀和即可</p><p>一遍AC</p><h3 id="Leetcode-304">Leetcode 304</h3><p>设计一个数据结构，使得其能够快速查询给定矩阵中，任意两个位置包围的长方形中所有数字的和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumMatrix</span> &#123;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; frontmatrix;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix) &#123;        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            vector&lt;<span class="hljs-type">int</span>&gt; temp;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)&#123;                    temp.<span class="hljs-built_in">push_back</span>(matrix[i][j]);                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;                    temp.<span class="hljs-built_in">push_back</span>(matrix[i][j] + temp[j<span class="hljs-number">-1</span>]);                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;                    temp.<span class="hljs-built_in">push_back</span>(matrix[i][j] + frontmatrix[i<span class="hljs-number">-1</span>][j]);                &#125;                <span class="hljs-keyword">else</span>&#123;                    temp.<span class="hljs-built_in">push_back</span>(matrix[i][j] + frontmatrix[i<span class="hljs-number">-1</span>][j] + temp[j<span class="hljs-number">-1</span>] - frontmatrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]);                &#125;            &#125;            frontmatrix.<span class="hljs-built_in">push_back</span>(temp);        &#125;    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumRegion</span><span class="hljs-params">(<span class="hljs-type">int</span> row1, <span class="hljs-type">int</span> col1, <span class="hljs-type">int</span> row2, <span class="hljs-type">int</span> col2)</span> </span>&#123;        <span class="hljs-keyword">if</span>(row1 == <span class="hljs-number">0</span> &amp;&amp; col1 == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> frontmatrix[row2][col2];        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(row1 == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> frontmatrix[row2][col2]-frontmatrix[row2][col1<span class="hljs-number">-1</span>];        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(col1 == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> frontmatrix[row2][col2]-frontmatrix[row1<span class="hljs-number">-1</span>][col2];        &#125;        <span class="hljs-keyword">return</span> frontmatrix[row2][col2]-frontmatrix[row2][col1<span class="hljs-number">-1</span>]-frontmatrix[row1<span class="hljs-number">-1</span>][col2]+frontmatrix[row1<span class="hljs-number">-1</span>][col1<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre></div><p>分析：二维上的前缀和（积分图）即可</p><p>一遍AC</p><h3 id="Leetcode-560">Leetcode 560</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回该数组中和为 <code>k</code> 的连续子数组的个数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>, psum = <span class="hljs-number">0</span>;        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hashmap;        hashmap[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始化很重要</span>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: nums) &#123;            psum += i;            count += hashmap[psum-k];            ++hashmap[psum];        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;;</code></pre></div><p>分析：本题同样是利用前缀和，不同的是这里我们使用一个哈希表 <code>hashmap</code>，其键是前缀和，而值是该前缀和出现的次数。在我们遍历到位置i 时，假设当前的前缀和是 <code>psum </code>，那么 <code>hashmap[psum-k]</code>即为以当前位置结尾、满足条件的区间个数。</p><p>错误：直接使用前缀和会超时，然而这个短代码挺难理解的样子。</p><h2 id="练习">练习</h2><h3 id="Leetcode-566">Leetcode 566</h3><p>在 MATLAB 中，有一个非常有用的函数 <code>reshape</code> ，它可以将一个 <code>m x n</code> 矩阵重塑为另一个大小不同（<code>r x c</code>）的新矩阵，但保留其原始数据。给你一个由二维数组 <code>mat</code> 表示的 <code>m x n</code> 矩阵，以及两个正整数 <code>r</code> 和 <code>c</code> ，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。如果具有给定参数的 <code>reshape</code> 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;        <span class="hljs-type">int</span> m = mat.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(m*n != r*c)&#123;            <span class="hljs-keyword">return</span> mat;        &#125;        <span class="hljs-type">int</span> rowindex = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> colindex = <span class="hljs-number">0</span>;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(r,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;c;++j)&#123;                result[i][j] = mat[rowindex][colindex];                ++colindex;                <span class="hljs-keyword">if</span>(colindex == n)&#123;                    ++rowindex;                    colindex = <span class="hljs-number">0</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：很简单的小题，没有任何难度。</p><p>一遍AC</p><h3 id="Leetcode-225">Leetcode 225</h3><p>用两个队列实现一个栈</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;    queue&lt;<span class="hljs-type">int</span>&gt; q1;    queue&lt;<span class="hljs-type">int</span>&gt; q2;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">MyStack</span>() &#123;    &#125;      <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;        q<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(x);        <span class="hljs-keyword">return</span>;    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span>(q<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>)&#123;            q<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(q<span class="hljs-number">1.f</span>ront());            q<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-type">int</span> a = q<span class="hljs-number">1.f</span>ront();        q<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">while</span>(!q<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;            q<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(q<span class="hljs-number">2.f</span>ront());            q<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-keyword">return</span> a;    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span>(q<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>)&#123;            q<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(q<span class="hljs-number">1.f</span>ront());            q<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-type">int</span> a = q<span class="hljs-number">1.f</span>ront();        q<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(q<span class="hljs-number">1.f</span>ront());        q<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();        <span class="hljs-keyword">while</span>(!q<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;            q<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(q<span class="hljs-number">2.f</span>ront());            q<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();        &#125;        <span class="hljs-keyword">return</span> a;    &#125;      <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> q<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>();    &#125;&#125;;</code></pre></div><p>分析：也是很简单的题，倒腾倒腾数字就行了</p><p>一遍AC</p><h3 id="Leetcode-503">Leetcode 503</h3><p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <code>nums</code> 中每个元素的<strong>下一个更大元素</strong> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        stack&lt;<span class="hljs-type">int</span>&gt; st;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n,<span class="hljs-number">-1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;++i)&#123;            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i%n] &gt; nums[st.<span class="hljs-built_in">top</span>()])&#123;                result[st.<span class="hljs-built_in">top</span>()] = nums[i%n];                st.<span class="hljs-built_in">pop</span>();            &#125;            st.<span class="hljs-built_in">push</span>(i%n);        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：使用单调栈解决本题。单调栈中保存的是下标，从栈底到栈顶的下标在数组 <code>nums</code>中对应的值是单调不升的。每次我们移动到数组中的一个新的位置 <code>i</code>，我们就将当前单调栈中所有对应值小于 <code>nums[i]</code>的下标弹出单调栈，这些值的下一个更大元素即为 <code>nums[i]</code>。随后我们将位置 <code>i</code>入栈。</p><p>错误：没有想到单调栈，看了一下思路后自己实现的。</p><h3 id="Leetcode-217">Leetcode 217</h3><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(nums[i]) == mp.<span class="hljs-built_in">end</span>())&#123;                mp[nums[i]] = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>分析：非常简单的哈希表，没什么难度</p><p>错误：下标和数字插入看的不太对</p><h3 id="Leetcode-697">Leetcode 697</h3><p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的<strong>度</strong>的定义是指数组里任一元素出现频数的最大值。你的任务是在 <code>nums</code> 中找到与 <code>nums</code> 拥有相同大小的度的最短连续子数组，返回其长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findShortestSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        unordered_map&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;&gt; mp;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(nums[i]) == mp.<span class="hljs-built_in">end</span>())&#123;                mp[nums[i]].<span class="hljs-built_in">push_back</span>(i);                mp[nums[i]].<span class="hljs-built_in">push_back</span>(i);                mp[nums[i]].<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(i &lt; mp[nums[i]][<span class="hljs-number">0</span>])&#123;                    mp[nums[i]][<span class="hljs-number">0</span>] = i;                &#125;                <span class="hljs-keyword">if</span>(i &gt; mp[nums[i]][<span class="hljs-number">1</span>])&#123;                    mp[nums[i]][<span class="hljs-number">1</span>] = i;                &#125;                ++mp[nums[i]][<span class="hljs-number">2</span>];            &#125;        &#125;        <span class="hljs-type">int</span> maxnum = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> result = n<span class="hljs-number">+1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">cbegin</span>();it != mp.<span class="hljs-built_in">cend</span>();++it)&#123;            <span class="hljs-keyword">if</span>(it-&gt;second[<span class="hljs-number">2</span>] &gt; maxnum)&#123;                maxnum = it-&gt;second[<span class="hljs-number">2</span>];                result = it-&gt;second[<span class="hljs-number">1</span>]-it-&gt;second[<span class="hljs-number">0</span>]<span class="hljs-number">+1</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it-&gt;second[<span class="hljs-number">2</span>] == maxnum)&#123;                result = <span class="hljs-built_in">min</span>(result,it-&gt;second[<span class="hljs-number">1</span>]-it-&gt;second[<span class="hljs-number">0</span>]<span class="hljs-number">+1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：比较简单的数据结构应用题</p><p>错误：语法问题，还有下标数字问题，后面自己调通</p><h3 id="Leetcode-594">Leetcode 594</h3><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 <strong>正好是 <code>1</code></strong> 。现在，给你一个整数数组 <code>nums</code> ，请你在所有可能的子序列中找到最长的和谐子序列的长度。数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLHS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(nums[i]) == mp.<span class="hljs-built_in">end</span>())&#123;                mp[nums[i]] = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                ++mp[nums[i]];            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">cbegin</span>();it != mp.<span class="hljs-built_in">cend</span>();++it)&#123;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(it-&gt;first<span class="hljs-number">-1</span>) != mp.<span class="hljs-built_in">end</span>())&#123;                ans = <span class="hljs-built_in">max</span>(ans,it-&gt;second + mp[it-&gt;first<span class="hljs-number">-1</span>]);            &#125;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(it-&gt;first<span class="hljs-number">+1</span>) != mp.<span class="hljs-built_in">end</span>())&#123;                ans = <span class="hljs-built_in">max</span>(ans,it-&gt;second + mp[it-&gt;first<span class="hljs-number">+1</span>]);            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：看起来挺像动态规划，实际上并不是，统计一下就好了</p><p>错误：还是map迭代器不太熟练，后面调通。</p><h3 id="Leetcode-287">Leetcode 287</h3><p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> len = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;            <span class="hljs-type">int</span> idx = Math.<span class="hljs-built_in">abs</span>(num);            <span class="hljs-keyword">if</span> (nums[idx] &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> idx;            &#125;            nums[idx] = -nums[idx];        &#125;        <span class="hljs-keyword">return</span> len;    &#125;&#125;;</code></pre></div><p>分析：考虑到数组元素值的范围是 <code>[1,n]</code>，但数组长度为 <code>n+1</code>，那么很显然在遍历数组的时候，我们将数组的值变为其对应的负数，那么再次遇到负数就得到了答案。</p><p>错误：上面不是最优解，没有想到最优解</p><h3 id="Leetcode-313">Leetcode 313</h3><p><strong>超级丑数</strong> 是一个正整数，并满足其所有质因数都出现在质数数组 <code>primes</code> 中。给你一个整数 <code>n</code> 和一个整数数组 <code>primes</code> ，返回第 <code>n</code> 个 <strong>超级丑数</strong> 。题目数据保证第 <code>n</code> 个 <strong>超级丑数</strong> 在 <strong>32-bit</strong> 带符号整数范围内。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">nthSuperUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; primes)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;        <span class="hljs-type">int</span> m = primes.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pointers</span><span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;        <span class="hljs-function">vector&lt;<span class="hljs-type">long</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(m, <span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-type">long</span> minNum = INT_MAX;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;                minNum = <span class="hljs-built_in">min</span>(minNum, nums[j]);            &#125;            dp[i] = minNum;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;                <span class="hljs-keyword">if</span> (nums[j] == minNum) &#123;                    pointers[j]++;                    nums[j] = dp[pointers[j]] * primes[j];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre></div><p>分析：动态规划，没有思路</p><p>错误：没有思路</p><h3 id="Leetcode-870">Leetcode 870</h3><p>给定两个大小相等的数组 <code>nums1</code> 和 <code>nums2</code>，<code>nums1</code> 相对于 <code>nums</code> 的<em>优势</em>可以用满足 <code>nums1[i] &gt; nums2[i]</code> 的索引 <code>i</code> 的数目来描述。返回 <code>nums1 </code>的<strong>任意</strong>排列，使其相对于 <code>nums2</code> 的优势最大化。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">advantageCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;        <span class="hljs-built_in">sort</span>(nums<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(),nums<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; vt;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();i++)&#123;            vt.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(nums2[i],i));        &#125;        <span class="hljs-built_in">sort</span>(vt.<span class="hljs-built_in">begin</span>(),vt.<span class="hljs-built_in">end</span>());        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(nums<span class="hljs-number">2.</span>size())</span></span>;        <span class="hljs-type">int</span> l1=<span class="hljs-number">0</span>,r1=nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,l2=<span class="hljs-number">0</span>,r2=nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(r2&gt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(nums1[r1]&gt;vt[r2].first)&#123;                ans[vt[r2].second]=nums1[r1];                r1--;            &#125;            <span class="hljs-keyword">else</span>&#123;                 ans[vt[r2].second]=nums1[l1];                 l1++;            &#125;            r2--;        &#125;              <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：田忌赛马，能打就打，打不过让最菜的送人头。</p><p>错误：没思路</p><h3 id="Leetcode-307">Leetcode 307</h3><p>线段树先算了</p><h2 id="总结">总结</h2><p>数据结构是最最基础的算法，没有合适的数据结构就不可能有高效的算法。普通的数据结构掌握的还不错，但是有一些比较高级的数据结构练的比较少，掌握的不太好。今后要注重这些比较高级的数据结构，并尽量去在实际中应用。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：模式识别与机器学习-第2章 统计判别</title>
    <link href="/2022/09/06/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-2/"/>
    <url>/2022/09/06/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-2/</url>
    
    <content type="html"><![CDATA[<p>《模式识别与机器学习》课程笔记：第2章 统计判别</p><span id="more"></span><h1>第2章 统计判别</h1><p>统计学（statistics）是用以收集数据，分析数据和由数据得出结论的一组概念、原则和方法。</p><h2 id="作为统计判别问题的模式分类">作为统计判别问题的模式分类</h2><ul><li>模式识别的目的就是要确定某一个给定的模式样本属于哪一类。</li><li>可以通过对被识别对象的<strong>多次</strong>观察和测量，构成特征向量，并将其作为某一个判决规则的输入，按此规则来对样本进行分类。</li><li>在获取模式的观测值时，有些事物具有确定的因果关系，即在一定的条件下，它必然会发生或必然不发生。<ul><li>例如识别一块模板是不是直角三角形，只要凭“三条直线边闭合连线和一个直角”这个特征，测量它是否有三条直线边的闭合连线并有一个直角，就完全可以确定它是不是直角三角形。这种现象是确定性的现象。</li></ul></li><li>但在现实世界中，由许多客观现象的发生，就每一次观察和测量来说，即使在基本条件保持不变的情况下也具有不确定性。</li><li>只有在<strong>大量重复</strong>的观察下，其结果才能呈现出某种规律性，即对它们观察到的特征具有统计特性。</li><li>特征值不再是一个确定的向量，而是一个<strong>随机向量</strong>。</li><li>此时，只能利用模式集的统计特性来分类，以使<strong>分类器发生错误的概率最小</strong>。</li></ul><p>给定观测值<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>,判断其属于类<img src="https://math.now.sh?inline=%5Comega_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>还是类<img src="https://math.now.sh?inline=%5Comega_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，作出某次判断时的错误率是：</p><p><img src="https://math.now.sh?inline=P%28error%5Cmid%20%5Cboldsymbol%7Bx%7D%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bl%7DP%5Cleft(%5Comega_1%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright)%2C%20%5Cboldsymbol%7Bx%7D%20%5Cin%20%5Comega_2%20%5C%5C%20P%5Cleft(%5Comega_2%20%5Cmid%20%5Cboldsymbol%7Bx%7D%5Cright)%2C%20%5Cboldsymbol%7Bx%7D%20%5Cin%20%5Comega_1%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>最小化误差概率条件下，若<img src="https://math.now.sh?inline=P%28%CF%89_1%20%7C%20x%29%20%3E%20P(%CF%89_2%20%7C%20x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；若<img src="https://math.now.sh?inline=P%28%CF%89_2%20%7C%20x%29%20%3E%20P(%CF%89_1%20%7C%20x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><h3 id="贝叶斯判别原则">贝叶斯判别原则</h3><p>两类模式集的分类：</p><p>目的：要确定<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是属于<img src="https://math.now.sh?inline=%5Comega_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类还是<img src="https://math.now.sh?inline=%5Comega_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类，要看<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是来自于<img src="https://math.now.sh?inline=%5Comega_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的概率大还是来自<img src="https://math.now.sh?inline=%5Comega_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的概率大。</p><p>根据概率判别规则，若<img src="https://math.now.sh?inline=P%28%CF%89_1%20%7C%20x%29%20%3E%20P(%CF%89_2%20%7C%20x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；若<img src="https://math.now.sh?inline=P%28%CF%89_2%20%7C%20x%29%20%3E%20P(%CF%89_1%20%7C%20x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>由贝叶斯定理，后验概率<img src="https://math.now.sh?inline=P%28%CF%89_i%20%7C%20x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可由类别<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的先验概率<img src="https://math.now.sh?inline=P%28%CF%89_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的条件概率密度<img src="https://math.now.sh?inline=p%28x%20%7C%20%CF%89_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来计算，即：</p><p><img src="https://math.now.sh?inline=%5Cmathrm%7BP%7D%5Cleft%28%5Comega_%7B%5Cmathrm%7Bi%7D%7D%20%5Cmid%20%5Cmathrm%7Bx%7D%5Cright%29%3D%5Cfrac%7B%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)%7D%7B%5Cmathrm%7Bp%7D(%5Cmathrm%7Bx%7D)%7D%3D%5Cfrac%7B%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)%7D%7B%5Csum_%7B%5Cmathrm%7Bi%7D%3D1%7D%5E%7B2%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=p%28x%20%7C%20%CF%89_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>也称为似然函数。</p><p>与概率判别规则结合，则若<img src="https://math.now.sh?inline=p%28x%20%7C%20%CF%89_1%29P(%CF%89_1)%3Ep(x%20%7C%20%CF%89_2)P(%CF%89_2)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；若<img src="https://math.now.sh?inline=p%28x%20%7C%20%CF%89_2%29P(%CF%89_2)%3Ep(x%20%7C%20%CF%89_1)P(%CF%89_1)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>不等式转换一下：</p><p>若<img src="https://math.now.sh?inline=l_%7B12%7D%28%5Cmathrm%7Bx%7D%29%3D%5Cfrac%7B%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright)%7D%7B%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%7D%3E%5Cfrac%7B%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)%7D%7B%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</p><p>若<img src="https://math.now.sh?inline=l_%7B12%7D%28%5Cmathrm%7Bx%7D%29%3D%5Cfrac%7B%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright)%7D%7B%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%7D%3C%5Cfrac%7B%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)%7D%7B%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</p><p>其中，<img src="https://math.now.sh?inline=l_%7B12%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>称为似然比，<img src="https://math.now.sh?inline=%CE%B8_%7B21%7D%3D%5Cfrac%7BP%28%CF%89_2%29%7D%7BP(%CF%89_1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>称为似然比的判决阈值</p><p>此判别称为贝叶斯判别。</p><p>贝叶斯判别的推广：</p><ul><li>允许使用多于一个特征：标量、向量、多种特征向量</li><li>允许多于两种类别状态的情形</li><li>允许有其他行为而不仅仅是判定类别：如后验概率接近的情况下，如果拒绝判断的代价不大，可以拒绝判断。</li></ul><p><strong>可以通过引入一个更一般的损失函数来替代误差概率</strong></p><h4 id="朴素贝叶斯">朴素贝叶斯</h4><p>特征<img src="https://math.now.sh?inline=x%3D%28x_1%2Cx_2%2C%5Ccdots%2Cx_D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是多维向量时，假设各个特征之间<strong>相互独立</strong></p><p><img src="https://math.now.sh?inline=p%5Cleft%28x_1%2C%20x_2%2C%20x_3%2C%20%5Ccdots%2C%20x_D%20%5Cmid%20%5Comega%5Cright%29%3D%5Cprod_%7Bi%3D1%7D%5ED%20p%5Cleft(x_i%20%5Cmid%20%5Comega%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="贝叶斯最小风险判别">贝叶斯最小风险判别</h3><p>当考虑到对于某一类的错误判决要比对另一类的判决更为关键时，就需要把最小错误概率的贝叶斯判别做一些修正，提出条件平均风险<img src="https://math.now.sh?inline=r_j%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>对<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类问题，如果观察样本被判定属于<img src="https://math.now.sh?inline=%CF%89_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类，则条件平均风险<img src="https://math.now.sh?inline=r_j%28x%29%3D%5Csum_%7Bi%3D1%7D%5EML_%7Bij%7DP(%5Comega_i%20%7C%20x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=L_%7Bij%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为将本应属于<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的模式判别成属于<img src="https://math.now.sh?inline=%CF%89_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的是非代价。</p><p>若<img src="https://math.now.sh?inline=i%3Dj" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即判别正确，得分，<img src="https://math.now.sh?inline=L_%7Bij%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>可以取负值或零，表示不失分。</p><p>若<img src="https://math.now.sh?inline=i%E2%89%A0j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即判别错误，失分，<img src="https://math.now.sh?inline=L_%7Bij%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>应取正值。</p><p>意义：</p><ul><li>对于自然属性是属于<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的模式<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来说，它来自<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的概率应为<img src="https://math.now.sh?inline=P%28%CF%89_i%7Cx%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>如果分类器判别<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是属于<img src="https://math.now.sh?inline=%CF%89_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类，但它实际上来自<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类，也就是说分类器失败，这时<img src="https://math.now.sh?inline=L_%7Bij%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为失分，对应的条件风险为后验概率进行<img src="https://math.now.sh?inline=L_%7Bij%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的加权运算。</li><li>由于模式<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的自然属性可能来自<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类中的任一类，因此可将观察样本指定为<img src="https://math.now.sh?inline=%CF%89_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类的条件平均风险用<img src="https://math.now.sh?inline=r_j%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的公式运算。</li></ul><p>分类器对每一个模式<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>有<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>种可能的类别可供选择，若对每一个<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>计算出全部类别的平均风险值<img src="https://math.now.sh?inline=r_1%28x%29%2Cr_2(x)%2C%E2%80%A6%2Cr_M(x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，并且将<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>指定为是具有最小风险值的那一类，则这种分类器称为最小平均条件风险分类器。</p><p>按贝叶斯公式，最小平均条件风险可写成：</p><p><img src="https://math.now.sh?inline=%5Cmathrm%7Br%7D_%7B%5Cmathrm%7Bj%7D%7D%28%5Cmathrm%7Bx%7D%29%3D%5Cfrac%7B1%7D%7B%5Cmathrm%7Bp%7D(%5Cmathrm%7Bx%7D)%7D%20%5Csum_%7B%5Cmathrm%7Bi%7D%3D1%7D%5E%7B%5Cmathrm%7BM%7D%7D%20%5Cmathrm%7BL%7D_%7B%5Cmathrm%7Bij%7D%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>可以舍去公共项，则可以简化为：</p><p><img src="https://math.now.sh?inline=%5Cmathrm%7Br%7D_%7B%5Cmathrm%7Bj%7D%7D%28%5Cmathrm%7Bx%7D%29%3D%5Csum_%7B%5Cmathrm%7Bi%7D%3D1%7D%5E%7B%5Cmathrm%7BM%7D%7D%20%5Cmathrm%7BL%7D_%7B%5Cmathrm%7Bij%7D%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>也是贝叶斯分类器，只是它的判别方法不是按错误概率最小作为标准，而是按平均条件风险作为标准。</p><p>举例若<img src="https://math.now.sh?inline=M%3D2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：</p><p>当分类器将<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>判别为<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时：<img src="https://math.now.sh?inline=%5Cmathrm%7Br%7D_%7B1%7D%28%5Cmathrm%7Bx%7D%29%3D%5Cmathrm%7BL%7D_%7B11%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%2B%5Cmathrm%7BL%7D_%7B21%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>当分类器将<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>判别为<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时：<img src="https://math.now.sh?inline=%5Cmathrm%7Br%7D_%7B2%7D%28%5Cmathrm%7Bx%7D%29%3D%5Cmathrm%7BL%7D_%7B12%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%2B%5Cmathrm%7BL%7D_%7B22%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>若<img src="https://math.now.sh?inline=r_1%28x%29%3Cr_2(x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>被判定为属于<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，</p><p>此时：<img src="https://math.now.sh?inline=%5Cmathrm%7BL%7D_%7B11%7D%20%5Cmathrm%7Bp%7D%5Cleft%28%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright%29%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%2B%5Cmathrm%7BL%7D_%7B21%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)%3C%20%5Cmathrm%7BL%7D_%7B12%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%2B%5Cmathrm%7BL%7D_%7B22%7D%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>即：<img src="https://math.now.sh?inline=%5Cleft%28%5Cmathrm%7BL%7D_%7B21%7D-%5Cmathrm%7BL%7D_%7B22%7D%5Cright%29%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)%3C%5Cleft(%5Cmathrm%7BL%7D_%7B12%7D-%5Cmathrm%7BL%7D_%7B11%7D%5Cright)%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright)%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>通常<img src="https://math.now.sh?inline=L_%7Bij%7D%3EL_%7Bii%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，因此</p><p>当<img src="https://math.now.sh?inline=%5Cfrac%7B%5Cmathrm%7Bp%7D%5Cleft%28%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright%29%7D%7B%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%7D%3E%5Cfrac%7B%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)%7D%7B%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%7D%20%5Ccdot%20%5Cfrac%7B%5Cmathrm%7BL%7D_%7B21%7D-%5Cmathrm%7BL%7D_%7B22%7D%7D%7B%5Cmathrm%7BL%7D_%7B12%7D-%5Cmathrm%7BL%7D_%7B11%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时，<img src="https://math.now.sh?inline=%5Cmathrm%7Bx%7D%20%5Cin%20%5Comega_%7B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>左边为似然比：<img src="https://math.now.sh?inline=%5Cmathrm%7Bl%7D_%7B12%7D%3D%5Cfrac%7B%5Cmathrm%7Bp%7D%5Cleft%28%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B1%7D%5Cright%29%7D%7B%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D%20%5Cmid%20%5Comega_%7B2%7D%5Cright)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，右边为阈值<img src="https://math.now.sh?inline=%5Ctheta_%7B21%7D%3D%5Cfrac%7B%5Cmathrm%7BP%7D%5Cleft%28%5Comega_%7B2%7D%5Cright%29%7D%7B%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%7D%20%5Ccdot%20%5Cfrac%7B%5Cmathrm%7BL%7D_%7B21%7D-%5Cmathrm%7BL%7D_%7B22%7D%7D%7B%5Cmathrm%7B~L%7D_%7B12%7D-%5Cmathrm%7BL%7D_%7B11%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此两类模式的贝叶斯判别条件为：</p><ul><li>若<img src="https://math.now.sh?inline=l_%7B12%7D%28x%29%3E%CE%B8_%7B21%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</li><li>若<img src="https://math.now.sh?inline=l_%7B12%7D%28x%29%3C%CE%B8_%7B21%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=x%20%5Cin%20%5Comega_%7B2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>；</li><li>若<img src="https://math.now.sh?inline=l_%7B12%7D%28x%29%3D%CE%B8_%7B21%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则可以做任意判别。</li></ul><p>通常，当判别正确时，不失分，可选常数<img src="https://math.now.sh?inline=L_%7B11%7D%3DL_%7B22%7D%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>判别错误时，可选常数<img src="https://math.now.sh?inline=L_%7B21%7D%3DL_%7B12%7D%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>此时：<img src="https://math.now.sh?inline=%5Ctheta_%7B21%7D%3D%5Cfrac%7B%5Cmathrm%7BP%7D%5Cleft%28%5Comega_%7B2%7D%5Cright%29%7D%7B%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>对于<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>类情况来说，若仍按判对失分为0，判错失分为1记，则<img src="https://math.now.sh?inline=r_j%28x%29%3Dp(x)-p%5Cleft(x%20%5Cmid%20%5Comega_j%5Cright)%20P%5Cleft(%5Comega_j%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>贝叶斯最小错误判别是计算得到某个类别的概率，而最小风险判别是计算得到某个类别后存在风险的概率。两者正好相反。</strong></p><h2 id="正态分布模式的贝叶斯分类器">正态分布模式的贝叶斯分类器</h2><p>出发点：当已知或者有理由设想类概率密度函数<img src="https://math.now.sh?inline=P%28x%7C%CF%89_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是多变量的正态分布时，贝叶斯分类器可以导出一些简单的判别函数。由于正态密度函数易于分析，且对许多重要的实际应用又是一种合适的模型，因此受到很大的重视。</p><p><img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>种模式类别的多变量正态类密度函数：（参考<a href="https://zhuanlan.zhihu.com/p/36522776">数学推导</a>）</p><p><img src="https://math.now.sh?inline=%5Cbegin%7Barray%7D%7Bc%7Dp%5Cleft%28x%20%5Cmid%20%5Comega_%7Bi%7D%5Cright%29%3D%5Cfrac%7B1%7D%7B(2%20%5Cpi)%5E%7Bn%20%2F%202%7D%5Cleft%7CC_%7Bi%7D%5Cright%7C%5E%7B1%20%2F%202%7D%7D%20%5Cexp%20%5Cleft%5C%7B-%5Cfrac%7B1%7D%7B2%7D%5Cleft(x-m_%7Bi%7D%5Cright)%5E%7BT%7D%20C_%7Bi%7D%5E%7B-1%7D%5Cleft(x-m_%7Bi%7D%5Cright)%5Cright%5C%7D%2Ci%3D1%2C2%2C%20%5Cldots%2C%20M%20%5Cend%7Barray%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中，每一类模式的分布密度都完全被其均值向量<img src="https://math.now.sh?inline=m_i%3DE_i%5C%7Bx%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和协方差矩阵<img src="https://math.now.sh?inline=C_i%3DE_i%5C%7B%28x-m_i%29(x-m_i)%5ET%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>所规定</p><p>当协方差矩阵的全部非对角线上的元素都为零时，多变量正态类密度函数可简化为<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个单变量正态类密度函数的乘积，<strong>即<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个单变量为互相独立的</strong>。</p><p>已知类别<img src="https://math.now.sh?inline=%CF%89_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的判别函数可写成如下形式：<img src="https://math.now.sh?inline=d_%7Bi%7D%28x%29%3Dp%5Cleft(x%20%5Cmid%20%5Comega_%7Bi%7D%5Cright)%20P%5Cleft(%5Comega_%7Bi%7D%5Cright)%2C%20%5Cquad%20i%3D1%2C2%2C%20%5Cldots%2C%20M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>可以取自然对数的形式以方便计算：<img src="https://math.now.sh?inline=d_%7Bi%7D%28x%29%3D%5Cln%20%5Cleft%5Bp%5Cleft(x%20%5Cmid%20%5Comega_%7Bi%7D%5Cright)%5Cright%5D%2B%5Cln%20P%5Cleft(%5Comega_%7Bi%7D%5Cright)%2C%20i%3D1%2C2%2C%20%5Cldots%2C%20M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>代入正态类密度函数，可以得到：</p><p><img src="https://math.now.sh?inline=d_%7Bi%7D%28x%29%3D%5Cln%20P%5Cleft(%5Comega_%7Bi%7D%5Cright)-%5Cfrac%7Bn%7D%7B2%7D%20%5Cln%20(2%20%5Cpi)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7CC_%7Bi%7D%5Cright%7C-%5Cfrac%7B1%7D%7B2%7D%5Cleft(x-m_%7Bi%7D%5Cright)%5E%7BT%7D%20C_%7Bi%7D%5E%7B-1%7D%5Cleft(x-m_%7Bi%7D%5Cright)%2C%20i%3D1%2C2%2C%20%5Cldots%2C%20M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>去掉与<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>无关的项，最终可以得到：<img src="https://math.now.sh?inline=d_%7Bi%7D%28x%29%3D%5Cln%20P%5Cleft(%5Comega_%7Bi%7D%5Cright)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7CC_%7Bi%7D%5Cright%7C-%5Cfrac%7B1%7D%7B2%7D%5Cleft(x-m_%7Bi%7D%5Cright)%5E%7BT%7D%20C_%7Bi%7D%5E%7B-1%7D%5Cleft(x-m_%7Bi%7D%5Cright)%2C%20i%3D1%2C2%2C%20%5Cldots%2C%20M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>即为正态分布模式的贝叶斯判别函数。</p><p>因此判别函数是一个超二次曲面，对于正态分布模式的贝叶斯分类器，两个模式类别之间用一个二次判别界面分开，就可以求得最优的分类效果。</p><h3 id="当M-2且类模式都是正态分布的情况">当M=2且类模式都是正态分布的情况</h3><ol><li>当<img src="https://math.now.sh?inline=C_1%E2%89%A0C_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时：</li></ol><p>两类模式的正态分布：<img src="https://math.now.sh?inline=p%28x%7C%CF%89_1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示为<img src="https://math.now.sh?inline=N%28m_1%2C%20C_1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=p%28x%7C%CF%89_2%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示为<img src="https://math.now.sh?inline=N%28m_2%2CC_2%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>两类的判别函数对应为：</p><p><img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D_%7B1%7D%28%5Cmathrm%7Bx%7D%29%3D%5Cln%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7C%5Cmathrm%7BC%7D_%7B1%7D%5Cright%7C-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%5Cmathrm%7Bx%7D-%5Cmathrm%7Bm%7D_%7B1%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D_%7B1%7D%5E%7B-1%7D%5Cleft(%5Cmathrm%7Bx%7D-%5Cmathrm%7Bm%7D_%7B1%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D_%7B2%7D%28%5Cmathrm%7Bx%7D%29%3D%5Cln%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7C%5Cmathrm%7BC%7D_%7B2%7D%5Cright%7C-%5Cfrac%7B1%7D%7B2%7D%5Cleft(%5Cmathrm%7Bx%7D-%5Cmathrm%7Bm%7D_%7B2%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D_%7B2%7D%5E%7B-1%7D%5Cleft(%5Cmathrm%7Bx%7D-%5Cmathrm%7Bm%7D_%7B2%7D%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>判别界面<img src="https://math.now.sh?inline=d_1%28x%29-d_2(x)%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的二次型方程，即<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>两类模式可用二次判别界面分开。</p><p>当<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是二维时，判别界面为二次曲线，如椭圆，圆，抛物线或双曲线等</p><ol start="2"><li>当<img src="https://math.now.sh?inline=C_1%3DC_2%3DC" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时：</li></ol><p><img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D_%7B%5Cmathrm%7Bi%7D%7D%28%5Cmathrm%7Bx%7D%29%3D%20%5Cln%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%7C%5Cmathrm%7BC%7D%7C-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathrm%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7Bx%7D%2B%20%5Cfrac%7B1%7D%7B2%7D%20%5Cmathrm%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7B~m%7D_%7B%5Cmathrm%7Bi%7D%7D%2B%5Cfrac%7B1%7D%7B2%7D%20%5Cmathrm%7B~m%7D_%7B%5Cmathrm%7Bi%7D%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7Bx%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathrm%7B~m%7D_%7B%5Cmathrm%7Bi%7D%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7B~m%7D_%7B%5Cmathrm%7Bi%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cmathrm%7Bi%7D%3D1%2C2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因<img src="https://math.now.sh?inline=C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为对称矩阵，上式可简化为：</p><p><img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D_%7B%5Cmathrm%7Bi%7D%7D%28%5Cmathrm%7Bx%7D%29%3D%20%5Cln%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B%5Cmathrm%7Bi%7D%7D%5Cright)-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%7C%5Cmathrm%7BC%7D%7C-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathrm%7Bx%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7Bx%7D%2B%20%5Cmathrm%7B~m%7D_%7B%5Cmathrm%7Bi%7D%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7Bx%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathrm%7B~m%7D_%7B%5Cmathrm%7Bi%7D%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7B~m%7D_%7B%5Cmathrm%7Bi%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cmathrm%7Bi%7D%3D1%2C2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>由此可导出类别<img src="https://math.now.sh?inline=%CF%89_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%CF%89_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>间的判别界面为：<img src="https://math.now.sh?inline=%5Cmathrm%7Bd%7D_%7B1%7D%28%5Cmathrm%7Bx%7D%29-%5Cmathrm%7Bd%7D_%7B2%7D(%5Cmathrm%7Bx%7D)%3D%5Cln%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B1%7D%5Cright)-%5Cln%20%5Cmathrm%7BP%7D%5Cleft(%5Comega_%7B2%7D%5Cright)%2B%5Cleft(%5Cmathrm%7Bm%7D_%7B1%7D-%5Cmathrm%7Bm%7D_%7B2%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7Bx%7D-%5Cfrac%7B1%7D%7B2%7D%20%5Cmathrm%7B~m%7D_%7B1%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7B~m%7D_%7B1%7D%2B%5Cfrac%7B1%7D%7B2%7D%20%5Cmathrm%7B~m%7D_%7B2%7D%5E%7B%5Cmathrm%7BT%7D%7D%20%5Cmathrm%7BC%7D%5E%7B-1%7D%20%5Cmathrm%7B~m%7D_%7B2%7D%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>判别界面为<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的线性函数，为一超平面。</p><p>当<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是二维时，判别界面为一直线</p><p>决策边界的特征：</p><ul><li>如果两种分布的协方差矩阵相等并且与单位阵成比例，且先验概率相等。则决策边界垂直于两个中心的连线。</li><li>协方差矩阵相等，判决边界同样是超平面。随着先验概率的改变，判决边界也随之改变；对于差别较大的离散先验概率而言，判决边界不会落于中心点之间。</li></ul><p>贝叶斯分类规则是基于统计概念的。如果只有少数模式样本，一般较难获得最优的结果。</p><h4 id="实际代码编写">实际代码编写</h4><div class="code-wrapper"><pre><code class="hljs python">defBayesian(data,label,P):    <span class="hljs-keyword">if</span> data.shape[<span class="hljs-number">0</span>] != label.shape[<span class="hljs-number">0</span>]: <span class="hljs-comment"># 如果数据和标签的数量不相同</span>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Error!&#x27;</span>)        sys.exit()    M = data[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>] <span class="hljs-comment"># 获取数据的维度</span>    data_list = [[],[]] <span class="hljs-comment"># 将不同类别的数据分开存储</span>    data_list[<span class="hljs-number">0</span>] = np.array([data[i] <span class="hljs-keyword">for</span> i inrange(<span class="hljs-built_in">len</span>(label)) <span class="hljs-keyword">if</span> label[i] ==<span class="hljs-number">0</span>])    data_list[<span class="hljs-number">1</span>] = np.array([data[i] <span class="hljs-keyword">for</span> i inrange(<span class="hljs-built_in">len</span>(label)) <span class="hljs-keyword">if</span> label[i] ==<span class="hljs-number">1</span>])    <span class="hljs-comment"># 计算均值向量</span>    m0 = np.<span class="hljs-built_in">sum</span>(data_list[<span class="hljs-number">0</span>],axis=<span class="hljs-number">0</span>) / data_list[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>]    m1 = np.<span class="hljs-built_in">sum</span>(data_list[<span class="hljs-number">1</span>],axis=<span class="hljs-number">0</span>) / data_list[<span class="hljs-number">1</span>].shape[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 计算协方差矩阵</span>    C0 = np.<span class="hljs-built_in">sum</span>(np.array([np.dot((data_list[<span class="hljs-number">0</span>][i] - m0).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), \        (data_list[<span class="hljs-number">0</span>][i] - m0).reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> i inrange(data_list[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])]),axis=<span class="hljs-number">0</span>) / data_list[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>]    C1 = np.<span class="hljs-built_in">sum</span>(np.array([np.dot((data_list[<span class="hljs-number">1</span>][i] - m1).reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),\        (data_list[<span class="hljs-number">1</span>][i] - m1).reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>)) <span class="hljs-keyword">for</span> i inrange(data_list[<span class="hljs-number">1</span>].shape[<span class="hljs-number">0</span>])]),axis=<span class="hljs-number">0</span>) / data_list[<span class="hljs-number">1</span>].shape[<span class="hljs-number">0</span>]    <span class="hljs-keyword">return</span> np.dot(m0-m1,np.linalg.inv(C0)),np.log(P[<span class="hljs-number">0</span>]) - np.log(P[<span class="hljs-number">1</span>]) +<span class="hljs-number">0.5</span>* (np.dot(np.dot(m1.reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>),\        np.linalg.inv(C0)),m1.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) - np.dot(np.dot(m0.reshape(<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>),np.linalg.inv(C0)),m0.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)))</code></pre></div><h2 id="均值向量和协方差矩阵的参数估计">均值向量和协方差矩阵的参数估计</h2><p>在贝叶斯分类器中，构造分类器需要知道类概率密度函数<img src="https://math.now.sh?inline=p%28x%7C%CF%89_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，如果按先验知识已知其分布，则只需知道分布的参数即可。（例如：类概率密度是正态分布，它完全由其均值向量和协方差矩阵所确定）。</p><p>对均值向量和协方差矩阵的估计即为贝叶斯分类器中的一种参数估计问题。</p><p>参数估计的两种方式：</p><ul><li>将参数作为非随机变量来处理，例如矩估计就是一种非随机参数的估计。</li><li>随机参数的估计，即把这些参数看成是随机变量，例如贝叶斯参数估计。</li></ul><h3 id="均值和协方差矩阵的非随机参数的估计">均值和协方差矩阵的非随机参数的估计</h3><h4 id="均值和协方差矩阵的估计量定义">均值和协方差矩阵的估计量定义</h4><p>设模式的类概率密度函数为<img src="https://math.now.sh?inline=p%28%5Cvec%20x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则其均值向量定义为：</p><p><img src="https://math.now.sh?inline=%5Cvec%20%7B%5Cmathrm%7Bm%7D%7D%3D%20%5Cmathrm%7BE%7D%20%28%5Cmathrm%7Bx%7D%29%3D%5Cint_%7B%5Cmathrm%7Bx%7D%7D%20%5Cmathrm%7Bxp%7D(%5Cmathrm%7Bx%7D)%20%5Cmathrm%7Bdx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=%5Cvec%7B%5Cmathrm%7Bx%7D%7D%3D%5Cleft%28%5Cmathrm%7Bx%7D_%7B1%7D%2C%20%5Cmathrm%7Bx%7D_%7B2%7D%2C%20%5Ccdot%20%5Cldots%2C%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bn%7D%7D%5Cright%29%5E%7B%5Cmathrm%7BT%7D%7D%2C%20%5Cquad%20%5Cvec%7B%5Cmathrm%7Bm%7D%7D%3D%5Cleft(%5Cmathrm%7Bm%7D_%7B1%7D%2C%20%5Cmathrm%7B~m%7D_%7B2%7D%2C%20%5Ccdots%2C%20%5Ccdot%20%5Cmathrm%7Bm%7D_%7B%5Cmathrm%7Bn%7D%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>若以样本的平均值作为均值向量的近似值，则均值估计量<img src="https://math.now.sh?inline=%5Chat%7Bm%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为</p><p><img src="https://math.now.sh?inline=%5Chat%7B%5Cmathrm%7Bm%7D%7D%3D%5Cfrac%7B1%7D%7B%5Cmathrm%7BN%7D%7D%20%5Csum_%7B%5Cmathrm%7Bj%7D%3D1%7D%5E%7B%5Cmathrm%7BN%7D%7D%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bj%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为样本的数目</p><p>协方差矩阵<img src="https://math.now.sh?inline=C%3D%5Cleft%28%5Cbegin%7Bmatrix%7Dc_%7B11%7D%26c_%7B12%7D%26%5Ccdots%26%20c_%7B1n%7D%5C%5Cc_%7B21%7D%26c_%7B22%7D%26%5Ccdots%26c_%7B2n%7D%5C%5C%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5Cc_%7Bn1%7D%26c_%7Bn2%7D%26%20%5Ccdots%5C%20%26c_%7Bnn%7D%20%5Cend%7Bmatrix%7D%5Cright%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>其中的每个元素<img src="https://math.now.sh?inline=%5Cmathrm%7Bc%7D_%7B%5Cmathrm%7Blk%7D%7D%3D%5Cmathrm%7BE%7D%5Cleft%5C%7B%5Cleft%28%5Cmathrm%7Bx%7D_l-%5Cmathrm%7Bm%7D_l%5Cright%29%5Cleft(%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bk%7D%7D-%5Cmathrm%7Bm%7D_%7B%5Cmathrm%7Bk%7D%7D%5Cright)%5Cright%5C%7D%3D%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%20%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D%5Cleft(%5Cmathrm%7Bx%7D_l-%5Cmathrm%7Bm%7D_l%5Cright)%5Cleft(%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bk%7D%7D-%5Cmathrm%7Bm%7D_%7B%5Cmathrm%7Bk%7D%7D%5Cright)%20%5Cmathrm%7Bp%7D%5Cleft(%5Cmathrm%7Bx%7D_l%2C%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bk%7D%7D%5Cright)%20%5Cmathrm%7Bdx%7D_l%20%5Cmathrm%7Bdx%7D_%7B%5Cmathrm%7Bk%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中，<img src="https://math.now.sh?inline=x_l%2Cx_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=m_l%2Cm_k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>分别为<img src="https://math.now.sh?inline=%5Cvec%20x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5Cvec%20m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的第<img src="https://math.now.sh?inline=l" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个分量。</p><p>协方差矩阵写成向量形式为：<img src="https://math.now.sh?inline=%5Cmathrm%7BC%7D%3D%5Cmathrm%7BE%7D%5Cleft%5C%7B%28%5Cmathrm%7B%5Cvec%20x%7D-%5Cmathrm%7B%5Cvec%20m%7D%29(%5Cmathrm%7B%5Cvec%20x%7D-%5Cmathrm%7B%5Cvec%20m%7D)%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%5C%7D%3D%5Cmathrm%7BE%7D%5Cleft%5C%7B%5Cmathrm%7B%5Cvec%20x%20%5Cvec%20x%7D%7B%20%7D%5E%7B%5Cmathrm%7BT%7D%7D%5Cright%5C%7D-%5Cmathrm%7B%5Cvec%20m%20%5Cvec%20m%7D%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，（后面这样算更简单一点）</p><p>协方差矩阵的估计量（当<img src="https://math.now.sh?inline=N%3E%3E1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>时）为：<img src="https://math.now.sh?inline=%5Chat%7B%5Cmathrm%7BC%7D%7D%20%5Capprox%20%5Cfrac%7B1%7D%7B%5Cmathrm%7BN%7D%7D%20%5Csum_%7B%5Cmathrm%7Bk%7D%3D1%7D%5E%7B%5Cmathrm%7BN%7D%7D%5Cleft%28%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bk%7D%7D-%5Chat%7B%5Cmathrm%7Bm%7D%7D%5Cright%29%5Cleft(%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bk%7D%7D-%5Chat%7B%5Cmathrm%7Bm%7D%7D%5Cright)%5E%7B%5Cmathrm%7BT%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h4 id="均值和协方差矩阵估计量的迭代运算形式">均值和协方差矩阵估计量的迭代运算形式</h4><p>假设已经计算了<img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个样本的均值估计量，若再加上一个样本，其新的估计量<img src="https://math.now.sh?inline=%5Chat%7B%5Cmathrm%7Bm%7D%7D%28%5Cmathrm%7BN%7D%2B1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为：</p><p><img src="https://math.now.sh?inline=%5Chat%7B%5Cmathrm%7Bm%7D%7D%28%5Cmathrm%7BN%7D%2B1%29%3D%5Cfrac%7B1%7D%7B%5Cmathrm%7BN%7D%2B1%7D%20%5Csum_%7B%5Cmathrm%7Bj%7D%3D1%7D%5E%7B%5Cmathrm%7BN%7D%2B1%7D%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bj%7D%7D%3D%5Cfrac%7B1%7D%7B%5Cmathrm%7BN%7D%2B1%7D%5Cleft%5B%5Csum_%7B%5Cmathrm%7Bj%7D%3D1%7D%5E%7B%5Cmathrm%7BN%7D%7D%20%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7Bj%7D%7D%2B%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BN%7D%2B1%7D%5Cright%5D%3D%5Cfrac%7B1%7D%7B%5Cmathrm%7BN%7D%2B1%7D%5Cleft%5B%5Cmathrm%7BN%5Chat%20m%7D(%5Cmathrm%7BN%7D)%2B%5Cmathrm%7Bx%7D_%7B%5Cmathrm%7BN%7D%2B1%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>其中<img src="https://math.now.sh?inline=%5Chat%20m%28N%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为从<img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个样本计算得到的估计量。迭代的第一步应取<img src="https://math.now.sh?inline=%5Chat%20m%281%29%3Dx_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>协方差矩阵估计量的迭代运算与上述相似：<img src="https://math.now.sh?inline=%5Chat%7B%5Cmathrm%7BC%7D%7D%28N%2B1%29%3D%5Cfrac%7B1%7D%7B(N%2B1)%5E2%7D%5Cleft%5BN%20%5Chat%7Bm%7D(N)%2Bx_%7BN%2B1%7D%5Cright%5D%5Cleft%5BN%20%5Chat%7Bm%7D(N)%2Bx_%7BN%2B1%7D%5Cright%5D%5ET" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h3 id="均值向量和协方差矩阵的贝叶斯学习">均值向量和协方差矩阵的贝叶斯学习</h3><p>将概率密度函数的参数估计量看成是随机变量<img src="https://math.now.sh?inline=%CE%B8" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，它可以是纯量、向量或矩阵。按这些估计量统计特性的先验知识，可以先粗略地预选出它们的密度函数。通过训练模式样本集<img src="https://math.now.sh?inline=%5C%7Bx_i%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，利用贝叶斯公式设计一个迭代运算过程求出参数的后验概率密度<img src="https://math.now.sh?inline=p%28%CE%B8%7Cx_i%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。当后验概率密度函数中的随机变量<img src="https://math.now.sh?inline=%CE%B8" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的确定性提高时，可获得较准确的估计量。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Pattern Recognition and Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第10章 位运算</title>
    <link href="/2022/09/05/Leetcode/Leetcode-101/Leetcode-101-10/"/>
    <url>/2022/09/05/Leetcode/Leetcode-101/Leetcode-101-10/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第10章 位运算</p><span id="more"></span><h1>位运算</h1><h2 id="常用技巧">常用技巧</h2><p>按位异或：<code>x ^ 0s = x, x ^ 1s = ~x, x ^ x = 0</code></p><p>按位与：<code>x &amp; 0s = 0, x &amp; 1s = x, x &amp; x = x</code></p><p>按位或：<code>x | 0s = x, x | 1s = 1s, x | x = x</code></p><p><code>n &amp; (n - 1)</code>可以去除 <code>n</code>的位级表示中最低的那一位，例如对于二进制表示 <code>11110100</code>，减去 <code>1</code>得到 <code>11110011</code>，这两个数按位与得到 <code>11110000</code>。</p><p><code>n &amp; (-n)</code>可以得到<code>n</code>的位级表示中最低的那一位，例如对于二进制表示 <code>11110100</code>，取负得到 <code>00001100</code>，这两个数按位与得到 <code>00000100</code>。</p><h2 id="位运算基础问题">位运算基础问题</h2><h3 id="Leetcode-461">Leetcode 461</h3><p>给定两个十进制数字，求它们二进制表示的汉明距离（Hamming distance，即不同位的个数）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingDistance</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;        <span class="hljs-type">int</span> diff = x ^ y;        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(diff)&#123;            ans += diff &amp; <span class="hljs-number">1</span>;            diff &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：将<code>x</code>和<code>y</code>按位异或，则不同的位置为<code>1</code>，相同的位置为<code>0</code>。然后将得到的结果与<code>1</code>进行与操作，为<code>0</code>说明是<code>0</code>，为<code>1</code>说明是<code>1</code>，就计数了<code>1</code>。然后将这个结果逐步右移就可以看出下一位了。</p><p>错误：第一道题不太熟悉。</p><h3 id="Leetcode-190">Leetcode 190</h3><p>颠倒给定的 32 位无符号整数的二进制位</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;        <span class="hljs-type">uint32_t</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">32</span>;++i)&#123;            ans &lt;&lt;= <span class="hljs-number">1</span>;            ans += n &amp; <span class="hljs-number">1</span>;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：摆出一个<code>0</code>，然后左移，逐步加上<code>n</code>右移的数字。</p><p>错误：不太明白左右移这种东西</p><h3 id="Leetcode-136">Leetcode 136</h3><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;        <span class="hljs-keyword">return</span> ret;    &#125;&#125;;</code></pre></div><p>分析：一个数字和 <code>0</code>进行按位异或会得到本身，一个数字和本身进行按位异或会得到0。因此在数组内部进行循环，两次的元素出现了一定会变为<code>0</code>，最后剩下的一个就是这个数字本身。</p><p>错误：不熟练</p><h2 id="二进制特性">二进制特性</h2><h3 id="Leetcode-342">Leetcode 342</h3><p>给定一个整数，判断它是否是4 的次方。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> &amp;&amp; !(n &amp; (n - <span class="hljs-number">1</span>)) &amp;&amp; (n &amp; <span class="hljs-number">1431655765</span>);    &#125;&#125;;</code></pre></div><p>分析：首先我们考虑一个数字是不是2 的（整数）次方：如果一个数字n 是2 的整数次方，那么它的二进制一定是0…010…0 这样的形式；考虑到n - 1 的二进制是0…001…1，这两个数求按位与的结果一定是0。因此如果n &amp; (n - 1) 为0，那么这个数是2 的次方。如果这个数也是4 的次方，那二进制表示中1 的位置必须为奇数位。我们可以把n 和二进制的10101…101（即十进制下的1431655765）做按位与，如果结果不为0，那么说明这个数是4的次方。</p><p>错误：不理解</p><h3 id="Leetcode-318">Leetcode 318</h3><p>给你一个字符串数组 <code>words</code> ，找出并返回 <code>length(words[i]) * length(words[j])</code> 的最大值，并且这两个单词不含有公共字母。如果不存在这样的两个单词，返回 <code>0</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string &amp; word : words) &#123;            <span class="hljs-type">int</span> mask = <span class="hljs-number">0</span>, size = word.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp; c : word) &#123;                mask |= <span class="hljs-number">1</span> &lt;&lt; (c - <span class="hljs-string">&#x27;a&#x27;</span>);            &#125;            hash[mask] = <span class="hljs-built_in">max</span>(hash[mask], size);            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [h_mask, h_len]: hash) &#123;                <span class="hljs-keyword">if</span> (!(mask &amp; h_mask)) &#123;                    ans = <span class="hljs-built_in">max</span>(ans, size * h_len);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：怎样快速判断两个字母串是否含有重复数字呢？可以为每个字母串建立一个长度为<code>26</code>的二进制数字，每个位置表示是否存在该字母。如果两个字母串含有重复数字，那它们的二进制表示的按位与不为<code>0</code>。</p><p>错误：看了思路后自己实现的。</p><h3 id="Leetcode-338">Leetcode 338</h3><p>给你一个整数 <code>n</code> ，对于 <code>0 &lt;= i &lt;= n</code> 中的每个 <code>i</code> ，计算其二进制表示中 <strong><code>1</code> 的个数</strong> ，返回一个长度为 <code>n + 1</code> 的数组 <code>ans</code> 作为答案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; ++i)&#123;            dp[i] = i &amp; <span class="hljs-number">1</span>? dp[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>: dp[i&gt;&gt;<span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：本题可以利用动态规划和位运算进行快速的求解。定义一个数组dp，其中dp[i] 表示数字i的二进制含有1 的个数。对于第i 个数字，如果它二进制的最后一位为1，那么它含有1 的个数<br>则为dp[i-1] + 1；如果它二进制的最后一位为0，那么它含有1 的个数和其算术右移结果相同，即dp[i&gt;&gt;1]。</p><h2 id="练习">练习</h2><h3 id="Leetcode-268">Leetcode 268</h3><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> total = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-type">int</span> arrSum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;            arrSum += nums[i];        &#125;        <span class="hljs-keyword">return</span> total - arrSum;    &#125;&#125;;</code></pre></div><p>分析：高斯求和后相减即可</p><h3 id="Leetcode-693">Leetcode 693</h3><p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasAlternatingBits</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n)&#123;            <span class="hljs-type">int</span> ans = n &amp; <span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">if</span>(pre == ans)&#123;                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;                &#125;            &#125;            pre = ans;            sign = <span class="hljs-number">1</span>;            n &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre></div><p>分析：存储并判断即可</p><p>错误：有一点小问题，很快调通</p><h3 id="Leetcode-476">Leetcode 476</h3><p>给你一个整数 <code>num</code> ，输出它的补数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findComplement</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;        uint t = <span class="hljs-number">1u</span> &lt;&lt; <span class="hljs-number">31</span>;        <span class="hljs-keyword">while</span> (! (t &amp; num)) &#123;            num |= t;            t &gt;&gt;= <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> ~num;    &#125;&#125;;</code></pre></div><p>分析：前边补1，然后就可以直接取反了</p><p>错误：没有思路</p><h3 id="Leetcode-260">Leetcode 260</h3><p>给你一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;            ++mp[nums[i]];        &#125;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[a,b] : mp)&#123;            <span class="hljs-keyword">if</span>(b == <span class="hljs-number">1</span>)&#123;                result.<span class="hljs-built_in">push_back</span>(a);            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：哈希表算了。。。</p><p><strong>一遍AC</strong></p><h2 id="总结">总结</h2><p>这东西和计组挺相关的，面试中应该不会怎么考察这种数学题，但不失为一种运算加速的好办法。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第9章 数学问题</title>
    <link href="/2022/09/05/Leetcode/Leetcode-101/Leetcode-101-9/"/>
    <url>/2022/09/05/Leetcode/Leetcode-101/Leetcode-101-9/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第9章 数学问题</p><span id="more"></span><h1>数学问题</h1><h2 id="公倍数与公因数">公倍数与公因数</h2><p>利用辗转相除法求得两个数的最大公因数，将两个数相乘再除以最大公因数即可得到最小公倍数</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a% b);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lcm</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a * b / <span class="hljs-built_in">gcd</span>(a, b);&#125;</code></pre></div><p>进一步也可以通过扩展欧几里得算法在求得 <code>a</code>和 <code>b</code>最大公因数的同时，也得到它们的系数 <code>x</code>和 <code>y</code>，从而使 <code>ax + by = gcd(a, b)</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">xGCD</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!b) &#123;        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-type">int</span> x1, y1, gcd = <span class="hljs-built_in">xGCD</span>(b, a % b, x1, y1);    x = y1, y = x1 - (a / b) * y1;    <span class="hljs-keyword">return</span> gcd;&#125;</code></pre></div><h2 id="质数">质数</h2><h3 id="Leetcode-204">Leetcode 204</h3><p>给定整数 <code>n</code> ，返回所有小于非负整数 <code>n</code> 的质数的数量 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">nums</span><span class="hljs-params">(n,<span class="hljs-literal">true</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-literal">true</span>)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>*i;j&lt;n;j += i)&#123;                    nums[j] = <span class="hljs-literal">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>) - <span class="hljs-number">2</span>;    &#125;&#125;;</code></pre></div><p>分析：使用埃拉托斯特尼筛法即可。</p><p>错误：有点忘记算法了。</p><h2 id="数字处理">数字处理</h2><p>给定一个整数 <code>num</code>，将其转化为<strong>7进制</strong>，并以字符串形式输出。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">convertToBase7</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;        <span class="hljs-type">int</span> sign = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;            num = -num;            sign = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;        &#125;        string result = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">while</span>(num/<span class="hljs-number">7</span>)&#123;            <span class="hljs-type">char</span> c = num%<span class="hljs-number">7</span> + <span class="hljs-string">&#x27;0&#x27;</span>;            result =  c + result;            num /= <span class="hljs-number">7</span>;        &#125;        <span class="hljs-keyword">if</span>(num != <span class="hljs-number">0</span>)&#123;            <span class="hljs-type">char</span> b = <span class="hljs-string">&#x27;0&#x27;</span> + num;            result =  b + result;        &#125;        <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;-&#x27;</span> + result;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：直接进制转换就行，注意进制转换的时候用十进制进行过渡比较方便。</p><p>错误：磕磕绊绊调通了。</p><h3 id="Leetcode-172">Leetcode 172</h3><p>给定一个整数 <code>n</code> ，返回 <code>n!</code> 结果中尾随零的数量。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span>? <span class="hljs-number">0</span>: n / <span class="hljs-number">5</span> + <span class="hljs-built_in">trailingZeroes</span>(n / <span class="hljs-number">5</span>);    &#125;&#125;;</code></pre></div><p>分析：每个尾部的0由2*5 = 10而来，因此我们可以把阶乘的每一个元素拆成质数相乘，统计有多少个2和5。明显的，质因子2的数量远多于质因子5的数量，因此我们可以只统计阶乘结果里有多少个质因子5。</p><p>错误：没想到这么好的思路</p><h3 id="Leetcode-415">Leetcode 415</h3><p>给定两个字符串形式的非负整数 <code>num1</code> 和 <code>num2</code> ，计算它们的和并同样以字符串形式返回。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">addStrings</span><span class="hljs-params">(string num1, string num2)</span> </span>&#123;        <span class="hljs-type">int</span> n1 = num<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n2 = num<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();        --n1;        --n2;        string result = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n1 &gt;= <span class="hljs-number">0</span> &amp;&amp; n2 &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-type">int</span> temp = num1[n1] - <span class="hljs-string">&#x27;0&#x27;</span> + num2[n2] - <span class="hljs-string">&#x27;0&#x27;</span> + cnt;            <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">10</span>)&#123;                cnt = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-type">char</span> c = temp%<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;            result = c + result;            --n1;            --n2;        &#125;        <span class="hljs-keyword">while</span>(n1 &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-type">int</span> temp = num1[n1] - <span class="hljs-string">&#x27;0&#x27;</span> + cnt;            <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">10</span>)&#123;                cnt = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-type">char</span> c = temp%<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;            result = c + result;            --n1;        &#125;        <span class="hljs-keyword">while</span>(n2 &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-type">int</span> temp = num2[n2] - <span class="hljs-string">&#x27;0&#x27;</span> + cnt;            <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">10</span>)&#123;                cnt = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-type">char</span> c = temp%<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;            result = c + result;            --n2;        &#125;        <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;1&#x27;</span> + result;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：大数相加，没什么新的东西</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-326">Leetcode 326</h3><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span> i=<span class="hljs-number">3</span>;i&lt;INT_MAX;i*=<span class="hljs-number">3</span>)&#123;            <span class="hljs-keyword">if</span>(i == n)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>分析：比较简单，有更好的解法，需要数学能力</p><p>错误：<code>n=1</code>没有考虑</p><h2 id="随机与取样">随机与取样</h2><h3 id="Leetcode-384">Leetcode 384</h3><p>给定一个数组，要求实现两个指令函数。第一个函数“shuffle”可以随机打乱这个数组，第二个函数“reset”可以恢复原来的顺序。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;        <span class="hljs-keyword">this</span>-&gt;nums = nums;        <span class="hljs-keyword">this</span>-&gt;original.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>());        <span class="hljs-built_in">copy</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), original.<span class="hljs-built_in">begin</span>());    &#125;      <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">reset</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">copy</span>(original.<span class="hljs-built_in">begin</span>(), original.<span class="hljs-built_in">end</span>(), nums.<span class="hljs-built_in">begin</span>());        <span class="hljs-keyword">return</span> nums;    &#125;      <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">shuffle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> &#123;&#125;;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">shuffled</span><span class="hljs-params">(nums)</span></span>;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;            <span class="hljs-built_in">swap</span>(shuffled[i], shuffled[<span class="hljs-built_in">rand</span>() % (i + <span class="hljs-number">1</span>)]);        &#125;        <span class="hljs-comment">// 正向洗牌：</span>        <span class="hljs-comment">// for (int i = 0; i &lt; n; ++i) &#123;</span>        <span class="hljs-comment">// int pos = rand() % (n - i);</span>        <span class="hljs-comment">// swap(shuffled[i], shuffled[i+pos]);</span>        <span class="hljs-comment">// &#125;</span>        <span class="hljs-keyword">return</span> shuffled;    &#125;<span class="hljs-keyword">private</span>:    vector&lt;<span class="hljs-type">int</span>&gt; nums;    vector&lt;<span class="hljs-type">int</span>&gt; original;&#125;;</code></pre></div><p>分析：经典的Fisher-Yates洗牌算法，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法</p><p>错误：类什么的还是不太会写</p><h3 id="Leetcode-528">Leetcode 528</h3><p>给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    vector&lt;<span class="hljs-type">int</span>&gt; W;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Solution</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; w) &#123;        <span class="hljs-built_in">partial_sum</span>(w.<span class="hljs-built_in">begin</span>(), w.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">back_inserter</span>(W));    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pickIndex</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-type">int</span> pos = <span class="hljs-built_in">rand</span>() % W.<span class="hljs-built_in">back</span>();        <span class="hljs-keyword">return</span> <span class="hljs-built_in">upper_bound</span>(W.<span class="hljs-built_in">begin</span>(), W.<span class="hljs-built_in">end</span>(), pos) - W.<span class="hljs-built_in">begin</span>();    &#125;&#125;;</code></pre></div><p>分析：我们可以先使用 <code>partial_sum</code>求前缀和（即到每个位置为止之前所有数字的和），这个结果对于正整数数组是单调递增的。每当需要采样时，我们可以先随机产生一个数字，然后使用二分法查找其在前缀和中的位置，以模拟加权采样的过程。</p><p>错误：没思路</p><h3 id="Leetcode-382">Leetcode 382</h3><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点被选中的概率一样 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    vector&lt;<span class="hljs-type">int</span>&gt; arr;<span class="hljs-keyword">public</span>:    <span class="hljs-built_in">Solution</span>(ListNode* head) &#123;        <span class="hljs-keyword">while</span> (head) &#123;            arr.<span class="hljs-built_in">emplace_back</span>(head-&gt;val);            head = head-&gt;next;        &#125;    &#125;      <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> arr[<span class="hljs-built_in">rand</span>() % arr.<span class="hljs-built_in">size</span>()];    &#125;&#125;;</code></pre></div><p>分析：用一个数组记录链表中的所有结点值，然后随机输出即可。</p><p>错误：思路简单就是不会写</p><h2 id="练习">练习</h2><h3 id="Leetcode-168">Leetcode 168</h3><p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">convertToTitle</span><span class="hljs-params">(<span class="hljs-type">int</span> columnNumber)</span> </span>&#123;        string ans;        <span class="hljs-keyword">while</span> (columnNumber &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-type">int</span> a0 = (columnNumber - <span class="hljs-number">1</span>) % <span class="hljs-number">26</span> + <span class="hljs-number">1</span>;            ans += a0 - <span class="hljs-number">1</span> + <span class="hljs-string">&#x27;A&#x27;</span>;            columnNumber = (columnNumber - a0) / <span class="hljs-number">26</span>;        &#125;        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：进制转换的变形题</p><p>错误：减法操作没想好</p><h3 id="Leetcode-67">Leetcode 67</h3><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">addBinary</span><span class="hljs-params">(string a, string b)</span> </span>&#123;        <span class="hljs-type">int</span> a_size = a.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> b_size = b.<span class="hljs-built_in">size</span>();        --a_size;        --b_size;        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> sign;        string result = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">while</span>(a_size &gt;= <span class="hljs-number">0</span> &amp;&amp; b_size &gt;= <span class="hljs-number">0</span>)&#123;            sign = a[a_size] - <span class="hljs-string">&#x27;0&#x27;</span> + b[b_size] - <span class="hljs-string">&#x27;0&#x27;</span> + cnt;            <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>)&#123;                result = <span class="hljs-string">&quot;0&quot;</span> + result;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;                result = <span class="hljs-string">&quot;1&quot;</span> + result;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">2</span>)&#123;                result = <span class="hljs-string">&quot;0&quot;</span> + result;                cnt = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">3</span>)&#123;                result = <span class="hljs-string">&quot;1&quot;</span> + result;                cnt = <span class="hljs-number">1</span>;            &#125;            --a_size;            --b_size;        &#125;        <span class="hljs-keyword">while</span>(a_size &gt;= <span class="hljs-number">0</span>)&#123;            sign = a[a_size] - <span class="hljs-string">&#x27;0&#x27;</span> + cnt;            <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>)&#123;                result = <span class="hljs-string">&quot;0&quot;</span> + result;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;                result = <span class="hljs-string">&quot;1&quot;</span> + result;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">2</span>)&#123;                result = <span class="hljs-string">&quot;0&quot;</span> + result;                cnt = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">3</span>)&#123;                result = <span class="hljs-string">&quot;1&quot;</span> + result;                cnt = <span class="hljs-number">1</span>;            &#125;            --a_size;        &#125;        <span class="hljs-keyword">while</span>(b_size &gt;= <span class="hljs-number">0</span>)&#123;            sign = b[b_size] - <span class="hljs-string">&#x27;0&#x27;</span> + cnt;            <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">0</span>)&#123;                result = <span class="hljs-string">&quot;0&quot;</span> + result;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;                result = <span class="hljs-string">&quot;1&quot;</span> + result;                cnt = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">2</span>)&#123;                result = <span class="hljs-string">&quot;0&quot;</span> + result;                cnt = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">3</span>)&#123;                result = <span class="hljs-string">&quot;1&quot;</span> + result;                cnt = <span class="hljs-number">1</span>;            &#125;            --b_size;        &#125;        <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)&#123;            result = <span class="hljs-string">&quot;1&quot;</span> + result;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：还是大数加法</p><p>错误：忘记了，应该没什么错误</p><h3 id="Leetcode-238">Leetcode 238</h3><p>给你一个整数数组 <code>nums</code>，返回 数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">left</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">right</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>;        left[<span class="hljs-number">0</span>] = start;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;            left[i] = start * nums[i<span class="hljs-number">-1</span>];            start = left[i];        &#125;        <span class="hljs-type">int</span> end = <span class="hljs-number">1</span>;        right[n<span class="hljs-number">-1</span>] = end;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;            right[i] = end * nums[i<span class="hljs-number">+1</span>];            end = right[i];        &#125;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            result[i] = left[i] * right[i];        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：前缀积+后缀积</p><p>错误：看了一下思路，后面自己想通了实现了</p><h3 id="Leetcode-462">Leetcode 462</h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，返回使所有数组元素相等需要的最少移动数。在一步操作中，你可以使数组中的一个元素加 <code>1</code> 或者减 <code>1</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minMoves2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());        <span class="hljs-type">int</span> num = nums[n/<span class="hljs-number">2</span>];        <span class="hljs-type">int</span> sum2 = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; num)&#123;                sum2 += nums[i] - num;            &#125;            <span class="hljs-keyword">else</span>&#123;                sum2 += num - nums[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> sum2;    &#125;&#125;;</code></pre></div><p>分析：如果仅仅考虑最大的数字和最小的数字，那么这个数字一定在这两个数字中间，去除掉后这个数字也一定在次大的和次小的数字之间。因此是中位数</p><p>错误：思路不对，开始想成平均数了</p><h3 id="Leetcode-169">Leetcode 169</h3><p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> candidate = <span class="hljs-number">-1</span>;        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;            <span class="hljs-keyword">if</span> (num == candidate)                ++count;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (--count &lt; <span class="hljs-number">0</span>) &#123;                candidate = num;                count = <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> candidate;    &#125;&#125;;</code></pre></div><p>分析：Boyer-Moore 算法：维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：如果 x 与 candidate 相等，那么计数器 count 的值增加 1；如果 x 与 candidate 不等，那么计数器 count 的值减少 1。在遍历完成后，candidate 即为整个数组的众数。</p><p>错误：算法想的不太好，没有想到最优的解法。</p><h3 id="Leetcode-470">Leetcode 470</h3><p>给定方法 <code>rand7</code> 可生成 <code>[1,7]</code> 范围内的均匀随机整数，试写一个方法 <code>rand10</code> 生成 <code>[1,10]</code> 范围内的均匀随机整数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rand10</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-type">int</span> row, col, idx;        <span class="hljs-keyword">do</span> &#123;            row = <span class="hljs-built_in">rand7</span>();            col = <span class="hljs-built_in">rand7</span>();            idx = col + (row - <span class="hljs-number">1</span>) * <span class="hljs-number">7</span>;        &#125; <span class="hljs-keyword">while</span> (idx &gt; <span class="hljs-number">40</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + (idx - <span class="hljs-number">1</span>) % <span class="hljs-number">10</span>;    &#125;&#125;;</code></pre></div><p>分析：调用两次rand7()，找到一些等概率的数字，然后拒绝掉另外的数字。</p><p>错误：想当然认为是直接乘法了。</p><h3 id="Leetcode-202">Leetcode 202</h3><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-type">int</span> sum = <span class="hljs-number">6</span>;        <span class="hljs-keyword">while</span>(sum--)&#123;            string s = <span class="hljs-built_in">to_string</span>(n);            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)&#123;                t += (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>) * (s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);            &#125;            <span class="hljs-keyword">if</span>(t == <span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            n = t;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>分析：看看会不会跳出循环</p><p><strong>一遍AC</strong>，但是解法不够好，后面要用更好的方法进行尝试。</p><h2 id="总结">总结</h2><p>数学问题需要有数学基础，一般面试中应该用的比较少，有些问题还是挺有意思的。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第8章 分治法</title>
    <link href="/2022/09/05/Leetcode/Leetcode-101/Leetcode-101-8/"/>
    <url>/2022/09/05/Leetcode/Leetcode-101/Leetcode-101-8/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第8章 分治法</p><span id="more"></span><h1>分治法</h1><p>顾名思义，分治问题由“分”（divide）和“治”（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。我们在排序章节展示的归并排序就是典型的分治问题，其中“分”即为把大数组平均分成两个小数组，通过递归实现，最终我们会得到多个长度为1的子数组；“治”即为把已经排好序的两个小数组合成为一个排好序的大数组，从长度为1 的子数组开始，最终合成一个大数组。</p><h2 id="表达式问题">表达式问题</h2><h3 id="Leetcode-241">Leetcode 241</h3><p>给定一个只包含加、减和乘法的数学表达式，求通过加括号可以得到多少种不同的结果</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(string expression)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; ways;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;expression.<span class="hljs-built_in">size</span>();++i)&#123;            <span class="hljs-type">char</span> c = expression[i];            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;                vector&lt;<span class="hljs-type">int</span>&gt; left = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,i));                vector&lt;<span class="hljs-type">int</span>&gt; right = <span class="hljs-built_in">diffWaysToCompute</span>(expression.<span class="hljs-built_in">substr</span>(i<span class="hljs-number">+1</span>));                <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;l : left)&#123;                    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r : right)&#123;                        <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;                            ways.<span class="hljs-built_in">push_back</span>(l+r);                        &#125;                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;                            ways.<span class="hljs-built_in">push_back</span>(l-r);                        &#125;                        <span class="hljs-keyword">else</span>&#123;                            ways.<span class="hljs-built_in">push_back</span>(l*r);                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">if</span> (ways.<span class="hljs-built_in">empty</span>())&#123;            ways.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">stoi</span>(expression));        &#125;        <span class="hljs-keyword">return</span> ways;    &#125;&#125;;</code></pre></div><p>分析：利用分治思想，我们可以把加括号转化为，对于每个运算符号，先执行处理两侧的数学表达式，再处理此运算符号。注意边界情况，即字符串内无运算符号，只有数字。</p><p>错误：想不通的</p><h2 id="练习">练习</h2><h3 id="Leetcode-932">Leetcode 932</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">beautifulArray</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; ans;        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);            <span class="hljs-keyword">return</span> ans;        &#125;        <span class="hljs-type">int</span> odd_num=(n<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-type">int</span> even_num=n/<span class="hljs-number">2</span>;        vector&lt;<span class="hljs-type">int</span>&gt; left_arry=<span class="hljs-built_in">beautifulArray</span>(odd_num);        vector&lt;<span class="hljs-type">int</span>&gt; right_arry=<span class="hljs-built_in">beautifulArray</span>(even_num);        <span class="hljs-comment">//将左侧数组映射为奇数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;val:left_arry)&#123;            ans.<span class="hljs-built_in">push_back</span>(val*<span class="hljs-number">2</span><span class="hljs-number">-1</span>);        &#125;        <span class="hljs-comment">//将右侧数组映射为偶数</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;val:right_arry)&#123;            ans.<span class="hljs-built_in">push_back</span>(val*<span class="hljs-number">2</span>);        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre></div><p>分析：不懂</p><p>错误：不懂</p><h3 id="Leetcode-312">Leetcode 312</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">rec</span>(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">2</span>));        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">val</span><span class="hljs-params">(n + <span class="hljs-number">2</span>)</span></span>;        val[<span class="hljs-number">0</span>] = val[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            val[i] = nums[i - <span class="hljs-number">1</span>];        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">2</span>; j &lt;= n + <span class="hljs-number">1</span>; j++) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i + <span class="hljs-number">1</span>; k &lt; j; k++) &#123;                    <span class="hljs-type">int</span> sum = val[i] * val[k] * val[j];                    sum += rec[i][k] + rec[k][j];                    rec[i][j] = <span class="hljs-built_in">max</span>(rec[i][j], sum);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> rec[<span class="hljs-number">0</span>][n + <span class="hljs-number">1</span>];    &#125;&#125;;</code></pre></div><p>分析：不懂</p><p>错误：不懂</p><h2 id="总结">总结</h2><p>不懂不懂不懂啊啊啊啊啊</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第3讲 索引压缩</title>
    <link href="/2022/09/05/UCAS/information-retrieval/information-retrieval-3/"/>
    <url>/2022/09/05/UCAS/information-retrieval/information-retrieval-3/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第3讲 索引压缩</p><span id="more"></span><h1>第3讲 索引压缩</h1><h2 id="压缩">压缩</h2><p>举例：将长编码串用短编码串来代替：111111111111111111➡18个1</p><p>为什么要压缩?</p><ul><li>减少磁盘空间占用（节省开销）</li><li>增加内存存储内容（加快速度）</li><li>加快从磁盘到内存的数据传输速度（同样加快速度）<ul><li>读压缩数据到内存+在内存中解压，比直接读入未压缩数据到内存要快很多</li></ul></li></ul><p>为什么在IR中需要压缩?</p><ul><li>占用更少的硬盘空间<ul><li>更经济，节省空间</li></ul></li><li>将更多数据载入内存<ul><li>加快处理速度（内存中读写很快）</li></ul></li><li>减少从磁盘读入内存的时间<ul><li>大型搜索引擎将相当比例的倒排记录表都放入内存（硬盘？）</li></ul></li></ul><p><strong>IR中压缩的两个基本要求：无损压缩和随机访问</strong></p><p>压缩的一个基本问题：对齐，即建立不同压缩单元之间的分界标识</p><p>有损压缩：丢弃一些信息-很多常用的预处理步骤可以看成是有损压缩</p><p>无损压缩：所有信息都保留-索引压缩中通常都使用无损压缩</p><h2 id="词项统计量">词项统计量</h2><p><strong>词典压缩中词典的大小即词汇表的大小是关键</strong></p><p>词汇表大小会随着文档集的大小增长而增长，没有办法估计数量。</p><p>存在一个经验规律可以进行估计：</p><p>Heaps定律：<img src="https://math.now.sh?inline=M%20%3D%20kT%5Eb" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=M" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是词汇表大小, <img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是文档集的大小。参数<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的一个经典取值是：<img src="https://math.now.sh?inline=30%20%5Cleq%20k%20%5Cleq100" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>及<img src="https://math.now.sh?inline=b%20%5Capprox%200.5" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>Heaps定律在对数空间下是线性的。</p><p>在容许拼写错误或者对拼写错误自动纠错的情况下，Heaps定律的效果如何？</p><ul><li>存在拼写错误：会增加词项数目</li><li>自动纠错：总体词项数目趋于正常</li><li>对效果有一定影响，但是除非存在大量拼写错误，否则不会有显著影响。</li></ul><p><strong>倒排记录表压缩中词项的分布情况是关键</strong></p><p>我们还需要知道在文档集中有多少高频词项和低频词项</p><p>Zipf定律：第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>常见的词项的频率<img src="https://math.now.sh?inline=cf_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7Bi%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>成正比</p><p><img src="https://math.now.sh?inline=cf_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是语料中词项频率：词项<img src="https://math.now.sh?inline=t_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在所有文档中出现的次数</p><p>实际统计中可以发现拟合度并不是很高，但是可以发现高频词项很少，低频罕见词项很多。</p><h2 id="词典压缩">词典压缩</h2><p>一般而言，相对于倒排记录表，词典所占空间较小。但是我们想将词典放入内存，另外满足一些特定领域特定应用的需要，如手机、机<br>载计算机上的应用或要求快速启动等需求。因此，压缩词典也很重要。</p><p>定长数组方式下的词典存储：每个词项需要20（字符串）+4（词频）+4（指向倒排索引表的指针）=28个字节。</p><p>不足之处：</p><ul><li>大量存储空间被浪费<ul><li>即使是长度为1的词项，我们也分配20个字节，但是英语中每个词项的平均长度为8个字符</li></ul></li><li>不能处理长度大于20字节的词项</li></ul><p>将整部词典看成单一字符串：4（词频）+4（指向倒排索引表的指针）+3（指向字符串的指针，按照实际大小决定，例如8*400000个位置需要$log_2(8 * 400000)&lt; 24 $位来表示）+8（每个字符串平均需要8个字节）=19个字节</p><p>按块存储，假设块大小k=4，此时每4个词项只需要保留1个词项指针，但是同时需要增加4个字节（比较短，1个字节就可以）来表示每个词项的长度，因此每4个词项需要3+4=7B，比之前的节省了12-7=5B</p><p>但是不采用块存储方式下的词项查找是典型的二叉查找，而采用块存储方式下的词项查找需要进行顺序查找，块如果太大会影响效率。</p><p>每个块当中，会有公共前缀，可以采用前端编码方式继续压缩。</p><p>哪些前缀应该用于前端编码？需要在哪些方面有所权衡？</p><ul><li>同一个单词的不同形式适合使用这种前端编码</li><li>没有什么公共前缀的话，压缩效果不太好，而且还会导致检索速度下降</li></ul><h2 id="倒排记录表压缩">倒排记录表压缩</h2><p>倒排记录表空间远大于词典，压缩关键是对每条倒排记录进行压缩</p><p><strong>关键思想：存储 <code>docID</code>间隔而不是 <code>docID</code>本身</strong></p><p>设计一个变长编码(variable length encoding)：可变长编码对于小间隔采用短编码而对于长间隔采用长编码</p><p><strong>可变字节(VB)码</strong>：设定一个专用位 (高位) c作为延续位(continuation bit)，如果间隔表示少于7比特，那么c置1，将间隔编入一个<br>字节的后7位中；否则将高7位放入当前字节中，并将c置0，剩下的位数采用同样的方法进行处理，最后一个字节的c置1（表<br>示结束）</p><ul><li>除字节外，还可以采用不同的对齐单位：比如32位(word)、16位及4位(nibble)等等</li><li>如果有很多很小的间隔，那么采用可变字节码会浪费很多空间，而此时采用4位为单位将会节省空间</li></ul><p>一元码：将n表示成n个1和最后一个0</p><p>基于位的编码：</p><p><strong><img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>编码</strong>：（不考虑0）</p><ul><li>将G (Gap, 间隔) 表示成长度(length)和偏移(offset)两部分</li><li>偏移对应G的二进制编码，只不过将首部的1去掉（因为所有的编码第一位都是1）</li><li>长度部分给出的是偏移的位数，采用一元编码</li><li>手动计算的时候先计算偏移，再根据偏移计算长度</li></ul><p>偏移部分是<img src="https://math.now.sh?inline=log_2G" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>比特位，长度部分需要<img src="https://math.now.sh?inline=log_2G%20%2B%201" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>比特位，因此全部编码需要<img src="https://math.now.sh?inline=2log_2G%20%2B%201" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>比特位。</p><ul><li><img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>编码是前缀无关的，也就是说一个合法的<img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>编码不会是任何一个其他的合法<img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>编码的前缀，也保证了解码的唯一性。</li><li><img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>编码在最优编码的2或3倍之内</li><li><img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>编码适用于任何分布，是通用性编码</li><li><img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>编码是无参数编码，不需要通过拟合得到参数</li></ul><p>组变长整数编码：</p><ul><li>按块存储，每块大小为5-17个字节，存放4个整数编码</li><li>每块首字节：4个2位的二进制长度，<img src="https://math.now.sh?inline=L_j%20%5Cin%20%5C%7B1%2C2%2C3%2C4%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>使用<img src="https://math.now.sh?inline=L_1%2BL_2%2BL_3%2BL_4" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 字节（在4–16之间）存放4个整数</li></ul><p>Simple9编码：每块4字节，前4位标识块内结构，剩余28位存储若干个数字，每个数字占用相同的位数。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第2讲 索引构建</title>
    <link href="/2022/09/04/UCAS/information-retrieval/information-retrieval-2/"/>
    <url>/2022/09/04/UCAS/information-retrieval/information-retrieval-2/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第2讲 索引构建</p><span id="more"></span><p>语料通常很大，而服务器内存通常相对较小，因此需要在内存有限的情况下的索引构建策略。</p><h1>第2讲 索引构建</h1><p>词项：一个语料中不同的词的数量</p><p>词条：一个语料中所有词的数量（包括重复的）</p><h2 id="基于排序的索引构建方法存在的问题">基于排序的索引构建方法存在的问题</h2><p>在构建索引时，每次解析一篇文档，因此对于每个词项而言，其倒排记录表不到最后一篇文档都是不完整的。</p><p>如果每个 <code>(termID, docID)</code>对占用 <code>8</code>个字节, 那么处理大规模语料需要大量的空间。</p><p>一般内存的容量比较小，没有办法将前面产生的倒排记录表全部放在内存中，需要在磁盘上存储中间结果。</p><h2 id="内存和硬盘">内存和硬盘</h2><p>内存的典型配置是几G ～ 几十G的内存或上百G或1-2T</p><p>磁盘空间通常有几T（小型服务器）或10T以上（磁盘阵列）</p><p>硬盘空间更大，但是在内存中访问数据会比从硬盘访问数据快很多（大概10倍以上的差距）</p><p>硬盘寻道时间是闲置时间：磁头在定位时不发生数据传输（假设使用的是机械硬盘）</p><p>因此一个大（连续）块的传输会比多个小块（非连续）的传输速度快</p><p>硬盘 I/O是基于块的：读写时是整块进行的。块大小：8KB到256KB不等</p><p><strong>不能在硬盘上对倒排索引表进行排序，因为寻道的时间很慢，导致排序的时间也很慢。</strong></p><h2 id="BSBI算法">BSBI算法</h2><p><strong>一种减少寻道操作的排序：Blocked sort-based Indexing</strong></p><p>将所有记录划分为每个大小约为10M的块，收集每一块的倒排记录，排序，将倒排索引写入硬盘，最后将不同的分块合并为一个大的倒排索引。</p><p><strong>关键决策：块的大小-块越大，最后的合并操作就越少</strong></p><p>合并的过程中需要在磁盘中同时保存数据的两份拷贝（合并前与正在合并），因此磁盘空间要足够大。</p><p><a href="https://imgse.com/i/vTB5VS"><img src="https://s1.ax1x.com/2022/09/05/vTB5VS.png" alt="vTB5VS.png"></a></p><p>词项字符串的占用空间比较大，因此维护一个全局词典来将字符串映射到唯一的全局ID</p><p><strong>合并的过程中，将每一个小块的一点点数据放入内存中进行排序，排序好了就放在写缓冲区中，写缓冲区满了就写回硬盘，直到排序完成。</strong></p><p>可以将两两合并的方式优化为多项合并(multi-way merge)：</p><ul><li>从所有块同时读取，并且为每块保持一个读缓冲区(read buffer)</li><li>为输出文件（即合并后的索引）保持一个写缓冲区（write buffer）</li><li>维护一个待处理 <code>termid</code>的优先级队列(priority queue)，每次迭代从队列中选取一个最小的未处理 <code>termid</code></li><li>合并不同块中所有的该 <code>termid</code>的倒排记录，并写入磁盘。</li><li>因此每次迭代均处理较小规模的数据（一个词项的倒排记录）。</li></ul><p>BSBI算法的问题：</p><ul><li>假定词典可以在内存中放下</li><li>通常需要一部词典（动态增长）来将 <code>term</code>映射成 <code>termID</code>。实际上倒排记录表可以直接采用 <code>(term,docID)</code>方式而不是<br><code>(termID,docID)</code>方式，但是此时中间文件（即待合并的倒排记录表）将会变得很大（字符串比整型数空间消耗更大）</li></ul><h2 id="SPIMI算法">SPIMI算法</h2><p><strong>内存式单遍扫描索引构建算法：Single-pass in-memory indexing</strong></p><p>关键思想：</p><ul><li>对每个块都产生一个独立的词典（不需要在块之间进行 <code>term-termID</code>的映射）</li><li>对倒排记录表不排序，按照它们出现的先后顺序排列，只对词典排序（实际上由于指针的存在，倒排记录表没有排序的必要）。</li></ul><p><strong>在扫描文档的同时，直接在内存中维护一个不断更新的倒排索引</strong></p><p>因此对每个块生成一个完整的倒排索引，这些独立的索引最后合并成一个大索引</p><p>最终合并词典的过程中，需要进行词项字符串的比较，因为此时没有全局词典提供词项-整数ID的映射。</p><p><a href="https://imgse.com/i/vTDP2R"><img src="https://s1.ax1x.com/2022/09/05/vTDP2R.png" alt="vTDP2R.png"></a></p><h3 id="BSBI算法和SPIMI算法的主要区别">BSBI算法和SPIMI算法的主要区别</h3><p>BSBI算法：在分块索引阶段，BSBI算法维护一个全局Term (String) – Termid (int) 的映射表，局部索引为Termid及其倒排记录表，仍然按词典顺序排序。</p><p>SPIMI算法：分块索引阶段与BSBI算法不同在于建立局部词典和索引，无需全局词典。在合并阶段，将局部索引两两合并，最后产生全局词典建立Term – Termid的映射。</p><h2 id="动态索引构建">动态索引构建</h2><p>实际中文档会增加、删除和修改，因此词典和倒排记录表必须要动态更新。</p><p>最简单的方法：主索引(Main index)+辅助索引(Auxiliary index)</p><ul><li>在磁盘上维护一个大的主索引(Main index)</li><li>新文档放入内存中较小的辅助索引中</li><li>同时搜索两个索引，然后合并结果</li><li>定期将辅助索引合并到主索引中</li></ul><p>删除的处理：</p><ul><li>采用无效位向量(Invalidation bit-vector)来表示删除的文档</li><li>利用该维向量过滤返回的结果，以去掉已删除文档</li></ul><p>问题：</p><ul><li>合并过于频繁</li><li>合并时如果正好在搜索，那么搜索的性能将很低</li></ul><p><strong>辅助索引方式： 每次合并都需要处理每个倒排记录，索引构建时间为<img src="https://math.now.sh?inline=O%28T%5E2%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></strong><em>，其中</em><img src="https://math.now.sh?inline=T" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是所有倒排记录的个数</p><p>对数合并(Logarithmic merge)：</p><p>对数合并算法能够缓解(随时间增长)索引合并的开销 → 用户并不感觉到响应时间上有明显延迟。</p><ul><li>维护一系列索引，其中每个索引是前一个索引的两倍大小</li><li>将最小的索引<img src="https://math.now.sh?inline=Z_0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>置于内存</li><li>将其他更大的索引 <img src="https://math.now.sh?inline=I_0%2C%20I_1%2C%20%5Ccdots" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> 置于磁盘</li><li>如果 <img src="https://math.now.sh?inline=Z_0%3En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，则将它作为 $I_0 $写到磁盘中（如果 $I_0 $不存在）</li><li>或者和<img src="https://math.now.sh?inline=I_0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>合并（如果<img src="https://math.now.sh?inline=I_0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>已经存在），并将合并结果作为<img src="https://math.now.sh?inline=I_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>写到磁盘中（如果<img src="https://math.now.sh?inline=I_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>不存在），或者和<img src="https://math.now.sh?inline=I_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>合并（如果<img src="https://math.now.sh?inline=I_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>已经存在），依此类推</li></ul><p><strong>因此每次两两合并中两个索引的大小相同</strong></p><p>索引数目的上界为<img src="https://math.now.sh?inline=O%28log%20T%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/> ，因此查询处理时需要合并<img src="https://math.now.sh?inline=O%28log%20T%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个索引，因此每个倒排记录需要合并<img src="https://math.now.sh?inline=O%28log%20T%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>次，则索引构建时间为<img src="https://math.now.sh?inline=O%28T%20log%20T%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，时间复杂度相比较辅助索引方式小了一个数量级。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第2章 贝叶斯学习</title>
    <link href="/2022/09/02/UCAS/machine-learning/machine-learning-2/"/>
    <url>/2022/09/02/UCAS/machine-learning/machine-learning-2/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第2章 贝叶斯学习</p><span id="more"></span><h1>第2章 贝叶斯学习</h1><h2 id="概述">概述</h2><ol><li>依赖先验的决策：</li></ol><p>某地全年365天，晴朗265天，非晴朗100天。判断明天天气如何？</p><p>令<img src="https://math.now.sh?inline=A%3D%E6%99%B4%E5%A4%A9" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cneg%7BA%7D%3D%E4%B8%8D%E6%99%B4%E5%A4%A9" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则：</p><p><img src="https://math.now.sh?inline=P%28A%29%3D%5Cfrac%7B265%7D%7B365%7D%3D0.726" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=P%28%5Cneg%7BA%7D%29%3D%5Cfrac%7B100%7D%7B365%7D%3D0.274" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，因此<img src="https://math.now.sh?inline=P%28A%29%3EP(%5Cneg%7BA%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，明天晴天的概率更大。</p><ol start="2"><li>若增加可观测信息：晴朗（非晴朗）天气前一天特征（是否有晚霞）的统计。</li></ol><p>令<img src="https://math.now.sh?inline=B%3D%E6%9C%89%E6%99%9A%E9%9C%9E" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cneg%7BB%7D%3D%E6%B2%A1%E6%9C%89%E6%99%9A%E9%9C%9E" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=P%28B%7CA%29%3D0.7" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=P%28%5Cneg%7BB%7D%7CA%29%3D0.3" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=P%28B%7C%5Cneg%7BA%7D%29%3D0.1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=P%28%5Cneg%7BB%7D%7C%5Cneg%7BA%7D%29%3D0.9" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>今天有晚霞，判断明天天气如何？ 即计算<img src="https://math.now.sh?inline=P%28A%7CB%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=P%28%5Cneg%7BA%7D%7CB%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>今天没有晚霞，判断明天天气如何？ 即计算<img src="https://math.now.sh?inline=P%28A%7C%5Cneg%7BB%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=P%28%5Cneg%7BA%7D%7C%5Cneg%7BB%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>利用贝叶斯决策原理：</p><p><img src="https://math.now.sh?inline=P%28A%7CB%29%3D%5Cfrac%7BP(B%7CA)P(A)%7D%7BP(B)%7D%3D%5Cfrac%7BP(B%7CA)P(A)%7D%7BP(B%7CA)P(A)%2BP(B%7C%5Cneg%7BA%7D)P(%5Cneg%7BA%7D)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=P%28%5Cneg%7BA%7D%7CB%29%3D%5Cfrac%7BP(B%7C%5Cneg%7BA%7D)P(%5Cneg%7BA%7D)%7D%7BP(B)%7D%3D%5Cfrac%7BP(B%7C%5Cneg%7BA%7D)P(%5Cneg%7BA%7D)%7D%7BP(B%7CA)P(A)%2BP(B%7C%5Cneg%7BA%7D)P(%5Cneg%7BA%7D)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=A" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的联合概率：<img src="https://math.now.sh?inline=P%28A%2CB%29%3DP(B%7CA)P(A)%3DP(A%7CB)P(B)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>因此可以求得<img src="https://math.now.sh?inline=P%28A%7CB%29%3EP(%5Cneg%7BA%7D%7CB)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则在前一天有晚霞的条件下晴天的概率要大于不是晴天的概率。</strong></p><h2 id="贝叶斯决策论">贝叶斯决策论</h2><p><strong>贝叶斯公式：</strong></p><p><img src="https://math.now.sh?inline=P%28A_i%7CB%29%3D%5Cfrac%7BP(B%7CA_i)P(A_i)%7D%7BP(B)%7D%3D%5Cfrac%7BP(B%7CA_i)P(A_i)%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%7BP(B%7CA_j)P(A_j)%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此<img src="https://math.now.sh?inline=P%28A_i%7CB%29%5Cpropto%20P(B%7CA_i)P(A_i)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>贝叶斯决策：</strong></p><p>基于观察特征、类别的贝叶斯公式：</p><p><img src="https://math.now.sh?inline=P%28%5Comega_i%7Cx%29%3D%5Cfrac%7BP(x%7C%5Comega_i)P(%5Comega_i)%7D%7BP(x)%7D%3D%5Cfrac%7BP(x%7C%5Comega_i)P(%5Comega_i)%7D%7B%5Csum_%7Bj%7D%7BP(x%7C%5Comega_j)P(%5Comega_j)%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>也就是：<img src="https://math.now.sh?inline=%E7%B1%BB%E5%88%AB%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%3D%5Cfrac%7B%E8%A7%82%E6%B5%8B%E6%A0%B7%E6%9C%AC%E4%BC%BC%E7%84%B6*%E7%B1%BB%E5%88%AB%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87%7D%7Bevidence%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此<img src="https://math.now.sh?inline=P%28%5Comega_i%7Cx%29%5Cpropto%20P(x%7C%5Comega_i)P(%5Comega_i)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即<img src="https://math.now.sh?inline=%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%20%5Cpropto%20%E4%BC%BC%E7%84%B6*%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>如果存在<img src="https://math.now.sh?inline=%5Comega_1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Comega_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>两个变量进行决策，即计算<img src="https://math.now.sh?inline=P%28%5Comega_1%7Cx%29%3FP(%5Comega_2%7Cx)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则可以转换为计算<img src="https://math.now.sh?inline=P%28x%7C%5Comega_1%29P(%5Comega_1)%3FP(x%7C%5Comega_2)P(%5Comega_2)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>更改为比值的形式：<img src="https://math.now.sh?inline=%5Cfrac%7BP%28x%7C%5Comega_1%29%7D%7BP(x%7C%5Comega_2)%7D%3F%5Cfrac%7BP(%5Comega_2)%7D%7BP(%5Comega_1)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>可以定义类别相似性函数<img src="https://math.now.sh?inline=g_i%28x%29%3DP(%5Comega_i%7Cx)%3D%5Cfrac%7BP(x%7C%5Comega_i)P(%5Comega_i)%7D%7B%5Csum_%7Bj%3D1%7D%7BP(x%7C%5Comega_j)P(%5Comega_j)%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>分母都是相同的，因此可以将<img src="https://math.now.sh?inline=g_i%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>转化为<img src="https://math.now.sh?inline=g_i%28x%29%3DP(x%7C%5Comega_i)P(%5Comega_i)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>概率有很多都是<img src="https://math.now.sh?inline=e%5Ex" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的形式，因此可以将<img src="https://math.now.sh?inline=g_i%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>转化为<img src="https://math.now.sh?inline=g_i%28x%29%3Dln%7BP(x%7C%5Comega_i)%7D%2Bln%7BP(%5Comega_i)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，将乘积的形式转换为和的形式。</p><p>对于两变量决策问题来说，可以计算决策边界<img src="https://math.now.sh?inline=g%28x%29%3Dg_1(x)-g_2(x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，绘制后可以直观看出边界的形状，可能是直线也可能是曲线，这样实现了贝叶斯决策方法。</p><h2 id="贝叶斯分类器">贝叶斯分类器</h2><ul><li>朴素贝叶斯分类器：假设<img src="https://math.now.sh?inline=P%28x%20%7C%20c%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>特征向量的各维属性独立；</li><li>半朴素贝叶斯分类器：假设<img src="https://math.now.sh?inline=P%28x%20%7C%20c%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的各维属性存在依赖；</li><li>正态分布的贝叶斯分类器：假设<img src="https://math.now.sh?inline=P%28x%20%7C%20c(%5Ctheta%29)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>服从正态分布；</li></ul><h3 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h3><p>采用了“属性条件独立性假设”</p><p><img src="https://math.now.sh?inline=P%28c%7Cx%29%3D%5Cfrac%7BP(x%7Cc)P(c)%7D%7BP(x)%7D%20%5Cpropto%20P(x%7Cc)P(c)%3DP(c)%5Cprod_%7Bi%3D1%7D%5EdP(x_i%7Cc)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>关键问题：由训练样本学习类别条件概率和类别先验概率<img src="https://math.now.sh?inline=P%28x%20%7Cc%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=P%28c%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></strong></p><p><img src="https://math.now.sh?inline=P%28x_i%7Cc_j%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>包括<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的<img src="https://math.now.sh?inline=d" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个属性和<img src="https://math.now.sh?inline=c" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的<img src="https://math.now.sh?inline=k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个类别，加上<img src="https://math.now.sh?inline=P%28c%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，共有<img src="https://math.now.sh?inline=1%2Bd*k" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个概率分布需要统计。</p><p>类别先验概率<img src="https://math.now.sh?inline=P%28c%29%3D%5Cfrac%7BD_c%7D%7BD%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>类别概率密度 <img src="https://math.now.sh?inline=P%28x%7Cc%29%3D%5Cprod_%7Bi%3D1%7D%5EdP(x_i%7Cc)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>对于<img src="https://math.now.sh?inline=P%28x_i%7Cc%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来说，若<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是离散的变量，则 <img src="https://math.now.sh?inline=P%28x_i%7Cc%29%3D%5Cfrac%7B%7CD_%7Bc%2Cx_i%7D%7C%7D%7B%7CD_c%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中<img src="https://math.now.sh?inline=D_%7Bc%2Cx_i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示<img src="https://math.now.sh?inline=D_c" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中在第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个属性上取值为<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的样本组成的集合。</p><p>若<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是连续的变量，则 <img src="https://math.now.sh?inline=P%28x_i%7Cc%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%5Csigma_%7Bc%2Ci%7D%7Dexp(-%5Cfrac%7B(x_i-%5Cmu_%7Bc%2Ci%7D)%5E2%7D%7B2%5Csigma%5E2_%7Bc%2Ci%7D%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（由某一概率分布估计类别概率）</p><p>拉普拉斯平滑：避免因训练集样本不充分而导致概率估计值为零。</p><p>平滑后：<img src="https://math.now.sh?inline=%5Chat%7BP%7D%28c%29%3D%5Cfrac%7B%7CD_c%7C%2B1%7D%7B%7CD%7C%2BN%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=N" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为类别数；<img src="https://math.now.sh?inline=%5Chat%7BP%7D%28x_i%7Cc%29%3D%5Cfrac%7B%7CD_%7Bc%2Cx_i%7D%7C%2B1%7D%7B%7CD_c%7C%2BN_i%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=N_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的可能取值个数。</p><h3 id="正态分布的贝叶斯分类器">正态分布的贝叶斯分类器</h3><p>若<img src="https://math.now.sh?inline=x_i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是连续的变量，则 <img src="https://math.now.sh?inline=P%28x_i%7Cc%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%5Csigma_%7Bc%2Ci%7D%7Dexp(-%5Cfrac%7B(x_i-%5Cmu_%7Bc%2Ci%7D)%5E2%7D%7B2%5Csigma%5E2_%7Bc%2Ci%7D%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（设置其为正态分布的概率密度）</p><p>多维正态分布的概率密度：<img src="https://math.now.sh?inline=p%28x%29%3D%5Cfrac%7B1%7D%7B(2%20%5Cpi)%5E%7Bd%20%2F%202%7D%7C%5CSigma%7C%5E%7B1%20%2F%202%7D%7D%20%5Cexp%20%5Cleft%5B-%5Cfrac%7B1%7D%7B2%7D(x-%5Cmu)%5ET%20%5CSigma%5E%7B-1%7D(x-%5Cmu)%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>在每个维度上都是正态分布：<img src="https://math.now.sh?inline=%5Cmu_i%3D%5Cvarepsilon%5Cleft%5Bx_i%5Cright%5D%20%3B%20%5Cquad%20%5Csigma_%7Bi%20j%7D%3D%5Cvarepsilon%5Cleft%5B%5Cleft%28x_i-%5Cmu_i%5Cright%29%5Cleft(x_j-%5Cmu_j%5Cright)%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>贝叶斯学习将公式化简为对数的形式：<img src="https://math.now.sh?inline=g_i%28x%29%3D-%5Cfrac%7B1%7D%7B2%7D%5Cleft(x-%5Cmu_i%5Cright)%5ET%20%5Csum_i%5E%7B-1%7D%5Cleft(x-%5Cmu_i%5Cright)-%5Cfrac%7Bd%7D%7B2%7D%20%5Cln%202%20%5Cpi-%5Cfrac%7B1%7D%7B2%7D%20%5Cln%20%5Cleft%7C%5Csum_i%5Cright%7C%2B%5Cln%20p%5Cleft(%5Comega_i%5Cright)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>不同的高斯参数情况：</strong></p><p><img src="https://math.now.sh?inline=%5Csum_i%3D%5Csigma%5E2%20I" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：均为正态分布（当各个类别先验相等时，退化为最小距离分类器，退化为垂直平分面）</p><p><a href="https://imgse.com/i/vL14KO"><img src="https://s1.ax1x.com/2022/09/09/vL14KO.md.png" alt="vL14KO.md.png"></a></p><p><img src="https://math.now.sh?inline=%5Csum_%7Bi%7D%3D%5Csum" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>：各类分布都相同</p><p><a href="https://imgse.com/i/vL1ORP"><img src="https://s1.ax1x.com/2022/09/09/vL1ORP.png" alt="vL1ORP.png"></a></p><h2 id="贝叶斯学习与参数估计问题">贝叶斯学习与参数估计问题</h2><p><a href="https://blog.csdn.net/qq_45785407/article/details/121018203">推导</a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：机器学习-第1章 绪论</title>
    <link href="/2022/09/02/UCAS/machine-learning/machine-learning-1/"/>
    <url>/2022/09/02/UCAS/machine-learning/machine-learning-1/</url>
    
    <content type="html"><![CDATA[<p>《机器学习》课程笔记：第1章 绪论</p><span id="more"></span><ul><li>了解机器学习研究问题<ul><li>有监督学习：分类、回归</li><li>无监督学习：聚类、降维、特征提取等；</li></ul></li><li>掌握基本的统计和优化方法<ul><li>统计学习基础：最大似然估计、最小均方等；</li><li>优化基础：梯度下降 、随机梯度下降等；</li></ul></li><li>掌握机器学习的基础理论和算法<ul><li>Bayes、 SVM、鉴别分析、 logistic、决策树、感知机、多层感知机、 Adaboost、线性回归、kmeans、 PCA、 概率图模型、知识图谱、深度学习及前沿等；</li></ul></li><li>能够针对任务设计机器学习方案</li></ul><h1>第1章 绪论</h1><h2 id="机器学习研究背景：人工智能">机器学习研究背景：人工智能</h2><p>什么是人工智能？</p><p>“人工智能就是让<strong>机器</strong>来完成那些如果由<strong>人</strong>来做则<strong>需要智能的事情</strong>的科学”；</p><p>“人工智能就是研究如何使<strong>计算机</strong>去做只有<strong>人</strong>才能做的<strong>智能工作</strong>”</p><p>“人工智能是研究使<strong>计算机</strong>来模拟人的某些思维过程和智能行为 （如学习、推理、思考、规划等）的学科 ”</p><p>图灵测试思考的问题：</p><ul><li>人的智能非常复杂： 例如 直觉 、顿悟、理解，等等</li><li>人的智能具有“人”性：例如 情绪、伪装、狡猾，等等；</li><li>人的智能缺陷：不依赖于数学工具，无法实现高难度、大规模的运算；不依赖于词典和存储工具，信息的记忆量、精准性有限；</li></ul><p><strong>我们研究的是弱人工智能</strong></p><h3 id="人工智能的发展">人工智能的发展</h3><ul><li>孕育期（~1956）：1950 年图灵测试</li><li>推理期（1956~1965）：1956 年逻辑理论家程序、 1960 年 Lisp 语言</li><li>知识期（1965~1983）：1965 年分子结构的专家系统 DENDRAL、1972年细菌感染专家系统MYCIN</li><li>学习期（1983~2006）：解决知识工程瓶颈， 统计机器学习主导</li><li>黄金期（2006~）：以深度学习为 代表的人工智能核心技术不断取得新突破</li></ul><p>对人工智能的期望</p><ul><li>在人工智能的第一波中，你必须成为一名程序员；</li><li>在人工智能的第二次浪潮中，你必须是一名数据科学家；</li><li>人工智能的第三次浪潮，你越道德越好。。。</li></ul><p>人工智能创新发展引领新一轮产业变革之势，推动人类社会进入智能化时代，人工智能成为世界各国竞相战略布局的新高地，我国人工智能综合实力不断提升。</p><h2 id="机器学习的发展">机器学习的发展</h2><p><strong>机器学习是一门人工智能的科学</strong></p><p>“机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能 。 Langley（1996）“</p><p>“机器学习是对能通过经验自动改进的计算机算法的研究 。 Tom Mitchell （1997）“</p><p>“机器学习是用数据或以往的经验，以此优化计算机程序的性能标准”。 Alpaydin （2004）</p><p><strong>机器学习发展时期</strong></p><p>推理期➡知识期➡学科形成➡蓬勃发展期</p><p><strong>应用领域</strong></p><ul><li>航空航天、军事、国防</li><li>机器人、无人车、 NASA-JPL 火星机器人</li><li>互联网应用</li><li>信息安全</li><li>生物信息学</li><li>天气预报、地震预警、环境污染检测</li><li>智能识别</li><li>金融、经贸、管理 、 公共安全 、 医学 、 交通 、</li></ul><p><strong>机器学习研究意义</strong></p><ul><li>机器学习是人工智能的基石</li><li>机器学习引领人工智能的前沿</li><li>支持宽泛的学科领域</li></ul><h2 id="机器学习研究的问题">机器学习研究的问题</h2><p>机器学习的一般过程</p><p><a href="https://imgse.com/i/vIfz4K"><img src="https://s1.ax1x.com/2022/09/02/vIfz4K.png" alt="vIfz4K.png"></a></p><ol><li>监督学习：学习输入 <code>x</code>到输出 <code>y</code>的映射，训练数据会有标签 <code>y</code>，分为回归问题和分类问题。</li><li>无监督学习：学习数据之间的关联，训练数据是没有标签的，典型问题是聚类。</li><li>强化学习：学习输入 <code>x</code>到输出 <code>y</code>的映射，不会提供标签，但是会给一个反馈表示目前的选择有多好。</li></ol><p>机器学习流程：</p><ol><li>收集数据</li><li>选择模型（选择合适的模型，确定优化函数）</li><li>训练模型：找到可以优化损失函数的合适的参数集</li><li>应用训练好的模型</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>UCAS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第7章 动态规划</title>
    <link href="/2022/09/02/Leetcode/Leetcode-101/Leetcode-101-7/"/>
    <url>/2022/09/02/Leetcode/Leetcode-101/Leetcode-101-7/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第7章 动态规划</p><span id="more"></span><h1>动态规划</h1><p>动态规划和其它遍历算法（如深/广度优先搜索）都是将原问题拆成多个子问题然后求解，他们之间最本质的区别是，动态规划<strong>保存子问题的解，避免重复计算</strong>。解决动态规划问题的关键是找到<strong>状态转移方程</strong>，这样我们可以通过计算和储存子问题的解来求解最终问题。同时也可以对动态规划进行<strong>空间压缩</strong>，起到节省空间消耗的效果。</p><h2 id="基本动态规划：一维">基本动态规划：一维</h2><h3 id="Leetcode-70">Leetcode 70</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">num</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> n;        &#125;        <span class="hljs-keyword">else</span>&#123;            num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;            num[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;++i)&#123;                num[i] = num[i<span class="hljs-number">-1</span>] + num[i<span class="hljs-number">-2</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> num[n];    &#125;&#125;;</code></pre></div><p>分析：<code>num[i]</code>表示在第 <code>i</code>阶的方法数，则到达第 <code>i</code>阶的方法是到达第 <code>i-1</code>阶的方法和到达第 <code>i-2</code>阶的方法数之和。因此 <code>num[i] = num[i-1] + num[i-2]</code>。判断边界条件即可。</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-198">Leetcode 198</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统， <strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。给定一个代表每个房屋存放金额的非负整数数组，计算<strong>你不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);        &#125;        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;++i)&#123;            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>] + nums[i<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre></div><p>分析：定义一个数组 <code>dp</code>，<code>dp[i]</code>表示抢劫到第i个房子时，可以抢劫的最大数量。我们考虑 <code>dp[i]</code>，此时可以抢劫的最大数量有两种可能，一种是我们选择不抢劫这个房子，此时累计的金额即为 <code>dp[i-1]</code>；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 <code>dp[i-2]</code>。因此本题的状态转移方程为 <code>dp[i] = max(dp[i-1],nums[i-1] + dp[i-2])</code>。然后判断边界条件即可。</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-413">Leetcode 413</h3><p>给定一个数组，求这个数组中连续且等差的子数组一共有多少个</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfArithmeticSlices</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(n<span class="hljs-number">+1</span>);        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i &lt; n;++i)&#123;            <span class="hljs-keyword">if</span>(nums[i] - nums[i<span class="hljs-number">-1</span>] == nums[i<span class="hljs-number">-1</span>] - nums[i<span class="hljs-number">-2</span>])&#123;                dp[i<span class="hljs-number">+1</span>] = dp[i] + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(dp.<span class="hljs-built_in">begin</span>(),dp.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);    &#125;&#125;;</code></pre></div><p>分析：这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 <code>num[i] - num[i-1] = num[i-1] - num[i-2]</code>。然而由于我们对于 <code>dp</code>数组的定义通常为以 <code>i</code>结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 <code>dp</code>数组求和。</p><p>错误：最开始写的时候越界了</p><h2 id="基本动态规划：二维">基本动态规划：二维</h2><h3 id="Leetcode-64">Leetcode 64</h3><p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)&#123;            dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;++j)&#123;            dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][j];        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;++j)&#123;                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre></div><p>分析：定义一个同样是二维的 <code>dp</code>数组，其中 <code>dp[i][j]</code>表示从左上角开始到 <code>(i, j)</code>位置的最优路径的数字和。因为每次只能向下或者向右移动，我们可以很容易得到状态转移方程 <code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>，其中 <code>grid</code>表示原数组。</p><p>错误：注意区间，开多大的 <code>dp</code>数组以及怎么进行状态转移，不要把自己转蒙。</p><h3 id="Leetcode-542">Leetcode 542</h3><p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>mat</code> ，请输出一个大小相同的矩阵，其中每一个格子是 <code>mat</code> 中对应位置元素到最近的 <code>0</code> 的距离。两个相邻元素间的距离为 <code>1</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat) &#123;        <span class="hljs-type">int</span> m = mat.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));        <span class="hljs-keyword">if</span>(mat[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;            dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">10002</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">if</span>(mat[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;                dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;++j)&#123;            <span class="hljs-keyword">if</span>(mat[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;                dp[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;++j)&#123;                <span class="hljs-keyword">if</span>(mat[i][j] == <span class="hljs-number">0</span>)&#123;                    dp[i][j] = <span class="hljs-number">0</span>;                &#125;                <span class="hljs-keyword">else</span>&#123;                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;            <span class="hljs-keyword">if</span>(mat[i][n<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span>)&#123;                dp[i][n<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                dp[i][n<span class="hljs-number">-1</span>] = <span class="hljs-built_in">min</span>(dp[i][n<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">+1</span>][n<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-2</span>;j&gt;=<span class="hljs-number">0</span>;--j)&#123;            <span class="hljs-keyword">if</span>(mat[m<span class="hljs-number">-1</span>][j] == <span class="hljs-number">0</span>)&#123;                dp[m<span class="hljs-number">-1</span>][j] = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                dp[m<span class="hljs-number">-1</span>][j] = <span class="hljs-built_in">min</span>(dp[m<span class="hljs-number">-1</span>][j],dp[m<span class="hljs-number">-1</span>][j<span class="hljs-number">+1</span>] + <span class="hljs-number">1</span>);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;--i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=n<span class="hljs-number">-2</span>;j&gt;=<span class="hljs-number">0</span>;--j)&#123;                <span class="hljs-keyword">if</span>(mat[i][j] != <span class="hljs-number">0</span>)&#123;                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j],<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">+1</span>][j],dp[i][j<span class="hljs-number">+1</span>])<span class="hljs-number">+1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp;    &#125;&#125;;</code></pre></div><p>分析：从左上到右下进行一次动态搜索，再从右下到左上进行一次动态搜索。两次动态搜索即可完成四个方向上的查找。</p><p>错误：看了一下题解的思路，还是有点不敢想。另外要细心，注意越界！！！</p><h3 id="Leetcode-221">Leetcode 221</h3><p>在一个由 <code>'0'</code> 和 <code>'1'</code> 组成的二维矩阵内，找到只包含 <code>'1'</code> 的最大正方形，并返回其面积。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximalSquare</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>));        <span class="hljs-type">int</span> maxside = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;                <span class="hljs-keyword">if</span>(matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],<span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j])) + <span class="hljs-number">1</span>;                &#125;                maxside = <span class="hljs-built_in">max</span>(maxside,dp[i][j]);            &#125;        &#125;        <span class="hljs-keyword">return</span> maxside * maxside;    &#125;&#125;;</code></pre></div><p>分析：<code>dp[i][j]</code>表示以 <code>(i, j)</code>为右下角的全由 <code>1</code>构成的最大正方形边长。</p><p>错误：状态转移方程没有想太好。</p><h2 id="分割类型题">分割类型题</h2><p>对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。</p><h3 id="Leetcode-279">Leetcode 279</h3><p>给你一个整数 <code>n</code> ，返回 和为 <code>n</code> 的完全平方数的最少数量 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">100000000</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j*j&lt;=i;++j)&#123;                dp[i] = <span class="hljs-built_in">min</span>(dp[i],dp[i-j*j]<span class="hljs-number">+1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre></div><p>分析：<code>dp[i]</code>表示数字 <code>i</code>最少可以由几个完全平方数相加构成。</p><p>错误：没有思路</p><h3 id="Leetcode-91">Leetcode 91</h3><p>输入是一个由数字组成的字符串，输出是满足条件的解码方式总数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        vector&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">dp</span>(n<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>);        <span class="hljs-type">int</span> prev = s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;            <span class="hljs-type">int</span> cur = s[i<span class="hljs-number">-1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>;            <span class="hljs-keyword">if</span>((prev == <span class="hljs-number">0</span> || prev &gt; <span class="hljs-number">2</span>) &amp;&amp; cur == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">if</span>((prev == <span class="hljs-number">1</span>) || (prev == <span class="hljs-number">2</span> &amp;&amp; cur &lt; <span class="hljs-number">7</span>))&#123;                <span class="hljs-keyword">if</span>(cur)&#123;                    dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];                &#125;                <span class="hljs-keyword">else</span>&#123;                    dp[i] = dp[i<span class="hljs-number">-2</span>];                &#125;            &#125;            <span class="hljs-keyword">else</span>&#123;                dp[i] = dp[i<span class="hljs-number">-1</span>];            &#125;            prev = cur;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre></div><p>分析：<code>dp[i]</code>表示以当前第i个位置上的数字为结尾的表示方法总数。<code>dp[i]</code>取决于两个数字，当前的数字和前一个数字。如果当前数字是 <code>0</code>，而前一个数字不是 <code>1</code>或者 <code>2</code>，说明这两个数字不可能构成字符，因此直接返回 <code>0</code>。如果前一个数字是 <code>1</code>，当前的数字是什么都行，或者前一个数字是 <code>2</code>，而当前的数字是 <code>0-6</code>的某一个数，说明这两个能构成一种组合。同时如果当前的数字不是 <code>0</code>，那么这个数字自己也能构成一种。如果前一个数字是其他，说明不能和当前的数字产生关系了，就只能是当前的数字自己了。</p><p>错误：不明白</p><h3 id="Leetcode-139">Leetcode 139</h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。请你判断是否可以利用字典中出现的单词拼接出 <code>s</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> string &amp; word : wordDict)&#123;                <span class="hljs-type">int</span> len = word.<span class="hljs-built_in">size</span>();                <span class="hljs-keyword">if</span>(i &gt;= len &amp;&amp; s.<span class="hljs-built_in">substr</span>(i-len,len) == word)&#123;                    dp[i] = dp[i] || dp[i-len];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre></div><p>分析：类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。注意对于位置0，需要初始化值为真。</p><h2 id="子序列问题">子序列问题</h2><p>对于子序列问题，第一种动态规划方法是，定义一个 <code>dp</code>数组，其中 <code>dp[i]</code>表示以 <code>i</code>结尾的子序列的性质。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。第二种动态规划方法是，定义一个 <code>dp</code>数组，其中 <code>dp[i]</code>表示到位置 <code>i</code>为止的子序列的性质，并不必须以 <code>i</code>结尾。这样 <code>dp</code>数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。</p><h3 id="Leetcode-300">Leetcode 300</h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;                <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>] &gt; nums[j])&#123;                    dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j<span class="hljs-number">+1</span>]<span class="hljs-number">+1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(),dp.<span class="hljs-built_in">end</span>());    &#125;&#125;;</code></pre></div><p>分析： <code>dp[i]</code>表示以 <code>i</code>结尾的子序列的性质。简单动态规划即可。</p><p>错误：下标指代不清，初始化应该全部为1</p><h3 id="Leetcode-1143">Leetcode 1143</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长<strong>公共子序列</strong>的长度。如果不存在<strong>公共子序列</strong>，返回 <code>0</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;        <span class="hljs-type">int</span> m = text<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = text<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span>&#123;                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j]);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;;</code></pre></div><p>分析：建立一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code>表示到第一个字符串位置 <code>i</code>为止、到第二个字符串位置 <code>j</code>为止、最长的公共子序列长度。</p><p>错误：没想到是二维的动态规划。</p><h2 id="背包问题">背包问题</h2><p>给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        sum /= <span class="hljs-number">2</span>;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(sum<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=sum;++j)&#123;                <span class="hljs-keyword">if</span>(j &lt; nums[i<span class="hljs-number">-1</span>])&#123;                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j];                &#125;                <span class="hljs-keyword">else</span>&#123;                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] || dp[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n][sum];    &#125;&#125;;</code></pre></div><p>分析：背包问题，价值是一半，背包容量没有限制。比较重要的是 <code>dp[0][0] =true</code>，后续的判断都是从这个 <code>true</code>继承过来的。</p><p>错误：思路不够完善</p><h3 id="Leetcode-474">Leetcode 474</h3><p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> ，请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中<strong>最多</strong>有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">getzerosandones</span><span class="hljs-params">(string &amp;str)</span></span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;        <span class="hljs-type">int</span> n = str.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;                ++result[<span class="hljs-number">0</span>];            &#125;            <span class="hljs-keyword">else</span>&#123;                ++result[<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxForm</span><span class="hljs-params">(vector&lt;string&gt;&amp; strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-type">int</span> l = strs.<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(l<span class="hljs-number">+1</span>,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(m<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=l;++i)&#123;            vector&lt;<span class="hljs-type">int</span>&gt; &amp;&amp; zerosones = <span class="hljs-built_in">getzerosandones</span>(strs[i<span class="hljs-number">-1</span>]);            <span class="hljs-type">int</span> zero = zerosones[<span class="hljs-number">0</span>];            <span class="hljs-type">int</span> one = zerosones[<span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;++j)&#123;                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=n;++k)&#123;                    dp[i][j][k] = dp[i<span class="hljs-number">-1</span>][j][k];                    <span class="hljs-keyword">if</span>(j &gt;= zero &amp;&amp; k &gt;= one)&#123;                        dp[i][j][k] = <span class="hljs-built_in">max</span>(dp[i][j][k],dp[i<span class="hljs-number">-1</span>][j-zero][k-one]<span class="hljs-number">+1</span>);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[l][m][n];    &#125;&#125;;</code></pre></div><p>分析：三维的背包问题，要同时考虑两个背包的容量。</p><p>错误：还是不理解</p><h3 id="Leetcode-322">Leetcode 322</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。计算并返回可以凑成总金额所需的<strong>最少的硬币个数</strong>。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> ，可以认为每种硬币的数量是无限的。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;        <span class="hljs-type">int</span> n = coins.<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(amount<span class="hljs-number">+1</span>,amount<span class="hljs-number">+1</span>));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=amount;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;                <span class="hljs-keyword">if</span>(coins[j<span class="hljs-number">-1</span>] &lt;= i)&#123;                    dp[j][i] = <span class="hljs-built_in">min</span>(dp[j<span class="hljs-number">-1</span>][i],dp[j][i-coins[j<span class="hljs-number">-1</span>]]<span class="hljs-number">+1</span>);                &#125;                <span class="hljs-keyword">else</span>&#123;                    dp[j][i] = dp[j<span class="hljs-number">-1</span>][i];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n][amount] == amount<span class="hljs-number">+1</span> ? <span class="hljs-number">-1</span> : dp[n][amount];    &#125;&#125;;</code></pre></div><p>分析：完全背包问题。</p><p>错误：就是不理解</p><h2 id="字符串编辑">字符串编辑</h2><h3 id="Leetcode-72">Leetcode 72</h3><p>给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;        <span class="hljs-type">int</span> m = word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i)&#123;            dp[i][<span class="hljs-number">0</span>] = i;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;++j)&#123;            dp[<span class="hljs-number">0</span>][j] = j;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>])&#123;                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];                &#125;                <span class="hljs-keyword">else</span>&#123;                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],<span class="hljs-built_in">min</span>(dp[i][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j])) + <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;;</code></pre></div><p>分析：使用一个二维数组 <code>dp[i][j]</code>，表示将第一个字符串到位置 <code>i</code>为止，和第二个字符串到位置 <code>j</code>为止，最多需要几步编辑。当第 <code>i</code>位和第 <code>j</code>位对应的字符相同时，<code>dp[i][j]</code>等于 <code>dp[i-1][j-1]</code>；当二者对应的字符不同时，修改的消耗是 <code>dp[i-1][j-1]+1</code>，插入 <code>i</code>位置/删除 <code>j</code>位置的消耗是 <code>dp[i][j-1] + 1</code>，插入 <code>j</code>位置/删除 <code>i</code>位置的消耗是 <code>dp[i-1][j] + 1</code>。</p><p>错误：初始化没有做好。</p><h3 id="Leetcode-650">Leetcode 650</h3><p>给定一个字母A，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作可以把字符串延展到指定长度。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSteps</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;            dp[i] = i;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j * j &lt;= i;++j)&#123;                <span class="hljs-keyword">if</span>(i % j == <span class="hljs-number">0</span>)&#123;                    dp[i] = dp[j] + dp[i/j];                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre></div><p>分析：我们使用一个一维数组dp，其中位置i表示延展到长度i的最少操作次数。对于每个位置j，如果j可以被i整除，那么长度i就可以由长度j操作得到，其操作次数等价于把一个长度为1的A延展到长度为i/j。因此我们可以得到递推公式dp[i] = dp[j] + dp[i/j]</p><p>错误：还是不会想。</p><h3 id="Leetcode-10">Leetcode 10</h3><p>给定一个字符串和一个正则表达式，求该字符串是否可以被匹配。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(string s, string p)</span> </span>&#123;        <span class="hljs-type">int</span> m = s.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = p.<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">if</span>(p[i<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;                dp[<span class="hljs-number">0</span>][i] = dp[<span class="hljs-number">0</span>][i<span class="hljs-number">-2</span>];            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;                <span class="hljs-keyword">if</span>(p[j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;.&#x27;</span>)&#123;                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] &amp;&amp; p[j<span class="hljs-number">-1</span>] == s[i<span class="hljs-number">-1</span>];                &#125;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p[j<span class="hljs-number">-2</span>] != s[i<span class="hljs-number">-1</span>] &amp;&amp; p[j<span class="hljs-number">-2</span>] != <span class="hljs-string">&#x27;.&#x27;</span>) &#123;                    dp[i][j] = dp[i][j<span class="hljs-number">-2</span>];                &#125;                 <span class="hljs-keyword">else</span> &#123;                    dp[i][j] = dp[i][j<span class="hljs-number">-1</span>] || dp[i<span class="hljs-number">-1</span>][j] || dp[i][j<span class="hljs-number">-2</span>];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;;</code></pre></div><p>分析：使用一个二维数组 <code>dp</code>，其中 <code>dp[i][j]</code>表示以 <code>i</code>截止的字符串是否可以被以 <code>j</code>截止的正则表达式匹配。</p><p>错误：没有思路</p><h2 id="股票交易">股票交易</h2><h3 id="Leetcode-121">Leetcode 121</h3><p>给定一段时间内每天某只股票的固定价格，已知你只可以买卖各一次，求最大的收益。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;        <span class="hljs-type">int</span> sell = <span class="hljs-number">0</span>, buy = INT_MIN;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); ++i) &#123;            buy = <span class="hljs-built_in">max</span>(buy, -prices[i]);            sell = <span class="hljs-built_in">max</span>(sell, buy + prices[i]);        &#125;        <span class="hljs-keyword">return</span> sell;    &#125;&#125;;</code></pre></div><p>分析：遍历一次就行，记录一下最小的价格，然后遍历到每个价格的时候看看是不是比这个价格更大就行了。</p><p>错误：简单的问题也不会想了。。。</p><h3 id="Leetcode-188">Leetcode 188</h3><p>给定一段时间内每天某只股票的固定价格，已知你只可以买卖各 <code>k</code>次，且每次只能拥有一支股票，求最大的收益。</p><h3 id="Leetcode-309">Leetcode 309</h3><p>给定一段时间内每天某只股票的固定价格，已知每次卖出之后必须冷却一天，且每次只能拥有一支股票，求最大的收益。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buy</span><span class="hljs-params">(n)</span>,<span class="hljs-title">sell</span><span class="hljs-params">(n)</span>,<span class="hljs-title">s1</span><span class="hljs-params">(n)</span>,<span class="hljs-title">s2</span><span class="hljs-params">(n)</span></span>;        s1[<span class="hljs-number">0</span>] = buy[<span class="hljs-number">0</span>] = -prices[<span class="hljs-number">0</span>];        sell[<span class="hljs-number">0</span>] = s2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;            buy[i] = s2[i<span class="hljs-number">-1</span>] - prices[i];            s1[i] = <span class="hljs-built_in">max</span>(buy[i<span class="hljs-number">-1</span>],s1[i<span class="hljs-number">-1</span>]);            sell[i] = <span class="hljs-built_in">max</span>(buy[i<span class="hljs-number">-1</span>],s1[i<span class="hljs-number">-1</span>]) + prices[i];            s2[i] = <span class="hljs-built_in">max</span>(s2[i<span class="hljs-number">-1</span>],sell[i<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(sell[n<span class="hljs-number">-1</span>],s2[n<span class="hljs-number">-1</span>]);    &#125;&#125;;</code></pre></div><p>分析：状态机求解</p><p>错误：完全不懂</p><h2 id="练习">练习</h2><h3 id="Leetcode-213">Leetcode 213</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;        <span class="hljs-type">int</span> answer_a;        dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;n;++i)&#123;            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>] + nums[i<span class="hljs-number">-1</span>]);        &#125;        answer_a = dp[n<span class="hljs-number">-1</span>];        dp[<span class="hljs-number">0</span>] = dp[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;        dp[<span class="hljs-number">2</span>] = nums[<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;++i)&#123;            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>] + nums[i<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(answer_a,dp[n]);    &#125;&#125;;</code></pre></div><p>分析：分两种情况进行讨论，选第一个和不选第一个。</p><p>错误：看了一下思路，最后调通了</p><h3 id="Leetcode-53">Leetcode 53</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">-20000</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            dp[i] = <span class="hljs-built_in">max</span>(nums[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>] + nums[i<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(),dp.<span class="hljs-built_in">end</span>());    &#125;&#125;;</code></pre></div><p>分析：dp数组记录以当前位置为结尾的子数组的最大和，因此后面再加一位有两种可能，一是和这个一起，二是自己一组。最后取最大的部分即可。</p><p>错误：开始没想太懂，后来自己调通了。</p><h3 id="Leetcode-343">Leetcode 343</h3><p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;++j)&#123;                dp[i] = <span class="hljs-built_in">max</span>(dp[i],<span class="hljs-built_in">max</span>(j*(i-j),j*dp[i-j]));            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre></div><p>分析：对于正整数n，当n≥2时，可以拆分成至少两个正整数的和。令x是拆分出的第一个正整数，则剩下的部分是n-x，n−x可以不继续拆分，或者继续拆分成至少两个正整数的和。每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积。</p><p>错误：分割问题还是没有什么思路</p><h3 id="Leetcode-583">Leetcode 583</h3><p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和  <code>word2</code> <strong>相同</strong>所需的 <strong>最小步数</strong> 。每步可以删除任意一个字符串中的一个字符。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;        <span class="hljs-type">int</span> m = word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;++i)&#123;            dp[i][<span class="hljs-number">0</span>] = i;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;++i)&#123;            dp[<span class="hljs-number">0</span>][i] = i;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;++j)&#123;                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>])&#123;                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];                &#125;                <span class="hljs-keyword">else</span>&#123;                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]) + <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[m][n];    &#125;&#125;;</code></pre></div><p>分析：不相等的时候看两边的字符串，相等的时候看前一位</p><p>错误：字符相等的时候有些没想明白，后来调通了</p><h3 id="Leetcode-646">Leetcode 646</h3><p>给出 <code>n</code> 个数对。 在每一个数对中，第一个数字总是比第二个数字小。现在，我们定义一种跟随关系，当且仅当 <code>b &lt; c</code> 时，数对 <code>(c, d)</code> 才可以跟在 <code>(a, b)</code> 后面。我们用这种形式来构造一个数对链。给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLongestChain</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;        <span class="hljs-type">int</span> n = pairs.<span class="hljs-built_in">size</span>();        <span class="hljs-built_in">sort</span>(pairs.<span class="hljs-built_in">begin</span>(),pairs.<span class="hljs-built_in">end</span>(),cmp);        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i<span class="hljs-number">-1</span>;++j)&#123;                <span class="hljs-keyword">if</span>(pairs[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] &gt; pairs[j][<span class="hljs-number">1</span>])&#123;                    dp[i] = <span class="hljs-built_in">max</span>(dp[i],dp[j<span class="hljs-number">+1</span>]<span class="hljs-number">+1</span>);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n];    &#125;&#125;;</code></pre></div><p>分析：排序后进行动态规划即可</p><p>错误：排序有问题。</p><h3 id="Leetcode-376">Leetcode 376</h3><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为摆动序列的<strong>最长子序列的长度</strong> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || (n == <span class="hljs-number">2</span> &amp;&amp; nums[<span class="hljs-number">0</span>] != nums[<span class="hljs-number">1</span>]))&#123;            <span class="hljs-keyword">return</span> n;        &#125;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span> &amp;&amp; nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>])&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">up</span><span class="hljs-params">(n)</span>,<span class="hljs-title">down</span><span class="hljs-params">(n)</span></span>;        up[<span class="hljs-number">0</span>] = down[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i<span class="hljs-number">-1</span>])&#123;                up[i] = <span class="hljs-built_in">max</span>(up[i<span class="hljs-number">-1</span>],down[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);                down[i] = down[i<span class="hljs-number">-1</span>];            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] &lt; nums[i<span class="hljs-number">-1</span>])&#123;                up[i] = up[i<span class="hljs-number">-1</span>];                down[i] = <span class="hljs-built_in">max</span>(down[i<span class="hljs-number">-1</span>],up[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>);            &#125;            <span class="hljs-keyword">else</span>&#123;                up[i] = up[i<span class="hljs-number">-1</span>];                down[i] = down[i<span class="hljs-number">-1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(up[n<span class="hljs-number">-1</span>],down[n<span class="hljs-number">-1</span>]);    &#125;&#125;;</code></pre></div><p>分析：每当我们选择一个元素作为摆动序列的一部分时，这个元素要么是上升的，要么是下降的，这取决于前一个元素的大小。那么列出状态表达式为：<code>up[i]</code>表示以前 <code>i</code>个元素中的某一个为结尾的最长的「上升摆动序列」的长度。<code>down[i]</code>表示以前i个元素中的某一个为结尾的最长的「下降摆动序列」的长度。</p><p>错误：没有思路</p><h3 id="Leetcode-494">Leetcode 494</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp; num : nums) &#123;            sum += num;        &#125;        <span class="hljs-type">int</span> diff = sum - target;        <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span> || diff % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), neg = diff / <span class="hljs-number">2</span>;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(neg + <span class="hljs-number">1</span>));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;            <span class="hljs-type">int</span> num = nums[i - <span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= neg; j++) &#123;                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];                <span class="hljs-keyword">if</span> (j &gt;= num) &#123;                    dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - num];                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> dp[n][neg];    &#125;&#125;;</code></pre></div><p>分析：转化为0-1背包问题</p><p>错误：背包问题一直都不怎么理解，就先这样，后续再补充。</p><h3 id="Leetcode-714">Leetcode 714</h3><p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices, <span class="hljs-type">int</span> fee)</span> </span>&#123;        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = -prices[<span class="hljs-number">0</span>];        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + prices[i] - fee);            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - prices[i]);        &#125;        <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];    &#125;&#125;;</code></pre></div><p>分析：股票问题的变形，比较类似于状态机，不是很能想得到</p><p>错误：股票问题后面也要再做一做</p><h2 id="总结">总结</h2><p>动态规划比较有难度，一是状态转移方程的写法，二是在实现状态转移中的各种细节。以后对于动态规划还要勤加练习，多练习思考方法。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：高级人工智能-第1讲 人工智能概述</title>
    <link href="/2022/09/01/UCAS/advanced-ai/advanced-ai-1/"/>
    <url>/2022/09/01/UCAS/advanced-ai/advanced-ai-1/</url>
    
    <content type="html"><![CDATA[<p>《高级人工智能》课程笔记：第1讲 人工智能概述</p><span id="more"></span><p>首先讲授人工智能基础知识，进而分三个专题（联结主义、符号主义、行为主义）介绍人工智能的新进展。</p><h1>第1讲 人工智能概述</h1><h2 id="智能和人工智能">智能和人工智能</h2><p>智能：个体适应环境并能在不同环境中实现其目标的能力。</p><p>蕴含众多方面的能力</p><ul><li>创造、推理、学习</li><li>归纳、演绎、类比</li><li>优化、规划、知识</li><li>模式识别、问题求解</li></ul><p>人工智能：</p><ul><li>机器智能：使机器具备计算和“判别”的行为能力</li><li>类脑智能：仿生智能，让机器像人或生物一样思考</li><li>群体智能：社会智能的机器重现与利用、涌现智能</li></ul><h2 id="人工智能的发展历史">人工智能的发展历史</h2><p>机械智能 ➡ 理性思考 ➡ 数理逻辑 ➡ 计算思维</p><p>萌芽期</p><ul><li>机械自动化<ul><li>希腊，蒸汽驱动的“会唱歌”的乌鸦</li><li>中国，鲁班的“木鸢”，诸葛亮的“木牛流马”</li></ul></li><li>逻辑推理<ul><li>亚里士多德的“三段论”：从一般前提到具体论断</li></ul></li></ul><p>孕育期（文艺复兴以来）</p><ul><li>理性主义<ul><li>笛卡尔：mind/body二象性，不相信机器会具有智能</li></ul></li><li>数理逻辑学科<ul><li>莱布尼茨：演算推论器，符号逻辑，提出将人的知识汇成“知识库”</li><li>弗雷治：谓词演算</li></ul></li><li>计算思维<ul><li>巴贝奇：差分机</li><li>图灵：图灵机</li></ul></li></ul><p>形成期（1956年-1961年）</p><ul><li>1956年，首次人工智能研讨会</li><li>IBM的西洋跳棋程序、文法体系、逻辑推理机、行动计划咨询系统、通用问题求解器</li></ul><p>发展期（60年代）</p><ul><li>研究领域拓展<ul><li>问题求解、博弈、定理证明、程序设计、机器视觉、自然语言理解、知识表示、专家系统、神经网络、智能机器人……</li></ul></li><li>1969年，第一届国际人工智能联合会议（IJCAI）</li><li>1970年，《人工智能》国际杂志创刊，《Artificial Intelligence 》</li></ul><p>寒冬期（60年代末到70年代初）</p><ul><li>1966年，美国政府取消了机器翻译项目的所有投资</li><li>英国政府取消了几乎所有人工智能研究投入</li><li>神经网络的研究经费缩减到几乎没有</li></ul><p>艰难前行（70年代）</p><ul><li>弱方法：构建搜索机制，试图找出完全解<ul><li>下棋：搜索解空间</li></ul></li><li>强方法：构建领域知识库<ul><li>专家系统：知识表示开始成为研究热点</li></ul></li></ul><p>走向工业（80年代）</p><ul><li>1982年，第一个商用专家系统RI</li><li>1981年，日本启动“第五代计算机”计划，运行prolog语言的智能计算机</li><li>美国、英国恢复对人工智能的投入</li></ul><p>今天</p><ul><li>大数据利用、计算能力提升、网络泛在化</li><li>神经网络的复兴<ul><li>多层感知机及其学习算法（BP算法）的提出</li><li>隐马尔科夫模型（HMM）在语音识别上取得成功</li><li>贝叶斯网络</li></ul></li><li>专家系统逐渐成熟<ul><li>知识发现、数据挖掘兴起</li></ul></li><li>人工智能开始成为科学<ul><li>学科边界开始明晰</li><li>并开始借鉴其他学科的理论，如控制论、心里学、统计学</li></ul></li></ul><h2 id="人工智能：研究如何像人一样行动？"><strong>人工智能：研究如何像人一样行动？</strong></h2><h3 id="考试内容：图灵测试"><strong>考试内容：图灵测试</strong></h3><p>Can Machine Think?</p><p>图灵测试：一个人（C）在完全不接触对方（A和B）的情况下，和对方进行一系列的问答，如果在相当长时间内，他无法根据这些问题判断对方是人（B）还是计算机（A），那么，就认为该计算机具有同人相当的智能（即计算机是能思维的）。</p><p>质疑：</p><ul><li>图灵测试不是可构造的<ul><li>例如：“完全不接触”的环境难以构建</li></ul></li><li>图灵测试不是可重现的<ul><li>例如：问题是开放的，答案正确性的判定是主观的</li></ul></li><li>图灵测试无法进行数学分析<ul><li>只是一种操作式测试，缺少形式化描述不严谨</li></ul></li></ul><p>图灵预言：到2000年，机器可以做到5分钟内以30%的可能性让普通人分辨不出其是机器还是人。</p><p>图灵测试案例</p><ul><li>Master横空出世：Master在围棋对战网站上出现连胜30多场，才开始有人怀疑这是“机器人”。</li><li>人工智能机器人Sophia：电视节目主持人查理•罗斯在节目《60分钟》中采访了Sophia机器人时，索菲亚不但对答如流，还与他开起了玩笑。</li></ul><h3 id="神经网络模拟器">神经网络模拟器</h3><ul><li>Snare：1951年由马文·明斯基提出，学习如何穿过迷宫</li><li>他是多智能体的最早尝试者之一，使机器能基于过去行为的知识，预测其当前行为的结果</li></ul><h2 id="人工智能三大学派">人工智能三大学派</h2><p>达特茅斯会议：1956年在达特茅斯学院发起</p><p>发起人</p><ul><li>约翰·麦卡锡（人工智能之父，Lisp语言发明者，1971年获图灵奖）</li><li>马文·明斯基（1969年获图灵奖，首个获图灵奖的人工智能学者）</li><li>克劳德·香农（信息论之父）</li><li>纳撒尼尔·罗彻斯特（IBM 700系列计算机首席工程师，发明了首个汇编语言）</li></ul><p>会议成就</p><ul><li>首次提出了“人工智能”一词</li><li>会议三大亮点<ul><li>明斯基的Snare</li><li>麦卡锡的𝛼-𝛽搜索法</li><li>西蒙和纽厄尔的“逻辑理论家”</li></ul></li></ul><p><strong>并且出现了人工智能三大学派：</strong></p><ul><li><strong>符号主义学派</strong></li><li><strong>联结主义学派</strong></li><li><strong>行为主义学派</strong></li></ul><h3 id="符号主义学派（逻辑学派）：规则驱动的确定性智能">符号主义学派（逻辑学派）：规则驱动的确定性智能</h3><ul><li>认为“<strong>人的认知基元是符号，认知过程即符号操作过程</strong>”</li><li>认为人和计算机都是物理符号系统，可以用计算机来模拟人的智能行为</li><li>认为人工智能的<strong>核心是知识表示、知识推理和知识运用</strong></li><li>代表人物<ul><li>西蒙（1975年获图灵奖、1978年获诺贝尔经济学奖）</li><li>纽厄尔</li></ul></li></ul><p><strong>衍生出：逻辑、专家系统、知识库</strong></p><h3 id="联结主义学派（仿生学派或生理学派）：数据驱动的不确定性智能">联结主义学派（仿生学派或生理学派）：数据驱动的不确定性智能</h3><ul><li>认为人的思维基元是神经元，而不是符号处理过程</li><li>认为人脑不同于电脑</li><li>原理：神经网络及神经网络间的连接机制和学习算法</li><li>代表人物<ul><li>麦卡洛克（McCulloch）</li><li>皮茨（Pitts）</li></ul></li></ul><p><strong>衍生出：人工神经网络、认知科学、类脑计算</strong></p><h3 id="行为主义学派（进化主义或控制论学派）：交互驱动的涌现智能">行为主义学派（进化主义或控制论学派）：交互驱动的涌现智能</h3><ul><li>认为智能取决于感知和行动</li><li>主张利用机器对环境作用后的响应或反馈为原型来实现智能化</li><li>认为人工智能可以像人类智能一样通过进化、学习来逐渐提高和增强</li><li>代表人物：布鲁克斯</li></ul><p><strong>衍生出：控制论、多智能体、强化学习等</strong></p><h2 id="人工智能研究的课题">人工智能研究的课题</h2><p>三大层次</p><ul><li>基础理论：数学、思维科学、认知科学等</li><li>原理技术：启发式搜索、演化计算</li><li>工程应用：模式识别、计算机视觉、自然语言理解、问答系统</li></ul><p>四大问题</p><ul><li>知识科学、问题求解、机器学习、系统构成</li></ul><h2 id="人工智能之哲学基础">人工智能之哲学基础</h2><p>弱人工智能</p><ul><li>机器表现得像具有智能一样</li><li>图灵测试</li></ul><p>强人工智能</p><ul><li>机器实际具有智能</li><li>机器具有自我意识吗？</li><li>自由意志悖论<ul><li>受物理法则严格支配的思想会是自由的吗？</li><li>如果不能够说出我下一步会做什么，就说明我具有自由意志？</li></ul></li></ul><p>人工智能恐慌</p><ul><li>会不会造成人们失业？<ul><li>目前来看，人工智能技术带来的自动化，其创造的就业就会大于其减少的就业机会</li></ul></li><li>对隐私权的侵害？</li><li>是否导致可审计的丧失？<ul><li>例如：听从了医疗诊断专家系统的建议而带来的医疗事故，责任归谁？</li></ul></li></ul><p>人工智能实现了会怎样？</p><ul><li>人工智能的成功是否会意味着人类灭亡<ul><li>人工演化取代自然选择</li><li>机器智能一旦超过人类智能，他就能设计出更聪明的机器</li><li>智力爆炸和技术奇点，人类时代的终结</li></ul></li><li>怎么办？<ul><li>让机器保持可控</li><li>使用人工智能拓展人类智能，将人工智能合并到人类智能中</li></ul></li></ul><p>人工智能伦理</p><ul><li>机器人三法则<ul><li>第一法则：机器人不得伤害人类，或袖手旁观坐视人类受到伤害</li><li>第二法则：除非违背第一法则，机器人必须服从人类的命令</li><li>第三法则：在不违背第一及第二法则下，机器人必须保护自己</li></ul></li></ul><h2 id="人工智能的目标">人工智能的目标</h2><ul><li>近期目标<ul><li>研究如何使机器做过去只有依靠人的智力才能完成的工作</li></ul></li><li>远期目标<ul><li>研究如何利用自动机模拟人的思维过程和智能行为，从而造出智能机器</li></ul></li><li>终极目标<ul><li>机器智能实现甚至超过生物智能</li></ul></li></ul><p>“准人”水平的人工智能：手写识别、物体识别、语音识别、自然语言处理、词义消歧、机器翻译</p><p>“过人”水平的人工智能：游戏、双陆棋、国际象棋、桥牌、填词、拼字、七巧板、自动驾驶、智力竞赛问答、OCR字符识别</p><p>“许多尖端的人工智能由于应用广泛，已经不再被称为人工智能。因为，人们一旦觉得某些东西非常有用并广泛使用，就不再称之为人工智能了。”</p><h2 id="人工智能案例实践">人工智能案例实践</h2><ul><li>定理证明<ul><li>50年代中期，西蒙和纽厄尔提出的“逻辑理论家”，证明了《数学原理》书中的38个定理</li><li>1962年，改进后证明了书中全部52个定理，被认为是用计算机探讨人类智能的第一个真正成果</li></ul></li><li>案例<ul><li>四色定理<ul><li>1852年提出，一直无人给出理论证明</li><li>1976年6月，哈肯在伊利诺伊用两台计算机，用时1200个小时，通过100亿次判断，完成了证明，轰动世界</li></ul></li><li>吴方法：吴文俊教授提出的“数学机器化”</li></ul></li><li>通用问题求解器（GPS：General Problem Solver）<ul><li>1957年开始，纽厄尔等人开始研究不依赖于具体领域的通用解题程序</li><li>模仿人类问题求解过程，第一个实现了“像人一样思考”的程序</li></ul></li><li>专家系统<ul><li>将领域专家的知识整理出来，让计算机利用这些知识求解专门领域的问题</li><li>DENDRAL：第一个专家系统，1968年问世，斯坦福大学完成，用于推断化学分子结构</li><li>MYCIN：著名的医疗诊断专家系统</li><li>RI：第一个商用专家系统，DEC公司于1982年正式使用</li></ul></li><li>海湾战争中的专家系统<ul><li>1991年的海湾战争，美国将专家系统用于后勤规划和运输日程安排</li><li>涉及50000个车辆、货物和人，需要考虑起点、目的地、路径以及解决参数冲突问题</li><li>该系统使一个计划可以在几个小时内产生，而旧方法需要几个星期</li></ul></li><li>数字识别<ul><li>清华大学智能技术与系统国家重点实验室采用神经元网络研制了数字识别系统</li><li>用于2000年我国的人口普查</li><li>错误率达到低于万分之一的水平</li></ul></li><li>古籍数字化（OCR技术）：《四库全书》</li><li>国际象棋：IBM的“深蓝”<ul><li>1997年，IBM公司的“深蓝”在美国纽约公平大厦以3.5:2.5击败了国际象棋世界冠军卡斯帕罗夫</li></ul></li><li>围棋<ul><li>AlphaGo: DeepMind<ul><li>使用深度学习技术（CNN：卷积神经网络）对棋局的局势进行估值</li><li>在和其他围棋程序的对弈中取得99.8%的胜率</li><li>和李世石的人机大战中以4:1取胜，在人机对战中60连胜，以3:0战胜柯洁</li></ul></li><li>AlphaGo背后的技术<ul><li><strong>深度学习</strong>（联结主义）+ <strong>强化学习</strong>（行为主义）</li><li>利用<strong>残差神经网络</strong>（ResNet）训练深度模型</li><li>利用<strong>马尔科夫树搜索</strong>技术解决围棋的搜索空间爆炸问题</li><li>采用**“自我对弈”**策略进行无人工标注的自我训练</li></ul></li></ul></li><li>自动驾驶<ul><li>在高速公路上，自动识别道路，自动躲避障碍物</li><li>平均时速达到100公里/小时，最高速度可达150公里/小时</li><li>从匹兹堡到圣地亚哥，98%的时间自动驾驶</li></ul></li><li>自然语言处理<ul><li>神经语言模型和词嵌入技术：word2vec</li><li>机器翻译：统计机器翻译（SMT）到神经机器翻译（NMT）</li><li>文本生成技术：给图像或视频加标题、聊天机器人、机器人写新闻报道、BERT和GPT-3</li></ul></li><li>生成式预训练语言模型：GPT</li><li>IBM仿人脑芯片：TrueNorth<ul><li>DARPA的研究项目SyNapse（自适应可塑可伸缩电子神经系统）的最新成果</li><li>邮票大小、重量只有几克，集成54 亿个硅晶体管，内置4096 个内核，100 万个“神经元”、2.56 亿个“突触”，能力相当于一台超级计算机，功耗只有65 毫瓦</li><li>目标：突破冯·诺依曼体系</li></ul></li><li>脑科学<ul><li>2013年1月，欧盟启动“人类大脑计划”</li><li>2013年4月，奥巴马宣布启动“大脑基金计划”</li><li>2014年，我国着手启动“脑科学计划”</li></ul></li><li>互联网大脑：知识图谱+深度学习，利用网络大数据推断目标间的潜在关联关系等关系，为用户提供查询推荐、搜索导航等知识获取和深度理解功能。</li><li>系统论<ul><li>复杂自适应系统<ul><li>1984年，美国圣塔菲研究所成立</li><li>诺贝尔物理学将得主盖尔曼认为智能体现为个体的自适应能力，大量智能体（agent）积极地相互竞争和合作，在没有中央指挥的情况下，通过彼此相互作用和相互适应也能形成整体的有序状态</li></ul></li></ul></li></ul><h2 id="人工智能的今天">人工智能的今天</h2><ol><li>自然语言理解（主战场之一）：聊天机器人：小冰</li><li>智能阅卷：安庆会考全学科智能阅卷</li><li>考试机器人：美国华盛顿大学图灵中心和日本Todai高考机器人</li><li>人工智能三级跳：运算智能（能存会算）➡感知智能（能听会说、能看会认）➡认知智能（能理解会思考）</li><li>深度学习技术：DNN、RNN、CNN</li><li>生物特征识别技术（刷脸、瞳仁、声纹……）</li><li>中国创业公司：Face++</li></ol><h2 id="人工智能的发展趋势">人工智能的发展趋势</h2><ul><li>从“人机对抗”走向“人机协作”<ul><li>AI 1.0<ul><li>让机器在某些任务上“战胜”人</li></ul></li><li>AI 2.0：人本计算（human computation）<ul><li>让机器和人相互协作，完成更复杂的任务</li><li>机器做机器擅长的：计算</li><li>人做人擅长的：思考</li></ul></li></ul></li><li>从单点智能走向网络智能<ul><li>AI 1.0<ul><li>单个机器具备人的某些智能，例如：听、说、读、写、感知、认知……</li></ul></li><li>AI 2.0<ul><li>借助互联网实现智能网络化</li></ul></li></ul></li><li>从专用人工智能走向通用人工智能<ul><li>AI 1.0<ul><li>在具体的任务上，让机器具备智能，例如：围棋、自动驾驶……</li></ul></li><li>AI 2.0<ul><li>研究通用人工智能，包括探索智能形成的机制，AlphaGo到Master是一种初步尝试，让机器具备能够自我学习、形成概念的能力</li></ul></li></ul></li></ul><p><strong>人工智能是国家战略：2017年，国务院印发了《新一代人工智能发展规划》，人工智能成为国家战略，大数据在人工智能中将扮演越来越重要的角色。</strong></p><p><strong>人工智能经过60余年的发展取得了长足进步，近年来呈现出爆发之势，但总体上还处于初级阶段，通用智能之路任重道远。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Advanced AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：模式识别与机器学习-第1章 概论</title>
    <link href="/2022/08/31/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-1/"/>
    <url>/2022/08/31/UCAS/pattern-recognition-and-machine-learning/pattern-recognition-and-machine-learning-1/</url>
    
    <content type="html"><![CDATA[<p>《模式识别与机器学习》课程笔记：第1章 概论</p><span id="more"></span><ul><li>着重讲述模式识别与机器学习的基本概念，基本理论和方法，关键算法原理以及典型应用情况。</li><li>注重理论与实践紧密结合<ul><li>实例教学：通过实例讲述如何将所学知识运用到实际应用之中</li></ul></li><li>尽量避免引用过多的、繁琐的数学推导</li></ul><h1>第1章 概论</h1><h2 id="什么是模式">什么是模式</h2><ul><li>广义地说，存在于时间和空间中可观察的物体，如果我们可以区别它们是否相同或是否相似，都可以称之为模式。</li><li>模式所指的不是事物本身，而是从事物获得的信息，因此，模式往往表现为具有时间和空间分布的信息。</li><li>模式的直观特性：①可观察性②可区分性③相似性</li></ul><p>模式识别的目的：利用计算机对物理对象进行分类，在错误概率最小的条件下，使识别的结果尽量与客观物体相符合。</p><p>模式识别的数学化：<code>Y= F(X)</code>，<code>X</code>的定义域取自特征集，<code>Y</code>的值域为类别的标号集，<code>F</code>是模式识别的判别方法。</p><p>机器学习：研究如何构造理论、算法和计算机系统，让机器通过从数据中学习后可以进行分类和识别事物、推理决策、预测未来等工作。</p><h3 id="模式识别系统的目标">模式识别系统的目标</h3><p>在特征空间和解释空间之间找到一种映射关系，这种映射也称之为假说。</p><ul><li>特征空间：从模式得到的对分类有用的度量、属性或基元构成的空间。</li><li>解释空间：<code>c</code>个类别的集合表示为Ω，称为解释空间。</li></ul><p>机器学习的目标：针对某类任务 <code>T</code>，用 <code>P</code>衡量性能，根据经验 <code>E</code>来学习和自我完善，提高性能。</p><p>假说的两种获得方法：</p><ul><li>监督学习、概念驱动或归纳假说：<strong>在特征空间中找到一个与解释空间的结构相对应的假说</strong>。在给定模式下假定一个解决方案，任何在训练集中接近目标的假说也都必须在“未知”的样本上得到近似的结果。<ul><li>依靠已知所属类别的训练样本集，按它们特征向量的分布来确定假说（通常为一个判别函数），在判别函数确定之后能用它对未知的模式进行分类</li><li>对分类的模式要有足够的先验知识，通常需要采集足够数量的具有典型性的样本进行训练。</li></ul></li><li>非监督学习、数据驱动或演绎假说：<strong>在解释空间中找到一个与特征空间的结构相对应的假说</strong>。这种方法试图找到一种只以特征空间中的相似关系为基础的有效假说。<ul><li>在没有先验知识的情况下，通常采用聚类分析方法，基于“物以类聚”的观点，用数学方法分析各特征向量之间的距离及分散情况；</li><li>如果特征向量集聚集若干个群，可按群间距离远近把它们划分成类；</li><li>这种按各类之间的亲疏程度的划分，若事先能知道应划分成几类，则可获得更好的分类结果。</li></ul></li></ul><h2 id="主要分类和学习方法">主要分类和学习方法</h2><p>数据聚类</p><ul><li>用某种相似性度量的方法将原始数据组织成有意义的和有用的各种数据集。</li><li>是一种非监督学习的方法，解决方案是数据驱动的。</li></ul><p>统计分类</p><ul><li>基于概率统计模型得到各类别的特征向量的分布，以取得分类的方法。</li><li>特征向量分布的获得是基于一个类别已知的训练样本集。</li><li>是一种监督分类的方法，分类器是概念驱动的。</li></ul><p>结构模式识别</p><ul><li>该方法通过考虑识别对象的各部分之间的联系来达到识别分类的目的。</li><li>识别采用结构匹配的形式，通过计算一个匹配程度值（matching score）来评估一个未知的对象或未知对象某些部分与某种典型模式的关系如何。</li><li>当成功地制定出了一组可以描述对象部分之间关系的规则后，可以应用一种特殊的结构模式识别方法-句法模式识别，来检查一个模式基元的序列是否遵守某种规则，即句法规则或语法。</li></ul><p>神经网络</p><ul><li>神经网络是受人脑组织的生理学启发而创立的。</li><li>由一系列互相联系的、相同的单元（神经元）组成。相互间的联系可以在不同的神经元之间传递增强或抑制信号。</li><li>增强或抑制是通过调整神经元相互间联系的权重系数来（weight）实现。</li><li>神经网络可以实现监督和非监督学习条件下的分类。</li></ul><p>监督学习</p><ul><li>监督学习是从有标记的训练数据来推断或建立一个模型，并依此模型推测新的实例。</li><li>训练数据包括一套训练实例。在监督学习中，每个实例是由一个输入对象（通常为矢量）和一个期望的输出值（也称为监督信号）组成。</li><li>一个最佳的模型将能够正确地决定那些看不见的实例的标签。常用于分类和回归。</li></ul><p>无监督学习</p><ul><li>无监督学习是我们不告诉计算机怎么做，而是让它自己去学习怎样做一些事情。</li><li>无监督学习与监督学习的不同之处在于，事先没有任何训练样本，需要直接对数据进行建模，寻找数据的内在结构及规律，如类别和聚类。</li><li>常用于聚类、概率密度估计。</li></ul><p>半监督学习</p><ul><li>半监督学习（Semi-supervised Learning）是模式识别和机器学习领域研究的重点问题，是监督学习与无监督学习相结合的一种学习方法。</li><li>它主要考虑如何利用少量的标注样本和大量的未标注样本进行训练和分类的问题。</li><li>半监督学习的主要算法有五类：基于概率的算法；在现有监督算法基础上改进的方法；直接依赖于聚类假设的方法；基于多视图的方法；基于图的方法。</li></ul><p>强化学习</p><ul><li>强化学习要解决的问题：一个能够感知环境的自治机器人，怎样通过学习选择能达到其目标的最优动作。</li><li>机器人选择一个动作用于环境，环境接受该动作后状态发生变化，同时产生一个强化信号（奖或惩）反馈回来。</li><li>机器人根据强化信号和环境当前状态再选择下一个动作，选择的原则是使受到正强化（奖）的概率增大。</li></ul><p>集成学习</p><ul><li>集成学习（Ensemble Learning）是机器学习中一类学习算法，指联合训练多个弱分类器并通过集成策略将弱分类器组合使用的方法。</li><li>由于整合了多个分类器，这类算法通常在实践中会取得比单个若分类器更好的预测结果。</li><li>常见的集成策略有：Boosting、Bagging、 Random subspace 、Stacking等。</li><li>常见的算法主要有：决策树、随机森林、Adaboost、GBDT、DART等。</li></ul><p>深度学习</p><ul><li>深度学习的概念源于人工神经网络的研究，除输入层和输出层外，含多个隐藏层的神经网络就是一种深度学习结构。</li><li>深度学习通过层次化模型结构可从低层原始特征中逐渐抽象出高层次的语义特征，以发现复杂、灵活、高效的特征表示。</li><li>常见的深度学习模型有：卷积神经网络，递归神经网络，深度信任网络，自编码器，变分自编码器等。</li></ul><p>元学习</p><ul><li>元学习（Meta Learning）或者叫做“学会学习”（Learning to Learn），它是要“学会如何学习”，即利用以往的知识经验来指导新任务的学习，具有学会学习的能力。</li><li>当前的机器学习模型往往只局限于从头训练已知任务并使用精调来学习新任务，耗时较长，且性能提升较为有限。</li><li>Meta Learning 就是研究如何让元模型记忆理解以往学习知识，使算法能在小样本训练的情况下完成新任务的学习。</li></ul><p>多任务学习</p><ul><li>多任务学习是指通过共享相关任务之间的表征，联合训练多个学习任务的学习范式。</li><li>在通常的机器学习范式中，不同任务的学习过程往往分别处理，任务间的关系完全被割裂。而在多任务学习范式中，联系学习机制使不同任务的学习过程充分共享，可显著减少每个任务所需的训练样本。</li><li>多任务学习的主要形式有：联合学习、自主学习和带有辅助任务的学习。</li></ul><p>多标记学习</p><ul><li>多标记学习问题为一种特殊的有监督分类问题，其所处理的数据集中的每个样本可同时存在多个真实类标。</li><li>多标记学习主要用于处理多种标签的语义重叠，如预测歌曲的音乐流派，预测图书、商品的属性标签。</li><li>多标记学习算法主要分为两类:<ul><li>问题转换法：把多标签问题转为其它学习场景，比如转为二分类、标签排序、多分类等。</li><li>算法改编法：通过改编流行的学习算法去直接处理多标签数据，比如改编决策树、核技巧等。</li></ul></li></ul><p>对抗学习</p><ul><li>对抗学习是针对传统机器学习的一种攻击性方法，是机器学习和计算机安全领域都十分关注的交叉问题。</li><li>对抗学习主要通过恶意输入来误导机器学习算法或模型使其得到错误结果，并在该过程中暴露机器学习算法存在的脆弱性，帮助设计适应复杂环境的鲁棒学习方法。</li><li>常见的对抗学习方法主要有针对训练阶段的毒害式攻击以及针对测试阶段的躲避式攻击，常见的对抗学习场景主要有：垃圾邮件过滤、身份识别以及恶意软件检测等。</li></ul><h2 id="模式识别系统构成">模式识别系统构成</h2><p>模式识别系统与机器学习系统构成对比</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://s1.ax1x.com/2022/08/31/v4Ot91.png" alt="v4Ot91.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="https://s1.ax1x.com/2022/08/31/v4OUc6.png" alt="v4OUc6.png"></div></div></div><h3 id="模式识别系统组成单元">模式识别系统组成单元</h3><ul><li>数据获取：用计算机可以运算的符号来表示所研究的对象<ul><li>二维图像：文字、指纹、地图、照片等</li><li>一维波形：脑电图、心电图、季节震动波形等</li><li>物理参量和逻辑值：体温、化验数据、参量正常与否的描述</li></ul></li><li>预处理单元：去噪声，提取有用信息，并对输入测量仪器或其它因素所造成的退化现象进行复原</li><li>特征提取和选择：对原始数据进行变换，得到最能反映分类本质的特征<ul><li>测量空间：原始数据组成的空间</li><li>特征空间：分类识别赖以进行的空间</li><li>模式表示：维数较高的测量空间-&gt;维数较低的特征空间</li></ul></li><li>分类决策：在特征空间中用模式识别方法把被识别对象归为某一类别<ul><li>基本做法：在样本训练集基础上确定某个判决规则，使得按这种规则对被识别对象进行分类所造成的错误识别率最小或引起的损失最小。</li></ul></li></ul><h3 id="机器学习系统组成单元">机器学习系统组成单元</h3><ul><li>环境：是系统的工作对象（包括外界条件），代表信息来源。<ul><li>信息水平：相对于执行环节要求而言，由学习环节消除差距</li><li>信息质量：实例示教是否正确、实例次序是否合理等</li></ul></li><li>知识库：存储学习到的知识<ul><li>知识的表示要合理</li><li>推理方法的实现不要太难</li><li>存储的知识是否支持修改（更新）</li></ul></li><li>学习环节：是系统的核心模块，是和外部环境的交互接口。<ul><li>对环境提供的信息进行整理、分析、归纳或类比，生成新的知识单元，或修改知识库。</li><li>接收从执行环节来的反馈信号，通过知识库修改，进一步改善执行环节的行为。</li></ul></li><li>执行：根据知识库执行一系列任务<ul><li>把执行结果或执行过程中获得的信息反馈给学习环节</li></ul></li></ul><h2 id="模式识别过程实例">模式识别过程实例</h2><p>在传送带上用光学传感器件对鱼按品种分类</p><ol><li>数据获取：架设一个摄像机，采集一些样本图像，获取样本数据</li><li>预处理：去噪声，用一个分割操作把鱼和鱼之间以及鱼和背景之间分开</li><li>特征提取和选择：对单个鱼的信息进行特征选择，从而通过测量某些特征来减少信息量</li><li>分类决策：把特征送入决策分类器</li></ol><h2 id="相关数学概念">相关数学概念</h2><ul><li>随机向量及其分布<ul><li>数学期望和方差</li><li>协方差矩阵</li></ul></li><li>正态分布<ul><li>一维正态密度函数</li><li>多维正态密度函数</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Pattern Recognition and Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第6章 搜索</title>
    <link href="/2022/08/30/Leetcode/Leetcode-101/Leetcode-101-6/"/>
    <url>/2022/08/30/Leetcode/Leetcode-101/Leetcode-101-6/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第6章 搜索</p><span id="more"></span><h1>搜索</h1><p>深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等结构中进行搜索。</p><h2 id="深度优先搜索">深度优先搜索</h2><h3 id="Leetcode-695">Leetcode 695</h3><p><strong>岛屿</strong>是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在水平或者竖直的四个方向上相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= m || y &lt; <span class="hljs-number">0</span> || y &gt;= n || grid[x][y] == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        grid[x][y] = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">DFS</span>(grid,x<span class="hljs-number">+1</span>,y,m,n) + <span class="hljs-built_in">DFS</span>(grid,x<span class="hljs-number">-1</span>,y,m,n) + <span class="hljs-built_in">DFS</span>(grid,x,y<span class="hljs-number">+1</span>,m,n) + <span class="hljs-built_in">DFS</span>(grid,x,y<span class="hljs-number">-1</span>,m,n);    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> maxarea = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;                    maxarea = <span class="hljs-built_in">max</span>(maxarea,<span class="hljs-built_in">DFS</span>(grid,i,j,m,n));                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> maxarea;    &#125;&#125;;</code></pre></div><p>分析：标准的DFS，重点要判断是否越界以及返回值的处理。</p><p>错误：基本思路是正确的，返回值的处理有问题，以及想的有些复杂。</p><h3 id="Leetcode-547">Leetcode 547</h3><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。<strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。返回矩阵中 <strong>省份</strong> 的数量。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visit,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= n || visit[x] == <span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        visit[x] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;            <span class="hljs-keyword">if</span>(isConnected[x][i] == <span class="hljs-number">1</span>)&#123;                <span class="hljs-built_in">DFS</span>(isConnected,visit,i,n);            &#125;        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;        <span class="hljs-type">int</span> n = isConnected.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> sumCount = <span class="hljs-number">0</span>;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n)</span></span>;        <span class="hljs-built_in">fill</span>(visit.<span class="hljs-built_in">begin</span>(),visit.<span class="hljs-built_in">end</span>(),<span class="hljs-literal">false</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;            <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-literal">false</span>)&#123;                <span class="hljs-built_in">DFS</span>(isConnected,visit,i,n);                ++sumCount;            &#125;        &#125;        <span class="hljs-keyword">return</span> sumCount;    &#125;&#125;;</code></pre></div><p>分析：还是比较基本的DFS，只不过是一个一维的DFS，比较简单</p><p>错误：开始的思路有一些偏差，后面纠正过来没什么问题了。</p><h3 id="Leetcode-417">Leetcode 417</h3><p>有一个 <code>m × n</code> 的矩形岛屿，与<strong>太平洋</strong>和<strong>大西洋</strong>相邻。 太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。这个岛被分割成一个由若干方形单元格组成的网格。给定一个 <code>m x n</code> 的整数矩阵 <code>heights</code> ， <code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格<strong>高于海平面的高度</strong> 。岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong> 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。返回网格坐标 <code>result</code> 的 <strong>2D 列表</strong> ，其中 <code>result[i] = [r&lt;sub&gt;i&lt;/sub&gt;, c&lt;sub&gt;i&lt;/sub&gt;]</code> 表示雨水从单元格 <code>(ri, ci)</code> 流动 <strong>既可流向太平洋也可流向大西洋</strong> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;&amp; Ocean,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n)</span></span>&#123;        Ocean[x][y] = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">if</span>(x<span class="hljs-number">+1</span> &lt; m &amp;&amp; Ocean[x<span class="hljs-number">+1</span>][y] == <span class="hljs-literal">false</span> &amp;&amp; heights[x<span class="hljs-number">+1</span>][y] &gt;= heights[x][y])&#123;            <span class="hljs-built_in">DFS</span>(heights,Ocean,x<span class="hljs-number">+1</span>,y,m,n);        &#125;        <span class="hljs-keyword">if</span>(x<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; Ocean[x<span class="hljs-number">-1</span>][y] == <span class="hljs-literal">false</span> &amp;&amp; heights[x<span class="hljs-number">-1</span>][y] &gt;= heights[x][y])&#123;            <span class="hljs-built_in">DFS</span>(heights,Ocean,x<span class="hljs-number">-1</span>,y,m,n);        &#125;        <span class="hljs-keyword">if</span>(y<span class="hljs-number">+1</span> &lt; n &amp;&amp; Ocean[x][y<span class="hljs-number">+1</span>] == <span class="hljs-literal">false</span> &amp;&amp; heights[x][y<span class="hljs-number">+1</span>] &gt;= heights[x][y])&#123;            <span class="hljs-built_in">DFS</span>(heights,Ocean,x,y<span class="hljs-number">+1</span>,m,n);        &#125;        <span class="hljs-keyword">if</span>(y<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; Ocean[x][y<span class="hljs-number">-1</span>] == <span class="hljs-literal">false</span> &amp;&amp; heights[x][y<span class="hljs-number">-1</span>] &gt;= heights[x][y])&#123;            <span class="hljs-built_in">DFS</span>(heights,Ocean,x,y<span class="hljs-number">-1</span>,m,n);        &#125;        <span class="hljs-keyword">return</span>;    &#125;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pacificAtlantic</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; heights) &#123;        <span class="hljs-type">int</span> m = heights.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = heights[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">pOcean</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">aOcean</span>(m,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">if</span>(pOcean[i][<span class="hljs-number">0</span>] == <span class="hljs-literal">false</span>)&#123;                <span class="hljs-built_in">DFS</span>(heights,pOcean,i,<span class="hljs-number">0</span>,m,n);            &#125;            <span class="hljs-keyword">if</span>(aOcean[i][n<span class="hljs-number">-1</span>] == <span class="hljs-literal">false</span>)&#123;                <span class="hljs-built_in">DFS</span>(heights,aOcean,i,n<span class="hljs-number">-1</span>,m,n);            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(pOcean[<span class="hljs-number">0</span>][i] == <span class="hljs-literal">false</span>)&#123;                <span class="hljs-built_in">DFS</span>(heights,pOcean,<span class="hljs-number">0</span>,i,m,n);            &#125;            <span class="hljs-keyword">if</span>(aOcean[m<span class="hljs-number">-1</span>][i] == <span class="hljs-literal">false</span>)&#123;                <span class="hljs-built_in">DFS</span>(heights,aOcean,m<span class="hljs-number">-1</span>,i,m,n);            &#125;        &#125;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;                <span class="hljs-keyword">if</span>(pOcean[i][j] == <span class="hljs-literal">true</span> &amp;&amp; aOcean[i][j] == <span class="hljs-literal">true</span>)&#123;                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;i,j&#125;);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：仍然是比较普通的DFS，不过只要对周围的一圈进行DFS就足够了，不需要全部遍历。</p><p>错误：细节问题，写的时候一定好好检查 <code>m</code>和 <code>n</code>有没有用反。</p><h2 id="回溯法">回溯法</h2><h3 id="Leetcode-46">Leetcode 46</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其所有可能的全排列。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,<span class="hljs-type">int</span> level,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp;result)</span></span>&#123;        <span class="hljs-keyword">if</span>(level == nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;            result.<span class="hljs-built_in">push_back</span>(nums);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=level;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-built_in">swap</span>(nums[i],nums[level]);            <span class="hljs-built_in">backtracking</span>(nums,level<span class="hljs-number">+1</span>,result);            <span class="hljs-built_in">swap</span>(nums[i],nums[level]);        &#125;    &#125;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;        <span class="hljs-built_in">backtracking</span>(nums,<span class="hljs-number">0</span>,result);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：对于每一个当前位置 <code>i</code>，我们可以将其于之后的任意位置交换，然后继续处理位置 <code>i+1</code>，直到处理到最后一位。为了防止我们每此遍历时都要新建一个子数组储存位置 <code>i</code>之前已经交换好的数字，我们可以利用回溯法，只对原数组进行修改，在递归完成后再修改回来。</p><p>错误：学习一下回溯法的基本框架。</p><h3 id="Leetcode-77">Leetcode 77</h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;result,vector&lt;<span class="hljs-type">int</span>&gt; &amp;temp,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> level,<span class="hljs-type">int</span> k)</span></span>&#123;        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == k)&#123;            result.<span class="hljs-built_in">push_back</span>(temp);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=level<span class="hljs-number">+1</span>;i&lt;=n;++i)&#123;            temp.<span class="hljs-built_in">push_back</span>(i);            <span class="hljs-built_in">backtracking</span>(result,temp,n,i,k);            temp.<span class="hljs-built_in">pop_back</span>();        &#125;    &#125;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;        vector&lt;<span class="hljs-type">int</span>&gt; temp;        <span class="hljs-built_in">backtracking</span>(result,temp,n,<span class="hljs-number">0</span>,k);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：类似于排列问题，也可以进行回溯。排列回溯的是交换的位置，而组合回溯的是是否把当前的数字加入结果中。</p><p>错误：需要有一个记录状态的数值，要不然就变成全排列了。</p><h3 id="Leetcode-79">Leetcode 79</h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string &amp;word,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;visited,<span class="hljs-type">bool</span> &amp;find,<span class="hljs-type">int</span> level)</span></span>&#123;        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= m || y &lt; <span class="hljs-number">0</span> || y &gt;= n)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(visited[x][y] == <span class="hljs-literal">true</span> || word[level] != board[x][y] || find == <span class="hljs-literal">true</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(level == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;            find = <span class="hljs-literal">true</span>;            <span class="hljs-keyword">return</span>;        &#125;        visited[x][y] = <span class="hljs-literal">true</span>;        <span class="hljs-built_in">backtracking</span>(board,word,x<span class="hljs-number">+1</span>,y,m,n,visited,find,level<span class="hljs-number">+1</span>);        <span class="hljs-built_in">backtracking</span>(board,word,x<span class="hljs-number">-1</span>,y,m,n,visited,find,level<span class="hljs-number">+1</span>);        <span class="hljs-built_in">backtracking</span>(board,word,x,y<span class="hljs-number">+1</span>,m,n,visited,find,level<span class="hljs-number">+1</span>);        <span class="hljs-built_in">backtracking</span>(board,word,x,y<span class="hljs-number">-1</span>,m,n,visited,find,level<span class="hljs-number">+1</span>);        visited[x][y] = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));        <span class="hljs-type">bool</span> find = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;                <span class="hljs-built_in">backtracking</span>(board,word,i,j,m,n,visited,find,<span class="hljs-number">0</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> find;    &#125;&#125;;</code></pre></div><p>分析：典型回溯题，判断条件需要多一些</p><p>错误1：回溯法不要有返回值，都使用引用传参</p><p>错误2：判断条件：①是否越界②访问过③不匹配④已经确定对的了</p><h3 id="Leetcode-51">Leetcode 51</h3><p><strong>n皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。给你一个整数 <code>n</code> ，返回所有不同的<strong>n皇后问题</strong>的解决方案。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp; result,vector&lt;string&gt; tempresult,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;column,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;ldiag,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;rdiag,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> level)</span></span>&#123;        <span class="hljs-keyword">if</span>(level == n)&#123;            result.<span class="hljs-built_in">push_back</span>(tempresult);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span> (column[i] || ldiag[n-level+i<span class="hljs-number">-1</span>] || rdiag[level+i]) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            tempresult[level][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;            column[i] = ldiag[n-level+i<span class="hljs-number">-1</span>] = rdiag[level+i] = <span class="hljs-literal">true</span>;            <span class="hljs-built_in">backtracking</span>(result,tempresult,column,ldiag,rdiag,n,level<span class="hljs-number">+1</span>);            column[i] = ldiag[n-level+i<span class="hljs-number">-1</span>] = rdiag[level+i] = <span class="hljs-literal">false</span>;            tempresult[level][i] = <span class="hljs-string">&#x27;.&#x27;</span>;        &#125;        <span class="hljs-keyword">return</span>;    &#125;    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;        vector&lt;vector&lt;string&gt;&gt; result;        string tempstring = <span class="hljs-string">&quot;&quot;</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;            tempstring += <span class="hljs-string">&quot;.&quot;</span>;        &#125;        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">tempresult</span><span class="hljs-params">(n,tempstring)</span></span>;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">column</span><span class="hljs-params">(n,<span class="hljs-literal">false</span>)</span></span>;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">ldiag</span><span class="hljs-params">(<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>,<span class="hljs-literal">false</span>)</span></span>;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">rdiag</span><span class="hljs-params">(<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>,<span class="hljs-literal">false</span>)</span></span>;        <span class="hljs-built_in">backtracking</span>(result,tempresult,column,ldiag,rdiag,n,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：最典型的回溯法之一。类似于在矩阵中寻找字符串，本题也是通过修改状态矩阵来进行回溯。不同的是，我们需要对每一行、列、左斜、右斜建立访问数组，来记录它们是否存在皇后。本题需要判断满足条件的结果中每一行或列有且仅有一个皇后。这是因为我们一共只有 <code>n</code>行和 <code>n</code>列。所以如果我们通过对每一行遍历来插入皇后，我们就不需要对行建立访问数组了。</p><p>错误：再理解吧。</p><h2 id="广度优先搜索">广度优先搜索</h2><h3 id="Leetcode-934">Leetcode 934</h3><p>在给定的二维二进制数组 <code>A</code> 中，存在两座岛。（岛是由四面相连的 <code>1</code> 形成的一个最大组。）现在，我们可以将 <code>0</code> 变为 <code>1</code>，以使两座岛连接起来，变成一座岛。返回必须翻转的 <code>0</code> 的最小数目。（可以保证答案至少是 <code>1</code> 。）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; &amp;points,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || x &gt;= n || y &lt; <span class="hljs-number">0</span> || y &gt;= n || grid[x][y] == <span class="hljs-number">2</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(grid[x][y] == <span class="hljs-number">0</span>)&#123;            points.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);            <span class="hljs-keyword">return</span>;        &#125;        grid[x][y] = <span class="hljs-number">2</span>;        <span class="hljs-built_in">DFS</span>(grid,points,x<span class="hljs-number">+1</span>,y,n);        <span class="hljs-built_in">DFS</span>(grid,points,x<span class="hljs-number">-1</span>,y,n);        <span class="hljs-built_in">DFS</span>(grid,points,x,y<span class="hljs-number">+1</span>,n);        <span class="hljs-built_in">DFS</span>(grid,points,x,y<span class="hljs-number">-1</span>,n);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestBridge</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>();        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; points;        <span class="hljs-type">bool</span> find = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(find == <span class="hljs-literal">true</span>)&#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;                    find = <span class="hljs-literal">true</span>;                    <span class="hljs-built_in">DFS</span>(grid,points,i,j,n);                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-type">int</span> level = <span class="hljs-number">0</span>;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; d = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;;        <span class="hljs-keyword">while</span>(!points.<span class="hljs-built_in">empty</span>())&#123;            ++level;            <span class="hljs-type">int</span> n_points = points.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">while</span>(n_points--)&#123;                <span class="hljs-keyword">auto</span> [r,c] = points.<span class="hljs-built_in">front</span>();                grid[r][c] = <span class="hljs-number">2</span>;                points.<span class="hljs-built_in">pop</span>();                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">4</span>;k++)&#123;                    <span class="hljs-type">int</span> x = r + d[k][<span class="hljs-number">0</span>];                    <span class="hljs-type">int</span> y = c + d[k][<span class="hljs-number">1</span>];                    <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &lt; n)&#123;                        <span class="hljs-keyword">if</span>(grid[x][y] == <span class="hljs-number">1</span>)&#123;                            <span class="hljs-keyword">return</span> level;                        &#125;                        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[x][y] == <span class="hljs-number">0</span>)&#123;                            grid[x][y] = <span class="hljs-number">2</span>;                            points.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;;</code></pre></div><p>分析：先通过任意搜索方法找到其中一个岛屿，然后利用广度优先搜索，查找其与另一个岛屿的最短距离</p><p>错误：BFS好久没有练习了，也是生疏了。</p><h3 id="Leetcode-126">Leetcode 126</h3><p>给定一个起始字符串和一个终止字符串，以及一个单词表，求是否可以将起始字符串每次改一个字符，直到改成终止字符串，且所有中间的修改过程表示的字符串都可以在单词表里找到。若存在，输出需要修改次数最少的所有更改方式。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">findLadders</span>(string beginWord, string endWord, vector&lt;string&gt; &amp;wordList) &#123;        vector&lt;vector&lt;string&gt;&gt; res;        <span class="hljs-comment">// 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」</span>        unordered_set&lt;string&gt; dict = &#123;wordList.<span class="hljs-built_in">begin</span>(), wordList.<span class="hljs-built_in">end</span>()&#125;;        <span class="hljs-comment">// 修改以后看一下，如果根本就不在 dict 里面，跳过</span>        <span class="hljs-keyword">if</span> (dict.<span class="hljs-built_in">find</span>(endWord) == dict.<span class="hljs-built_in">end</span>()) &#123;            <span class="hljs-keyword">return</span> res;        &#125;        <span class="hljs-comment">// 特殊用例处理</span>        dict.<span class="hljs-built_in">erase</span>(beginWord);        <span class="hljs-comment">// 第 1 步：广度优先搜索建图</span>        <span class="hljs-comment">// 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先搜索的第几层</span>        unordered_map&lt;string, <span class="hljs-type">int</span>&gt; steps = &#123;&#123;beginWord, <span class="hljs-number">0</span>&#125;&#125;;        <span class="hljs-comment">// 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系</span>        unordered_map&lt;string, set&lt;string&gt;&gt; from = &#123;&#123;beginWord, &#123;&#125;&#125;&#125;;        <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>;        <span class="hljs-type">bool</span> found = <span class="hljs-literal">false</span>;        queue&lt;string&gt; q = queue&lt;string&gt;&#123;&#123;beginWord&#125;&#125;;        <span class="hljs-type">int</span> wordLen = beginWord.<span class="hljs-built_in">length</span>();        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;            step++;            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;                <span class="hljs-type">const</span> string currWord = <span class="hljs-built_in">move</span>(q.<span class="hljs-built_in">front</span>());                string nextWord = currWord;                q.<span class="hljs-built_in">pop</span>();                <span class="hljs-comment">// 将每一位替换成 26 个小写英文字母</span>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; wordLen; ++j) &#123;                    <span class="hljs-type">const</span> <span class="hljs-type">char</span> origin = nextWord[j];                    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; ++c) &#123;                        nextWord[j] = c;                        <span class="hljs-keyword">if</span> (steps[nextWord] == step) &#123;                            from[nextWord].<span class="hljs-built_in">insert</span>(currWord);                        &#125;                        <span class="hljs-keyword">if</span> (dict.<span class="hljs-built_in">find</span>(nextWord) == dict.<span class="hljs-built_in">end</span>()) &#123;                            <span class="hljs-keyword">continue</span>;                        &#125;                        <span class="hljs-comment">// 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span>                        dict.<span class="hljs-built_in">erase</span>(nextWord);                        <span class="hljs-comment">// 这一层扩展出的单词进入队列</span>                        q.<span class="hljs-built_in">push</span>(nextWord);                        <span class="hljs-comment">// 记录 nextWord 从 currWord 而来</span>                        from[nextWord].<span class="hljs-built_in">insert</span>(currWord);                        <span class="hljs-comment">// 记录 nextWord 的 step</span>                        steps[nextWord] = step;                        <span class="hljs-keyword">if</span> (nextWord == endWord) &#123;                            found = <span class="hljs-literal">true</span>;                        &#125;                    &#125;                    nextWord[j] = origin;                &#125;            &#125;            <span class="hljs-keyword">if</span> (found) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-comment">// 第 2 步：回溯找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部</span>        <span class="hljs-keyword">if</span> (found) &#123;            vector&lt;string&gt; Path = &#123;endWord&#125;;            <span class="hljs-built_in">backtrack</span>(res, endWord, from, Path);        &#125;        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;vector&lt;string&gt;&gt; &amp;res, <span class="hljs-type">const</span> string &amp;Node, unordered_map&lt;string, set&lt;string&gt;&gt; &amp;from,</span></span><span class="hljs-params"><span class="hljs-function">             vector&lt;string&gt; &amp;path)</span> </span>&#123;        <span class="hljs-keyword">if</span> (from[Node].<span class="hljs-built_in">empty</span>()) &#123;            res.<span class="hljs-built_in">push_back</span>(&#123;path.<span class="hljs-built_in">rbegin</span>(), path.<span class="hljs-built_in">rend</span>()&#125;);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> string &amp;Parent: from[Node]) &#123;            path.<span class="hljs-built_in">push_back</span>(Parent);            <span class="hljs-built_in">backtrack</span>(res, Parent, from, path);            path.<span class="hljs-built_in">pop_back</span>();        &#125;    &#125;&#125;;</code></pre></div><p>分析：比较复杂的BFS+回溯法</p><p>错误：太复杂暂时还理解不了，慢慢来吧。。。</p><h2 id="练习">练习</h2><h3 id="Leetcode-130">Leetcode 130</h3><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n)</span></span>&#123;        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= m || y &gt;= n)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(board[x][y] == <span class="hljs-string">&#x27;X&#x27;</span> || board[x][y] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        board[x][y] = <span class="hljs-string">&#x27;A&#x27;</span>;        <span class="hljs-built_in">DFS</span>(board,x<span class="hljs-number">+1</span>,y,m,n);        <span class="hljs-built_in">DFS</span>(board,x<span class="hljs-number">-1</span>,y,m,n);        <span class="hljs-built_in">DFS</span>(board,x,y<span class="hljs-number">-1</span>,m,n);        <span class="hljs-built_in">DFS</span>(board,x,y<span class="hljs-number">+1</span>,m,n);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            <span class="hljs-built_in">DFS</span>(board,i,<span class="hljs-number">0</span>,m,n);            <span class="hljs-built_in">DFS</span>(board,i,n<span class="hljs-number">-1</span>,m,n);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-built_in">DFS</span>(board,<span class="hljs-number">0</span>,i,m,n);            <span class="hljs-built_in">DFS</span>(board,m<span class="hljs-number">-1</span>,i,m,n);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;++j)&#123;                <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27;A&#x27;</span>)&#123;                    board[i][j] = <span class="hljs-string">&#x27;O&#x27;</span>;                &#125;                <span class="hljs-keyword">else</span>&#123;                    board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span>;    &#125;&#125;;</code></pre></div><p>分析：也是比较普通的DFS，注意记录是否访问过即可。</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-257">Leetcode 257</h3><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* &amp;root,vector&lt;string&gt; &amp;paths,string temp)</span></span>&#123;        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>)&#123;            temp += <span class="hljs-built_in">to_string</span>(root-&gt;val);            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>)&#123;                paths.<span class="hljs-built_in">push_back</span>(temp);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                temp += <span class="hljs-string">&quot;-&gt;&quot;</span>;                <span class="hljs-built_in">DFS</span>(root-&gt;left,paths,temp);                <span class="hljs-built_in">DFS</span>(root-&gt;right,paths,temp);            &#125;        &#125;    &#125;    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        vector&lt;string&gt; paths;        <span class="hljs-built_in">DFS</span>(root,paths,<span class="hljs-string">&quot;&quot;</span>);        <span class="hljs-keyword">return</span> paths;    &#125;&#125;;</code></pre></div><p>分析：使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。如此，当遍历完整棵二叉树以后我们就得到了所有从根节点到叶子节点的路径。</p><p>错误：陷入回溯法的坑了。</p><h3 id="Leetcode-47">Leetcode 47</h3><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong>返回所有不重复的全排列。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;result,<span class="hljs-type">int</span> level)</span></span>&#123;        <span class="hljs-keyword">if</span>(level == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;            result.<span class="hljs-built_in">push_back</span>(nums);            <span class="hljs-keyword">return</span>;        &#125;        set&lt;<span class="hljs-type">int</span>&gt; st;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=level;i&lt;nums.<span class="hljs-built_in">size</span>();++i)&#123;            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">find</span>(nums[i]) == st.<span class="hljs-built_in">end</span>())&#123;                st.<span class="hljs-built_in">insert</span>(nums[i]);                <span class="hljs-built_in">swap</span>(nums[level],nums[i]);                <span class="hljs-built_in">backtracking</span>(nums,result,level<span class="hljs-number">+1</span>);                <span class="hljs-built_in">swap</span>(nums[level],nums[i]);            &#125;        &#125;        <span class="hljs-keyword">return</span>;    &#125;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;        <span class="hljs-built_in">backtracking</span>(nums,result,<span class="hljs-number">0</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：与全排列基本相同，添加一个<code>set</code>用于记录曾经交换过的数字，如果这个数字曾经交换过就不换了</p><p>错误：看了网上的思路。</p><h3 id="Leetcode-40">Leetcode 40</h3><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中只能使用<strong>一次</strong> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates,vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; &amp;result,vector&lt;<span class="hljs-type">int</span>&gt; &amp;path,vector&lt;<span class="hljs-type">bool</span>&gt; &amp;used,<span class="hljs-type">int</span> level,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> target)</span></span>&#123;        <span class="hljs-keyword">if</span>(sum &gt; target)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum == target)&#123;            result.<span class="hljs-built_in">push_back</span>(path);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=level;i&lt;candidates.<span class="hljs-built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;++i)&#123;                <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; candidates[i] == candidates[i<span class="hljs-number">-1</span>] &amp;&amp; used[i - <span class="hljs-number">1</span>] == <span class="hljs-literal">false</span>)&#123;                    <span class="hljs-keyword">continue</span>;                &#125;                sum += candidates[i];                path.<span class="hljs-built_in">push_back</span>(candidates[i]);                used[i] = <span class="hljs-literal">true</span>;                <span class="hljs-built_in">backtracking</span>(candidates,result,path,used,i<span class="hljs-number">+1</span>,sum,target);                used[i] = <span class="hljs-literal">false</span>;                sum -= candidates[i];                path.<span class="hljs-built_in">pop_back</span>();            &#125;        &#125;    &#125;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;        vector&lt;<span class="hljs-type">int</span>&gt; path;        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(candidates.size(),<span class="hljs-literal">false</span>)</span></span>;        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());        <span class="hljs-built_in">backtracking</span>(candidates,result,path,used,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,target);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：还是组合数，但是数字内部有重复的，因此需要对<strong>同一树层上的“使用过”进行去重。</strong></p><p>错误：没什么思路。</p><h3 id="Leetcode-37">Leetcode 37</h3><p>编写一个程序，通过填充空格来解决数独问题。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j,<span class="hljs-type">char</span> k,vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span>&#123;        set&lt;<span class="hljs-type">char</span>&gt; st;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>;x&lt;<span class="hljs-number">9</span>;x++)&#123;            st.<span class="hljs-built_in">insert</span>(board[i][x]);            st.<span class="hljs-built_in">insert</span>(board[x][j]);        &#125;        <span class="hljs-type">int</span> p = i / <span class="hljs-number">3</span>;        <span class="hljs-type">int</span> q = j / <span class="hljs-number">3</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = p*<span class="hljs-number">3</span>;x &lt; p*<span class="hljs-number">3</span><span class="hljs-number">+3</span>;++x)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = q * <span class="hljs-number">3</span>;y &lt; q*<span class="hljs-number">3</span><span class="hljs-number">+3</span>;++y)&#123;                st.<span class="hljs-built_in">insert</span>(board[x][y]);            &#125;        &#125;        <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">find</span>(k) == st.<span class="hljs-built_in">end</span>())&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span></span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;++i)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;++j)&#123;                <span class="hljs-keyword">if</span>(board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span>)&#123;                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> k = <span class="hljs-string">&#x27;1&#x27;</span>;k &lt;= <span class="hljs-string">&#x27;9&#x27;</span>;++k)&#123;                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(i,j,k,board))&#123;                        board[i][j] = k;                        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">backtracking</span>(board) == <span class="hljs-literal">true</span>)&#123;                            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                        &#125;                        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span>;                    &#125;                &#125;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;        <span class="hljs-type">bool</span> judge = <span class="hljs-built_in">backtracking</span>(board);        <span class="hljs-keyword">return</span>;    &#125;&#125;;</code></pre></div><p>分析：二维的回溯问题，说白了就是去尝试填充每一个数字，合理就填上，不合理就删掉之前填充的重新进行尝试。</p><p>错误：看题解。</p><h3 id="Leetcode-310">Leetcode 310</h3><p>给你一棵包含 <code>n</code> 个节点的树，标记为 <code>0</code> 到 <code>n - 1</code> 。给定数字 <code>n</code> 和一个有 <code>n - 1</code> 条无向边的 <code>edges</code> 列表（每一个边都是一对标签），其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条无向边。可选择树中任何一个节点作为根。当选择节点 <code>x</code> 作为根节点时，设结果树的高度为 <code>h</code> 。在所有可能的树中，具有最小高度的树（即，<code>min(h)</code>）被称为 <strong>最小高度树</strong> 。请你找到所有的 <strong>最小高度树</strong> 并按 <strong>任意顺序</strong> 返回它们的根节点标签列表。树的 <strong>高度</strong> 是指根节点和叶子节点之间最长向下路径上边的数量。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMinHeightTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;        <span class="hljs-type">int</span> m = edges.<span class="hljs-built_in">size</span>();        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;            result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">degree</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">tree</span>(n);        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;++i)&#123;            ++degree[edges[i][<span class="hljs-number">0</span>]];            ++degree[edges[i][<span class="hljs-number">1</span>]];            tree[edges[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(edges[i][<span class="hljs-number">1</span>]);            tree[edges[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(edges[i][<span class="hljs-number">0</span>]);        &#125;        queue&lt;<span class="hljs-type">int</span>&gt; q;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span>(degree[i] == <span class="hljs-number">1</span>)&#123;                q.<span class="hljs-built_in">push</span>(i);            &#125;        &#125;        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;            <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();            result.<span class="hljs-built_in">clear</span>();            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;++i)&#123;                <span class="hljs-type">int</span> top = q.<span class="hljs-built_in">front</span>();                result.<span class="hljs-built_in">push_back</span>(top);                q.<span class="hljs-built_in">pop</span>();                --degree[top];                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;tree[top].<span class="hljs-built_in">size</span>();++j)&#123;                    --degree[tree[top][j]];                    <span class="hljs-keyword">if</span>(degree[tree[top][j]] == <span class="hljs-number">1</span>)&#123;                        q.<span class="hljs-built_in">push</span>(tree[top][j]);                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：拓扑排序的思想，从多端同时BFS到中心点，直到到达最后一层，输出这一层的结点即为最小的高度。</p><p>错误：看了思路后自己实现，注意判断边界条件。</p><h2 id="总结">总结</h2><p>深度优先、广度优先和回溯法，理解的还是并不是非常深入，今后还要多加练习。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第0讲 课程简介</title>
    <link href="/2022/08/29/UCAS/information-retrieval/information-retrieval-0/"/>
    <url>/2022/08/29/UCAS/information-retrieval/information-retrieval-0/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第0讲 课程简介</p><span id="more"></span><h1>第0讲 课程简介</h1><h2 id="什么是信息检索">什么是信息检索</h2><p>信息检索应用例子的共同特征：</p><p>给定需求或者是对象，从信息库中找出与之最<strong>匹配</strong>的信息或对象。</p><p>数据形式是无固定结构的自由文本（谷歌搜索）或者结构化数据（京东商品）</p><h3 id="信息检索的定义">信息检索的定义</h3><ol><li>信息检索是给定用户需求返回满足该需求信息的一门学科。通常涉及信息的获取、存储、组织和访问。</li><li><strong>信息检索是从大规模非结构化数据（通常是文本）的集合（通常保存在计算机上）中找出满足用户信息需求的资料（通常是文档）的过程。</strong></li><li>信息检索是“找对象”的学科，即定义并计算某种匹配“相似度”的学科。</li></ol><p>信息检索与其他的学科关系密切，包括自然语言处理、数据挖掘和机器学习。</p><p>信息检索技术广泛应用于搜索、推荐、挖掘、舆情分析、情报处理和内容安全。</p><p>从信息规模上分类，信息检索可以分为：</p><ol><li>个人信息检索：个人相关信息的组织、整理、搜索等，包括桌面搜索、个人信息管理、个人数字记忆等</li><li>企业级信息检索：在企业内容文档的组织、管理、搜索等。企业级信息检索是内容管理的重要组成部分。</li><li>Web信息检索：在超大规模数据集上的检索。</li></ol><h2 id="为什么要学习信息检索">为什么要学习信息检索</h2><ol><li>用户国家、企业、个人等需要信息检索技术：互联网的信息量太大、噪音太多，寻找所需要的信息非常不容易。互联网的不只是搜索引擎才需要信息检索技术，电子商务、社交网、数字图书馆、大规模数据分析、金融证券行业等都需要信息检索技术。</li><li>公司需要信息检索技术：搜索引擎改变了很多传统的生活方式，互联网五大盈利模式或多或少都依赖信息检索技术的支撑，目前搜索引擎公司甚至整个互联网正常运转的计算广告的核心技术是信息检索技术。</li><li>应用需求：移动搜索、产品搜索、专利搜索、广告推荐、社会网络分析、消费行为分析、网络评论分析、SEO营销</li></ol><h2 id="信息检索学科的特点">信息检索学科的特点</h2><ol><li>应用性：目标非常实际，例如提升网络搜索引擎返回结果准确率、商品推荐转化率。</li><li>经验性：理论上漂亮的方法并不一定有用，理论需要结合实践。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究生课程：现代信息检索-第1讲 布尔检索</title>
    <link href="/2022/08/29/UCAS/information-retrieval/information-retrieval-1/"/>
    <url>/2022/08/29/UCAS/information-retrieval/information-retrieval-1/</url>
    
    <content type="html"><![CDATA[<p>《现代信息检索》课程笔记：第1讲 布尔检索</p><span id="more"></span><h1>第1讲 布尔检索</h1><h2 id="信息检索概述">信息检索概述</h2><p>现在提到信息检索，通常会首先想到Web搜索，但是除此之外还有很多其它的搜索应用，如电子邮件搜索、笔记本电脑（桌面）搜索、知识库搜索、法律文献搜索等。</p><p>本课程主要关注文本检索，因为文本检索是最早的检索应用，也仍然是目前最主要的应用，且文本检索理论可以用于其他领域。</p><p><strong>信息检索与数据库的区别主要在于数据的区别，信息检索关注的是非结构化的数据，而数据库关注的是结构化的数据。</strong></p><p>数据库常常支持范围或者精确匹配查询。</p><p>非结构化数据通常指自由文本，允许关键词加上操作符号的查询和更复杂的概念性查询，经典的检索模型一般都针对自由文本进行处理。</p><h2 id="信息检索的一些基本概念">信息检索的一些基本概念</h2><p>文档集（Collection）: 由固定数目的文档组成</p><p>目标：返回与用户需求相关的文档并辅助用户来完成某项任务</p><p>相关性（Relevance）：主观的概念，反映对象的匹配程度不同，应用相关性不同。</p><p>检索效果的评价：准确率和召回率（准确率是自己的，召回率才是真正的）</p><p>布尔检索：针对布尔查询的检索，布尔查询是指利用 <code>AND</code>，<code>OR</code>或者 <code>NOT</code>操作符将词项连接起来的查询。</p><h2 id="索引方法">索引方法</h2><p>需求：莎士比亚的哪部剧本包含Brutus及Caesar但是不包含Calpurnia</p><p>将需求表示为布尔表达式： Brutus AND Caesar AND NOT Calpurnia</p><h3 id="暴力索引方法">暴力索引方法</h3><p>从头到尾扫描所有剧本，对每部剧本判断它是否包含Brutus AND Caesar ，同时又不包含Calpurnia</p><p>暴力方法的优点：①实现简单②很容易支持文档动态变化</p><p>暴力方法的不足：</p><ol><li>速度超慢 (特别是大型文档集)</li><li>处理NOT Calpurnia 并不容易（不到末尾不能停止判断）</li><li>不太容易支持其他操作 (e.g., 寻找靠近countrymen的单词Romans)</li><li>不支持检索结果的<strong>灵活</strong>排序 (排序时只返回较好的结果)</li></ol><h3 id="倒排索引">倒排索引</h3><p>关联矩阵：</p><table><thead><tr><th></th><th>Antony and Cleopatra</th><th>Julius Caesar</th><th>The Tempest</th><th>Hamlet</th><th>Othello</th><th>Macbeth</th></tr></thead><tbody><tr><td>Antony</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>Brutus</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Caesar</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Calpurnia</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>Cleopatra</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>mercy</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>worser</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>行表示单词，列表示文本，若文本中包含这个单词，则记录为1，反之记录为0</p><p>使用关联矩阵进行查询的时候，即将关联矩阵有关单词的行向量取出来后进行按位与或非操作即可。</p><p>但是这种词项-文档的关联矩阵将非常大，由于是 <code>one-hot</code>存储，矩阵高度稀疏，需要更好的表示方式，因此有了倒排索引。</p><p>对每个词项 <code>t</code>，记录所有包含 <code>t</code>的文档列表，每篇文档用一个唯一的 <code>docID</code>来表示，通常是正整数。</p><p>词典 ➡ 倒排记录（Posting）</p><p>Brutus ➡ 1 2 4 11 31 45 173</p><p>Calpurnia ➡ 1 2 4 5 6 16 57 132</p><p>Caesar ➡2 31 54 101</p><p>倒排索引的存储通常采用变长表方式</p><ol><li>磁盘上，顺序存储方式比较好，便于快速读取</li><li>内存中，采用链表或者可变长数组方式，便于节省空间</li></ol><h3 id="构建倒排索引的流程">构建倒排索引的流程</h3><p>文本预处理：</p><ol><li>词条化（Tokenization）：将字符序列切分为词条</li><li>规范化（Normalization）：将文档和查询中的词项映射到相同的形式</li><li>词干还原（Stemming）：将同一词汇的不同形式还原到词根</li><li>停用词去除(Stopwords removal)：去除高频词项</li></ol><p>构建词条序列：&lt;词条，<code>docID</code>&gt; 类型的二元组</p><p>按词项排序：每个词项按 <code>docID</code>排序</p><p>某个词项在单篇文档中的多次出现会被合并</p><p>拆分成词典和倒排记录表两部分</p><p>每个词项出现的文档数目(doc.frequency, DF)会被加入</p><p>最终构成倒排索引：</p><p><a href="https://imgse.com/i/v4BM1f"><img src="https://s1.ax1x.com/2022/08/31/v4BM1f.png" alt="v4BM1f.png"></a></p><h2 id="布尔查询的处理">布尔查询的处理</h2><p>对于布尔查询来说，对倒排记录表进行操作即可。</p><p>每个倒排记录表都有一个定位指针，两个指针同时从前往后扫描, 每次比较当前指针对应倒排记录，然后移动某个或两个指针。合并时间为两个表长之和的线性时间。时间复杂度为 <code>O(m+n)</code></p><p><strong>这也是倒排记录表按照 <code>docID</code>排序的关键原因！</strong></p><p>查询处理中存在处理的顺序问题：<code>n</code>个词项的 <code>AND</code>我们希望查询的次数越少越好，因此要按照表从小到大（即 <code>df</code>从小到大）的顺序进行处理，每次从最小的开始合并（这样可以尽量提前结束合并）</p><p>按照直接加和的方式对 <code>Or</code>的 <code>df</code>进行估计。</p><h3 id="合并策略">合并策略</h3><p>每个布尔表达式都能转换成（合取范式）</p><p><strong>获得每个词项的 <code>df</code></strong></p><p>通过将词项的 <code>df</code>相加，估计每个 <code>OR</code>表达式对应的倒排记录表的大小</p><p>按照上述估计从小到大依次处理每个 <code>OR</code>表达式</p><h3 id="布尔检索的优点">布尔检索的优点</h3><p>构建简单，是构建信息检索系统的一种最简单方式</p><ul><li>在30多年中是最主要的检索工具</li><li>当前许多搜索系统仍然使用布尔检索模型</li><li>有一些扩展的布尔操作符</li><li>如果非常清楚想要查什么、能得到什么，很多专业人士喜欢使用布尔搜索</li></ul><h3 id="布尔检索的缺点">布尔检索的缺点</h3><ul><li>布尔查询构建复杂，不适合普通用户。构建不当，检索结果过多或者过少</li><li>没有充分利用词项的频率信息。因为词通常出现的越多越好，需要利用词项在文档中的词项频率（term frequency, tf）信息</li><li>不能对检索结果进行排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
      <tag>UCAS</tag>
      
      <tag>Information Retrieval</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第5章 排序算法</title>
    <link href="/2022/08/29/Leetcode/Leetcode-101/Leetcode-101-5/"/>
    <url>/2022/08/29/Leetcode/Leetcode-101/Leetcode-101-5/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第5章 排序算法</p><span id="more"></span><h1>排序算法</h1><p>排序自然都有C++的STL搞定了，但是在实际中仍然需要这些排序算法，一方面夯实基础，另一方面有一些题目是从这些排序算法中引申出来的，掌握这些排序算法对于做题也会有很大的帮助。</p><h2 id="常用排序算法">常用排序算法</h2><h3 id="调用">调用</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">temp</span><span class="hljs-params">(nums.size())</span></span>;    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());    <span class="hljs-built_in">quick_sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>());    <span class="hljs-built_in">print</span>(nums);    <span class="hljs-built_in">merge_sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>(), temp);    <span class="hljs-built_in">print</span>(nums);    <span class="hljs-built_in">insertion_sort</span>(nums, nums.<span class="hljs-built_in">size</span>());    <span class="hljs-built_in">print</span>(nums);    <span class="hljs-built_in">bubble_sort</span>(nums, nums.<span class="hljs-built_in">size</span>());    <span class="hljs-built_in">print</span>(nums);    <span class="hljs-built_in">selection_sort</span>(nums, nums.<span class="hljs-built_in">size</span>());    <span class="hljs-built_in">print</span>(nums);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h3 id="快速排序">快速排序</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;    <span class="hljs-type">int</span> l = left;    <span class="hljs-type">int</span> r = right;    <span class="hljs-keyword">if</span>(left<span class="hljs-number">+1</span> &gt;= right)&#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> k = nums[left];    <span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span> &lt; right)&#123;        <span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span> &lt; right &amp;&amp; nums[right<span class="hljs-number">-1</span>] &gt;= k)&#123;            --right;        &#125;        nums[left] = nums[right<span class="hljs-number">-1</span>];        <span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span> &lt; right &amp;&amp; nums[left] &lt; k)&#123;            ++left;        &#125;        nums[right<span class="hljs-number">-1</span>] = nums[left];    &#125;    nums[left] = k;    <span class="hljs-built_in">quick_sort</span>(nums,l,left);    <span class="hljs-built_in">quick_sort</span>(nums,left<span class="hljs-number">+1</span>,r);&#125;</code></pre></div><p><strong>错误：<code>while</code>内部的 <code>left &lt; right</code>的条件没有加，导致内部会出问题，而且也是要+1的</strong></p><h3 id="归并排序">归并排序</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,vector&lt;<span class="hljs-type">int</span>&gt; &amp;temp)</span></span>&#123;    <span class="hljs-keyword">if</span>(left + <span class="hljs-number">1</span> &gt;= right)&#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;    <span class="hljs-built_in">merge_sort</span>(nums,left,mid,temp);    <span class="hljs-built_in">merge_sort</span>(nums,mid,right,temp);    <span class="hljs-type">int</span> p = left;    <span class="hljs-type">int</span> q = mid;    <span class="hljs-type">int</span> i = left;    <span class="hljs-keyword">while</span>(p &lt; mid &amp;&amp; q &lt; right)&#123;        <span class="hljs-keyword">if</span>(nums[p] &lt;= nums[q])&#123;            temp[i++] = nums[p++];        &#125;        <span class="hljs-keyword">else</span>&#123;            temp[i++] = nums[q++];        &#125;    &#125;    <span class="hljs-keyword">while</span>(p &lt; mid)&#123;        temp[i++] = nums[p++];    &#125;    <span class="hljs-keyword">while</span>(q &lt; right)&#123;        temp[i++] = nums[q++];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=left;j&lt;right;++j)&#123;        nums[j] = temp[j];    &#125;&#125;</code></pre></div><p><strong>错误：应该是 <code>left + 1 &gt;= right</code>，只剩下一个数字后就应该返回了。</strong></p><h3 id="插入排序">插入排序</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> a = i;        <span class="hljs-keyword">while</span>(a - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[a] &lt; nums[a<span class="hljs-number">-1</span>])&#123;            <span class="hljs-built_in">swap</span>(nums[a],nums[a<span class="hljs-number">-1</span>]);            --a;        &#125;    &#125;    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><h3 id="冒泡排序">冒泡排序</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n-i<span class="hljs-number">-1</span>;j++)&#123;            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j<span class="hljs-number">+1</span>])&#123;                <span class="hljs-built_in">swap</span>(nums[j],nums[j<span class="hljs-number">+1</span>]);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><h3 id="选择排序">选择排序</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;        <span class="hljs-type">int</span> minnum = nums[i];        <span class="hljs-type">int</span> minindex = i;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;n;j++)&#123;            <span class="hljs-keyword">if</span>(nums[j] &lt; minnum)&#123;                minnum = nums[j];                minindex = j;            &#125;        &#125;        <span class="hljs-built_in">swap</span>(nums[i],nums[minindex]);    &#125;    <span class="hljs-keyword">return</span>;&#125;</code></pre></div><h2 id="快速排序-2">快速排序</h2><h3 id="Leetcode-215">Leetcode 215</h3><p>在一个未排序的数组中，找到第 <code>k</code>大的数字</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">quick_selection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> k)</span></span>&#123;        <span class="hljs-type">int</span> l = left;        <span class="hljs-type">int</span> r = right;        <span class="hljs-type">int</span> k2 = nums[left];        <span class="hljs-keyword">if</span>(left + <span class="hljs-number">1</span> &gt; right)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span> &lt; right)&#123;            <span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span> &lt; right &amp;&amp; nums[right<span class="hljs-number">-1</span>] &lt; k2)&#123;                --right;            &#125;            nums[left] = nums[right<span class="hljs-number">-1</span>];            <span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span> &lt; right &amp;&amp; nums[left] &gt;= k2)&#123;                ++left;            &#125;            nums[right<span class="hljs-number">-1</span>] = nums[left];        &#125;        nums[left] = k2;        <span class="hljs-keyword">if</span>(k &lt;= left)&#123;            <span class="hljs-built_in">quick_selection</span>(nums,l,left,k);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-built_in">quick_selection</span>(nums,left<span class="hljs-number">+1</span>,r,k);        &#125;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;        <span class="hljs-built_in">quick_selection</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>(),k<span class="hljs-number">-1</span>);        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre></div><p>分析：与快速排序相同的思路，但是不需要对没有用的一侧进行快速排序，只需要对<code>k</code>在的区间一侧进行快速排序即可。</p><p>错误：开始快速排序有问题，然后<code>k</code>的值想不清楚造成错误。</p><h2 id="桶排序">桶排序</h2><h3 id="Leetcode-347">Leetcode 347</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;        <span class="hljs-keyword">return</span> a.first &gt; b.first;    &#125;    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp1,mp2;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : nums)&#123;            ++mp1[i];        &#125;        vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; pr;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = mp<span class="hljs-number">1.</span><span class="hljs-built_in">cbegin</span>();i != mp<span class="hljs-number">1.</span><span class="hljs-built_in">cend</span>();++i)&#123;            pr.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(i-&gt;second,i-&gt;first));        &#125;        <span class="hljs-built_in">sort</span>(pr.<span class="hljs-built_in">begin</span>(),pr.<span class="hljs-built_in">end</span>(),cmp);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = pr.<span class="hljs-built_in">cbegin</span>();i != pr.<span class="hljs-built_in">cend</span>();++i)&#123;            <span class="hljs-keyword">if</span>(k != <span class="hljs-number">0</span>)&#123;                result.<span class="hljs-built_in">push_back</span>(i-&gt;second);            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">break</span>;            &#125;            k--;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：也是比较简单的一道题，通过这道题可以复习一下各种 <code>STL</code>数据结构，总也不用生疏了。</p><p>错误：<code>STL</code>有一些生疏，调了一段时间才调好。</p><h2 id="练习">练习</h2><h3 id="Leetcode-451">Leetcode 451</h3><p>给定一个字符串 <code>s</code> ，根据字符出现的<strong>频率</strong>对其进行<strong>降序排序。<strong>一个字符出现的</strong>频率</strong>是它出现在字符串中的次数。返回<strong>已排序的字符串</strong>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; &amp;a,pair&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;        <span class="hljs-keyword">return</span> a.second &gt; b.second;    &#125;    <span class="hljs-function">string <span class="hljs-title">frequencySort</span><span class="hljs-params">(string s)</span> </span>&#123;        string result = <span class="hljs-string">&quot;&quot;</span>;        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : s)&#123;            mp[i] += <span class="hljs-number">1</span>;        &#125;        vector&lt;pair&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;&gt; pr;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = mp.<span class="hljs-built_in">cbegin</span>();i != mp.<span class="hljs-built_in">cend</span>();i++)&#123;            pr.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(i-&gt;first,i-&gt;second));        &#125;        <span class="hljs-built_in">sort</span>(pr.<span class="hljs-built_in">begin</span>(),pr.<span class="hljs-built_in">end</span>(),cmp);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = pr.<span class="hljs-built_in">cbegin</span>();i != pr.<span class="hljs-built_in">cend</span>();i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i-&gt;second;j++)&#123;                result += i-&gt;first;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：桶排序的变形题，没有什么新意，还是数据结构</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-75">Leetcode 75</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();    <span class="hljs-type">int</span> p0 = <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> p1 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;        <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>)&#123;            <span class="hljs-built_in">swap</span>(nums[i],nums[p1]);            ++p1;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;            <span class="hljs-built_in">swap</span>(nums[i],nums[p0]);            <span class="hljs-keyword">if</span>(p0 &lt; p1)&#123;                <span class="hljs-built_in">swap</span>(nums[i],nums[p1]);            &#125;            ++p0;            ++p1;        &#125;    &#125;&#125;</code></pre></div><p>分析：荷兰国旗问题，双指针一次遍历就可以得到三个数字的排序。</p><p>错误：想复杂了。</p><h2 id="总结">总结</h2><p>排序算法基本都可以写，就是变形的题目还是有些不太熟练。还是要多多练习。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第4章 二分查找</title>
    <link href="/2022/08/28/Leetcode/Leetcode-101/Leetcode-101-4/"/>
    <url>/2022/08/28/Leetcode/Leetcode-101/Leetcode-101-4/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第4章 二分查找</p><span id="more"></span><h1>二分查找</h1><p>二分查找也常被称为二分法或者折半查找，每次查找时通过将待查找区间分成两部分并只取一部分继续查找，将查找的复杂度大大减少。</p><p>二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。</p><h2 id="一点点细节小笔记">一点点细节小笔记</h2><ol><li>最基本的二分查找算法：</li></ol><p>因为我们初始化 <code>right = nums.length - 1</code>，所以决定了我们的「搜索区间」是 <code>[left, right]</code>，所以决定了 <code>while (left &lt;= right)</code>，同时也决定了 <code>left = mid+1</code> 和 <code>right = mid-1</code>，因为我们只需找到一个 <code>target</code> 的索引即可，所以当 <code>nums[mid] == target</code> 时可以立即返回。</p><ol start="2"><li>寻找左侧边界的二分查找：</li></ol><p>因为我们初始化 <code>right = nums.length</code>，所以决定了我们的「搜索区间」是 <code>[left, right)</code>，所以决定了 <code>while (left &lt; right)</code>，同时也决定了 <code>left = mid + 1</code> 和 <code>right = mid</code>，因为我们需找到 <code>target</code> 的最左侧索引，所以当 <code>nums[mid] == target</code> 时不要立即返回，而要收紧右侧边界以锁定左侧边界。</p><ol start="3"><li>寻找右侧边界的二分查找：</li></ol><p>因为我们初始化 <code>right = nums.length</code>，所以决定了我们的「搜索区间」是 <code>[left, right)</code>，所以决定了 <code>while (left &lt; right)</code>，同时也决定了 <code>left = mid + 1</code> 和 <code>right = mid</code>，因为我们需找到 <code>target</code> 的最右侧索引，所以当 <code>nums[mid] == target</code> 时不要立即返回，而要收紧左侧边界以锁定右侧边界，又因为收紧左侧边界时必须 <code>left = mid + 1</code>，所以最后无论返回 <code>left</code> 还是 <code>right</code>，必须减一。</p><h2 id="求开方">求开方</h2><h3 id="Leetcode-69">Leetcode 69</h3><p>给定一个非负整数，求它的开方，向下取整。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;        <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = <span class="hljs-built_in">sqrt</span>(x) + <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span>(mid * mid &lt; x)&#123;                left = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid * mid &gt; x)&#123;                right = mid - <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> mid;            &#125;        &#125;        <span class="hljs-keyword">return</span> left - <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre></div><p>思路很简单，主要是细节问题，已经整理了笔记。</p><h2 id="查找区间">查找区间</h2><h3 id="Leetcode-34">Leetcode 34</h3><p>给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;        &#125;        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = n;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target)&#123;                right = mid;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(right &gt;= n || nums[right] != target)&#123;            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;        &#125;        <span class="hljs-keyword">else</span>&#123;            result.<span class="hljs-built_in">push_back</span>(right);        &#125;        left = <span class="hljs-number">0</span>;        right = n;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;                right = mid;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt;= target)&#123;                left = mid + <span class="hljs-number">1</span>;            &#125;        &#125;        result.<span class="hljs-built_in">push_back</span>(left - <span class="hljs-number">1</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：也是最基础的二分查找，实现了 <code>upper_bound</code>和 <code>lower_bound</code>两个函数。</p><p>错误：判断的时候忘记判断是否越界。</p><h2 id="旋转数组查找数字">旋转数组查找数字</h2><h3 id="Leetcode-81">Leetcode 81</h3><p>一个原本增序的数组被首尾相连后按某个位置断开（如[1,2,2,3,4,5] - [2,3,4,5,1,2]，在第一位和第二位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个旋转数组中。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = n;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[right<span class="hljs-number">-1</span>])&#123;                <span class="hljs-comment">// 说明右端是排好序的</span>                <span class="hljs-keyword">if</span>(target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right<span class="hljs-number">-1</span>])&#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span>&#123;                    right = mid;                &#125;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[right<span class="hljs-number">-1</span>])&#123;                <span class="hljs-comment">// 说明左端是排好序的</span>                <span class="hljs-keyword">if</span>(target &lt;= nums[mid] &amp;&amp; target &gt;= nums[left])&#123;                    right = mid;                &#125;                <span class="hljs-keyword">else</span>&#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;            &#125;            <span class="hljs-keyword">else</span>&#123;                --right;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>分析：旋转数组是一类经典题目，需要抓住旋转后二分会有一个区间是单调的性质进行判断，从而对所查找的数字进行区间的锁定。</p><p>错误：条件考虑不全面，没有对旋转数组充分理解。</p><h2 id="练习">练习</h2><h3 id="Leetcode-154">Leetcode 154</h3><p>寻找旋转排序数组中的最小值</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = n;        <span class="hljs-type">int</span> minnum = <span class="hljs-number">10000</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span>(nums[mid] &gt; nums[left])&#123;                <span class="hljs-comment">// 左边一定有序</span>                minnum = <span class="hljs-built_in">min</span>(minnum,nums[left]);                left = mid + <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; nums[left])&#123;                <span class="hljs-comment">// 右边一定有序</span>                minnum = <span class="hljs-built_in">min</span>(minnum,nums[mid]);                right = mid;            &#125;            <span class="hljs-keyword">else</span>&#123;                minnum = <span class="hljs-built_in">min</span>(minnum,nums[mid]);                ++left;            &#125;        &#125;        <span class="hljs-keyword">return</span> minnum;    &#125;&#125;;</code></pre></div><p>分析：比查找还要稍稍简单一点，只需要想好最小值可能出现的位置即可。</p><p>错误：相等的时候没有判断，会导致漏掉元素。</p><h3 id="Leetcode-540">Leetcode 540</h3><p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。请你找出并返回只出现一次的那个数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = n;        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-type">int</span> mid  = (right - left) / <span class="hljs-number">2</span> + left;            <span class="hljs-keyword">if</span>(mid % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(nums[mid] == nums[mid<span class="hljs-number">+1</span>])&#123;                    left = mid + <span class="hljs-number">2</span>;                &#125;                <span class="hljs-keyword">else</span>&#123;                    right = mid;                &#125;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">if</span>(nums[mid] == nums[mid<span class="hljs-number">-1</span>])&#123;                    left = mid + <span class="hljs-number">1</span>;                &#125;                <span class="hljs-keyword">else</span>&#123;                    right = mid;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> nums[left];    &#125;&#125;;</code></pre></div><p>分析：如果mid是偶数，则比较nums[mid]和nums[mid+1]是否相等；如果mid是奇数，则比较nums[mid−1]和nums[mid]是否相等。</p><p>错误：感觉需要判断很多条件？其实不用，只需要考虑长度为1的数组，然后根据下标寻找规律就可以。</p><h3 id="Leetcode-4">Leetcode 4</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的<strong>中位数</strong> 。</p><p>分析：二分的解法太难了。。后续补充吧</p><p>错误：没有思路。。。</p><h2 id="总结">总结</h2><p>二分查找是非常好的降低时间复杂度的方法之一，整体的思想不是很难，但是细节的部分需要多多注意。当然也有难题，还要多练习。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第3章 双指针</title>
    <link href="/2022/08/28/Leetcode/Leetcode-101/Leetcode-101-3/"/>
    <url>/2022/08/28/Leetcode/Leetcode-101/Leetcode-101-3/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第3章 双指针</p><span id="more"></span><h1>双指针</h1><p>双指针主要用于遍历数组，两个指针指向不同的元素，从而协同完成任务。也可以延伸到多个数组的多个指针。</p><p>若两个指针指向同一数组，遍历方向相同且不会相交，则也称为滑动窗口（两个指针包围的区域即为当前的窗口），经常用于区间搜索。</p><p>若两个指针指向同一数组，但是遍历方向相反，则可以用来进行搜索，待搜索的数组往往是排好序的。</p><h2 id="Two-Sum">Two Sum</h2><h3 id="Leetcode-167">Leetcode 167</h3><p>在一个增序的整数数组里找到两个数，使它们的和为给定值。已知有且只有一对解。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt; right)&#123;            <span class="hljs-keyword">if</span>(numbers[left] + numbers[right] &lt; target)&#123;                ++left;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[left] + numbers[right] &gt; target)&#123;                --right;            &#125;            <span class="hljs-keyword">else</span>&#123;                result.<span class="hljs-built_in">push_back</span>(left<span class="hljs-number">+1</span>);                result.<span class="hljs-built_in">push_back</span>(right<span class="hljs-number">+1</span>);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：左右两个指针分别进行移动，加和小了就把左边的指针往右移动一下，加和大了就把右边的指针往左移动一下。这道题比较特殊，限定了一定有答案而且答案只会有一个，因此不需要添加任何其他的额外条件。</p><p>错误：没看清下标的表示方式，直接输出数组下标了。</p><h2 id="归并两个有序数组">归并两个有序数组</h2><h3 id="Leetcode-88">Leetcode 88</h3><p>给定两个有序数组，把两个数组合并为一个。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;            nums1 = nums2;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">int</span> mi = m - <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> ni = n - <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> numIndex = m+n<span class="hljs-number">-1</span>;        <span class="hljs-keyword">while</span>(numIndex &gt;= <span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(mi &gt;= <span class="hljs-number">0</span> &amp;&amp; ni &gt;= <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(nums1[mi] &gt; nums2[ni])&#123;                    <span class="hljs-built_in">swap</span>(nums1[mi],nums1[numIndex]);                    --mi;                &#125;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-built_in">swap</span>(nums2[ni],nums1[numIndex]);                    --ni;                  &#125;                      &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mi == <span class="hljs-number">-1</span>)&#123;                <span class="hljs-keyword">while</span>(ni != <span class="hljs-number">-1</span>)&#123;                    nums1[numIndex] = nums2[ni];                    --ni;                    --numIndex;                &#125;                <span class="hljs-keyword">break</span>;            &#125;            --numIndex;        &#125;    &#125;&#125;;</code></pre></div><p>分析：从后边开始安排数字，填充0的空位</p><p>错误：挺简单的一道题，首先是刚开始没有想到非常好的解法，看了答案后双指针又有一些问题。。真的是生疏了。</p><h2 id="快慢指针">快慢指针</h2><h3 id="Leetcode-142">Leetcode 142</h3><p>给定一个链表，如果有环路，找出环路的开始点。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;        ListNode* slow = head;        ListNode* fast = head;        <span class="hljs-keyword">do</span>&#123;            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;            &#125;            slow = slow-&gt;next;            fast = fast-&gt;next-&gt;next;        &#125;<span class="hljs-keyword">while</span>(slow != fast);        fast = head;        <span class="hljs-keyword">while</span>(slow != fast)&#123;            slow = slow-&gt;next;            fast = fast-&gt;next;        &#125;        <span class="hljs-keyword">return</span> fast;    &#125;&#125;;</code></pre></div><p>分析：有一个通用的解法——快慢指针（Floyd判圈法）。给定两个指针，分别命名为slow和fast，起始位置在链表的开头。每次fast前进两步，slow前进一步。如果fast可以走到尽头，那么说明没有环路；如果fast可以无限走下去，那么说明一定有环路，且一定存在一个时刻slow 和fast 相遇。当slow和fast第一次相遇时，我们将fast重新移动到链表开头，并让slow和fast每次都前进一步。当slow和fast第二次相遇时，相遇的节点即为环路的开始点。</p><p>错误：算法忘记了，没有思路。</p><h2 id="滑动窗口">滑动窗口</h2><h3 id="Leetcode-76">Leetcode 76</h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;        <span class="hljs-type">size_t</span> s_size = s.<span class="hljs-built_in">size</span>();        <span class="hljs-type">size_t</span> t_size = t.<span class="hljs-built_in">size</span>();        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp1;        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>;i&lt;t_size;i++)&#123;            <span class="hljs-keyword">if</span>(mp<span class="hljs-number">1.</span><span class="hljs-built_in">count</span>(t[i]))&#123;                mp1[t[i]] += <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                mp1[t[i]] = <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,cnt = <span class="hljs-number">0</span>,min_l = <span class="hljs-number">0</span>,min_size = s_size<span class="hljs-number">+1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;s_size;++r)&#123;            <span class="hljs-keyword">if</span>(mp<span class="hljs-number">1.</span><span class="hljs-built_in">count</span>(s[r]))&#123;                --mp1[s[r]];                <span class="hljs-keyword">if</span>(mp1[s[r]] &gt;= <span class="hljs-number">0</span>)&#123;                    ++cnt;                &#125;                <span class="hljs-keyword">while</span>(cnt == t_size)&#123;                    <span class="hljs-keyword">if</span>(r - left + <span class="hljs-number">1</span> &lt; min_size)&#123;                        min_size = r - left + <span class="hljs-number">1</span>;                        min_l = left;                    &#125;                    <span class="hljs-keyword">if</span>(mp<span class="hljs-number">1.</span><span class="hljs-built_in">count</span>(s[left]) &amp;&amp; ++mp1[s[left]] &gt; <span class="hljs-number">0</span>)&#123;                           --cnt;                    &#125;                     ++left;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> min_size &gt; s_size ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(min_l,min_size);    &#125;&#125;;</code></pre></div><p>分析：滑动窗口典型题目</p><p>首先对子字符串进行计数，记录是否出现，以及出现的次数。然后采取滑动窗口的策略，两个指针都从左开始滑动，以右指针为基准构成外侧的大循环。右指针滑动的过程中，对之前的计数进行更改，滑动到了一个字符就减小1。等到0的时候，说明右指针滑动过了的字符串一定包含子字符串的全部字符，然后将左指针向右滑动来减小这个字符串的长度。左指针碰到了某个子字符串内部的字符，就会将计数+1，从而不满足这个字符串包含整个子字符串的要求，因此重新开始移动右字符串，以尝试再次包含整个子字符串。</p><p>错误：算法忘记了，没有思路。</p><h2 id="练习">练习</h2><h3 id="Leetcode-633">Leetcode 633</h3><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a^2 + b^2 = c</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judgeSquareSum</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> </span>&#123;        <span class="hljs-type">long</span> <span class="hljs-type">long</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">long</span> <span class="hljs-type">long</span> right = <span class="hljs-built_in">sqrt</span>(c);        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-keyword">if</span>(left * left + right * right &lt; c)&#123;                ++left;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left * left + right * right &gt; c)&#123;                --right;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre></div><p>分析：仍然是双指针的问题，多了一点点细节问题。</p><p>错误：<code>left = right</code>，right的范围考虑的不太好。</p><h3 id="Leetcode-680">Leetcode 680</h3><p>给你一个字符串 <code>s</code>，<strong>最多</strong>可以从中删除一个字符。请你判断 <code>s</code>是否能成为回文字符串：如果能，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-keyword">if</span>(s[left] == s[right])&#123;                ++left;                --right;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-type">size_t</span> s_size = s.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> right = s_size - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;            <span class="hljs-keyword">if</span>(s[left] == s[right])&#123;                ++left;                --right;            &#125;            <span class="hljs-keyword">else</span>&#123;                <span class="hljs-keyword">return</span> <span class="hljs-built_in">judge</span>(s,left<span class="hljs-number">+1</span>,right) || <span class="hljs-built_in">judge</span>(s,left,right<span class="hljs-number">-1</span>);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;;</code></pre></div><p>分析：双指针移动就好</p><p>错误：没有考虑到删除一个字符后有两种情况，应该共同考虑而不是仅仅使用某一种情况进行判断。</p><h3 id="Leetcode-524">Leetcode 524</h3><p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> ，找出并返回 <code>dictionary</code> 中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。如果答案不止一个，返回长度最长且字母序最小的字符串。如果答案不存在，则返回空字符串。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string &amp;a,string &amp;b)</span></span>&#123;        <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">size</span>() != b.<span class="hljs-built_in">size</span>())&#123;            <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">size</span>() &gt; b.<span class="hljs-built_in">size</span>();        &#125;        <span class="hljs-keyword">return</span> a &lt; b;    &#125;    <span class="hljs-function">string <span class="hljs-title">findLongestWord</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;        <span class="hljs-built_in">sort</span>(dictionary.<span class="hljs-built_in">begin</span>(),dictionary.<span class="hljs-built_in">end</span>(),cmp);        <span class="hljs-type">size_t</span> s_size = s.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t : dictionary)&#123;            <span class="hljs-type">size_t</span> t_size = t.<span class="hljs-built_in">size</span>();            <span class="hljs-type">int</span> si = <span class="hljs-number">0</span>,ti = <span class="hljs-number">0</span>;            <span class="hljs-keyword">while</span>(si != s_size)&#123;                <span class="hljs-keyword">if</span>(s[si] == t[ti])&#123;                    ++ti;                &#125;                ++si;                <span class="hljs-keyword">if</span>(ti == t_size)&#123;                    <span class="hljs-keyword">return</span> t;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;    &#125;&#125;;</code></pre></div><p>分析：先排序，然后双指针进行移动匹配，如果子字符串的指针移动到字符串的末尾了，说明已经匹配成功了，可以直接输出这个字符串。如果原始的字符串的指针移动到末尾了，说明没有匹配成功，因此转为匹配下一个字符串。</p><p>错误：题目要求的排序条件没有看好，返回了长度比较短的字符串。</p><h3 id="Leetcode-340">Leetcode 340</h3><p>给定一个字符串 <code>s</code>，找出至多包含 <code>k</code>个不同字符的最长子串 <code>T</code></p><p>分析：还是滑动窗口的策略，以右边指针为基准，滑动一下就记录一下最长的长度，滑动到不满足条件了，就将左边的指针收回来，收到满足条件了就继续放右边的指针去滑动。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstringKDistinct</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;        <span class="hljs-type">size_t</span> s_size - s.<span class="hljs-built_in">size</span>();        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;        <span class="hljs-type">int</span> maxlen = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> r=<span class="hljs-number">0</span>;r&lt;s_size;r++)&#123;            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">size</span>() &lt;= k)&#123;                ++mp[s[r]];            &#125;            <span class="hljs-keyword">while</span>(mp.<span class="hljs-built_in">size</span>() &gt; k)&#123;                <span class="hljs-keyword">if</span>(--mp[s[l]] == <span class="hljs-number">0</span>)&#123;                    mp.<span class="hljs-built_in">erase</span>(s[l]);                &#125;                l++;            &#125;            maxlen = <span class="hljs-built_in">max</span>(maxlen,r-l<span class="hljs-number">+1</span>);        &#125;        <span class="hljs-keyword">return</span> maxlen;    &#125;&#125;;</code></pre></div><p>错误：会员题，无法提交。</p><h2 id="总结">总结</h2><p>双指针的题目还可以，感觉重要的是判断条件。滑动窗口的题目比较困难，可能也是做的题目比较少。后面还需要加强练习。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 刷题笔记-Leetcode 101 第2章 贪心算法</title>
    <link href="/2022/08/27/Leetcode/Leetcode-101/Leetcode-101-2/"/>
    <url>/2022/08/27/Leetcode/Leetcode-101/Leetcode-101-2/</url>
    
    <content type="html"><![CDATA[<p>Leetcode 刷题笔记-Leetcode 101 第2章 贪心算法</p><span id="more"></span><h1>贪心算法</h1><p>贪心算法或贪心思想采用贪心的策略，保证每次操作都是局部最优的，从而使最后得到的结果是全局最优的。</p><h2 id="分配问题">分配问题</h2><h3 id="Leetcode-455">Leetcode 455</h3><p>有一群孩子和一堆饼干，每个孩子有一个饥饿度，每个饼干都有一个大小。每个孩子只能吃一个饼干，且只有饼干的大小不小于孩子的饥饿度时，这个孩子才能吃饱。求解最多有多少孩子可以吃饱。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(),g.<span class="hljs-built_in">end</span>());        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(),s.<span class="hljs-built_in">end</span>());        <span class="hljs-type">int</span> childrenCount = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>() &amp;&amp; childrenCount &lt; g.<span class="hljs-built_in">size</span>();i++)&#123;            <span class="hljs-keyword">if</span>(s[i] &gt;= g[childrenCount])&#123;                ++childrenCount;            &#125;        &#125;        <span class="hljs-keyword">return</span> childrenCount;    &#125;&#125;;</code></pre></div><p>分析：用最小大小的饼干 <code>(s)</code>去满足最小饥饿度的孩子 <code>(g)</code>，一直满足到饥饿度最大的孩子，相当于双指针的移动。</p><p>贪心策略是给剩余孩子里最小饥饿度的孩子分配最小的能饱腹的饼干。</p><p><strong>错误：忘记检查g是否越界，可能发生所有饼干都能满足所有孩子，然而饼干还剩着的情况。下标运算一定要确认是否越界。</strong></p><h3 id="Leetcode-135">Leetcode 135</h3><p>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；所有孩子至少要有一个糖果。求解最少需要多少个糖果。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyNum</span><span class="hljs-params">(ratings.size(),<span class="hljs-number">1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i&lt;ratings.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;++i)&#123;            <span class="hljs-keyword">if</span>(ratings[i<span class="hljs-number">+1</span>] &gt; ratings[i] &amp;&amp; candyNum[i<span class="hljs-number">+1</span>] &lt;= candyNum[i])&#123;                candyNum[i<span class="hljs-number">+1</span>] = candyNum[i] + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = ratings.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;--i)&#123;            <span class="hljs-keyword">if</span>(ratings[i<span class="hljs-number">-1</span>] &gt; ratings[i] &amp;&amp; candyNum[i<span class="hljs-number">-1</span>] &lt;= candyNum[i])&#123;                candyNum[i<span class="hljs-number">-1</span>] = candyNum[i] + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(candyNum.<span class="hljs-built_in">cbegin</span>(),candyNum.<span class="hljs-built_in">cend</span>(),<span class="hljs-number">0</span>);    &#125;&#125;;</code></pre></div><p>分析：首先至少有一个糖果分配好，然后从左向右扫一遍，如果右边的孩子评分高，则<strong>右边孩子的糖果=左边孩子的糖果+1</strong>，再从右往左扫一遍，如果左边的孩子评分高，则<strong>左边孩子的糖果=右边孩子的糖果+1</strong>。最后求和即可。</p><p>贪心策略：在每次遍历中，只考虑并更新相邻一侧的大小关系</p><p><strong>错误：没有更新为相邻孩子+1，而是仅仅加了1，考虑不够完整。</strong></p><h2 id="区间问题">区间问题</h2><h3 id="Leetcode-435">Leetcode 435</h3><p>给定一个区间的集合 <code>intervals</code> ，返回 需要移除区间的最小数量，使剩余区间互不重叠。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(),intervals.<span class="hljs-built_in">end</span>(),cmp);        <span class="hljs-type">int</span> intervalsCount = <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> searchBack = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-type">size_t</span> n = intervals.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;            <span class="hljs-keyword">if</span> (intervals[i][<span class="hljs-number">0</span>] &gt;= searchBack)&#123;                intervalsCount += <span class="hljs-number">1</span>;                searchBack = intervals[i][<span class="hljs-number">1</span>];            &#125;         &#125;        <span class="hljs-keyword">return</span> n - intervalsCount;    &#125;&#125;;</code></pre></div><p>分析：假设第一个区间是 <code>k</code>，<code>k</code>的左边没有任何区间，因此使用其他任何一个区间，只要右端点小于 <code>k</code>的右端点就可以了。而且右端点向左移动，比 <code>k</code>更优。因此<strong>首个区间就是所有可以选择的区间中右端点最小的那个区间</strong> 。后面只要去寻找其中<strong>与首个区间不重合</strong>并且右端点最小的区间即可。</p><p>贪心策略：优先保留结尾小且不相交的区间</p><p>错误1：没想明白右端点的问题</p><p>错误2：函数要加 <code>static</code>（但是不太明白）</p><p>错误3：使用引用传参，防止拷贝浪费时间</p><p>建议：一些比如数组大小的数字提前计算出来，避免反复计算。</p><h2 id="练习">练习</h2><h3 id="Leetcode-605">Leetcode 605</h3><p>有一个很长的花坛，一部分地块种植了花，另一部分却没有。花不能种植在相邻的地块上。 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPlaceFlowers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; flowerbed, <span class="hljs-type">int</span> n)</span> </span>&#123;        <span class="hljs-type">int</span> flowerCount = <span class="hljs-number">0</span>;        <span class="hljs-type">size_t</span> m = flowerbed.<span class="hljs-built_in">size</span>();        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; n == <span class="hljs-number">1</span>)&#123;                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span>(flowerbed[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)&#123;            flowerbed[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;            flowerCount += <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span>(flowerbed[m<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[m<span class="hljs-number">-2</span>] == <span class="hljs-number">0</span>)&#123;            flowerbed[m<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;            flowerCount += <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">1</span>;i&lt;m<span class="hljs-number">-1</span>;i++)&#123;            <span class="hljs-keyword">if</span>(flowerbed[i] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i<span class="hljs-number">-1</span>] == <span class="hljs-number">0</span> &amp;&amp; flowerbed[i<span class="hljs-number">+1</span>] == <span class="hljs-number">0</span>)&#123;                flowerbed[i] = <span class="hljs-number">1</span>;                flowerCount += <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> flowerCount &gt;= n;    &#125;&#125;;</code></pre></div><p>分析：遍历即可，尤其注意开头部分和结尾部分。</p><p><strong>错误：最后没有考虑等于条件也为 <code>true</code></strong></p><p>建议：判断太多，有更为简洁的解法，大致思路是计算相邻的 <code>1</code>之间能种多少个 <code>0</code>。</p><h3 id="Leetcode-452">Leetcode 452</h3><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，不知道具体位置，但是知道一个位置的范围。一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，射进了气球的位置范围后，该气球就会被引爆。可以射出的弓箭的数量<strong>没有限制</strong>。 弓箭一旦被射出之后，可以无限地前进。给你一个数组 <code>points</code> ， 返回引爆所有气球所必须射出的<strong>最小</strong>弓箭数 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];    &#125;    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(),points.<span class="hljs-built_in">end</span>(),cmp);        <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();        <span class="hljs-type">int</span> arrowCount = <span class="hljs-number">1</span>;        <span class="hljs-type">int</span> endPoint = points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;            <span class="hljs-keyword">if</span>(points[i][<span class="hljs-number">0</span>] &gt; endPoint)&#123;                ++arrowCount;                endPoint = points[i][<span class="hljs-number">1</span>];            &#125;        &#125;        <span class="hljs-keyword">return</span> arrowCount;    &#125;&#125;;</code></pre></div><p>分析：拿第一个气球来说，要是想射爆，最佳的方法就是射最右侧的位置，这样能射到的其他的气球数量也会增加，以此类推，构成贪心算法。</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-763">Leetcode 763</h3><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">last</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">-1</span>)</span></span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span>;i--)&#123;            <span class="hljs-keyword">if</span>(last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">-1</span>)&#123;                last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;            &#125;        &#125;        vector&lt;<span class="hljs-type">int</span>&gt; result;        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;        <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;            end = <span class="hljs-built_in">max</span>(end,last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);            <span class="hljs-keyword">if</span>(i == end)&#123;                result.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);                start = i + <span class="hljs-number">1</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：首先得到字符出现的最后的下标位置，然后重新遍历字符串，得到每个字符最后出现的位置。一旦前面的所有字符都出现完了，就算一个区间。</p><p>上述做法使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p><p><strong>错误：思路有问题，没有做对</strong></p><h3 id="Leetcode-122">Leetcode 122</h3><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候<strong>最多</strong>只能持有<strong>一股</strong>股票。你也可以先购买，然后在<strong>同一天</strong>出售。返回你能获得的<strong>最大</strong>利润 。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;        <span class="hljs-type">int</span> stockSum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;            <span class="hljs-keyword">if</span>(prices[i<span class="hljs-number">+1</span>] &gt; prices[i])&#123;                stockSum = stockSum+prices[i<span class="hljs-number">+1</span>]-prices[i];            &#125;        &#125;        <span class="hljs-keyword">return</span> stockSum;    &#125;&#125;;</code></pre></div><p>分析：什么都不限制，涨了就卖就完事了，比较简单。贪心策略就是只要价格上涨就直接出售。</p><p><strong>一遍AC</strong></p><h3 id="Leetcode-406">Leetcode 406</h3><p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面<strong>正好</strong>有 <code>ki</code>个身高大于或等于 <code>hi</code> 的人。</p><p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a,vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>])&#123;            <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];        &#125;        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>];    &#125;    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(people.<span class="hljs-built_in">size</span>());        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(),people.<span class="hljs-built_in">end</span>(),cmp);        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i=<span class="hljs-number">0</span>;i&lt;people.<span class="hljs-built_in">size</span>();++i)&#123;            <span class="hljs-type">int</span> pos = people[i][<span class="hljs-number">1</span>];            <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> j=<span class="hljs-number">0</span>;j&lt;result.<span class="hljs-built_in">size</span>();j++)&#123;                <span class="hljs-keyword">if</span>(result[j].<span class="hljs-built_in">empty</span>())&#123;                    pos--;                &#125;                <span class="hljs-keyword">if</span>(pos == <span class="hljs-number">-1</span>)&#123;                    result[j] = people[i];                    <span class="hljs-keyword">break</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;&#125;;</code></pre></div><p>分析：将人员从低往高先排列，然后一个个进行插入。插入的人只会对后面的人有影响，因为后面的人的身高都会大于等于他。而对已经插入的人没有影响。因此插入的时候给后面的人要留出空位置，以便后面的人插入进去。如果身高相同，就去比较 <code>ki</code>。 <code>ki</code>更小一点的，说明这个人在靠前一点，也就是最小的 <code>ki</code>前面是不会有相同身高的人的，由于相同身高也会算在内，因此要先插入大 <code>ki</code>。</p><p><strong>错误：思路有问题，没有做对</strong></p><h3 id="Leetcode-665">Leetcode 665</h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，请你判断在最多改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkPossibility</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;            <span class="hljs-keyword">if</span> (nums[i] &lt; nums[i - <span class="hljs-number">1</span>]) &#123;                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> || nums[i] &gt;= nums[i - <span class="hljs-number">2</span>])&#123;                    nums[i - <span class="hljs-number">1</span>] = nums[i];                &#125;                <span class="hljs-keyword">else</span>&#123;                    nums[i] = nums[i - <span class="hljs-number">1</span>];                &#125;                ++count;            &#125;        &#125;        <span class="hljs-keyword">return</span> count &lt;= <span class="hljs-number">1</span>;    &#125;&#125;;</code></pre></div><p>分析：要多种情况一起考虑。。。。</p><p><strong>错误：思路有问题，没有做对。另外不要去改 <code>i+1</code>啊。。判断什么修改什么好吧，要不就乱套了。</strong></p><h2 id="总结">总结</h2><p>贪心算法确实是比较好理解的，但是怎么贪心？什么时候贪心？这些问题都要去详细认真的思考，真正出题的时候不会如此直白，要多练多想。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C++</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈-20220826</title>
    <link href="/2022/08/26/diary/diary20220826/"/>
    <url>/2022/08/26/diary/diary20220826/</url>
    
    <content type="html"><![CDATA[<p>开学第一周，或者算是第二周，开学但是没有任何课程，也没有什么活动，开了一次班会，然后一个学院的开学典礼。新认识的人呢，也就一个室友+之前室友的同学，也就寥寥几人，同一个套间住着的人几乎都不认识。这几天就一直有些不太舒服，写些文字简单发泄一下。</p><p>总的来说，这里确实是一群学霸。首先可以拿我室友来说，早上7点起床，晚上11点左右睡觉，几乎每时每刻都在看论文做实验，甚至在看比赛的过程中间也会去看论文。他的目标就是要发文章，发一篇顶会文章，因此现在在努力完成这个目标。之后的方向他还没有想好，可能出国或者找音频算法相关的工作。其次是图书馆的同学们，才开学没有几天，图书馆就已经爆满了。大家都是思维缜密且有计划的人，昨天一窝蜂去抢机房，抢各种台式电脑去选课，选过课后去找相关的书籍，这在之前都是我的标准操作，在这里却被其他人不断模仿甚至比我做的更好。我有一种压力感，同时也有一种恐惧。</p><p>我的内心真的很脆弱。感觉其他人都还很适应的，我表面上也是这样，但是内心里已经稍稍有点崩溃了。我不禁回想我本科阶段，如果我高考真的考的好了，去了一些顶级985的学校，那么我是会坚持住学下去拼下去，还是会基本上崩溃掉，完全没有任何的竞争实力了呢？或许去了中南大学，并不是考的不好，而是帮我减轻了同龄人的压力。现在研究生的阶段，我是真真正正感受到了同龄人的压力。这么多优秀的人当中，我又能排到一个什么水平？如果真的在各个方面都比不上别人，我会不会崩溃呢？这些都是我现在所担心的。</p><p>其实换个角度来想，我没有必要去和任何人去比较。大家的人生道路都是不一样的，也无所谓好与不好，只是适不适合，以及过的是否开心罢了。对于我现在来说，虽然我知道不要去和其他人比较，总有人比你更强，比你过的更好。但是我还是时不时会看看想想别人现在在做什么，看看别人取得的成就，想想自己有没有可能赶得上甚至超过。这样就造成了现在每一天都非常不开心，学习也没有什么动力，学到后面甚至有一点混时间的感觉。这种想法困扰了我很长的一段时间，目前仍然在困扰着我。</p><p>我现在能做的，就是找准自己的目标，制定好计划，坚定不移地实施下去。至于我脆弱的内心，慢慢调解吧。没有人能帮助我，最后能靠得住的只有我自己。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer - 第二部分 C++标准库</title>
    <link href="/2022/08/21/c-plus-stl/"/>
    <url>/2022/08/21/c-plus-stl/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer - 第二部分 C++标准库</p><span id="more"></span><h1>第8章 IO库</h1><h2 id="IO类">IO类</h2><p><code>iostream</code>定义了用于读写流的基本类型</p><p><code>fstream</code>定义了读写命名文件的类型</p><p><code>sstream</code>定义了读写内存 <code>string</code>对象的类型</p><p>用法都是完全相同的，得益于继承机制</p><p>流的状态：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> old_state = cin.<span class="hljs-built_in">rdstate</span>(); <span class="hljs-comment">// 获取流的当前状态</span>cin.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 将所有条件状态复位，将流的状态置为有效</span>cin.<span class="hljs-built_in">setstate</span>(old_state); <span class="hljs-comment">// 根据给定的标志位对流进行复位</span></code></pre></div><p>输出缓冲：每个输出流都管理一个缓冲区，保存程序读写的数据。</p><p>控制输出缓冲：</p><div class="code-wrapper"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;hi!&quot;</span> &lt;&lt; endl; <span class="hljs-comment">// 多输出一个换行符，然后刷新缓冲区</span>cout &lt;&lt; <span class="hljs-string">&quot;hi!&quot;</span> &lt;&lt; flush; <span class="hljs-comment">// 输出后直接刷新缓冲区</span>cout &lt;&lt; <span class="hljs-string">&quot;hi!&quot;</span> &lt;&lt; ends; <span class="hljs-comment">// 多输出一个空字符，然后刷新缓冲区</span>cout &lt;&lt; unitbuf; <span class="hljs-comment">// 所有输出操作后都立即刷新缓冲区</span>cout &lt;&lt; nounitbuf; <span class="hljs-comment">// 回到正常的缓冲方式</span></code></pre></div><p>关联输入和输出流：如果某一个输入流和输出流关联，则从输入流读取的操作会对这个输出流进行刷新。</p><p>标准库将 <code>cout</code>和 <code>cin</code>关联在一起</p><div class="code-wrapper"><pre><code class="hljs cpp">cin.<span class="hljs-built_in">tie</span>(&amp;cerr); <span class="hljs-comment">// 将cin和cerr关联在一起</span></code></pre></div><h2 id="文件输入输出">文件输入输出</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;infile&quot;</span>)</span></span>;<span class="hljs-function">ofstream <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-string">&quot;outfile&quot;</span>)</span></span>;string s;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(in,s))&#123;    output &lt;&lt; s &lt;&lt; endl;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><p>显式打开或者关闭文件流：</p><div class="code-wrapper"><pre><code class="hljs cpp">ofstream output; <span class="hljs-comment">// 空文件流对象</span>output.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;outfile&quot;</span>); <span class="hljs-comment">// 调用open进行关联</span>output.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭文件流</span></code></pre></div><p>文件模式：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ofstream <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-string">&quot;outfile&quot;</span>)</span></span>;</code></pre></div><p>这种方式其实隐含了以输出模式打开文件并进行截断，显式控制如下：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ofstream <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-string">&quot;outfile&quot;</span>,ofstream::out | ofstream::trunc)</span></span>;</code></pre></div><p>为了保留之前的文件内容，需要显式指定 <code>app</code>模式</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ofstream <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-string">&quot;outfile&quot;</span>,ofstream::out | ofstream::app)</span></span>;</code></pre></div><h2 id="string流">string流</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ifstream <span class="hljs-title">in</span><span class="hljs-params">(<span class="hljs-string">&quot;infile&quot;</span>)</span></span>;<span class="hljs-function">ofstream <span class="hljs-title">output</span><span class="hljs-params">(<span class="hljs-string">&quot;outfile&quot;</span>,ofstream::out | ofstream::app)</span></span>;string s;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(in,s))&#123;    string a,b,c;    <span class="hljs-function">istringstream <span class="hljs-title">s1</span><span class="hljs-params">(s)</span></span>;    ostringstream s2;    s1 &gt;&gt; a;    s2 &lt;&lt; a;    s1 &gt;&gt; b;    s2 &lt;&lt; b;    s1 &gt;&gt; c;    s2 &lt;&lt; c;    cout &lt;&lt; s<span class="hljs-number">2.</span><span class="hljs-built_in">str</span>() &lt;&lt; endl;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><h1>第9章 顺序容器</h1><p>一个容器就是一些特定类型对象的集合，顺序容器为程序员提供了控制元素存储和访问顺序的能力。</p><h2 id="顺序容器种类">顺序容器种类</h2><p><code>vector</code>是可变大小数组，支持快速随机访问。但是在尾部之外的位置插入或者删除元素可能很慢。</p><p><code>deque</code>是双端队列，支持快速随机访问，在头尾部插入或者删除元素的速度很快。</p><p><code>list</code>是双向链表，只支持双向顺序访问，在 <code>list</code>中任意位置进行插入/删除的速度都很快</p><p><code>forward_list</code>是单向链表，只支持单向顺序访问，在链表中任意位置进行插入/删除的速度都很快</p><p><code>array</code>是固定大小的数组，支持快速随机访问，不能添加或者删除元素</p><p><code>string</code>是与 <code>vector</code>相似的容器，专门用于保存字符，随机访问快，在尾部插入/删除的速度很快</p><p>顺序容器几乎可以保存任意类型的元素</p><p>各种迭代器：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it1 = a.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// list&lt;string&gt;::iterator</span><span class="hljs-keyword">auto</span> it2 = a.<span class="hljs-built_in">rbegin</span>(); <span class="hljs-comment">// list&lt;string&gt;::reverse_iterator</span><span class="hljs-keyword">auto</span> it3 = a.<span class="hljs-built_in">cbegin</span>(); <span class="hljs-comment">// list&lt;string&gt;::const_iterator</span><span class="hljs-keyword">auto</span> it4 = a.<span class="hljs-built_in">crbegin</span>(); <span class="hljs-comment">// list&lt;string&gt;::const_reverse_iterator</span></code></pre></div><p>元素的拷贝初始化：</p><div class="code-wrapper"><pre><code class="hljs cpp">list&lt;string&gt; a = &#123;<span class="hljs-string">&quot;Milton&quot;</span>,<span class="hljs-string">&quot;SHakespeare&quot;</span>,<span class="hljs-string">&quot;Austen&quot;</span>&#125;;<span class="hljs-function">list&lt;string&gt; <span class="hljs-title">a2</span><span class="hljs-params">(a)</span></span>;</code></pre></div><p>array具有固定的大小，并且可以进行拷贝</p><div class="code-wrapper"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>,10&gt; ia1 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;array&lt;<span class="hljs-type">int</span>,10&gt; ia2 = ia1;</code></pre></div><p>使用 <code>assign</code>对不同但相容的类型进行赋值</p><div class="code-wrapper"><pre><code class="hljs cpp">list&lt;string&gt; names;vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; oldstyle;names.<span class="hljs-built_in">assign</span>(oldstyle.<span class="hljs-built_in">cbegin</span>(),oldstyle.<span class="hljs-built_in">cend</span>());</code></pre></div><p>添加元素三种方法：<code>push_front()</code>，<code>insert()</code>，<code>push_back()</code></p><p>新标准对应了三种直接构造元素的方法：<code>emplace_front()</code>、<code>emplace()</code>、<code>emplace_back()</code></p><p>更安全的访问元素的方法：<code>svec.at(0)</code></p><p>改变容器大小并使用某个元素填充更大的部分：<code>ilist.resize(15,-1)</code></p><p>管理容量的成员函数：</p><div class="code-wrapper"><pre><code class="hljs cpp">c.<span class="hljs-built_in">capacity</span>(); <span class="hljs-comment">// 不重新分配内存空间的话最多能保存多少元素</span>c.<span class="hljs-built_in">reserve</span>(n); <span class="hljs-comment">// 分配至少能容纳n个元素的内存空间</span>c.<span class="hljs-built_in">shrink_to_fit</span>() <span class="hljs-comment">// 请求将capacity()减小为size()一样的大小</span></code></pre></div><p>数值转换：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;string s = <span class="hljs-built_in">to_string</span>(i);<span class="hljs-type">double</span> d = <span class="hljs-built_in">stod</span>(s);cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">42 </span><span class="hljs-number">42</span></code></pre></div><h1>第10章 泛型算法</h1><p>对于容器的其他操作，并没有通过定义成员函数的方式实现，而是定义一套泛型算法，实现了一些算法的公共接口。</p><p>在容器中对值进行查找使用 <code>find</code>，返回查找元素的指针的位置</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">find</span>(vec.<span class="hljs-built_in">cbegin</span>(),vec.<span class="hljs-built_in">cend</span>(),val)</code></pre></div><p>返回元素在容器中出现的次数：</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a;<span class="hljs-type">int</span> temp;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;    cin &gt;&gt; temp;    a.<span class="hljs-built_in">push_back</span>(temp);&#125;cin &gt;&gt; temp;<span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">count</span>(a.<span class="hljs-built_in">cbegin</span>(),a.<span class="hljs-built_in">cend</span>(),temp);cout &lt;&lt; result &lt;&lt; endl;</code></pre></div><p>泛型算法本身不会执行容器的操作，只会运行于迭代器之上，执行迭代器的操作。</p><p>因此泛型算法永远不会改变底层容器的大小。</p><h2 id="各种泛型算法">各种泛型算法</h2><p>元素求和：</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">cbegin</span>(),a.<span class="hljs-built_in">cend</span>(),<span class="hljs-number">0</span>);cout &lt;&lt; sum &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">36</code></pre></div><p>可以推广到字符串中用来连接字符串：</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;vector&lt;string&gt; b&#123;<span class="hljs-string">&quot;df&quot;</span>,<span class="hljs-string">&quot;fsfds&quot;</span>,<span class="hljs-string">&quot;rte&quot;</span>&#125;;string sum = <span class="hljs-built_in">accumulate</span>(b.<span class="hljs-built_in">cbegin</span>(),b.<span class="hljs-built_in">cend</span>(),<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;&quot;</span>));cout &lt;&lt; sum &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">dffsfdsrte</span></code></pre></div><p>确定两个序列中保存的值是否相同（假定第二个序列至少与第一个序列一样长）</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;vector&lt;string&gt; b&#123;<span class="hljs-string">&quot;df&quot;</span>,<span class="hljs-string">&quot;fsfds&quot;</span>,<span class="hljs-string">&quot;rte&quot;</span>&#125;;vector&lt;string&gt; c&#123;<span class="hljs-string">&quot;df&quot;</span>,<span class="hljs-string">&quot;fsfds&quot;</span>,<span class="hljs-string">&quot;rte&quot;</span>,<span class="hljs-string">&quot;fdsf&quot;</span>&#125;;<span class="hljs-keyword">auto</span> sum = <span class="hljs-built_in">equal</span>(b.<span class="hljs-built_in">cbegin</span>(),b.<span class="hljs-built_in">cend</span>(),c.<span class="hljs-built_in">cbegin</span>());cout &lt;&lt; sum &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">1</code></pre></div><p>使用 <code>fill</code>和 <code>fill_n</code>填充元素：</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<span class="hljs-built_in">fill</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : a)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-built_in">fill_n</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">size</span>(),<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : a)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre></div><p>算法是不会检查写操作的，泛型算法也不能更改容器的大小。因此需要自行检查容器是否越界等问题。</p><p>安全的方式：插入迭代器</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; a&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;vector&lt;string&gt; b&#123;<span class="hljs-string">&quot;df&quot;</span>,<span class="hljs-string">&quot;fsfds&quot;</span>,<span class="hljs-string">&quot;rte&quot;</span>&#125;;vector&lt;string&gt; c&#123;<span class="hljs-string">&quot;df&quot;</span>,<span class="hljs-string">&quot;fsfds&quot;</span>,<span class="hljs-string">&quot;rte&quot;</span>,<span class="hljs-string">&quot;fdsf&quot;</span>&#125;;<span class="hljs-built_in">fill_n</span>(<span class="hljs-built_in">back_inserter</span>(a),<span class="hljs-number">10</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : a)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre></div><p>将 <code>a1</code>的内容拷贝到 <code>a2</code>：<code>copy(begin(a1),end(a1),a2)</code></p><p>对元素进行排序去重：</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;string&gt; d&#123;<span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;quick&quot;</span>,<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;fox&quot;</span>,<span class="hljs-string">&quot;jumps&quot;</span>,<span class="hljs-string">&quot;over&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;slow&quot;</span>,<span class="hljs-string">&quot;red&quot;</span>,<span class="hljs-string">&quot;turtle&quot;</span>&#125;;<span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(),d.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 排序</span><span class="hljs-keyword">auto</span> end_unique = <span class="hljs-built_in">unique</span>(d.<span class="hljs-built_in">begin</span>(),d.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将重复的移到末尾，并同时返回最后一个不重复的元素的后一位置</span>d.<span class="hljs-built_in">erase</span>(end_unique,d.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 使用容器操作删除重复的元素（因为泛型算法无法改变容器大小）</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : d)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vim">fox <span class="hljs-keyword">jumps</span> over quick <span class="hljs-keyword">red</span> slow the turtle</code></pre></div><p><code>lambda</code>表达式：</p><p>一个 <code>lambda</code>表达式表示一个可调用的代码单元，可以理解为一个未命名的内联函数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> f = []&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;&#125;;cout &lt;&lt; <span class="hljs-built_in">f</span>() &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">42</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>;<span class="hljs-keyword">auto</span> f6 = [&amp;a, &amp;b]&#123; <span class="hljs-keyword">return</span> a + b; &#125;;cout &lt;&lt; <span class="hljs-built_in">f6</span>() &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">1</code></pre></div><p>lambda表达式还有其他的一些用法。</p><h2 id="其他迭代器">其他迭代器</h2><p>插入迭代器：</p><p><code>back_inserter</code>：创建一个使用 <code>push_back</code>的迭代器</p><p><code>front_inserter</code>：创建一个使用 <code>push_front</code>的迭代器</p><p><code>inserter</code>：创建一个使用 <code>insert</code>的迭代器</p><div class="code-wrapper"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; lst = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;list&lt;<span class="hljs-type">int</span>&gt; lst2 = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;list&lt;<span class="hljs-type">int</span>&gt; lst3 = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>&#125;;list&lt;<span class="hljs-type">int</span>&gt; lst4 = &#123;<span class="hljs-number">12</span>&#125;;<span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">cbegin</span>(),lst.<span class="hljs-built_in">cend</span>(),<span class="hljs-built_in">front_inserter</span>(lst2));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : lst2)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">cbegin</span>(),lst.<span class="hljs-built_in">cend</span>(),<span class="hljs-built_in">inserter</span>(lst3,lst<span class="hljs-number">3.</span><span class="hljs-built_in">begin</span>()));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : lst3)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-built_in">copy</span>(lst.<span class="hljs-built_in">cbegin</span>(),lst.<span class="hljs-built_in">cend</span>(),<span class="hljs-built_in">back_inserter</span>(lst4));<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : lst4)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-symbol">12 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span></code></pre></div><p>流迭代器：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">istream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in</span><span class="hljs-params">(cin)</span>,eof</span>;cout &lt;&lt; <span class="hljs-built_in">accumulate</span>(in,eof,<span class="hljs-number">0</span>) &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs tap">&gt;<span class="hljs-number"> 2 </span>1<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>942</code></pre></div><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ostream_iterator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">out</span><span class="hljs-params">(cout,<span class="hljs-string">&quot; &quot;</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;    out = i;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre></div><p>反向迭代器：</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vi&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i = vi.<span class="hljs-built_in">crbegin</span>();i != vi.<span class="hljs-built_in">crend</span>();i++)&#123;    cout &lt;&lt; *i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span></code></pre></div><p>要注意反向迭代器真的是反的。。。比如下面的例子：</p><div class="code-wrapper"><pre><code class="hljs cpp">string line = <span class="hljs-string">&quot;first,middle,end&quot;</span>;<span class="hljs-keyword">auto</span> rcomma = <span class="hljs-built_in">find</span>(line.<span class="hljs-built_in">crbegin</span>(),line.<span class="hljs-built_in">crend</span>(),<span class="hljs-string">&#x27;,&#x27;</span>);cout &lt;&lt; <span class="hljs-built_in">string</span>(line.<span class="hljs-built_in">crbegin</span>(),rcomma) &lt;&lt; endl;cout &lt;&lt; <span class="hljs-built_in">string</span>(rcomma.<span class="hljs-built_in">base</span>(),line.<span class="hljs-built_in">cend</span>()) &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ada">dne<span class="hljs-keyword">end</span></code></pre></div><h1>第11章 关联容器</h1><p>关联容器中的元素是按关键字来保存和访问的，而顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p><p><code>map</code>是关键字-值对的结合</p><div class="code-wrapper"><pre><code class="hljs cpp">map&lt;string,<span class="hljs-type">size_t</span>&gt; word_count;string word;<span class="hljs-keyword">while</span>(cin &gt;&gt; word)&#123;    ++word_count[word];&#125;<span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;w : word_count)&#123;    cout &lt;&lt; w.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; w.second &lt;&lt; endl;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css">&gt; <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c d e d <span class="hljs-selector-tag">b</span> c<span class="hljs-selector-tag">a</span> <span class="hljs-number">1</span><span class="hljs-selector-tag">b</span> <span class="hljs-number">2</span>c <span class="hljs-number">2</span>d <span class="hljs-number">2</span>e <span class="hljs-number">1</span></code></pre></div><p>关联容器的元素都是根据关键字存储的，因此不支持位置相关的操作。</p><p><code>multimap</code>和 <code>multiset</code>允许相同关键字：</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vi&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">iset</span><span class="hljs-params">(vi.cbegin(),vi.cend())</span></span>;<span class="hljs-function">multiset&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">miset</span><span class="hljs-params">(vi.cbegin(),vi.cend())</span></span>;cout &lt;&lt; iset.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; miset.<span class="hljs-built_in">size</span>() &lt;&lt; endl;</code></pre></div><p>关联容器的迭代器：</p><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vi&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<span class="hljs-function">set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">iset</span><span class="hljs-params">(vi.cbegin(),vi.cend())</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> set_it = iset.<span class="hljs-built_in">cbegin</span>();set_it != iset.<span class="hljs-built_in">cend</span>();set_it++)&#123;    cout &lt;&lt; *set_it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span></code></pre></div><p>插入元素：</p><div class="code-wrapper"><pre><code class="hljs cpp">iset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">8</span>);</code></pre></div><p>查找元素的下标操作：</p><div class="code-wrapper"><pre><code class="hljs cpp">c[k]; <span class="hljs-comment">// 如果没有会添加，并对值进行初始化</span>c.<span class="hljs-built_in">at</span>(k); <span class="hljs-comment">// 如果没有会抛出异常</span></code></pre></div><p>访问元素：<code>find</code>和 <code>count</code></p><p>在 <code>multimap</code>中查找元素：</p><div class="code-wrapper"><pre><code class="hljs cpp">multimap&lt;string,<span class="hljs-type">int</span>&gt; mi&#123;<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;as&quot;</span>,<span class="hljs-number">1</span>),<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;as&quot;</span>,<span class="hljs-number">2</span>),<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-number">2</span>),<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;ac&quot;</span>,<span class="hljs-number">2</span>),<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;ac&quot;</span>,<span class="hljs-number">5</span>)&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> pos = mi.<span class="hljs-built_in">equal_range</span>(<span class="hljs-string">&quot;as&quot;</span>);pos.first != pos.second;++pos.first)&#123;    cout &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><p>根据转换规则对文件内容进行转换：</p><p>转换规则：</p><div class="code-wrapper"><pre><code class="hljs css">brb be <span class="hljs-attribute">right</span> backk okay?<span class="hljs-attribute">y</span> why<span class="hljs-attribute">r</span> areu youpic <span class="hljs-selector-tag">picture</span>thk thanks!l8r later</code></pre></div><p>文件内容：</p><div class="code-wrapper"><pre><code class="hljs css">where <span class="hljs-attribute">r</span> u<span class="hljs-attribute">y</span> dont u send me <span class="hljs-selector-tag">a</span> pic k thk l8r</code></pre></div><p>转换代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 实际的转换工作，生成转换文本</span><span class="hljs-function"><span class="hljs-type">const</span> string &amp; <span class="hljs-title">transform</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s, <span class="hljs-type">const</span> map&lt;string,string&gt; &amp;m)</span></span>&#123;    <span class="hljs-keyword">auto</span> map_it = m.<span class="hljs-built_in">find</span>(s);    <span class="hljs-keyword">if</span> (map_it != m.<span class="hljs-built_in">cend</span>())&#123;        <span class="hljs-keyword">return</span> map_it-&gt;second;    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> s;    &#125;&#125;<span class="hljs-comment">// 读入给定文件，建立转换映射</span><span class="hljs-function">map&lt;string,string&gt; <span class="hljs-title">buildMap</span><span class="hljs-params">(ifstream &amp;map_file)</span></span>&#123;    map&lt;string,string&gt; trans_map;    string key,value;    <span class="hljs-comment">// 读取第一个单词存入key，剩余内容存入value</span>    <span class="hljs-keyword">while</span>(map_file &gt;&gt; key &amp;&amp; <span class="hljs-built_in">getline</span>(map_file,value))&#123;        <span class="hljs-keyword">if</span>(value.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>)&#123;            trans_map[key] = value.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;No rule for &quot;</span> + key);        &#125;    &#125;    <span class="hljs-keyword">return</span> trans_map;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-function">ifstream <span class="hljs-title">map_file</span><span class="hljs-params">(<span class="hljs-string">&quot;rules&quot;</span>)</span></span>;    <span class="hljs-function">ifstream <span class="hljs-title">input</span><span class="hljs-params">(<span class="hljs-string">&quot;text&quot;</span>)</span></span>;    <span class="hljs-keyword">auto</span> trans_map = <span class="hljs-built_in">buildMap</span>(map_file); <span class="hljs-comment">// 保存转换规则</span>    string text; <span class="hljs-comment">// 保存输入中的每一行</span>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(input,text))&#123;        <span class="hljs-function">istringstream <span class="hljs-title">stream</span><span class="hljs-params">(text)</span></span>; <span class="hljs-comment">// 读取每个单词</span>        string word;        <span class="hljs-type">bool</span> firstword = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 控制是否打印空格</span>        <span class="hljs-keyword">while</span>(stream &gt;&gt; word)&#123;            <span class="hljs-keyword">if</span>(firstword)&#123;                firstword = <span class="hljs-literal">false</span>;            &#125;            <span class="hljs-keyword">else</span>&#123;                cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;            &#125;            cout &lt;&lt; <span class="hljs-built_in">transform</span>(word,trans_map);        &#125;        cout &lt;&lt; endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>输出：</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-keyword">where</span> are youwhy dont you send <span class="hljs-keyword">me</span> a pictureokay? thanks! later</code></pre></div><p>无序容器：不适用比较运算符来组织元素，而是使用哈希函数组织元素。</p><p>一般情况下的性能要比有序容器更好，但是不能按照顺序输出。</p><h1>第12章 动态内存</h1><h2 id="动态内存与智能指针">动态内存与智能指针</h2><p>前面都是静态对象，由程序自动分配内存并销毁。而动态对象需要被显式进行释放。</p><p>动态内存需要显式进行分配和释放，因此很容易忘记释放导致一些问题。因此定义了两种智能指针来管理这些动态对象，自动进行释放。</p><div class="code-wrapper"><pre><code class="hljs cpp">shared_ptr&lt;string&gt; p1; <span class="hljs-comment">// 指向string的shared_ptr</span>shared_ptr&lt;list&lt;<span class="hljs-type">int</span>&gt;&gt; p2; <span class="hljs-comment">// 指向int的list的shared_ptr</span></code></pre></div><p>默认初始化的智能指针中保存着一个空指针。</p><p>最安全的分配和使用动态内存的方式是调用 <code>make_shared</code>的标准库函数。</p><div class="code-wrapper"><pre><code class="hljs cpp">shared_ptr&lt;<span class="hljs-type">int</span>&gt; p3 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);shared_ptr&lt;string&gt; p4 = <span class="hljs-built_in">make_shared</span>&lt;string&gt;(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;9&#x27;</span>);shared_ptr&lt;<span class="hljs-type">int</span>&gt; p5 = <span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;();</code></pre></div><p><code>shared_ptr</code>会自动记录有多少个其他 <code>shared_ptr</code>指向相同的对象，如果没有了，会自动销毁所管理的对象并自动释放相关联的内存。</p><p>离开作用域也会被销毁。如果返回这个指针，也不会被销毁（就是挺智能的）</p><p>直接管理内存：使用 <code>new</code>和 <code>delete</code></p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;string *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;9&#x27;</span>);<span class="hljs-type">const</span> string *pcs = <span class="hljs-keyword">new</span> <span class="hljs-type">const</span> string;<span class="hljs-keyword">delete</span> pi;<span class="hljs-keyword">delete</span> ps;<span class="hljs-keyword">delete</span> pcs;</code></pre></div><p><code>delete</code>不会抛出任何异常，尽管可能已经释放过了，甚至有可能都不是指针也会释放，会造成一些问题。</p><p><code>delete</code>还可能会造成空悬指针，因此这个 <code>delete</code>只提供了有限的保护。</p><p>不要混用智能指针和普通指针，不要使用 <code>get</code>初始化另一个智能指针或者赋值。</p><p><code>unique_ptr</code>“拥有”它所指向的对象，某个时刻只能由一个 <code>unique_ptr</code>指向一个给定对象。销毁指针就一起销毁了。</p><p><code>weak_ptr</code>指向一个 <code>shared_ptr</code>管理的对象，不会改变 <code>shared_ptr</code>的计数，计数为 <code>0</code>后会自动释放。</p><h2 id="动态数组">动态数组</h2><p>使用 <code>new</code>分配一个 <code>int</code>数组：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">42</span>];</code></pre></div><p>实际上并没有得到一个数组类型的对象，而是得到一个数据元素类型的指针。</p><p>动态分配并初始化数组：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *pia3 = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;</code></pre></div><p>动态分配的数组的大小可以为0，会返回一个类似于尾后迭代器的指针。</p><p>释放动态数组：<code>delete [] p</code></p><p>智能指针管理动态数组：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>])</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;i != <span class="hljs-number">10</span>;++i)&#123;    up[i] = i;&#125;up.<span class="hljs-built_in">release</span>();</code></pre></div><p><code>allocator</code>将内存分配和对象构造分离开来，提供一种类型感知的内存分配方法。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;allocator&lt;string&gt; alloc;<span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> p = alloc.<span class="hljs-built_in">allocate</span>(n);</code></pre></div><p>这个 <code>allocator</code>为5个 <code>string</code>分配了内存</p><p>在内存中构造对象：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> q = p;alloc.<span class="hljs-built_in">construct</span>(q++,<span class="hljs-string">&quot;hi&quot;</span>);cout &lt;&lt; *p &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hi</span></code></pre></div><h2 id="案例：文本查询程序">案例：文本查询程序</h2><p>在一个给定文件中查询单词，最终返回单词在文件中出现的次数及其所在行的列表。</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer - 第一部分 C++基础</title>
    <link href="/2022/08/09/c-plus-basic/"/>
    <url>/2022/08/09/c-plus-basic/</url>
    
    <content type="html"><![CDATA[<p>C++ Primer 阅读笔记 - 第一部分 C++基础</p><span id="more"></span><h1>开始学习</h1><p>大一学过C语言，当时学的不是很好，但是后面接触到算法竞赛的时候就慢慢补上来了，而且增加了一些C++特性以及STL标准模板库，也靠着半吊子C++拿了一些小奖，但是确实没有系统的学过C++。总之听说C++比较难，这次准备半系统性的学习一下。之前会的东西就做做题简单过一下，不会的重点看，尤其是指针和面向对象方面。希望以后能更加得心应手地使用C++，也为后面求职打打基础。</p><h1>第1章 开始</h1><h2 id="注释">注释</h2><div class="code-wrapper"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;/*&quot;</span>;std::cout &lt;&lt; <span class="hljs-string">&quot;*/&quot;</span>;std::cout &lt;&lt; <span class="hljs-comment">/*  &quot;*/</span><span class="hljs-string">&quot; *.;</span><span class="hljs-string">std::cout &lt;&lt; /* &quot;</span>*/<span class="hljs-string">&quot; /* &quot;</span><span class="hljs-comment">/*&quot; */</span>;</code></pre></div><p>前两行没问题，注释只有一边，编译运行顺利通过</p><p>第三行注释全，但是字符串不全，缺少右边的&quot;，编译运行不能通过</p><p>第四行两边分别有两组注释，且中间的字符串是全的，因此编译运行顺利通过</p><h2 id="读取数量不定的输入">读取数量不定的输入</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>,value = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(std::cin &gt;&gt; value)&#123;    sum += value;&#125;std::cout &lt;&lt; sum &lt;&lt; std::endl;</code></pre></div><p>读取数量不定的整数，将其加和。</p><p><code>std::cin</code>属于一种 <code>istream</code>对象，将其作为条件时是检测流的状态，遇到文件结束符或者无效输入时会变为无效，从而退出循环。</p><p>在Ubuntu中输入 <code>Ctrl+D</code>来输入一个文件结束符。</p><h2 id="类简介">类简介</h2><p>定义好的头文件：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SALESITEM_H</span><span class="hljs-comment">// we&#x27;re here only if SALESITEM_H has not yet been defined </span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SALESITEM_H</span><span class="hljs-comment">// Definition of Sales_item class and related functions goes here</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_item</span> &#123;<span class="hljs-comment">// these declarations are explained section 7.2.1, p. 270 </span><span class="hljs-comment">// and in chapter 14, pages 557, 558, 561</span><span class="hljs-keyword">friend</span> std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp;, Sales_item&amp;);<span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp;, <span class="hljs-type">const</span> Sales_item&amp;);<span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Sales_item&amp;, <span class="hljs-type">const</span> Sales_item&amp;);<span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Sales_item&amp;, <span class="hljs-type">const</span> Sales_item&amp;);<span class="hljs-keyword">public</span>:    <span class="hljs-comment">// constructors are explained in section 7.1.4, pages 262 - 265</span>    <span class="hljs-comment">// default constructor needed to initialize members of built-in type</span>    <span class="hljs-built_in">Sales_item</span>() = <span class="hljs-keyword">default</span>;    <span class="hljs-built_in">Sales_item</span>(<span class="hljs-type">const</span> std::string &amp;book): <span class="hljs-built_in">bookNo</span>(book) &#123; &#125;    <span class="hljs-built_in">Sales_item</span>(std::istream &amp;is) &#123; is &gt;&gt; *<span class="hljs-keyword">this</span>; &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">// operations on Sales_item objects</span>    <span class="hljs-comment">// member binary operator: left-hand operand bound to implicit this pointer</span>    Sales_item&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Sales_item&amp;);      <span class="hljs-comment">// operations on Sales_item objects</span>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> bookNo; &#125;    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// private members as before</span><span class="hljs-keyword">private</span>:    std::string bookNo;      <span class="hljs-comment">// implicitly initialized to the empty string</span>    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>; <span class="hljs-comment">// explicitly initialized</span>    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;&#125;;<span class="hljs-comment">// used in chapter 10</span><span class="hljs-function"><span class="hljs-keyword">inline</span></span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareIsbn</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_item &amp;lhs, <span class="hljs-type">const</span> Sales_item &amp;rhs)</span> </span><span class="hljs-function"></span>&#123; <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>(); &#125;<span class="hljs-comment">// nonmember binary operator: must declare a parameter for each operand</span>Sales_item <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Sales_item&amp;, <span class="hljs-type">const</span> Sales_item&amp;);<span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Sales_item &amp;lhs, <span class="hljs-type">const</span> Sales_item &amp;rhs)&#123;    <span class="hljs-comment">// must be made a friend of Sales_item</span>    <span class="hljs-keyword">return</span> lhs.units_sold == rhs.units_sold &amp;&amp;           lhs.revenue == rhs.revenue &amp;&amp;           lhs.<span class="hljs-built_in">isbn</span>() == rhs.<span class="hljs-built_in">isbn</span>();&#125;<span class="hljs-keyword">inline</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Sales_item &amp;lhs, <span class="hljs-type">const</span> Sales_item &amp;rhs)&#123;    <span class="hljs-keyword">return</span> !(lhs == rhs); <span class="hljs-comment">// != defined in terms of operator==</span>&#125;<span class="hljs-comment">// assumes that both objects refer to the same ISBN</span>Sales_item&amp; Sales_item::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Sales_item&amp; rhs) &#123;    units_sold += rhs.units_sold;     revenue += rhs.revenue;     <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">// assumes that both objects refer to the same ISBN</span>Sales_item <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Sales_item&amp; lhs, <span class="hljs-type">const</span> Sales_item&amp; rhs) &#123;    <span class="hljs-function">Sales_item <span class="hljs-title">ret</span><span class="hljs-params">(lhs)</span></span>;  <span class="hljs-comment">// copy (|lhs|) into a local object that we&#x27;ll return</span>    ret += rhs;           <span class="hljs-comment">// add in the contents of (|rhs|) </span>    <span class="hljs-keyword">return</span> ret;           <span class="hljs-comment">// return (|ret|) by value</span>&#125;std::istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(std::istream&amp; in, Sales_item&amp; s)&#123;    <span class="hljs-type">double</span> price;    in &gt;&gt; s.bookNo &gt;&gt; s.units_sold &gt;&gt; price;    <span class="hljs-comment">// check that the inputs succeeded</span>    <span class="hljs-keyword">if</span> (in)        s.revenue = s.units_sold * price;    <span class="hljs-keyword">else</span>         s = <span class="hljs-built_in">Sales_item</span>();  <span class="hljs-comment">// input failed: reset object to default state</span>    <span class="hljs-keyword">return</span> in;&#125;std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="hljs-type">const</span> Sales_item&amp; s)&#123;    out &lt;&lt; s.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span>        &lt;&lt; s.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s.<span class="hljs-built_in">avg_price</span>();    <span class="hljs-keyword">return</span> out;&#125;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sales_item::avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (units_sold)         <span class="hljs-keyword">return</span> revenue/units_sold;     <span class="hljs-keyword">else</span>         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><p>暂时不用怎么管，先试着使用：</p><ol><li>读取单价和数量，输出总价格</li></ol><div class="code-wrapper"><pre><code class="hljs cpp">Sales_item book; <span class="hljs-comment">// 创建一个对象</span>std::cin &gt;&gt; book;std::cout &lt;&lt; book &lt;&lt; std::endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit">0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-x 4 24.99&gt; 0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-x 4 99.96 24.99</code></pre></div><ol start="2"><li>对象相加，输出总价格和平均价格</li></ol><div class="code-wrapper"><pre><code class="hljs cpp">Sales_item book1,book2; <span class="hljs-comment">// 创建一个对象</span>std::cin &gt;&gt; book1 &gt;&gt; book2;std::cout &lt;&lt; book1+book2 &lt;&lt; std::endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit">0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-x 3 20.000<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-x 2 25.00&gt; 0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-x 5 110 22</code></pre></div><ol start="3"><li>增加成员函数，加和之前先判断两书的序列号是否相等</li></ol><div class="code-wrapper"><pre><code class="hljs cpp">Sales_item book1,book2; <span class="hljs-comment">// 创建一个对象</span>std::cin &gt;&gt; book1 &gt;&gt; book2;<span class="hljs-keyword">if</span>(book<span class="hljs-number">1.</span><span class="hljs-built_in">isbn</span>() == book<span class="hljs-number">2.</span><span class="hljs-built_in">isbn</span>())&#123;    std::cout &lt;&lt; book1+book2 &lt;&lt; std::endl;&#125;<span class="hljs-keyword">else</span>&#123;    std::cerr &lt;&lt; <span class="hljs-string">&quot;Error!&quot;</span> &lt;&lt; std::endl;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit">0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-x 3 20.000<span class="hljs-string">-201</span><span class="hljs-string">-70343</span>-x 2 25.00&gt; Error!</code></pre></div><ol start="4"><li>读取销售记录，生成每本书的销售报告</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Sales_item.h&quot;</span></span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    Sales_item total;    <span class="hljs-keyword">if</span>(std::cin &gt;&gt; total)&#123; <span class="hljs-comment">// 读取第一条数据，确保有数据可以处理</span>        Sales_item trans;        <span class="hljs-keyword">while</span>(std::cin &gt;&gt; trans)&#123;            <span class="hljs-keyword">if</span>(total.<span class="hljs-built_in">isbn</span>() == trans.<span class="hljs-built_in">isbn</span>())&#123;                total += trans;            &#125;            <span class="hljs-keyword">else</span>&#123;                std::cout &lt;&lt; total &lt;&lt; std::endl;                total = trans;            &#125;        &#125;        std::cout &lt;&lt; total &lt;&lt; std::endl; <span class="hljs-comment">// 打印最后一本书</span>    &#125;    <span class="hljs-keyword">else</span>&#123;        std::cerr &lt;&lt; <span class="hljs-string">&quot;No data!&quot;</span> &lt;&lt; std::endl;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit">0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-X 4 24.990<span class="hljs-string">-201</span><span class="hljs-string">-82470</span><span class="hljs-string">-1</span> 4 45.390<span class="hljs-string">-201</span><span class="hljs-string">-88954</span><span class="hljs-string">-4</span> 2 15.00 0<span class="hljs-string">-201</span><span class="hljs-string">-88954</span><span class="hljs-string">-4</span> 5 12.00 0<span class="hljs-string">-201</span><span class="hljs-string">-88954</span><span class="hljs-string">-4</span> 7 12.00 0<span class="hljs-string">-201</span><span class="hljs-string">-88954</span><span class="hljs-string">-4</span> 2 12.00 0<span class="hljs-string">-399</span><span class="hljs-string">-82477</span><span class="hljs-string">-1</span> 2 45.390<span class="hljs-string">-399</span><span class="hljs-string">-82477</span><span class="hljs-string">-1</span> 3 45.390<span class="hljs-string">-201</span><span class="hljs-string">-78345</span>-X 3 20.000<span class="hljs-string">-201</span><span class="hljs-string">-78345</span>-X 2 25.00&gt; 0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-X 4 99.96 24.990<span class="hljs-string">-201</span><span class="hljs-string">-82470</span><span class="hljs-string">-1</span> 4 181.56 45.390<span class="hljs-string">-201</span><span class="hljs-string">-88954</span><span class="hljs-string">-4</span> 16 198 12.3750<span class="hljs-string">-399</span><span class="hljs-string">-82477</span><span class="hljs-string">-1</span> 5 226.95 45.390<span class="hljs-string">-201</span><span class="hljs-string">-78345</span>-X 5 110 22</code></pre></div><p>这个程序的局限性在于，必须是连号的输入，不连号的输入就失效了。</p><p>当然这个时候学到的还不多，后面会将这个程序继续完善。</p><h1>第2章 变量和基本类型</h1><p>整型可以分为带符号类型和无符号类型（在前面添加 <code>unsigned</code>）</p><p>选择类型的原则：</p><ol><li>明确知道不可能为负值时，选用无符号类型</li><li>整数运算使用int，超过范围了使用long long</li><li>浮点数运算使用double</li><li>不要在算术表达式中使用char或者bool</li><li>不要混用无符号类型和带符号类型，因为带符号类型会自动转换为无符号类型，运算过程中出现负值即错误</li></ol><h2 id="初始化">初始化</h2><p><strong>创建变量时赋予其一个初始值（赋值指的是将对象的当前值用一个新值来替代，含义不同）</strong></p><p>初始化的4种方式：</p><ol><li><code>int a = 0;</code></li><li><code>int a = {0};</code></li><li><code>int a{0};</code> // 列表初始化</li><li><code>int a(0);</code></li></ol><p>变量声明：<strong>“一个文件如果想使用别处定义的名字，必须包含对那个名字的声明”</strong></p><p><strong>与定义的区别在于不赋初值</strong></p><p><code>extern int i;</code></p><h2 id="作用域">作用域</h2><ol><li>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字</li><li>允许在内层作用域中重新定义外层作用域已有的名字</li></ol><p>如：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    std::cout &lt;&lt; a &lt;&lt; std::endl;    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;    std::cout &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; ::a &lt;&lt; std::endl; <span class="hljs-comment">// 显式指定访问全局变量</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">010</code></pre></div><h2 id="引用">引用</h2><p>相当于为对象起一个另外的名字，通过 <code>&amp;</code>符号来定义</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ival = <span class="hljs-number">1024</span>;<span class="hljs-type">int</span> &amp;refVal = ival;</code></pre></div><p>引用必须初始化，因为引用需要和它的初始化对象一起绑定在一起，不能重新绑定到其他对象。</p><p>定义引用之后，对其进行的所有操作都是在它的绑定对象上进行的</p><div class="code-wrapper"><pre><code class="hljs cpp">refVal = <span class="hljs-number">12</span>;std::cout &lt;&lt; refVal &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">12</code></pre></div><p>引用本身不是一个对象，不能定义引用的引用</p><p>如下面的方式，实际上是绑定到了该引用对应的绑定对象上：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> &amp;refVal2 = refVal;std::cout &lt;&lt; refVal2 &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">12</code></pre></div><p>引用的类型要与绑定的对象严格匹配</p><p>引用不能绑定到字面值上</p><h2 id="指针">指针</h2><p>指针也实现了对其他对象的间接访问，但是指针本身也是一个对象，通过 <code>*</code>符号来定义</p><ol><li>指针存放某个对象的地址，如果获取这个地址，需要使用取地址符 <code>&amp;</code></li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ival = <span class="hljs-number">42</span>;<span class="hljs-type">int</span> *p = &amp;ival;</code></pre></div><p>指针的类型也要与它所指向的对象严格匹配</p><ol start="2"><li>如果指针指向了一个对象，可以使用解引用符 <code>*</code>来访问这个对象</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ival = <span class="hljs-number">42</span>;<span class="hljs-type">int</span> *p = &amp;ival;std::cout &lt;&lt; *p &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">42</code></pre></div><p>符号的多重含义：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-type">int</span> &amp;r = i; <span class="hljs-comment">// &amp;随类型名出现，是声明的一部分，r是一个引用</span><span class="hljs-type">int</span> *p; <span class="hljs-comment">// *随类型名出现，是声明的一部分，p是一个指针</span>p = &amp;i; <span class="hljs-comment">// &amp;出现在表达式中，是一个取地址符</span>*p = i; <span class="hljs-comment">// *出现在表达式中，是一个解引用符</span><span class="hljs-type">int</span> &amp;r2 = *p; <span class="hljs-comment">// r2是一个引用，*是一个解引用符</span>std::cout &lt;&lt; i &lt;&lt; std::endl &lt;&lt; r &lt;&lt; std::endl &lt;&lt; *p &lt;&lt; std::endl &lt;&lt; r2 &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">42424242</code></pre></div><p>空指针：<code>int *p1 = nullptr</code></p><p><strong>建议：初始化所有的指针</strong></p><p>指针与引用不同，是可以赋值的。赋值的时候永远改变的是等号左侧的对象。</p><p><code>void*</code>指针，可以用于存放任意类型对象的地址</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">double</span> obj = <span class="hljs-number">3.14</span>;<span class="hljs-type">double</span> *pd = &amp;obj;<span class="hljs-type">void</span> *pv = &amp;obj;pv = pd;std::cout &lt;&lt; *pv &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>‘void*’ is not a pointer-to-object type</code></pre></div><p><code>void*</code>指针只能与其他指针作比较，作为函数的输入和输出，或者赋值给另外一个 <code>void*</code>指针。</p><p>甚至连访问对象都不可以</p><p>指向指针的指针</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ival = <span class="hljs-number">1024</span>;<span class="hljs-type">int</span> *pi = &amp;ival;<span class="hljs-type">int</span> **ppi = πstd::cout &lt;&lt; ival &lt;&lt; std::endl;std::cout &lt;&lt; *pi &lt;&lt; std::endl;std::cout &lt;&lt; **ppi &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-number">1024</span><span class="hljs-number">1024</span><span class="hljs-number">1024</span></code></pre></div><p>指向指针的引用</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-type">int</span> *p;<span class="hljs-type">int</span> *&amp;r = p;r = &amp;i; <span class="hljs-comment">// p = &amp;i;</span>std::cout &lt;&lt; i &lt;&lt; std::endl;std::cout &lt;&lt; *r &lt;&lt; std::endl;std::cout &lt;&lt; *p &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">424242</code></pre></div><p>阅读定义要从右往左，离变量名最近的符号对变量类型有最直接的影响</p><p>最近的是 <code>&amp;</code>，因此 <code>r</code>是一个引用</p><p>然后是 <code>*</code>，说明 <code>r</code>引用的是一个指针</p><h2 id="const">const</h2><p><code>const</code>对象一旦创建，值不可以再改变，因此在创建的时候必须初始化</p><p><code>const int a = 45;</code></p><p>只能在 <code>const</code>类型的对象上执行不改变其内容的操作</p><p>可以添加extern关键字，使const变量在文件间共享</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufSize = <span class="hljs-built_in">fcn</span>(); <span class="hljs-comment">// file.cpp定义并初始化了这个常量，可以被其他文件访问</span><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> bufSize; <span class="hljs-comment">// file.h 和上面的变量是同一个，只是一个声明，说明定义会在其他地方出现</span></code></pre></div><p><code>const</code>的引用是对常量的引用，不能改变引用的值，引用的时候也要添加 <code>const</code>限定符</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci = <span class="hljs-number">1024</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = ci;</code></pre></div><p>初始化常量引用时可以使用任意的表达式，只要表达式的结果能转化成引用的类型即可</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r1 = i;<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r2 = <span class="hljs-number">42</span>;<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>;std::cout &lt;&lt; r1 &lt;&lt; std::endl;std::cout &lt;&lt; r2 &lt;&lt; std::endl;std::cout &lt;&lt; r3 &lt;&lt; std::endl;i = <span class="hljs-number">56</span>;std::cout &lt;&lt; r1 &lt;&lt; std::endl;std::cout &lt;&lt; r2 &lt;&lt; std::endl;std::cout &lt;&lt; r3 &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">424284564284</code></pre></div><p><strong>因此，对 <code>const</code>的引用可以并非一个 <code>const</code>的对象，不能通过这种引用改变被引用的对象的值，但是可以通过其他方式改变这个对象的值</strong></p><p>指向常量的指针也不能用于改变其所指对象的值，且指向常量的指针所指的对象也不一定是一个常量</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> *cptr = &amp;pistd::cout &lt;&lt; *cptr &lt;&lt; std::endl;<span class="hljs-type">double</span> dval = <span class="hljs-number">3.14</span>;cptr = &amp;dval;std::cout &lt;&lt; *cptr &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">14</span><span class="hljs-attribute">3</span>.<span class="hljs-number">14</span></code></pre></div><p><code>const</code>指针：将指针本身定义为常量，也就是指针所指的地址不变</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> errNumb = <span class="hljs-number">0</span>;<span class="hljs-type">int</span> *<span class="hljs-type">const</span> curErr = &amp;errNumb; <span class="hljs-comment">// curErr将一直指向errNumb，不能改变</span><span class="hljs-type">const</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.14159</span>;<span class="hljs-type">const</span> <span class="hljs-type">double</span> *<span class="hljs-type">const</span> pip = &amp;pi <span class="hljs-comment">// 一个指向常量对象的常量指针</span>*curErr = <span class="hljs-number">56</span>;std::cout &lt;&lt; errNumb &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">56</code></pre></div><p>指针所指的地址不变，但是如果指向的不是常量，还是可以改变指向的值的</p><p>顶层 <code>const</code>可以表示任意的对象是一个常量，底层 <code>const</code>与复合类型有关，指的是下一层对象是常量。</p><p>常量表达式：值不会改变且在编译过程就能得到计算结果的表达式</p><p>将变量声明为 <code>constexpr</code>来由编译器验证是否为一个常量表达式：<code>constexpr int limit = mf + 1;</code></p><p>在 <code>constexpr</code>中如果声明了一个指针，那么一定是常量指针，即顶层 <code>const</code></p><h2 id="处理变量类型">处理变量类型</h2><p>类型别名的两种定义方式：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">double</span> wages;<span class="hljs-keyword">using</span> wages = <span class="hljs-type">double</span>;</code></pre></div><p>如果别名是一个复合类型，不能仅仅将其替换进行理解。</p><p><code>auto</code>类型：将类型交给编译器自己去分析，一般会忽略掉顶层 <code>const</code>，如果需要保留要加 <code>const auto</code>进行推断</p><p><code>decltype</code>类型指示符：通过表达式的类型推断出要定义的变量的类型</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>,b = <span class="hljs-number">0</span>;<span class="hljs-keyword">decltype</span>(a+b) x = <span class="hljs-number">0</span>;std::cout &lt;&lt; x &lt;&lt; std::endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">0</code></pre></div><p>如果希望得到引用类型，可以添加两层括号，即 <code>decltype((a+b))</code></p><h2 id="自定义数据结构">自定义数据结构</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span>&#123;    std::string bookNo;    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;&#125;;</code></pre></div><p>读取单价和数量，输出总价格</p><div class="code-wrapper"><pre><code class="hljs cpp">Sales_item book; <span class="hljs-comment">// 创建一个对象</span>std::cin &gt;&gt; book;std::cout &lt;&lt; book &lt;&lt; std::endl;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs subunit">0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-x 4 24.99&gt; 0<span class="hljs-string">-201</span><span class="hljs-string">-70353</span>-x 4 99.96 24.99</code></pre></div><p>头文件：包含只能被定义一起的实体</p><p>通过头文件保护符来确保不允许重复包含：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SALES_DATA_H</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> SALES_DATA_H</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sales_data</span>&#123;    std::string bookNo;    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;&#125;;<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span></code></pre></div><h1>第3章 字符串、向量和数组</h1><p><code>using</code>声明：使用命名空间中的成员</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> std::cin;</code></pre></div><p>头文件不应包含 <code>using</code>声明</p><h2 id="标准库类型string">标准库类型string</h2><h3 id="定义和初始化">定义和初始化</h3><div class="code-wrapper"><pre><code class="hljs cpp">string s1;<span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>; <span class="hljs-comment">// string s2 = s1;</span><span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(<span class="hljs-string">&quot;value&quot;</span>)</span></span>; <span class="hljs-comment">// string s3 = &quot;value&quot;;</span><span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;c&#x27;</span>)</span></span>;cout &lt;&lt; s1 &lt;&lt; endl;cout &lt;&lt; s2 &lt;&lt; endl;cout &lt;&lt; s3 &lt;&lt; endl;cout &lt;&lt; s4 &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">value</span><span class="hljs-attribute">cccccccccc</span></code></pre></div><p>初始化分为直接初始化和拷贝初始化，有 <code>=</code>的为拷贝初始化，一般只用于单个初始值的情况下</p><h3 id="string对象的操作">string对象的操作</h3><p>输入输出与对整数等的操作相同</p><p>使用getline读入一整行（可以带空格）</p><div class="code-wrapper"><pre><code class="hljs cpp">string line;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(cin,line))&#123;    cout &lt;&lt; line &lt;&lt; endl;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">fds fdsfdsf dsf</span>fds fdsfdsf dsf<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript">dsfdsfdsfds fdsfds </span>dsfdsfdsfds fdsfds</code></pre></div><p><code>string.size()</code>返回的是无符号整形数，不要去负数值混用</p><p>字面值不为字符串，不能将字面值相加，只能将字符串相加，如 <code>&quot;df&quot;+&quot;fdsfs&quot;</code>是不合法的</p><p>基于范围的 <code>for</code>语句：遍历给定序列中的每一个元素</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : str)&#123;    cout &lt;&lt; c;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-keyword">some</span> <span class="hljs-built_in">string</span></code></pre></div><p>如果要改变字符，需要使用引用类型：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;some string&quot;</span>)</span></span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : str)&#123;    c = <span class="hljs-built_in">toupper</span>(c);&#125;cout &lt;&lt; str &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs ada"><span class="hljs-keyword">SOME</span> STRING</code></pre></div><h2 id="标准库类型vector">标准库类型vector</h2><p><code>vector</code>属于一个<strong>类模板</strong>，模板不是类或者函数，但是可以看作编译器生成类或函数编写的一份说明，编译器根据模板创建类或函数的过程称为<strong>实例化</strong>。</p><h3 id="定义和初始化vector对象">定义和初始化vector对象</h3><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; ivec;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec2</span><span class="hljs-params">(ivec)</span></span>;vector&lt;<span class="hljs-type">int</span>&gt; ivec3 = ivec;vector&lt;string&gt; articles&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;an&quot;</span>,<span class="hljs-string">&quot;the&quot;</span>&#125;;<span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;hi&quot;</span>)</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i : svec)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span> <span class="hljs-keyword">hi</span></code></pre></div><p>值初始化：只初始化 <code>vector</code>的大小，不赋值具体数值 <code>vector&lt;int&gt; i(10)</code></p><h3 id="其他vector操作">其他vector操作</h3><p><code>vector</code>在设计上事先指定容量是不好的做法，比较适合运行时再添加具体的值</p><p>循环内部如果包含向 <code>vector</code>添加元素的语句，不能使用范围 <code>for</code>循环</p><p>不能用下标形式添加元素，也就是下标操作只能对确知已经存在的元素进行</p><h3 id="迭代器">迭代器</h3><div class="code-wrapper"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vi = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it1 = vi.<span class="hljs-built_in">begin</span>();it1 != vi.<span class="hljs-built_in">end</span>();it1++)&#123;    *it1 *= <span class="hljs-number">2</span>;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it2 = vi.<span class="hljs-built_in">cbegin</span>();it2 != vi.<span class="hljs-built_in">cend</span>();it2++)&#123;    cout &lt;&lt; *it2 &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">14</span> <span class="hljs-number">16</span> <span class="hljs-number">18</span> <span class="hljs-number">10</span> <span class="hljs-number">12</span> <span class="hljs-number">8</span></code></pre></div><h2 id="数组">数组</h2><h3 id="定义与初始化">定义与初始化</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a2[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<span class="hljs-type">int</span> a3[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;; <span class="hljs-comment">// 多余的初始化成默认值</span><span class="hljs-type">char</span> a4[<span class="hljs-number">8</span>] = <span class="hljs-string">&quot;Daniel&quot;</span>; <span class="hljs-comment">// 至少是7，要有一个空字符</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: a3)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i: a4)&#123;    cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-attribute">D</span> a n i e l</code></pre></div><p>数组不允许拷贝和赋值</p><p>复杂的数组声明：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ptrs[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 含有10个整型指针的数组</span><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>];<span class="hljs-built_in">int</span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">// Parray指向一个含有10个整数的数组</span><span class="hljs-built_in">int</span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr; <span class="hljs-comment">// arrRef引用一个含有10个整数的数组</span><span class="hljs-type">int</span> *(&amp;arry)[<span class="hljs-number">10</span>] = ptrs; <span class="hljs-comment">// arry是数组的引用，该数组含有10个指针</span></code></pre></div><h3 id="指针和数组">指针和数组</h3><p>使用数组的时候编译器一般将其转化为指针</p><div class="code-wrapper"><pre><code class="hljs cpp">string nums[] = &#123;<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>,<span class="hljs-string">&quot;three&quot;</span>&#125;;string *p = &amp;nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">// p指向nums的第1个元素</span>string *p2 = nums <span class="hljs-comment">// 等价于上面的语句</span></code></pre></div><p>使用 <code>auto</code>推断时会返回一个指针，但是只用 <code>decltype</code>推断的时候会返回数组</p><p>利用指针对数组可以起到迭代器的效果</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<span class="hljs-type">int</span> *beg = <span class="hljs-built_in">begin</span>(ia); <span class="hljs-comment">// 指向ia的第一个元素</span><span class="hljs-type">int</span> *last = <span class="hljs-built_in">end</span>(ia); <span class="hljs-comment">// 指向ia的最后一个元素的下一个位置</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = beg;it != last;it++)&#123;    cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><h3 id="C风格字符串">C风格字符串</h3><p><code>string</code>转化为C风格字符串</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World!&quot;</span>)</span></span>;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = s.<span class="hljs-built_in">c_str</span>();cout &lt;&lt; *str &lt;&lt; endl;</code></pre></div><p>使用数组初始化vector</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> int_arr[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(begin(int_arr),end(int_arr))</span></span>;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it : ivec)&#123;    cout &lt;&lt; it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;cout &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span></code></pre></div><h3 id="指针和多维数组">指针和多维数组</h3><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ia[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;,&#123;<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>&#125;&#125;;<span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">4</span>] = ia; <span class="hljs-comment">// p指向含有4个整数的数组</span>p = &amp;ia[<span class="hljs-number">2</span>]; <span class="hljs-comment">// p 指向ia的尾元素</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = ia;p != ia<span class="hljs-number">+3</span>;++p)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q = *p;q != *p<span class="hljs-number">+4</span>;q++)&#123;        cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;&#125;cout &lt;&lt; endl;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">begin</span>(ia);p != <span class="hljs-built_in">end</span>(ia);++p)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q = <span class="hljs-built_in">begin</span>(*p);q != <span class="hljs-built_in">end</span>(*p);q++)&#123;        cout &lt;&lt; *q &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;&#125;cout &lt;&lt; endl;</code></pre></div><h1>第4章 表达式</h1><p>通俗的讲，左值就是能够出现在赋值符号左面的东西，而右值就是那些可以出现在赋值符号右面的东西.</p><p>左值：指表达式结束后依然存在的持久对象，可以取地址，具名变量或对象</p><p>右值：表达式结束后就不再存在的临时对象，不可以取地址，没有名字。</p><p>当一个对象被用作右值的时候，使用的是对象的值（内容）；当一个对象被用作左值的时候，用的是对象的身份（在内存中的位置）</p><ol><li>算术运算符的运算结果和求值对象都是右值</li></ol><p><code>m%n</code>的符号与 <code>m</code>相同</p><ol start="2"><li>逻辑和关系运算符的运算结果和求值对象都是右值</li><li>赋值运算符的左侧运算对象必须是一个可修改的左值，结果是他的左侧运算对象，并且是一个左值</li><li>递增和递减运算符必须作用于左值运算对象，前置版本将对象本身作为左值返回，后置版本将对象原始值的副本作为右值返回</li><li>箭头运算符作用于一个指针类型的运算对象，结果是一个左值</li><li>点运算符的结果与成员所属的对象相同</li><li>条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值，否则运算的结果是右值</li></ol><p>强制类型转换：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">52</span>;<span class="hljs-type">int</span> j = <span class="hljs-number">9</span>;<span class="hljs-type">double</span> slope = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(j) / i;cout &lt;&lt; slope &lt;&lt; endl;</code></pre></div><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">173077</span></code></pre></div><h1>第5章 语句</h1><p><code>switch</code>语句：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a;<span class="hljs-keyword">while</span>(cin &gt;&gt; a)&#123;    <span class="hljs-keyword">switch</span>(a)&#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: cout &lt;&lt; <span class="hljs-string">&#x27;1&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: cout &lt;&lt; <span class="hljs-string">&#x27;2&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: cout &lt;&lt; <span class="hljs-string">&#x27;3&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: cout &lt;&lt; <span class="hljs-string">&#x27;4&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: cout &lt;&lt; <span class="hljs-string">&#x27;5&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>: cout &lt;&lt; <span class="hljs-string">&#x27;6&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>: cout &lt;&lt; <span class="hljs-string">&#x27;7&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>: cout &lt;&lt; <span class="hljs-string">&#x27;8&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: cout &lt;&lt; <span class="hljs-string">&#x27;9&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>: cout &lt;&lt; <span class="hljs-string">&#x27;0&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;        <span class="hljs-keyword">default</span>: cout &lt;&lt; <span class="hljs-string">&#x27;N&#x27;</span> &lt;&lt; endl;<span class="hljs-keyword">break</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0</span></span>1<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">9</span></span>0<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">45</span></span>N</code></pre></div><p><code>try</code>语句块和异常处理：</p><p><code>throw</code>语句抛出异常：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;fdsdfds&quot;</span>);</code></pre></div><div class="code-wrapper"><pre><code class="hljs smali">terminate called after throwing an<span class="hljs-built_in"> instance </span>of &#x27;std::runtime_error&#x27;  what():  fdsdfdsAborted</code></pre></div><p><code>catch</code>语句捕捉异常：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-type">double</span> m, n;cin &gt;&gt; m &gt;&gt; n;<span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> - <span class="hljs-number">1</span>;  <span class="hljs-comment">//抛出整型异常</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> - <span class="hljs-number">1.0</span>;  <span class="hljs-comment">//拋出 double 型异常</span>    <span class="hljs-keyword">else</span>        cout &lt;&lt; m / n &lt;&lt; endl;&#125;<span class="hljs-built_in">catch</span> (<span class="hljs-type">double</span> d) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;catch (double)&quot;</span> &lt;&lt; d &lt;&lt; endl;&#125;<span class="hljs-built_in">catch</span> (...) &#123;    cout &lt;&lt; <span class="hljs-string">&quot;catch (...)&quot;</span> &lt;&lt; endl;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">0</span> <span class="hljs-number">6</span></span>catch (double)-1<span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-number">6</span> <span class="hljs-number">0</span></span>catch (...)</code></pre></div><h1>第6章 函数</h1><p>局部静态对象：程序第一次经过时被初始化，直到程序终止时才被销毁。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_calls</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-type">static</span> <span class="hljs-type">int</span> ctr = <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> ++ctr;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i != <span class="hljs-number">10</span>; ++i)&#123;        cout &lt;&lt; <span class="hljs-built_in">count_calls</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span></code></pre></div><p>函数声明（函数原型）：在使用函数之前对函数的名字进行声明</p><p>函数声明可以忽略形参的名字，也可以加上形参的名字。</p><p>函数声明最好写在头文件中</p><p>分离式编译：编译和链接多个源文件</p><h2 id="参数传递">参数传递</h2><p>指针形参：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> *ip)</span></span>&#123;    *ip = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;    <span class="hljs-built_in">reset</span>(&amp;i);    cout &lt;&lt; i &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">0</code></pre></div><p>传引用参数：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;i)</span></span>&#123;    i = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;    <span class="hljs-built_in">reset</span>(i);    cout &lt;&lt; i &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">0</code></pre></div><p>尽量使用引用形式从而避免拷贝</p><p>还可以通过引用形式返回一些额外信息。因为函数只能返回一个返回值，但是如果某个值是引用的形式传到函数中的，也会保留下修改后的值。</p><p>不修改的变量尽量使用常量引用</p><p>数组形参：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i[])</span></span>&#123;    cout &lt;&lt; i[<span class="hljs-number">0</span>] &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *i)</span></span>&#123;    cout &lt;&lt; i[<span class="hljs-number">0</span>] &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i[<span class="hljs-number">10</span>])</span></span>&#123;    cout &lt;&lt; i[<span class="hljs-number">0</span>] &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;    <span class="hljs-type">int</span> j[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;;    <span class="hljs-built_in">Print</span>(&amp;i);    <span class="hljs-built_in">Print</span>(j);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">56</code></pre></div><p>数组不能直接进行传递，直接作为指针的形式传递，因此丢掉了数组大小的信息</p><p>可以使用指针的形式进行提示，也可以传入一个表示数组大小的参数。</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> *beg,<span class="hljs-type">const</span> <span class="hljs-type">int</span> *end)</span></span>&#123;    <span class="hljs-keyword">while</span>(beg != end)&#123;        cout &lt;&lt; *beg++ &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i[] ,<span class="hljs-type">size_t</span> size)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> a=<span class="hljs-number">0</span>;a&lt;size;a++)&#123;        cout &lt;&lt; i[a] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-type">int</span> i[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">begin</span>(i),<span class="hljs-built_in">end</span>(i));    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span></code></pre></div><p>数组引用形参：（缺点是只能作用于大小固定的数组）</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;arr)[<span class="hljs-number">10</span>])</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> elem : arr)&#123;        cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;&#125;</code></pre></div><p>含有可变形参的函数：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(initializer_list&lt;string&gt; il)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> beg = il.<span class="hljs-built_in">begin</span>();beg != il.<span class="hljs-built_in">end</span>();++beg)&#123;        cout &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;    cout &lt;&lt; endl;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>&#125;);    <span class="hljs-built_in">error_msg</span>(&#123;<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>&#125;);&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">b</span> c</code></pre></div><h2 id="函数的返回值">函数的返回值</h2><p>函数返回时不要返回局部对象的引用或指针</p><p>调用一个返回引用的函数会得到左值</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">char</span> &amp;<span class="hljs-title">get_val</span><span class="hljs-params">(string &amp;str,string::size_type ix)</span></span>&#123;    <span class="hljs-keyword">return</span> str[ix];&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;a value&quot;</span>)</span></span>;    cout &lt;&lt; s &lt;&lt; endl;    <span class="hljs-built_in">get_val</span>(s,<span class="hljs-number">0</span>) = <span class="hljs-string">&#x27;A&#x27;</span>;    cout &lt;&lt; s &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> value<span class="hljs-selector-tag">A</span> value</code></pre></div><p>返回值也可以是一个花括号包围起来的列表</p><h2 id="函数重载">函数重载</h2><p>定义相同名称的函数，但是形参列表不同，可能是数量上的不同，也可能是类型上的不同。使得函数调用的时候根据不同的形参列表自动判断指定哪一个函数。</p><p>顶层 <code>const</code>不影响传入的参数</p><p>在不同的作用域中无法重载函数，会覆盖掉</p><h2 id="特殊用途语言特性">特殊用途语言特性</h2><p>默认实参：在函数的声明中给一个默认值，调用时可以覆盖掉，也可以不写以使用默认值。</p><p>内联函数：将函数在调用点展开，但是编译器不一定支持</p><p><code>constexpr</code>函数：能用于常量表达式的函数，函数的返回值和所有形参的类型都要是字面值类型，函数体中有且只有一条 <code>return</code>语句。</p><p><code>assert</code>表达式：用于调试的时候对程序进行检查 <code>assert(s == &quot;dfdsf&quot;);</code>如果不满足条件程序会中断退出。</p><h2 id="函数指针">函数指针</h2><p>完全不明白。。。没有示例程序看不懂</p><h1>第7章 类</h1><h2 id="定义抽象数据类型">定义抽象数据类型</h2><p>成员函数是类定义的一部分，通过特定的对象来调用。非成员函数就是普通的函数。</p><p>成员函数的声明必须在类的内部，定义可以在类的内部或者外部。非成员函数的声明和定义都在类的外部。</p><p>构造函数：控制对象的初始化过程</p><p>访问控制与封装：</p><p>定义在public说明符后的成员在整个程序内可被访问，public成员定义类的接口。</p><p>定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。</p><p>使用class和struct定义类的区别在于默认的访问权限不同，struct默认访问权限都是public的</p><p>友元：令其他类或成员成为访问它的非公有成员。但是友元只算一个权限控制，在类外一样要进行声明。</p><p>上述代码：</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-keyword">using</span> std::string;<span class="hljs-keyword">using</span> std::vector;<span class="hljs-keyword">using</span> std::cin;<span class="hljs-keyword">using</span> std::cout;<span class="hljs-keyword">using</span> std::endl;<span class="hljs-keyword">using</span> std::begin;<span class="hljs-keyword">using</span> std::end;<span class="hljs-keyword">using</span> std::runtime_error;<span class="hljs-keyword">using</span> std::initializer_list;<span class="hljs-keyword">using</span> std::istream;<span class="hljs-keyword">using</span> std::ostream;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Sales_data</span>&#123;<span class="hljs-function"><span class="hljs-keyword">friend</span> Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data&amp;,<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<span class="hljs-function"><span class="hljs-keyword">friend</span> std::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(std::ostream&amp;,<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<span class="hljs-function"><span class="hljs-keyword">friend</span> std::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(std::istream&amp;,Sales_data&amp;)</span></span>;<span class="hljs-keyword">public</span>:    <span class="hljs-comment">// 构造函数</span>    <span class="hljs-built_in">Sales_data</span>() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// 默认构造函数</span>    <span class="hljs-comment">// 构造函数初始值列表</span>    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s):<span class="hljs-built_in">bookNo</span>(s)&#123; &#125;    <span class="hljs-built_in">Sales_data</span>(<span class="hljs-type">const</span> std::string &amp;s,<span class="hljs-type">unsigned</span> n,<span class="hljs-type">double</span> p):<span class="hljs-built_in">bookNo</span>(s),<span class="hljs-built_in">units_sold</span>(n),<span class="hljs-built_in">revenue</span>(p*n)&#123; &#125;    <span class="hljs-built_in">Sales_data</span>(std::istream &amp;);    <span class="hljs-comment">// 常量成员函数</span>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;        <span class="hljs-keyword">return</span> bookNo;    &#125;    <span class="hljs-function">Sales_data &amp;<span class="hljs-title">combine</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<span class="hljs-keyword">private</span>:    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;    std::string bookNo;    <span class="hljs-type">unsigned</span> units_sold = <span class="hljs-number">0</span>;    <span class="hljs-type">double</span> revenue = <span class="hljs-number">0.0</span>;&#125;;<span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data&amp;,<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<span class="hljs-function">std::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(std::ostream&amp;,<span class="hljs-type">const</span> Sales_data&amp;)</span></span>;<span class="hljs-function">std::istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(std::istream&amp;,Sales_data&amp;)</span></span>;<span class="hljs-comment">// 在类的外部定义成员函数</span><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sales_data::avg_price</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;    <span class="hljs-keyword">if</span>(units_sold)&#123;        <span class="hljs-keyword">return</span> revenue / units_sold;    &#125;    <span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-comment">// 定义一个返回this对象的函数</span><span class="hljs-function">Sales_data&amp; <span class="hljs-title">Sales_data::combine</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;rhs)</span></span>&#123;    units_sold += rhs.units_sold;    revenue += rhs.revenue;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">// 类相关的非成员函数</span><span class="hljs-function">istream &amp;<span class="hljs-title">read</span><span class="hljs-params">(istream &amp;is, Sales_data &amp;item)</span></span>&#123;    <span class="hljs-type">double</span> price = <span class="hljs-number">0</span>;    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;    item.revenue = price * item.units_sold;    <span class="hljs-keyword">return</span> is;&#125;<span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os,<span class="hljs-type">const</span> Sales_data &amp;item)</span></span>&#123;    os &lt;&lt; item.<span class="hljs-built_in">isbn</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.revenue &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.<span class="hljs-built_in">avg_price</span>();    <span class="hljs-keyword">return</span> os;&#125;<span class="hljs-function">Sales_data <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Sales_data &amp;lhs,<span class="hljs-type">const</span> Sales_data &amp;rhs)</span></span>&#123;    Sales_data sum = lhs;    sum.<span class="hljs-built_in">combine</span>(rhs);    <span class="hljs-keyword">return</span> sum;&#125;<span class="hljs-comment">// 在类的外部定义构造函数</span>Sales_data::<span class="hljs-built_in">Sales_data</span>(std::istream &amp;is)&#123;    <span class="hljs-built_in">read</span>(is,*<span class="hljs-keyword">this</span>);&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="类的其他特性">类的其他特性</h2><ol><li>定义一个类型成员：一般写在最开头的位置</li><li>令成员作为内联函数：可以将 <code>inline</code>写在类内或者类外，一般写在类外</li><li>重载成员函数</li><li>可变数据成员：在 <code>const</code>里面也可以变化</li><li>类数据成员的初始值：一个类里面由另外一个类提供初始值</li></ol><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">typedef</span> std::string::size_type pos; <span class="hljs-comment">// 定义类型的成员</span>        <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;        <span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c): <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c)&#123; &#125;        <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;            <span class="hljs-keyword">return</span> contents[cursor]; <span class="hljs-comment">// 隐式内联函数</span>        &#125;;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 显式内联函数</span>        <span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>; <span class="hljs-comment">// 后面设置为内联函数</span>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;        <span class="hljs-function">Screen &amp;<span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;        <span class="hljs-function">Screen &amp;<span class="hljs-title">set</span><span class="hljs-params">(pos,pos,<span class="hljs-type">char</span>)</span></span>;        <span class="hljs-function">Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span></span>&#123;            <span class="hljs-built_in">do_display</span>(os);            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-function"><span class="hljs-type">const</span> Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;            <span class="hljs-built_in">do_display</span>(os);            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        &#125;    <span class="hljs-keyword">private</span>:        pos cursor = <span class="hljs-number">0</span>;        pos height = <span class="hljs-number">0</span>,width = <span class="hljs-number">0</span>;        std::string contents;        <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;            os &lt;&lt; contents;        &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::move</span><span class="hljs-params">(pos r,pos c)</span></span>&#123;    pos row = r * width;    cursor = row + c;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos r,pos c)</span> <span class="hljs-type">const</span> </span>&#123;    pos row = r * width;    <span class="hljs-keyword">return</span> contents[row + c];&#125;<span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">Screen::some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;    ++access_ctr;    <span class="hljs-keyword">return</span> access_ctr;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;    contents[cursor] = c;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::set</span><span class="hljs-params">(pos r,pos col,<span class="hljs-type">char</span> ch)</span></span>&#123;    contents[r*width+col] = ch;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">// 类数据成员的初始值</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_mgr</span>&#123;    <span class="hljs-keyword">private</span>:        std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>,<span class="hljs-number">80</span>,<span class="hljs-string">&#x27; &#x27;</span>)&#125;;&#125;;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    Screen myscreen;    <span class="hljs-type">char</span> ch = myscreen.<span class="hljs-built_in">get</span>();    cout &lt;&lt; myscreen.<span class="hljs-built_in">some_member</span>() &lt;&lt; endl;    ch = myscreen.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    cout &lt;&lt; myscreen.<span class="hljs-built_in">some_member</span>() &lt;&lt; endl;    myscreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>);    myscreen.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);    cout &lt;&lt; myscreen.<span class="hljs-built_in">get</span>() &lt;&lt; endl;    <span class="hljs-function">Screen <span class="hljs-title">myScreen</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;!&#x27;</span>)</span></span>;    <span class="hljs-function"><span class="hljs-type">const</span> Screen <span class="hljs-title">blank</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;?&#x27;</span>)</span></span>;    myScreen.<span class="hljs-built_in">set</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;#&#x27;</span>).<span class="hljs-built_in">display</span>(cout);    cout &lt;&lt; endl;    blank.<span class="hljs-built_in">display</span>(cout);    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs erlang-repl"><span class="hljs-number">1</span><span class="hljs-number">2</span>#!!!!!!!#!!!!!!!???????????????</code></pre></div><p>类之间的友元关系：不存在传递性</p><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_mgr</span>;<span class="hljs-comment">// 类数据成员的初始值</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_mgr</span>&#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;    <span class="hljs-keyword">private</span>:        std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>,<span class="hljs-number">80</span>,<span class="hljs-string">&#x27; &#x27;</span>)&#125;;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Window_mgr::clear</span><span class="hljs-params">(ScreenIndex i)</span></span>&#123;    Screen &amp;s = screens[i];    s.contents = <span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);&#125;</code></pre></div><h2 id="类的作用域">类的作用域</h2><div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Screen</span>&#123;    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_mgr</span>;    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">typedef</span> std::string::size_type pos; <span class="hljs-comment">// 定义类型的成员</span>        <span class="hljs-built_in">Screen</span>() = <span class="hljs-keyword">default</span>;        <span class="hljs-built_in">Screen</span>(pos ht,pos wd,<span class="hljs-type">char</span> c): <span class="hljs-built_in">height</span>(ht), <span class="hljs-built_in">width</span>(wd),<span class="hljs-built_in">contents</span>(ht*wd,c)&#123; &#125;        <span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;            <span class="hljs-keyword">return</span> contents[cursor]; <span class="hljs-comment">// 隐式内联函数</span>        &#125;;        <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title">get</span><span class="hljs-params">(pos ht,pos wd)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// 显式内联函数</span>        <span class="hljs-function">Screen &amp;<span class="hljs-title">move</span><span class="hljs-params">(pos r, pos c)</span></span>; <span class="hljs-comment">// 后面设置为内联函数</span>        <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;        <span class="hljs-function">Screen &amp;<span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span></span>;        <span class="hljs-function">Screen &amp;<span class="hljs-title">set</span><span class="hljs-params">(pos,pos,<span class="hljs-type">char</span>)</span></span>;        <span class="hljs-function">Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span></span>&#123;            <span class="hljs-built_in">do_display</span>(os);            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        &#125;        <span class="hljs-function"><span class="hljs-type">const</span> Screen &amp;<span class="hljs-title">display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;            <span class="hljs-built_in">do_display</span>(os);            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;        &#125;    <span class="hljs-keyword">private</span>:        pos cursor = <span class="hljs-number">0</span>;        pos height = <span class="hljs-number">0</span>,width = <span class="hljs-number">0</span>;        std::string contents;        <span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> access_ctr = <span class="hljs-number">0</span>;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_display</span><span class="hljs-params">(std::ostream &amp;os)</span> <span class="hljs-type">const</span> </span>&#123;            os &lt;&lt; contents;        &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::move</span><span class="hljs-params">(pos r,pos c)</span></span>&#123;    pos row = r * width;    cursor = row + c;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-type">char</span> <span class="hljs-title">Screen::get</span><span class="hljs-params">(pos r,pos c)</span> <span class="hljs-type">const</span> </span>&#123;    pos row = r * width;    <span class="hljs-keyword">return</span> contents[row + c];&#125;<span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">Screen::some_member</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;    ++access_ctr;    <span class="hljs-keyword">return</span> access_ctr;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::set</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;    contents[cursor] = c;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">inline</span> Screen &amp;<span class="hljs-title">Screen::set</span><span class="hljs-params">(pos r,pos col,<span class="hljs-type">char</span> ch)</span></span>&#123;    contents[r*width+col] = ch;    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;&#125;<span class="hljs-comment">// 类数据成员的初始值</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window_mgr</span>&#123;    <span class="hljs-keyword">public</span>:        <span class="hljs-keyword">using</span> ScreenIndex = std::vector&lt;Screen&gt;::size_type;        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">(ScreenIndex)</span></span>;        <span class="hljs-function">ScreenIndex <span class="hljs-title">addScreen</span><span class="hljs-params">(<span class="hljs-type">const</span> Screen&amp;)</span></span>;    <span class="hljs-keyword">private</span>:        std::vector&lt;Screen&gt; screens&#123;<span class="hljs-built_in">Screen</span>(<span class="hljs-number">24</span>,<span class="hljs-number">80</span>,<span class="hljs-string">&#x27; &#x27;</span>)&#125;;&#125;;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Window_mgr::clear</span><span class="hljs-params">(ScreenIndex i)</span></span>&#123;    Screen &amp;s = screens[i];    s.contents = <span class="hljs-built_in">string</span>(s.height * s.width, <span class="hljs-string">&#x27; &#x27;</span>);&#125;<span class="hljs-function">Window_mgr::ScreenIndex <span class="hljs-title">Window_mgr::addScreen</span><span class="hljs-params">(<span class="hljs-type">const</span> Screen &amp;s)</span></span>&#123;    screens.<span class="hljs-built_in">push_back</span>(s);    <span class="hljs-keyword">return</span> screens.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;    Screen myscreen;    <span class="hljs-type">char</span> ch = myscreen.<span class="hljs-built_in">get</span>();    cout &lt;&lt; myscreen.<span class="hljs-built_in">some_member</span>() &lt;&lt; endl;    ch = myscreen.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);    cout &lt;&lt; myscreen.<span class="hljs-built_in">some_member</span>() &lt;&lt; endl;    myscreen.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>);    myscreen.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;#&#x27;</span>);    cout &lt;&lt; myscreen.<span class="hljs-built_in">get</span>() &lt;&lt; endl;    <span class="hljs-function">Screen <span class="hljs-title">myScreen</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;!&#x27;</span>)</span></span>;    <span class="hljs-function"><span class="hljs-type">const</span> Screen <span class="hljs-title">blank</span><span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;?&#x27;</span>)</span></span>;    myScreen.<span class="hljs-built_in">set</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;#&#x27;</span>).<span class="hljs-built_in">display</span>(cout);    cout &lt;&lt; endl;    blank.<span class="hljs-built_in">display</span>(cout);    cout &lt;&lt; endl;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h2 id="构造函数进阶">构造函数进阶</h2><p>构造函数初始值列表：定义变量的时候习惯对其立即进行初始化，有时初始化的值是必不可少的，且要注意成员初始化的顺序。</p><p>委托构造函数：使用它所属类的其他构造函数执行它自己的初始化过程</p><p>默认构造函数</p><p>类类型转换</p><p>聚合类：就是比较简单的结构体</p><p>字面值常量类</p><h2 id="类的静态成员">类的静态成员</h2><p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据</p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy中axis的理解</title>
    <link href="/2022/08/06/ndarray-axis/"/>
    <url>/2022/08/06/ndarray-axis/</url>
    
    <content type="html"><![CDATA[<p>Numpy是个好东西，但是ndarray的轴感觉弄不太明白。可能二维三维数组还好，要是再增加几维就无法在脑海中想象这个东西，对于一些有关轴的操作就稀里糊涂，只能一个个尝试。现在准备把它彻底弄明白！</p><span id="more"></span><h1>思路</h1><p>首先从二维入手，然后扩展到三维以及更高的维度（从特殊到一般），然后找出普遍的规律，再进行验证（从一般到特殊）</p><p>官方文档应该是最权威的，首先看官方文档是怎么说明的，然后查找一些资料，看看其他人是怎么理解的，最后总结出自己的一套规律</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np</code></pre></div><h1>ndarray.shape</h1><p>感受一个ndarray，最简单的方法就是打印ndarray的shape。</p><p>官方文档里面是这样写的：</p><p>the dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension. For a matrix with <em>n</em> rows and <em>m</em> columns, <code>shape</code> will be <code>(n,m)</code>. The length of the <code>shape</code> tuple is therefore the number of axes, <code>ndim</code>.</p><p>只列举了矩阵的例子，尝试一下：</p><div class="code-wrapper"><pre><code class="hljs python">a1 = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<span class="hljs-built_in">print</span>(a1,<span class="hljs-string">&#x27;\n&#x27;</span>,a1.shape,<span class="hljs-string">&#x27;\n&#x27;</span>,a1.ndim)</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs shell">[[ 0  1  2  3  4] [ 5  6  7  8  9] [10 11 12 13 14]]  (3, 5)  2</code></pre></div><ol><li>reshape成什么样，最后打印出来的shape就会是什么样，这一点可以确定。</li><li>官方文档里面写道“对于一个n行m列的矩阵来说，shape将会是(n,m)”。经验证，打印出来了一个3行5列的矩阵，shape是(3,5)。</li><li>官方文档里面写道“shape元组的长度就是轴的数量，也就是ndim”。经验证，ndim=2</li></ol><p>简单推断：最开始有2个方括号，因此矩阵是2维的，且第1个方括号内部有3个“2级方括号”，每一个“2级方括号”内部都有5个元素，因此这个shape可能是从外向里数的。</p><p>尝试1维ndarray：</p><div class="code-wrapper"><pre><code class="hljs python">a2 = np.arange(<span class="hljs-number">15</span>)<span class="hljs-built_in">print</span>(a2,<span class="hljs-string">&#x27;\n&#x27;</span>,a2.shape,<span class="hljs-string">&#x27;\n&#x27;</span>,a2.ndim)</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs shell">[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]  (15,)  1</code></pre></div><ol><li>打印ndim为1，最开始有1个方括号，因此数组是1维的。结论得到验证。</li><li>打印shape为(15,)（一维元组），第1个方括号内部没有“2级方括号”shape从外向里数只有15。结论得到验证。</li></ol><p>尝试3维ndarray：</p><div class="code-wrapper"><pre><code class="hljs python">a3 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<span class="hljs-built_in">print</span>(a3,<span class="hljs-string">&#x27;\n&#x27;</span>,a3.shape,<span class="hljs-string">&#x27;\n&#x27;</span>,a3.ndim)</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs shell">[[[ 0  1  2  3]  [ 4  5  6  7]] [[ 8  9 10 11]  [12 13 14 15]] [[16 17 18 19]  [20 21 22 23]]]  (3, 2, 4)  3</code></pre></div><ol><li>打印ndim为3，最开始有3个方括号，因此数组是3维的。结论得到验证。</li><li>打印shape为(3, 2, 4)，第1个方括号内部有3个“2级方括号”，“2级方括号”内部有2个“3级方括号”，“3级方括号”内部有4个元素。满足shape从外向里数，结论得到验证。</li></ol><p>尝试4维ndarray：</p><div class="code-wrapper"><pre><code class="hljs python">a4 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)<span class="hljs-built_in">print</span>(a4,<span class="hljs-string">&#x27;\n&#x27;</span>,a4.shape,<span class="hljs-string">&#x27;\n&#x27;</span>,a4.ndim)</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs shell">[[[[ 0  1  2  3]]  [[ 4  5  6  7]]] [[[ 8  9 10 11]]  [[12 13 14 15]]] [[[16 17 18 19]]  [[20 21 22 23]]]]  (3, 2, 1, 4)  4</code></pre></div><ol><li>打印ndim为4，最开始有4个方括号，因此数组是4维的。结论得到验证。</li><li>打印shape为(3, 2, 1, 4)，第1个方括号内部有3个“2级方括号”，“2级方括号”内部有2个“3级方括号”，“3级方括号”内部有1个“4级方括号”，“4级方括号”内部有4个元素。满足shape从外向里数，结论得到验证。</li><li>有一个维度是1，也就是这个维度实际上并没有任何的作用。但是在实际中可能会有“凑维度”的操作，需要手动增加或者减少维度，会出现这种维度为1的情况。（增加维度使用reshape()实现，减小维度使用squeeze()实现）</li></ol><p><strong>因此可以得出结论：对于给定的ndarray，判断ndim就是计数最前面有多少个相连的方括号，判断shape就是从外向内看，每一层分别有多少个“元素”。</strong></p><p>也可以看出，数组超过4维后，肉眼就有些难以区分了。</p><h1>索引</h1><p>索引就是取数组中的某些元素，官方文档有下面的举例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = np.arange(<span class="hljs-number">30</span>).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>aarray([[[ <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">2</span>,  <span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],        [ <span class="hljs-number">5</span>,  <span class="hljs-number">6</span>,  <span class="hljs-number">7</span>,  <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>],        [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]],        [[<span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>],        [<span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>],        [<span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>]]])<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, :]array([<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>a[<span class="hljs-number">0</span>, :, <span class="hljs-number">3</span>]array([ <span class="hljs-number">3</span>,  <span class="hljs-number">8</span>, <span class="hljs-number">13</span>])</code></pre></div><p>索引操作是与shape相对应的。如上述例子，a[0]即为取数组的第1个维度（2）的第1个元素，这样原来3维的数组就降到了2维；a[0, :]就是在a[0]的基础上取数组的第2个维度（3）的全部元素，数组的维度不变，还是2维；a[0, :, 3]就是在a[0, :]的基础上取数组的第3个维度（5）的第4个元素，即可得出上面的结果。</p><p><strong>索引操作后的维度与索引的数量以及是否有“:”相关。如果索引的数量与ndim相同，则最后取出来的是一个数。如果数量不同或者有“:”（数量不同可以看成在后面补“:”），则最终取得的数组的维度与“:”对应的原数组的维度相同。</strong></p><h1>轴</h1><p>以numpy.sum为例：</p><p>官方文档：</p><p>Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</p><p>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</p><p>以三维数组为例：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;origin&#x27;</span>)<span class="hljs-built_in">print</span>(a3,a3.shape)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;axis=0&#x27;</span>)<span class="hljs-built_in">print</span>(a3.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>),a3.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">0</span>).shape)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;axis=1&#x27;</span>)<span class="hljs-built_in">print</span>(a3.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>),a3.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">1</span>).shape)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;axis=2&#x27;</span>)<span class="hljs-built_in">print</span>(a3.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">2</span>),a3.<span class="hljs-built_in">sum</span>(axis=<span class="hljs-number">2</span>).shape)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;axis=(0,1)&#x27;</span>)<span class="hljs-built_in">print</span>(a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)),a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)).shape)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;axis=(1,2)&#x27;</span>)<span class="hljs-built_in">print</span>(a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)),a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)).shape)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;axis=(0,2)&#x27;</span>)<span class="hljs-built_in">print</span>(a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)),a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)).shape)<span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;axis=(0,1,2)&#x27;</span>)<span class="hljs-built_in">print</span>(a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)),a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)).shape)</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">origin[[[ 0  1  2  3]  [ 4  5  6  7]] [[ 8  9 10 11]  [12 13 14 15]] [[16 17 18 19]  [20 21 22 23]]] (3, 2, 4)axis=0[[24 27 30 33] [36 39 42 45]] (2, 4)axis=1[[ 4  6  8 10] [20 22 24 26] [36 38 40 42]] (3, 4)axis=2[[ 6 22] [38 54] [70 86]] (3, 2)axis=(0,1)[60 66 72 78] (4,)axis=(1,2)[ 28  92 156] (3,)axis=(0,2)[114 162] (2,)axis=(0,1,2)276 ()</code></pre></div><p><strong>axis为多少，就是在这个维度上进行操作，最终的结果就是这个维度消失</strong></p><p>不要从行列什么的去思考怎么变化，直接从shape的角度入手。设置axis为多少，这个维度就没有了！比如原来是(3,2,4)的维度，要是axis=0，第一个维度就没有了，加和得到的矩阵就是(2,4)。</p><p>如果希望保留维度，可以增加keepdims=True的选项，这样被操作的维度就会变为1而不是直接消失。</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;axis=(0,1)&#x27;</span>)<span class="hljs-built_in">print</span>(a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),keepdims=<span class="hljs-literal">True</span>),a3.<span class="hljs-built_in">sum</span>(axis=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),keepdims=<span class="hljs-literal">True</span>).shape)</code></pre></div><div class="code-wrapper"><pre><code class="hljs lua">axis=(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<span class="hljs-string">[[[60 66 72 78]]</span>] (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</code></pre></div><p>这样想应该会比较好理解，尤其是对于更高维的数组来说，行列的概念基本失效，从shape的角度思考会好。</p><h2 id="np-concatenate">np.concatenate</h2><p>另外一个比较常用的操作是np.concatenate，可以将数组进行合并，在数据处理或者神经网络中很常用。</p><p>在np.concatenate上检验一下对于axis的理解：</p><div class="code-wrapper"><pre><code class="hljs python">ta = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)tb = np.arange(<span class="hljs-number">24</span>,<span class="hljs-number">36</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)<span class="hljs-built_in">print</span>(ta,ta.shape)<span class="hljs-built_in">print</span>(tb,tb.shape)</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">[[[ 0  1  2  3]  [ 4  5  6  7]] [[ 8  9 10 11]  [12 13 14 15]] [[16 17 18 19]  [20 21 22 23]]] (3, 2, 4)[[[24 25 26 27]] [[28 29 30 31]] [[32 33 34 35]]] (3, 1, 4)</code></pre></div><p>两者合并，第2个维度不相同，应该是可以合并的，合并后的shape应该为(3,3,4)</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.concatenate((ta,tb),axis=<span class="hljs-number">1</span>),np.concatenate((ta,tb),axis=<span class="hljs-number">1</span>).shape)</code></pre></div><div class="code-wrapper"><pre><code class="hljs shell">[[[ 0  1  2  3]  [ 4  5  6  7]  [24 25 26 27]] [[ 8  9 10 11]  [12 13 14 15]  [28 29 30 31]] [[16 17 18 19]  [20 21 22 23]  [32 33 34 35]]] (3, 3, 4)</code></pre></div><p><strong>np.concatenate除了在待合并的axis上之外，必须具有相同的shape</strong></p><p>之前的结论也得到了验证。</p><h1>总结</h1><p>我们处在三维空间中，二维和三维是比较直观的，可以在脑海中想象出来。因此我们会觉得axis的设计有些反直觉。以后应该从shape的角度去看待axis的设计思想，首先理解上比较直观，其次在更高维度的数组上也能合理的进行操作。不要去思考数组实际中应该是个什么样子，直接观察axis就足够了。</p><h1>参考资料</h1><p><a href="https://zhangzhao219.github.io/file/ndarray-axis.ipynb" title="Code for Numpy axis">Code</a></p><p><a href="https://numpy.org/doc/" title="Numpy官方文档">Numpy官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unsupervised Learning, Recommenders, Reinforcement Learning</title>
    <link href="/2022/08/04/Coursera/Unsupervised-Learning-Recommenders-Reinforcement-Learning/"/>
    <url>/2022/08/04/Coursera/Unsupervised-Learning-Recommenders-Reinforcement-Learning/</url>
    
    <content type="html"><![CDATA[<p>机器学习-无监督学习，推荐系统与强化学习</p><span id="more"></span><h1>课程简介</h1><p>In the third course of the Machine Learning Specialization, you will:</p><p>• Use unsupervised learning techniques for unsupervised learning: including clustering and anomaly detection.<br>• Build recommender systems with a collaborative filtering approach and a content-based deep learning method.<br>• Build a deep reinforcement learning model.</p><p>The Machine Learning Specialization is a foundational online program created in collaboration between <a href="http://DeepLearning.AI">DeepLearning.AI</a> and Stanford Online. In this beginner-friendly program, you will learn the fundamentals of machine learning and how to use these techniques to build real-world AI applications.</p><p>This Specialization is taught by Andrew Ng, an AI visionary who has led critical research at Stanford University and groundbreaking work at Google Brain, Baidu, and <a href="http://Landing.AI">Landing.AI</a> to advance the AI field.</p><p>This 3-course Specialization is an updated and expanded version of Andrew’s pioneering Machine Learning course, rated 4.9 out of 5 and taken by over 4.8 million learners since it launched in 2012.</p><p>It provides a broad introduction to modern machine learning, including supervised learning (multiple linear regression, logistic regression, neural networks, and decision trees), unsupervised learning (clustering, dimensionality reduction, recommender systems), and some of the best practices used in Silicon Valley for artificial intelligence and machine learning innovation (evaluating and tuning models, taking a data-centric approach to improving performance, and more.)</p><p>By the end of this Specialization, you will have mastered key concepts and gained the practical know-how to quickly and powerfully apply machine learning to challenging real-world problems. If you’re looking to break into AI or build a career in machine learning, the new Machine Learning Specialization is the best place to start.</p><h1>无监督学习</h1><p>无监督学习是在没有标签的数据中自动寻找某些规律</p><p>聚类任务是典型的无监督学习任务，通过某些特征将相似的人或事物自动归为一类</p><p>无监督学习任务还有异常检测（找出一些不寻常的数据）和维度降低（使用更少的数字对数据进行压缩）</p><h2 id="聚类">聚类</h2><p>聚类是一种典型的无监督学习算法，不定义标签，让算法自己去寻找数据中有趣的特征</p><p>聚类可以在下面几个方面得到应用：</p><ol><li>找出比较相似的新闻</li><li>对用户或者市场进行分析</li><li>分析DNA</li><li>分析宇宙数据</li></ol><p>K-means聚类步骤：</p><ol><li>随机初始化<img src="https://math.now.sh?inline=K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个中心点<img src="https://math.now.sh?inline=%5Cmu_1%2C%5Cmu_2%2C%5Ccdots%2C%5Cmu_K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（<img src="https://math.now.sh?inline=K" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>预先定义）</li><li>计算其余的点与中心点的距离，与最近的中心点归为一类</li><li>更改中心点为类别中所有点的平均值</li><li>迭代上述步骤直到所有点的类别不再变化</li></ol><p>如何决定聚类的数量？Elbow method</p><p>多种聚类数量都尝试一下，找到“肘点”，也就是增加聚类数量后代价函数也不能明显减小的点</p><p>如何随机初始化最初的类别中心点？</p><ol><li>随机选择几个训练样本作为中心点</li><li>随机选取中心点多次，运行一轮算法，寻找代价最小的作为初始化的中心点</li></ol><h2 id="异常检测">异常检测</h2><p>已经拥有一些数据，增加一条数据，判断其是否符合已有的数据的特征，如果不符合则为异常数据</p><p>正态分布：<img src="https://math.now.sh?inline=p%28x%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%5Cpi%7D%5Csigma%7De%5E%7B%5Cfrac%7B-(x-%5Cmu)%5E2%7D%7B2%5Csigma%5E2%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>异常检测：<img src="https://math.now.sh?inline=p%28x%29%3D%5Cprod_%7Bj%3D1%7D%5E%7Bn%7Dp(x_j%3B%5Cmu_j%2C%5Csigma_j%5E2)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，计算点的<img src="https://math.now.sh?inline=p%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是否满足大于预先定义的阈值<img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>实际应用中，可以找一些有标记的异常点，指导算法选取合适的阈值<img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>在某种类别（异常）的数据量很少的情况下，且异常的种类较多，特征无法很好区分出来的时候，使用异常检测算法比较好。</p><h1>推荐系统</h1><p>场景：很多用户对电影进行打分，分数从0-5，如何向用户推荐合适的电影？</p><p>设用户的数量为<img src="https://math.now.sh?inline=n_u" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，电影的数量为<img src="https://math.now.sh?inline=n_m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>如果用户<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对电影<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>进行了打分，那么<img src="https://math.now.sh?inline=r%28i%2Cj%29%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，反之<img src="https://math.now.sh?inline=r%28i%2Cj%29%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p><img src="https://math.now.sh?inline=y%28i%2Cj%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示用户<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对电影<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>打分的分数（0-5）</p><p><img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示电影的特征数量（如浪漫程度、武打程度等等），则用户<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对应的特征向量为<img src="https://math.now.sh?inline=x%5E%7B%28j%29%7D%3D%5Cleft%5B%5Cbegin%7Bmatrix%7Dx_1%5E%7B(j)%7D%5C%5Cx_2%5E%7B(j)%7D%5C%5C%5Cvdots%5C%5Cx_%7Bn%7D%5E%7B(j)%7D%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=m%5E%7B%28j%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示的是用户<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>打分的电影数目</p><p>预测用户<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对电影<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的打分：<img src="https://math.now.sh?inline=w%5E%7B%28j%29%7D%5Ccdot%20x%5E%7B(i)%7D%2Bb%5E%7B(j)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>代价函数：<img src="https://math.now.sh?inline=J%28w%5E%7B(j%29%7D%2Cb%5E%7B(j)%7D)%3D%5Cfrac%7B1%7D%7B2m%5E%7B(j)%7D%7D%5Csum_%7Bi%3Ar(i%2Cj)%3D1%7D%7B(w%5E%7B(j)%7D%20%5Ccdot%20x%5E%7B(i)%7D%2Bb%5E%7B(j)%7D-y%5E%7B(i%2Cj)%7D)%5E2%7D%2B%5Cfrac%7B%5Clambda%7D%7B2m%5E%7B(j)%7D%7D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%7B(w_k%5E%7B(j)%7D)%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>对所有用户来说，<img src="https://math.now.sh?inline=J%28w%5E%7B(1%29%7D%2Cw%5E%7B(2)%7D%2C%5Ccdots%2Cw%5E%7B(n_u)%7D%2Cb%5E%7B(1)%7D%2Cb%5E%7B(2)%7D%2C%5Ccdots%2Cb%5E%7B(n_u)%7D)%3D%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bj%3D1%7D%5E%7Bn_u%7D%5Csum_%7Bi%3Ar(i%2Cj)%3D1%7D%7B(w%5E%7B(j)%7D%20%5Ccdot%20x%5E%7B(i)%7D%2Bb%5E%7B(j)%7D-y%5E%7B(i%2Cj)%7D)%5E2%7D%2B%5Cfrac%7B%5Clambda%7D%7B2%7D%5Csum_%7Bj%3D1%7D%5E%7Bn_u%7D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%7B(w_k%5E%7B(j)%7D)%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=m%5E%7B%28j%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是定值，忽略不计</p><h2 id="协同过滤算法">协同过滤算法</h2><p>前面是有特征，通过类似于线性回归的方式可以进行预测，但是如果没有特征应该怎么做呢？</p><p>已知<img src="https://math.now.sh?inline=w%5E%7B%281%29%7D%2Cw%5E%7B(2)%7D%2C%5Ccdots%2Cw%5E%7B(n_u)%7D%2Cb%5E%7B(1)%7D%2Cb%5E%7B(2)%7D%2C%5Ccdots%2Cb%5E%7B(n_u)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，预测<img src="https://math.now.sh?inline=x%5E%7B%28i%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>代价函数：<img src="https://math.now.sh?inline=J%28x%5E%7B(1%29%7D%2Cx%5E%7B(2)%7D%2C%5Ccdots%2Cx%5E%7B(n_m)%7D)%3D%5Cfrac%7B1%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5E%7Bn_m%7D%5Csum_%7Bj%3Ar(i%2Cj)%3D1%7D%7B(w%5E%7B(j)%7D%20%5Ccdot%20x%5E%7B(i)%7D%2Bb%5E%7B(j)%7D-y%5E%7B(i%2Cj)%7D)%5E2%7D%2B%5Cfrac%7B%5Clambda%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5E%7Bn_m%7D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%7B(x_k%5E%7B(i)%7D)%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>将两个代价函数结合到一起：<img src="https://math.now.sh?inline=J%28w%2Cb%2Cx%29%3D%5Cfrac%7B1%7D%7B2%7D%5Csum_%7B(i%2Cj)%3Ar(i%2Cj)%3D1%7D%7B(w%5E%7B(j)%7D%20%5Ccdot%20x%5E%7B(i)%7D%2Bb%5E%7B(j)%7D-y%5E%7B(i%2Cj)%7D)%5E2%7D%2B%5Cfrac%7B%5Clambda%7D%7B2%7D%5Csum_%7Bi%3D1%7D%5E%7Bn_m%7D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%7B(x_k%5E%7B(i)%7D)%5E2%7D%2B%5Cfrac%7B%5Clambda%7D%7B2%7D%5Csum_%7Bj%3D1%7D%5E%7Bn_u%7D%5Csum_%7Bk%3D1%7D%5E%7Bn%7D%7B(w_k%5E%7B(j)%7D)%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>如果评分是二值化的，则类似于线性回归与逻辑回归的区别：</p><p><img src="https://math.now.sh?inline=f_%7B%28w%2Cb%2Cx%29%7D(x)%3Dg(w%5E%7B(j)%7D%20%5Ccdot%20x%5E%7B(i)%7D%2Bb%5E%7B(j)%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=L%28f_%7Bw%2Cb%2Cx%7D(x%29%2Cy%5E%7B(i%2Cj)%7D)%3D-y%5E%7B(i%2Cj)%7Dlog%7B(f_%7Bw%2Cb%2Cx%7D(x))%7D-(1-y%5E%7B(i%2Cj)%7D)log%7B(1-f_%7Bw%2Cb%2Cx%7D(x))%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=J%28w%2Cb%2Cx%29%3D%5Csum_%7B(i%2Cj)%3Ar(i%2Cj)%3D1%7D%7BL(f_%7Bw%2Cb%2Cx%7D(x)%2Cy%5E%7B(i%2Cj)%7D)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>如果一个人没有对任何电影进行评分，则选取其他所有人的评分平均值作为他的评分。</p><p>协同过滤算法的局限性：</p><ol><li>对于新加进来的事物不太好办，没有办法与其他的一起排名，且推荐后有一点讲不出道理</li><li>不能使用一些已有的其他特征</li></ol><h2 id="基于内容的过滤算法">基于内容的过滤算法</h2><p>协同过滤算法是基于用户的评分，根据比较相似的评分情况来进行推荐</p><p>基于内容的过滤算法是基于用户和物品的特征来寻找比较合适的匹配对</p><p>设用户<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对应的特征是<img src="https://math.now.sh?inline=x_u%5E%7B%28j%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，电影<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对应的特征是<img src="https://math.now.sh?inline=x_m%5E%7B%28i%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>比较两个特征之间相似度的方法是点乘，但是两者的维度不同，因此要对输入的特征增加几层神经网络，使其输出相同，再进行点乘。</p><p>通过神经网络后，<img src="https://math.now.sh?inline=v_u%5E%7B%28j%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<img src="https://math.now.sh?inline=x_u%5E%7B%28j%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的32维向量，<img src="https://math.now.sh?inline=v_m%5E%7B%28j%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是<img src="https://math.now.sh?inline=x_m%5E%7B%28i%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的32维向量，</p><p>代价函数为：：<img src="https://math.now.sh?inline=J%3D%5Csum_%7B%28i%2Cj%29%3Ar(i%2Cj)%3D1%7D%7B(v_u%5E%7B(j)%7D%20%5Ccdot%20v_m%5E%7B(j)%7D-y%5E%7B(i%2Cj)%7D)%5E2%7D%2B%E6%AD%A3%E5%88%99%E9%A1%B9" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="大型推荐系统">大型推荐系统</h2><p>检索和排序策略：</p><ol><li>检索策略会从大规模中选择可信的候选者，如对于电影来说找这个国家最流行的20个电影等等，然后汇总、去重</li><li>然后对去重后的列表使用算法进行排序，按照排名的先后顺序向用户推荐。</li></ol><h1>强化学习</h1><p>强化学习不告诉应该怎么做，而是只告诉做什么，如果做的好有奖励，做的不好有惩罚，从而让算法自动向着奖赏最多的方向优化，最终学习出最好的结果。</p><p>目前的状态、动作、奖励、下一个状态，下一个状态的动作<img src="https://math.now.sh?inline=%28s%2Ca%2CR(s%29%2Cs%5E%7B'%7D%2Ca%5E%7B'%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>每一个时间步后，会有一个权重<img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，最终的返回值（Return）是权重<img src="https://math.now.sh?inline=%5Cgamma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与奖励<img src="https://math.now.sh?inline=R%28s%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的乘积</p><p>一般来说，权重按照幂的方式变化，如第一步是<img src="https://math.now.sh?inline=%5Cgamma%5E1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，第二步是<img src="https://math.now.sh?inline=%5Cgamma%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，第<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>步是<img src="https://math.now.sh?inline=%5Cgamma%5En" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>措施<img src="https://math.now.sh?inline=%5Cpi%28s%29%3Da" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>指的是在状态<img src="https://math.now.sh?inline=s" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>应该采取什么样的动作<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>强化学习的目标就是找到合适的措施<img src="https://math.now.sh?inline=%5Cpi%28s%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>从而最大化返回的奖励（Return）</p><p>马尔可夫决策过程：未来只取决于现在所处的位置，与之前是怎么到达现在这个位置的无关。</p><p>状态-动作方程：<img src="https://math.now.sh?inline=Q%28s%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示从状态<img src="https://math.now.sh?inline=s" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>开始进行动作<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，然后后面采取最优化的动作</p><p>因此，可以得出两个结论：</p><ol><li>从状态<img src="https://math.now.sh?inline=s" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>开始的最佳的返回奖励是<img src="https://math.now.sh?inline=max_aQ%28s%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>从状态<img src="https://math.now.sh?inline=s" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>开始的最好的动作是能达到<img src="https://math.now.sh?inline=max_aQ%28s%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的动作<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li></ol><p>贝尔曼方程：<img src="https://math.now.sh?inline=Q%28s%2Ca%29%3DR(s)%2B%5Cgamma%5Ccdot%20max_%7Ba%7B'%7D%7DQ(s%7B'%7D%2Ca%7B'%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>在更为复杂的环境下，状态之间的转移可能并不是确定的，有一定的几率到达其他的状态</p><p>因此得到的返回奖励实际上是<strong>期望的</strong>返回奖励，即<img src="https://math.now.sh?inline=Q%28s%2Ca%29%3DR(s)%2B%5Cgamma%5Ccdot%20E%5Bmax_%7Ba%7B'%7D%7DQ(s%7B'%7D%2Ca%7B'%7D)%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>状态空间可能是连续的，对于月球车来说，有方向（前后左右和旋转）和速度两种变量，因此<img src="https://math.now.sh?inline=s%3D%5Cleft%5B%5Cbegin%7Bmatrix%7Dx%5C%5Cy%5C%5C%5Ctheta%5C%5C%5Cdot%7Bx%7D%5C%5C%5Cdot%7By%7D%5C%5C%5Cdot%7B%5Ctheta%7D%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="强化学习神经网络（DQN）">强化学习神经网络（DQN）</h2><p>训练神经网络：输入是<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Bmatrix%7Ds%5C%5Ca%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，输出目的是找到最合适的动作<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>使得<img src="https://math.now.sh?inline=Q%28s%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最大。其中，神经网络的最后一层输出的神经元数量可以修改为<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的数量，就可以对所有可能情况的<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>进行同时训练。</p><p>训练步骤：</p><ol><li>随意进行一个动作，得到<img src="https://math.now.sh?inline=%28s%2Ca%2CR(s%29%2Cs%5E%7B'%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>采集大量的<img src="https://math.now.sh?inline=%28s%2Ca%2CR(s%29%2Cs%5E%7B'%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>使用<img src="https://math.now.sh?inline=%28s%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>作为输入，<img src="https://math.now.sh?inline=R%28s%29%2B%5Cgamma%5Ccdot%20max_%7Ba%7B'%7D%7DQ(s%7B'%7D%2Ca%7B'%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>作为输出训练<img src="https://math.now.sh?inline=Q_%7Bnew%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>使得<img src="https://math.now.sh?inline=Q_%7Bnew%7D%28s%2Ca%29%5Capprox%20y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></li><li>令<img src="https://math.now.sh?inline=Q%3DQ_%7Bnew%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，重复上述步骤</li></ol><h2 id="算法优化">算法优化</h2><p><img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>-贪心策略：在DQN的第一步中，以<img src="https://math.now.sh?inline=%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的概率随意选取，以<img src="https://math.now.sh?inline=1-%5Cepsilon" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的概率选取能使<img src="https://math.now.sh?inline=Q%28s%2Ca%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最大化的<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>mini-batch：在<img src="https://math.now.sh?inline=%28s%2Ca%2CR(s%29%2Cs%5E%7B'%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>只选取一部分进行训练</p><p>soft update：<img src="https://math.now.sh?inline=Q%3DQ_%7Bnew%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>步骤中，并不直接修改，而是使用权重对新旧参数进行组合</p><h2 id="强化学习的现状">强化学习的现状</h2><ol><li>用于实验室模拟的效果比较好，实际中有些困难</li><li>目前的应用比监督学习或者无监督学习要少很多</li><li>在未来应用上还是有很大的潜力的</li></ol><h1>资料</h1><h2 id="第一周课件">第一周课件</h2><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/C3_W1.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="第二周课件">第二周课件</h2><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/C3_W2.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="第三周课件和代码">第三周课件和代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/Notebooks-W3.zip" title="Notebooks Week 3 for Unsupervised Learning, Recommenders, Reinforcement Learning">Notebooks Week 3</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/C3_W3.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="作业代码">作业代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/Exercises-W1-1.zip" title="Exercise 1 for Unsupervised Learning, Recommenders, Reinforcement Learning">Exercise 1</a></p><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/Exercises-W1-2.zip" title="Exercise 2 for Unsupervised Learning, Recommenders, Reinforcement Learning">Exercise 2</a></p><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/Exercises-W2-1.zip" title="Exercise 3 for Unsupervised Learning, Recommenders, Reinforcement Learning">Exercise 3</a></p><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/Exercises-W2-2.zip" title="Exercise 4 for Unsupervised Learning, Recommenders, Reinforcement Learning">Exercise 4</a></p><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Unsupervised-Learning-Recommenders-Reinforcement-Learning/Exercises-W3.zip" title="Exercise 5 for Unsupervised Learning, Recommenders, Reinforcement Learning">Exercise 5</a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Advanced Learning Algorithms</title>
    <link href="/2022/08/01/Coursera/Advanced-Learning-Algorithms/"/>
    <url>/2022/08/01/Coursera/Advanced-Learning-Algorithms/</url>
    
    <content type="html"><![CDATA[<p>机器学习-高级学习算法</p><span id="more"></span><h1>课程简介</h1><p>In the second course of the Machine Learning Specialization, you will:</p><p>• Build and train a neural network with TensorFlow to perform multi-class classification<br>• Apply best practices for machine learning development so that your models generalize to data and tasks in the real world<br>• Build and use decision trees and tree ensemble methods, including random forests and boosted trees</p><p>The Machine Learning Specialization is a foundational online program created in collaboration between <a href="http://DeepLearning.AI">DeepLearning.AI</a> and Stanford Online. In this beginner-friendly program, you will learn the fundamentals of machine learning and how to use these techniques to build real-world AI applications.</p><p>This Specialization is taught by Andrew Ng, an AI visionary who has led critical research at Stanford University and groundbreaking work at Google Brain, Baidu, and <a href="http://Landing.AI">Landing.AI</a> to advance the AI field.</p><p>This 3-course Specialization is an updated and expanded version of Andrew’s pioneering Machine Learning course, rated 4.9 out of 5 and taken by over 4.8 million learners since it launched in 2012.</p><p>It provides a broad introduction to modern machine learning, including supervised learning (multiple linear regression, logistic regression, neural networks, and decision trees), unsupervised learning (clustering, dimensionality reduction, recommender systems), and some of the best practices used in Silicon Valley for artificial intelligence and machine learning innovation (evaluating and tuning models, taking a data-centric approach to improving performance, and more.)</p><p>By the end of this Specialization, you will have mastered key theoretical concepts and gained the practical know-how to quickly and powerfully apply machine learning to challenging real-world problems. If you’re looking to break into AI or build a career in machine learning, the new Machine Learning Specialization is the best place to start.</p><h1>生物神经网络</h1><p>生物神经元：通过树突接收到来自不同地方的输入，然后通过轴突将神经冲动传递出去。</p><p>但是目前对于人脑的运作方式了解的还不是很透彻。</p><h1>Tensorflow搭建神经网络</h1><ol><li>定义神经网络：</li></ol><div class="code-wrapper"><pre><code class="hljs python">model = Sequential(    [           tf.keras.Input(shape=(<span class="hljs-number">400</span>,)),    <span class="hljs-comment">#specify input size</span>        tf.keras.layers.Dense(<span class="hljs-number">25</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>),        tf.keras.layers.Dense(<span class="hljs-number">15</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>),        tf.keras.layers.Dense(<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>)    ], name = <span class="hljs-string">&quot;my_model&quot;</span> )</code></pre></div><ol start="2"><li>训练神经网络</li></ol><div class="code-wrapper"><pre><code class="hljs python">model.<span class="hljs-built_in">compile</span>(    loss=tf.keras.losses.BinaryCrossentropy(),    optimizer=tf.keras.optimizers.Adam(<span class="hljs-number">0.001</span>),)model.fit(    X,y,    epochs=<span class="hljs-number">20</span>)</code></pre></div><ol start="3"><li>预测</li></ol><div class="code-wrapper"><pre><code class="hljs python">prediction = model.predict(X[<span class="hljs-number">0</span>].reshape(<span class="hljs-number">1</span>,<span class="hljs-number">400</span>))  <span class="hljs-comment"># a zero</span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; predicting a zero: <span class="hljs-subst">&#123;prediction&#125;</span>&quot;</span>)prediction = model.predict(X[<span class="hljs-number">500</span>].reshape(<span class="hljs-number">1</span>,<span class="hljs-number">400</span>))  <span class="hljs-comment"># a one</span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; predicting a one:  <span class="hljs-subst">&#123;prediction&#125;</span>&quot;</span>)</code></pre></div><h1>Python搭建神经网络</h1><ol><li>定义网络层</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_dense_v</span>(<span class="hljs-params">A_in, W, b, g</span>):    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    Computes dense layer</span><span class="hljs-string">    Args:</span><span class="hljs-string">      A_in (ndarray (m,n)) : Data, m examples, n features each</span><span class="hljs-string">      W    (ndarray (n,j)) : Weight matrix, n features per unit, j units</span><span class="hljs-string">      b    (ndarray (1,j)) : bias vector, j units  </span><span class="hljs-string">      g    activation function (e.g. sigmoid, relu..)</span><span class="hljs-string">    Returns</span><span class="hljs-string">      A_out (ndarray (m,j)) : m examples, j units</span><span class="hljs-string">    &quot;&quot;&quot;</span>    z = np.matmul(A_in,W)+b    A_out = g(z)    <span class="hljs-keyword">return</span>(A_out)</code></pre></div><ol start="2"><li>组合不同的层</li></ol><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_sequential_v</span>(<span class="hljs-params">X, W1, b1, W2, b2, W3, b3</span>):    A1 = my_dense_v(X,  W1, b1, sigmoid)    A2 = my_dense_v(A1, W2, b2, sigmoid)    A3 = my_dense_v(A2, W3, b3, sigmoid)    <span class="hljs-keyword">return</span>(A3)</code></pre></div><ol start="3"><li>预测</li></ol><div class="code-wrapper"><pre><code class="hljs python">Prediction = my_sequential_v(X, W1_tmp, b1_tmp, W2_tmp, b2_tmp, W3_tmp, b3_tmp )Prediction.shape</code></pre></div><h1>通用人工智能（AGI）</h1><p>人工智能（AI）可以分为两种，ANI和AGI：</p><p>ANI指在某一特定领域应用的人工智能，目前已经取得了很好的效果；</p><p>AGI指通用人工智能，人工智能可以做任何人类可以做到的事情。</p><p>鉴于对人脑的了解还不够，如果通过模拟人脑的方式达到通用人工智能比较困难。</p><p>不过目前有一些进展，让通用人工智能看到了一点点希望。</p><h1>训练神经网络</h1><ol><li>决定输入变量、模型的数学形式、参数以及最终输出的结果形式</li><li>定义损失函数和代价函数（损失函数是针对一个训练样本而言的，代价函数是结合全部训练数据的损失函数得来的）</li><li>在数据上使用某种方法（如梯度下降法）进行训练，从而使代价函数最小</li></ol><h1>激活函数</h1><p>如果不使用激活函数，那么不管多么复杂的神经网络都会退化成线性回归方法可以实现的效果。</p><p>Sigmoid激活函数：<img src="https://math.now.sh?inline=g%28z%29%3D%5Cfrac%7B1%7D%7B1%2Be%5E%7B-z%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>ReLU激活函数：<img src="https://math.now.sh?inline=g%28z%29%3Dmax(0%2Cz)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>如何选择<strong>输出层</strong>的激活函数：</p><ol><li>二分类问题，选择Sigmiod激活函数</li><li>线性回归问题不使用激活函数，如果确保没有负数值出现，可以使用ReLU激活函数</li></ol><p><strong>隐藏层中大多数使用ReLU激活函数而非Sigmoid激活函数</strong></p><ol><li>ReLU激活函数比Sigmoid激活函数计算更快</li><li>ReLU激活函数与x轴平行的部分更少，使用梯度下降算法运行更快</li></ol><h1>多类别分类</h1><p>多类别分类是指输出不止两种情况的分类问题，如对手写数字进行分类，输出的类别会有10个</p><p>可以使用Softmax回归算法：</p><p><img src="https://math.now.sh?inline=z_j%3D%5Cvec%7Bw_j%7D%5Ccdot%5Cvec%7Bx%7D%2Bb_j%2Cj%3D1%2C2%2C%5Ccdots%2CN" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=a_j%3D%5Cfrac%7Be%5E%7Bz_j%7D%7D%7B%5Csum_%7Bk%3D1%7D%5E%7BN%7D%7Be%5E%7Bz_k%7D%7D%7D%3DP%28y%3Dj%7C%5Cvec%7Bx%7D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>损失函数：<img src="https://math.now.sh?inline=Loss%28a_1%2Ca_2%2C%5Ccdots%2Ca_N%2Cy%29%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bc%7D-%5Clog%7Ba_1%7D%5C%2Cif%5C%2Cy%3D1%5C%5C-%5Clog%7Ba_2%7D%5C%2Cif%5C%2Cy%3D2%5C%5C%5Cvdots%5C%5C-%5Clog%7Ba_N%7D%5C%2Cif%5C%2Cy%3DN%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，也就是<img src="https://math.now.sh?inline=Loss%3D-%5Clog%7Ba_j%7D%5C%2Cif%5C%2Cy%3Dj" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>多标签分类：可以看成很多多类别分类问题，也可以使用一个神经网络预测所有的类别</p><h1>优化方法</h1><p>Adam优化方法：自动调节学习率</p><p>如果梯度下降的方向一直是同一方向则增大学习率，让算法运行更快</p><p>如果梯度下降的方向一直在波动，则减小学习率。</p><h1>机器学习问题诊断</h1><p>如果发现训练好的模型在预测上存在很大的问题，可以从以下几个方面入手查找原因：</p><ol><li>采集更多的训练样本——高方差</li><li>尝试减小特征数目——高方差</li><li>尝试增加额外的特征——高偏差</li><li>尝试增加一些其他多项式的特征，如<img src="https://math.now.sh?inline=x_1%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>、<img src="https://math.now.sh?inline=x_2%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>、<img src="https://math.now.sh?inline=x_1x_2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>等等——高偏差</li><li>尝试增加或减少正则项<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>——高方差、高偏差</li></ol><p>训练时对训练集进行划分，可以划分为训练集和测试集，如果希望使用交叉验证的方式，可以划分为训练集、验证集和测试集。通过测试集的表型评估模型的效果。模型的选择上，可以从多项式的次数从低到高依次进行选择，找出测试集误差最小的模型。</p><p>更大规模的神经网络的偏差往往更小</p><p>如果恰当选择正则化参数，更大规模的神经网络的表现比小规模的神经网络表现更好</p><h1>偏差和方差</h1><p>欠拟合：函数对于训练集的拟合效果不好——高偏差（high bias）</p><p>过拟合：函数对于训练集的拟合效果好，对于测试集的效果不好——高方差（high variance）</p><p>避免过拟合的方法：</p><ol><li>收集更多的训练数据</li><li>从全部的特征中挑选最相关的特征进行训练</li><li>正则化——减小某一参数对拟合函数的影响</li></ol><p>正则项参数<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>对模型的影响</p><ol><li>太大的<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>导致模型的训练集拟合效果不好——高偏差（high bias）</li><li>太小的<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>导致模型对于训练集的拟合效果好，对于测试集的效果不好——高方差（high variance）</li></ol><p>学习曲线：</p><ol><li>正常的学习曲线，随着训练集样本数量的增加，训练集的误差会逐渐增大，验证集的误差会逐渐减小，但是验证集的误差会始终大于训练集的误差</li><li>如果一个模型偏差比较大，增加更多的训练数据不会帮助提升效果</li><li>如果一个模型的方差比较大，可以考虑增加更多的训练数据</li></ol><p>评价分类（尤其针对分布不平衡的数据）</p><p><img src="https://math.now.sh?inline=precision%3D%5Cfrac%7Btrue%5C%2Cpositives%7D%7Btotal%5C%2Cpredicted%5C%2Cpositive%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=recall%3D%5Cfrac%7Btrue%5C%2Cpositives%7D%7Btotal%5C%2Cactual%5C%2Cpositive%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=F1%5C%2Cscore%3D%5Cfrac%7B2*precision*recall%7D%7Bprecison%2Brecall%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>决策树</h1><p>熵（Entropy）<img src="https://math.now.sh?inline=H%28p_1%29%3D-p_1%5Clog%7Bp_1%7D-(1-p_1)%5Clog%7B(1-p_1)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>信息增益<img src="https://math.now.sh?inline=%3DH%28p_1%5E%7Broot%7D%29-(w%5E%7Bleft%7DH(p_1%5E%7Bleft%7D)%2Bw%5E%7Bright%7DH(p_1%5E%7Bright%7D))" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><ol><li>在根结点处使用所有的数据示例</li><li>对每一种可能的分类方式计算信息增益，选择信息增益最高的分类方式</li><li>使用上一步选择的分类方式对数据进行划分，划分成为左子树和右子树</li><li>重复上述的操作，直到①某一个节点仅有一种类别②决策树高度超过阈值③信息增益小于阈值</li></ol><p>如果一个决策结点有三个可选项，可以通过独热编码的方式将其转换为多个二分类形式。</p><p>如果变量是连续的数值，可以计算从那里开始划分的信息增益最高，从而转化为判断大小于的二分类形式。</p><p>决策树解决回归问题，则将熵替换为节点上数据的方差进行计算。</p><p>随机森林：</p><ol><li>有放回采样训练数据，并且分别使用采样后的训练数据训练决策树</li><li>为了使决策树的决策结点不完全相同，每一次选取特征的时候只选取一部分子集的特征</li><li>最后使用投票法确定最终的分类</li></ol><p>XGBoost：采样训练数据的时候更倾向于采样前面的树中被分类错误的数据</p><p>决策树更适用于结构化的数据，快速，但是不适用于其他类似于图片文本等的数据</p><p>神经网络适用于所有类型的数据，运行可能稍慢一些，可以迁移学习，更适合将不同的神经网络结合到一起。</p><h1>资料</h1><h2 id="第一周课件和代码">第一周课件和代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/Notebooks-W1.zip" title="Notebooks Week 1 for Advanced Learning Algorithms">Notebooks Week 1</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/C2_W1.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="第二周课件和代码">第二周课件和代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/Notebooks-W2.zip" title="Notebooks Week 2 for Advanced Learning Algorithms">Notebooks Week 2</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/C2_W2.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="第三周课件">第三周课件</h2><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/C2_W3.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="第四周课件">第四周课件</h2><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/C2_W4.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="作业代码">作业代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/Exercises-W1.zip" title="Exercise 1 for Advanced Learning Algorithms">Exercise 1</a></p><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/Exercises-W2.zip" title="Exercise 2 for Advanced Learning Algorithms">Exercise 2</a></p><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/Exercises-W3.zip" title="Exercise 3 for Advanced Learning Algorithms">Exercise 3</a></p><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Advanced-Learning-Algorithms/Exercises-W4.zip" title="Exercise 4 for Advanced Learning Algorithms">Exercise 4</a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematics for Machine Learning: Multivariate Calculus</title>
    <link href="/2022/07/31/Coursera/Mathematics-for-Machine-Learning-Multivariate-Calculus/"/>
    <url>/2022/07/31/Coursera/Mathematics-for-Machine-Learning-Multivariate-Calculus/</url>
    
    <content type="html"><![CDATA[<p>数学在机器学习领域的应用二：多元微积分</p><span id="more"></span><h1>课程简介</h1><p>This course offers a brief introduction to the multivariate calculus required to build many common machine learning techniques. We start at the very beginning with a refresher on the “rise over run” formulation of a slope, before converting this to the formal definition of the gradient of a function. We then start to build up a set of tools for making calculus easier and faster. Next, we learn how to calculate vectors that point up hill on multidimensional surfaces and even put this into action using an interactive game. We take a look at how we can use calculus to build approximations to functions, as well as helping us to quantify how accurate we should expect those approximations to be. We also spend some time talking about where calculus comes up in the training of neural networks, before finally showing you how it is applied in linear regression models. This course is intended to offer an intuitive understanding of calculus, as well as the language necessary to look concepts up yourselves when you get stuck. Hopefully, without going into too much detail, you’ll still come away with the confidence to dive into some more focused machine learning courses in future.</p><h1>函数</h1><p>函数是从输入到输出的映射，选择函数来建模世界的过程是伟大天才的科学目的，微积分只是对这些函数如何相对于它们的输入变量如何变化的研究。</p><h1>导数（derivative）</h1><p>对于线性函数而言，斜率（梯度、gradient）=‘rise over run’，也就是任意取两点，<img src="https://math.now.sh?inline=y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>方向的距离与<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>方向的距离之比即为梯度。</p><p>对于梯度一直在变化的函数来说，设函数为<img src="https://math.now.sh?inline=f%28x%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，任意取两点<img src="https://math.now.sh?inline=%28x%2Cf(x%29)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%28x%2B%5CDelta%7Bx%7D%2Cf(x%2B%5CDelta%7Bx%7D%29)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p><img src="https://math.now.sh?inline=gradient_x%3D%5Cfrac%7Brise%7D%7Brun%7D%3D%5Clim_%7B%5CDelta%7Bx%7D%5Cto0%7D%7B%28%5Cfrac%7Bf(x%2B%5CDelta%7Bx%7D%29-f(x)%7D%7B%5CDelta%7Bx%7D%7D)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>即，<img src="https://math.now.sh?inline=%5Cfrac%7Bdf%7D%7Bdx%7D%3Df%5E%7B'%7D%28x%29%3D%5Clim_%7B%5CDelta%7Bx%7D%5Cto0%7D%7B(%5Cfrac%7Bf(x%2B%5CDelta%7Bx%7D)-f(x)%7D%7B%5CDelta%7Bx%7D%7D)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>导数的求和法则：<img src="https://math.now.sh?inline=%5Cfrac%7Bd%7D%7Bdx%7D%28f(x%29%2Bg(x))%3D%5Cfrac%7Bdf(x)%7D%7Bdx%7D%2B%5Cfrac%7Bdg(x)%7D%7Bdx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>幂函数求导法则：令<img src="https://math.now.sh?inline=f%28x%29%3Dax%5Eb" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=f%5E%7B'%7D%28x%29%3Dabx%5E%7Bb-1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>不连续（discontinuity）的函数，例如<img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，在<img src="https://math.now.sh?inline=x%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>处没有定义，导数<img src="https://math.now.sh?inline=f%5E%7B'%7D%28x%29%3D%5Cfrac%7B1%7D%7Bx%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在<img src="https://math.now.sh?inline=x%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>处也没有定义.</p><p>例如<img src="https://math.now.sh?inline=f%28x%29%3De%5Ex" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>这种函数，<img src="https://math.now.sh?inline=f%28x%29%3Df%5E%7B'%7D(x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，这种类型的函数与导数始终相等，因此有两个特点：</p><ol><li>函数必须恒大于0或者恒小于0，如果函数改变符号，导数也会改变符号，会使得函数不改变符号，与定义不符</li><li>函数是单调的，因为函数永远不可能达到其原来的值</li></ol><p>三角函数：<img src="https://math.now.sh?inline=%28%5Csin%7Bx%7D%29%5E%7B'%7D%3D%5Ccos%7Bx%7D%2C(%5Ccos%7Bx%7D)%5E%7B'%7D%3D-%5Csin%7Bx%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>导数乘积法则：令<img src="https://math.now.sh?inline=A%28x%29%3Df(x)%5Ccdot%20g(x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=A%5E%7B'%7D%28x%29%3Df(x)%5Ccdot%20g%5E%7B'%7D(x)%2Bf%5E%7B'%7D(x)%5Ccdot%20g(x)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>求导的链式法则：若<img src="https://math.now.sh?inline=h%3Dh%28p%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，且<img src="https://math.now.sh?inline=p%3Dp%28m%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=%5Cfrac%7Bdh%7D%7Bdm%7D%3D%5Cfrac%7Bdh%7D%7Bdp%7D%5Ccdot%20%5Cfrac%7Bdp%7D%7Bdm%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>偏导数求导法则：<img src="https://math.now.sh?inline=%5Cfrac%7Bdf%28x%2Cy%2Cz%29%7D%7Bdt%7D%3D%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bx%7D%7D%5Cfrac%7Bdx%7D%7Bdt%7D%2B%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7By%7D%7D%5Cfrac%7Bdy%7D%7Bdt%7D%2B%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bz%7D%7D%5Cfrac%7Bdz%7D%7Bdt%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>偏导数仍然遵循导数的求导法则</strong></p><h1>雅可比行列式（Jacobian）</h1><p>设函数<img src="https://math.now.sh?inline=f%28x_1%2Cx_2%2Cx_3%2C%5Ccdots%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，它的雅可比行列式为<img src="https://math.now.sh?inline=J%3D%5B%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bx_1%7D%7D%2C%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bx_2%7D%7D%2C%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bx_3%7D%7D%2C%5Ccdots%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>这样给予一组<img src="https://math.now.sh?inline=%28x%2Cy%2Cz%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的值，可以快速得出函数在该点指向此函数最陡斜率方向的向量。</p><p>设函数<img src="https://math.now.sh?inline=u%28x%2Cy%29%2Cv(x%2Cy)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则它的雅可比行列式为<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D%5Cfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7Bx%7D%7D%26%5Cfrac%7B%5Cpartial%7Bu%7D%7D%7B%5Cpartial%7By%7D%7D%5C%5C%5Cfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7Bx%7D%7D%26%5Cfrac%7B%5Cpartial%7Bv%7D%7D%7B%5Cpartial%7By%7D%7D%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>海森矩阵（The Hessian）</h1><p>对雅可比行列式再求一次偏导数，构成的二阶偏导数矩阵为海森矩阵</p><p>设函数<img src="https://math.now.sh?inline=f%28x_1%2Cx_2%2Cx_3%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，它的雅可比行列式为<img src="https://math.now.sh?inline=J%3D%5B%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bx_1%7D%7D%2C%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bx_2%7D%7D%2C%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bx_3%7D%7D%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则海森矩阵为<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%5Cpartial%7Bx_1x_1f%7D%26%5Cpartial%7Bx_1x_2f%7D%26%5Cpartial%7Bx_1x_3f%7D%5C%5C%20%5Cpartial%7Bx_2x_1f%7D%26%5Cpartial%7Bx_2x_2f%7D%26%5Cpartial%7Bx_2x_3f%7D%5C%5C%5Cpartial%7Bx_3x_1f%7D%26%5Cpartial%7Bx_3x_2f%7D%26%5Cpartial%7Bx_3x_3f%7D%5C%5C%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>雅可比行列式求得的值为0的情况下，首先求海森矩阵的行列式，如果行列式为正数，说明目前的点是一个极值点；然后看海森矩阵的第一个数字，如果第一个数字是正数，说明目前在极小值点，否则在极大值点；如果海森矩阵的行列式为负，说明目前的点是一个鞍点。</p><h1>神经网络</h1><p>最简单的神经网络：<img src="https://math.now.sh?inline=a%5E%7B%281%29%7D%3D%5Csigma(wa%5E%7B(0)%7D%2Bb)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，其中，<img src="https://math.now.sh?inline=a" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示活动，<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示权重，<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示偏差，<img src="https://math.now.sh?inline=%5Csigma" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示激活函数</p><p>输入可能不仅仅是一个，设输入的神经元有<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个，则<img src="https://math.now.sh?inline=a%5E%7B%281%29%7D%3D%5Csigma((%5Csum_%7Bj%3D0%7D%5E%7Bn%7D%7Bw_ja_j%5E%7B(0)%7D%7D)%2Bb)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>输出可能也不仅仅是一个，设输出的神经元有<img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个，总体的神经网络表示为：</p><p><img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Bmatrix%7Da_0%5E%7B%281%29%7D%5C%5Ca_1%5E%7B(1)%7D%5C%5C%5Cvdots%5C%5Ca_%7Bm-1%7D%5E%7B(1)%7D%5Cend%7Bmatrix%7D%5Cright%5D%3D%5Csigma(%5Cleft%5B%5Cbegin%7Bmatrix%7Dw_%7B0%2C0%7D%5E%7B(1)%7D%26w_%7B0%2C1%7D%5E%7B(1)%7D%26%5Ccdots%26w_%7B0%2Cn-1%7D%5E%7B(1)%7D%5C%5Cw_%7B1%2C0%7D%5E%7B(1)%7D%26w_%7B1%2C1%7D%5E%7B(1)%7D%26%5Ccdots%26w_%7B1%2Cn-1%7D%5E%7B(1)%7D%5C%5C%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5Cw_%7Bm-1%2C0%7D%5E%7B(1)%7D%26w_%7Bm-1%2C1%7D%5E%7B(1)%7D%26%5Ccdots%26w_%7Bm-1%2Cn-1%7D%5E%7B(1)%7D%20%5Cend%7Bmatrix%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Bmatrix%7Da_0%5E%7B(1)%7D%5C%5Ca_1%5E%7B(1)%7D%5C%5C%5Cvdots%5C%5Ca_%7Bn-1%7D%5E%7B(1)%7D%5Cend%7Bmatrix%7D%5Cright%5D%2B%5Cleft%5B%5Cbegin%7Bmatrix%7Db_0%5E%7B(1)%7D%5C%5Cb_1%5E%7B(1)%7D%5C%5C%5Cvdots%5C%5Cb_%7Bm-1%7D%5E%7B(1)%7D%5Cend%7Bmatrix%7D%5Cright%5D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>可以简化表示为：<img src="https://math.now.sh?inline=%5Cvec%7Ba%7D%5E%7B%281%29%7D%3D%5Csigma(%5Cvec%7Bw%7D%5E%7B(1)%7D%5Ccdot%5Cvec%7Ba%7D%5E%7B(0)%7D%2B%5Cvec%7Bb%7D%5E%7B(1)%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>如果神经网络不止一层，则可以表示为：<img src="https://math.now.sh?inline=%5Cvec%7Ba%7D%5E%7B%28L%29%7D%3D%5Csigma(%5Cvec%7Bw%7D%5E%7B(L)%7D%5Ccdot%5Cvec%7Ba%7D%5E%7B(L-1)%7D%2B%5Cvec%7Bb%7D%5E%7B(L)%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>神经网络（分类任务）的损失函数为<img src="https://math.now.sh?inline=C%3D%5Csum_%7Bi%7D%28a_i%5E%7B(L%29%7D-y_i)%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>泰勒展开式</h1><p>泰勒展开式是对一个复杂函数的简化估计函数</p><p><img src="https://math.now.sh?inline=g_0%28x%29%3Df(0)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g_1%28x%29%3Df(0)%2Bf%5E%7B'%7D(0)x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g_2%28x%29%3Df(0)%2Bf%5E%7B'%7D(0)x%2B%5Cfrac%7B1%7D%7B2%7Df%5E%7B''%7D(0)x%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g_3%28x%29%3Df(0)%2Bf%5E%7B'%7D(0)x%2B%5Cfrac%7B1%7D%7B2%7Df%5E%7B''%7D(0)x%5E2%2B%5Cfrac%7B1%7D%7B6%7Df%5E%7B(3)%7D(0)x%5E3" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g_4%28x%29%3Df(0)%2Bf%5E%7B'%7D(0)x%2B%5Cfrac%7B1%7D%7B2%7Df%5E%7B''%7D(0)x%5E2%2B%5Cfrac%7B1%7D%7B6%7Df%5E%7B(3)%7D(0)x%5E3%2B%5Cfrac%7B1%7D%7B24%7Df%5E%7B(4)%7D(0)x%5E4" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g_n%28x%29%3D%5Csum_%7Bn%3D0%7D%5E%7B%5Cinfty%7D%7B%5Cfrac%7B1%7D%7Bn!%7Df%5E%7B(n)%7D(0)x%5En%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（麦克劳林形式，需要知道零点）</p><p>泰勒形式：</p><p><img src="https://math.now.sh?inline=g_0%28x%29%3Df(p)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g_1%28x%29%3Df(p)%2Bf%5E%7B'%7D(p)(x-p)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g_2%28x%29%3Df(p)%2Bf%5E%7B'%7D(p)(x-p)%2B%5Cfrac%7B1%7D%7B2%7Df%5E%7B''%7D(p)(x-p)%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=g_n%28x%29%3D%5Csum_%7Bn%3D0%7D%5E%7B%5Cinfty%7D%7B%5Cfrac%7B1%7D%7Bn!%7Df%5E%7B(n)%7D(p)(x-p)%5En%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（泰勒形式，知道任意一点<img src="https://math.now.sh?inline=p" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>即可）</p><h2 id="二维泰勒展开">二维泰勒展开</h2><p><img src="https://math.now.sh?inline=f%28x%2B%5CDelta%7Bx%7D%2Cy%2B%5CDelta%7By%7D%29%3D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=f%28x%2Cy%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（零阶泰勒展开）<br><img src="https://math.now.sh?inline=%2B%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cpartial_x%7Bf%28x%2Cy%29%7D%5C%5C%5Cpartial_y%7Bf(x%2Cy)%7D%5Cend%7Bmatrix%7D%5Cright%5D%5Ccdot%5Cleft%5B%5Cbegin%7Bmatrix%7D%5CDelta%7Bx%7D%5C%5C%5CDelta%7By%7D%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（一阶泰勒展开-雅可比行列式）</p><p><img src="https://math.now.sh?inline=%2B%5Cfrac%7B1%7D%7B2%7D%5Ccdot%5Cleft%5B%5Cbegin%7Bmatrix%7D%5CDelta%7Bx%7D%26%5CDelta%7By%7D%5Cend%7Bmatrix%7D%5Cright%5D%5Ccdot%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cpartial_%7Bxx%7D%7Bf%28x%2Cy%29%7D%26%5Cpartial_%7Bxy%7D%7Bf(x%2Cy)%7D%5C%5C%5Cpartial_%7Byx%7D%7Bf(x%2Cy)%7D%26%5Cpartial_%7Byy%7D%7Bf(x%2Cy)%7D%5Cend%7Bmatrix%7D%5Cright%5D%5Ccdot%5Cleft%5B%5Cbegin%7Bmatrix%7D%5CDelta%7Bx%7D%5C%5C%5CDelta%7By%7D%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>（二阶泰勒展开-海森矩阵）</p><h1>牛顿迭代法（Newton-Raphson）</h1><p>迭代求解方程的近似根：</p><p><img src="https://math.now.sh?inline=x_%7Bi%2B1%7D%3Dx_i-%5Cfrac%7Bf%28x_i%29%7D%7Bf%5E%7B'%7D(x_i)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>这种方法会存在一些问题，如果选取的点比较靠近函数的拐点，会得不到正确的结果，或者得到的结果并不是与选取的点最接近的。</p><h1>梯度下降</h1><p>如何使用梯度找到多元函数的最大值或者最小值</p><p>函数的梯度：<img src="https://math.now.sh?inline=%5Cnabla%7Bf%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%5Cfrac%7B%5Cpartial%7Bf_%7B%28a%2Cb%29%7D%7D%7D%7B%5Cpartial%7Bx%7D%7D%5C%5C%5Cfrac%7B%5Cpartial%7Bf_%7B(a%2Cb)%7D%7D%7D%7B%5Cpartial%7By%7D%7D%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即为函数值增加最快的方向</p><p>如果希望找到最大值，将梯度与它的单位向量相乘，则<img src="https://math.now.sh?inline=%5Cnabla%7Bf%7D%5Ccdot%5Cfrac%7B%5Cnabla%7Bf%7D%7D%7B%7C%7C%5Cnabla%7Bf%7D%7C%7C%7D%3D%7C%7C%5Cnabla%7Bf%7D%7C%7C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>梯度下降：<img src="https://math.now.sh?inline=S_%7Bn%2B1%7D%3DS_n-%5Cgamma%5Cnabla%7Bf_%7BS_n%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>拉格朗日乘子法（Lagrange multipliers）</h1><p>计算函数在某些约束下的最大值或者最小值</p><p><img src="https://math.now.sh?inline=maximize%5C%2Cf%28x%2Cy%29%2C%5C%2Cwith%5C%2Cconstrain%5C%2Cg(x%2Cy)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=solve%5C%2C%5Cnabla%7Bf%7D%3D%5Clambda%5Cnabla%7Bg%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为拉格朗日乘子</p><p>即：<img src="https://math.now.sh?inline=%5Cnabla%7BL%28x%2Cy%2C%5Clambda%29%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7Bx%7D%7D-%5Clambda%5Cfrac%7B%5Cpartial%7Bg%7D%7D%7B%5Cpartial%7Bx%7D%7D%5C%5C%5Cfrac%7B%5Cpartial%7Bf%7D%7D%7B%5Cpartial%7By%7D%7D-%5Clambda%5Cfrac%7B%5Cpartial%7Bg%7D%7D%7B%5Cpartial%7By%7D%7D%5C%5C-g(x)%5Cend%7Barray%7D%5Cright%5D%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>多元微积分在回归问题中的应用</h1><h2 id="线性回归">线性回归</h2><p>设函数<img src="https://math.now.sh?inline=y%3Dy%28x%3Ba_i%29%3Dmx_i%2Bc" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=a%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7Dm%5C%5Cc%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>计算平方误差：<img src="https://math.now.sh?inline=L%5E2%3D%5Csum_i%7Br_i%5E2%7D%3D%5Csum_i%7B%28y_i-mx_i-c%29%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>求解使得误差最小：<img src="https://math.now.sh?inline=%5Cnabla%7BL%5E2%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%5Cfrac%7B%5Cpartial%7BL%5E2%7D%7D%7B%5Cpartial%7Bm%7D%7D%5C%5C%5Cfrac%7B%5Cpartial%7BL%5E2%7D%7D%7B%5Cpartial%7Bc%7D%7D%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D0%5C%5C0%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D-2%5Csum_i%7Bx_i%28y_i-mx_i-c%29%7D%5C%5C-2%5Csum_i%7B(y_i-mx_i-c)%7D%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>则可以解得：</p><p><img src="https://math.now.sh?inline=m%3D%5Cfrac%7B%5Csum_i%7B%28x-%5Cbar%7Bx%7D%29y%7D%7D%7B%5Csum_i%7B(x-%5Cbar%7Bx%7D)%5E2%7D%7D%2C%5Csigma_%7Bm%7D%5Capprox%5Cfrac%7BL%5E2%7D%7B%5Csum_i%7B(x-%5Cbar%7Bx%7D)%5E2%7D(n-2)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=c%3D%5Cbar%7By%7D-m%5Cbar%7Bx%7D%2C%5Csigma_%7Bc%7D%5Capprox%5Csigma_%7Bm%7D%5Csqrt%7B%5Cbar%7Bx%7D%5E2%2B%5Cfrac%7B1%7D%7Bn%7D%5Csum_i%7B%28x-%5Cbar%7Bx%7D%29%5E2%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="非线性回归">非线性回归</h2><ol><li>梯度下降法</li><li>泰勒展开式+海森矩阵</li><li>莱文贝格-马夸特方法（Levenberg-Marquardt）</li><li>高斯-牛顿迭代法 （Gauss-Newton iteration method）</li><li>拟牛顿法（BFGS）</li></ol><h1>资料</h1><p>Formula Sheet: Sheet summarising all the formulae covered in this course.</p><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Mathematics-for-Machine-Learning-Specialization/Mathematics-for-Machine-Learning-Multivariate-Calculus/Formula-Sheet.pdf" width="100%" height="550" type="application/pdf"></div><p><a href="https://zhangzhao219.github.io/file/Coursera/Mathematics-for-Machine-Learning-Specialization/Mathematics-for-Machine-Learning-Multivariate-Calculus/Notebooks.zip" title="Code for Mathematics for Machine Learning: Multivariate Calculus">Code and Notebooks</a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Calculus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Supervised Machine Learning: Regression and Classification</title>
    <link href="/2022/07/28/Coursera/Supervised-Machine-Learning-Regression-and-Classification/"/>
    <url>/2022/07/28/Coursera/Supervised-Machine-Learning-Regression-and-Classification/</url>
    
    <content type="html"><![CDATA[<p>机器学习-监督学习：回归和分类</p><span id="more"></span><h1>开始学习</h1><p>吴恩达的机器学习课程终于更新了！！！想当初应该是大二的时候，看了吴恩达的课程，对机器学习有了初步的了解。当时听的不是很明白，英语看不太懂，一些给了充分提示的代码也写不太好，也就是入了一个门而已。这次有一些时间，正好捡一捡机器学习的基础知识，推一推那些一直在调包的数学公式。注重记录！</p><h1>课程简介</h1><p>In the first course of the Machine Learning Specialization, you will:</p><p>• Build machine learning models in Python using popular machine learning libraries NumPy and scikit-learn.<br>• Build and train supervised machine learning models for prediction and binary classification tasks, including linear regression and logistic regression</p><p>The Machine Learning Specialization is a foundational online program created in collaboration between <a href="http://DeepLearning.AI">DeepLearning.AI</a> and Stanford Online. In this beginner-friendly program, you will learn the fundamentals of machine learning and how to use these techniques to build real-world AI applications.</p><p>This Specialization is taught by Andrew Ng, an AI visionary who has led critical research at Stanford University and groundbreaking work at Google Brain, Baidu, and <a href="http://Landing.AI">Landing.AI</a> to advance the AI field.</p><p>This 3-course Specialization is an updated and expanded version of Andrew’s pioneering Machine Learning course, rated 4.9 out of 5 and taken by over 4.8 million learners since it launched in 2012.</p><p>It provides a broad introduction to modern machine learning, including supervised learning (multiple linear regression, logistic regression, neural networks, and decision trees), unsupervised learning (clustering, dimensionality reduction, recommender systems), and some of the best practices used in Silicon Valley for artificial intelligence and machine learning innovation (evaluating and tuning models, taking a data-centric approach to improving performance, and more.)</p><p>By the end of this Specialization, you will have mastered key concepts and gained the practical know-how to quickly and powerfully apply machine learning to challenging real-world problems. If you’re looking to break into AI or build a career in machine learning, the new Machine Learning Specialization is the best place to start.</p><h1>什么是机器学习</h1><ul><li>在谷歌、必应或百度上进行网络搜索会出现想要的答案。这是因为他们的机器学习软件已经解决了如何对网页进行排名。</li><li>上传照片到Instagram或Snapchat，并且想标记我的朋友，让他们可以看到他们的照片。这些应用程序可以识别你照片中的朋友，并给他们贴上标签。</li><li>刚刚在视频流服务上看完一部星球大战电影，流媒体服务可能会使用机器学习来推荐您可能喜欢的内容。</li><li>用语音短信在手机上写短信时，手机会做出你希望的行为</li><li>收到一封赢了一百万美元的电子邮件，你的电子邮件服务很可能会将其标记为垃圾邮件。</li><li>除了消费者应用之外，人工智能也在迅速进入大公司和工业应用。机器学习已经有望优化风力涡轮机发电，开始进入医院，帮助医生做出准确的诊断，将计算机视觉应用到工厂中，以帮助检查生产线中的产品是否有任何缺陷。</li><li>机器学习是一门让计算机在没有明确编程的情况下学习的科学-1950</li></ul><h1>监督学习</h1><p>监督学习是学习从输入<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到输出标签<img src="https://math.now.sh?inline=y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的一个函数映射，主要特征是给予算法示例去学习，也就是从被给予的正确答案中学习。</p><p>监督学习的基本类型有两种：<strong>回归和分类</strong></p><p>回归任务是在大量的数值空间中，对某一个具体数值进行预测</p><p>分类任务是在给定的数值空间中（如0和1），对某一个具体数据进行预测</p><h2 id="符号表示方法">符号表示方法</h2><p><img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示输入的变量或者特征</p><p><img src="https://math.now.sh?inline=y" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示输出的实际目标变量，<img src="https://math.now.sh?inline=%5Chat%7By%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示预测的变量</p><p><img src="https://math.now.sh?inline=m" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示训练样本总数</p><p><img src="https://math.now.sh?inline=%28x%2Cy%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示一个训练样本，<img src="https://math.now.sh?inline=%28x%5E%7B(i%29%7D%2Cy%5E%7B(i)%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个训练样本</p><p>线性回归的机器学习模型可以表示为：<img src="https://math.now.sh?inline=f_%7Bw%2Cb%7D%28x%29%3Dwx%2Bb" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h2 id="损失函数">损失函数</h2><p>度量预测值与实际目标值之间的差异</p><p>线性回归中使用的平方损失函数：<img src="https://math.now.sh?inline=J%28w%2Cb%29%3D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B(%5Chat%7By%7D%5E%7B(i)%7D-y%5E%7B(i)%7D)%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，将机器学习模型代入，则表示为<img src="https://math.now.sh?inline=J%28w%2Cb%29%3D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7Bw%2Cb%7D(x%5E%7B(i)%7D)-y%5E%7B(i)%7D)%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>目标就是要找出最合适的<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，使得<img src="https://math.now.sh?inline=J%28w%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>最小</p><p>使用<strong>梯度下降</strong>算法：</p><p><img src="https://math.now.sh?inline=w%3Dw-%5Calpha%20%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bw%7D%7DJ%28w%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=b%3Db-%5Calpha%20%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bb%7D%7DJ%28w%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Calpha" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为学习率</p><p>梯度下降在更新的时候需要同时更新<img src="https://math.now.sh?inline=w" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，因此在计算的过程中，首先要计算<img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bw%7D%7DJ%28w%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>和<img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bb%7D%7DJ%28w%2Cb%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，然后再相减，保证同步更新。</p><p>具体计算：</p><p><img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bw%7D%7DJ%28w%2Cb%29%3D%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bw%7D%7D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7Bw%2Cb%7D(x%5E%7B(i)%7D)-y%5E%7B(i)%7D)%5E2%7D%3D%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bw%7D%7D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B(wx%5E%7B(i)%7D%2Bb-y%5E%7B(i)%7D)%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%3D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B%28wx%5E%7B(i%29%7D%2Bb-y%5E%7B(i)%7D)2x%5E%7B(i)%7D%7D%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7Bw%2Cb%7D(x%5E%7B(i)%7D)-y%5E%7B(i)%7D)x%5E%7B(i)%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bb%7D%7DJ%28w%2Cb%29%3D%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bb%7D%7D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7Bw%2Cb%7D(x%5E%7B(i)%7D)-y%5E%7B(i)%7D)%5E2%7D%3D%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bb%7D%7D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B(wx%5E%7B(i)%7D%2Bb-y%5E%7B(i)%7D)%5E2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%3D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B%28wx%5E%7B(i%29%7D%2Bb-y%5E%7B(i)%7D)2%7D%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7Bw%2Cb%7D(x%5E%7B(i)%7D)-y%5E%7B(i)%7D)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>学习率的选择：</p><p>如果学习率过小，梯度下降算法运行会比较慢</p><p>如果学习率过大，梯度下降算法可能运行过头，最终导致算法不能收敛</p><p>如果使用固定的学习率，梯度下降算法运行到局部最小值后不会再变化。因为到达局部最小值的附近后，梯度下降的每一步会变得更小，更新的值也会逐渐变小。</p><p>通过损失值随着迭代次数的变化可以看出一些错误：</p><ol><li>随着迭代次数增加，损失值波动上升下降——代码有问题或者学习率过大</li><li>随着迭代次数增加，损失值一直上升——学习率过大或代码有问题（可能每一次的计算符号反了）</li><li>如果很长时间不收敛，可能是学习率太小了</li></ol><p><strong>将学习率调整足够小，损失值在每一次迭代的过程中都会减小</strong></p><h1>多元线性回归</h1><p><img src="https://math.now.sh?inline=x_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示第<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征，<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示特征的数量</p><p><img src="https://math.now.sh?inline=%5Cvec%7Bx%7D%5E%7B%28i%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个训练样本的全部特征，<img src="https://math.now.sh?inline=x_j%5E%7B%28i%29%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>表示第<img src="https://math.now.sh?inline=i" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个训练样本中的第<img src="https://math.now.sh?inline=j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>个特征</p><p><img src="https://math.now.sh?inline=f_%7Bw%2Cb%7D%28x%29%3Dw_1x_1%2Bw_2x_2%2B%5Ccdots%2Bw_nx_n%2Bb" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>令<img src="https://math.now.sh?inline=%5Cvec%7Bw%7D%3D%5Bw_1%2Cw_2%2C%5Ccdots%2Cw_n%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cvec%7Bx%7D%3D%5Bx_1%2Cx_2%2C%5Ccdots%2Cx_n%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则</p><p><img src="https://math.now.sh?inline=f_%7B%5Cvec%7Bw%7D%2Cb%7D%28%5Cvec%7Bx%7D%29%3D%5Cvec%7Bw%7D%5Ccdot%5Cvec%7Bx%7D%2Bb%3Dw_1x_1%2Bw_2x_2%2B%5Ccdots%2Bw_nx_n%2Bb" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><strong>可以通过Numpy的向量化进行计算</strong></p><h2 id="特征缩放">特征缩放</h2><p>当具有不同的值范围的不同特征时，可能会导致梯度下降算法运行较慢</p><p>需要对不同的特征重新缩放到相同或相似的范围</p><p>均值归一化：<img src="https://math.now.sh?inline=x%3D%5Cfrac%7Bx-%5Cmu%7D%7Bx_%7Bmax%7D-x_%7Bmin%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，可以缩放到<img src="https://math.now.sh?inline=%28-1%2C1%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的范围内</p><p>Z-score归一化：<img src="https://math.now.sh?inline=x%3D%5Cfrac%7Bx-%5Cmu%7D%7B%5Csigma%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>逻辑回归（分类问题）</h1><p>sigmoid函数：<img src="https://math.now.sh?inline=g%28z%29%3D%5Cfrac%7B1%7D%7B1%2Be%5E%7B-z%7D%7D%2C0%3Cg(z)%3C1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>逻辑回归：<img src="https://math.now.sh?inline=f_%7B%5Cvec%7Bw%7D%2Cb%7D%28%5Cvec%7Bx%7D%29%3D%5Cfrac%7B1%7D%7B1%2Be%5E%7B-(%5Cvec%7Bw%7D%5Ccdot%5Cvec%7Bx%7D%2Bb)%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，用概率的形式表达：<img src="https://math.now.sh?inline=f_%7B%5Cvec%7Bw%7D%2Cb%7D%28%5Cvec%7Bx%7D%29%3DP(y%3D1%7C%5Cvec%7Bx%7D%3B%5Cvec%7Bw%7D%2Cb)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>不同的决策边界：</p><p><img src="https://math.now.sh?inline=f_%7B%5Cvec%7Bw%7D%2Cb%7D%28%5Cvec%7Bx%7D%29%3Dg(z)%3Dg(w_1x_1%2Bw_2x_2%2Bb)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=f_%7B%5Cvec%7Bw%7D%2Cb%7D%28%5Cvec%7Bx%7D%29%3Dg(z)%3Dg(w_1x_1%5E2%2Bw_2x_2%5E2%2Bb)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=f_%7B%5Cvec%7Bw%7D%2Cb%7D%28%5Cvec%7Bx%7D%29%3Dg(z)%3Dg(w_1x_1%2Bw_2x_2%2Bw_3x_1%5E2%2Bw_4x_1x_2%2Bw_5x_2%5E2%2Bb)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>逻辑回归损失函数：</p><p><img src="https://math.now.sh?inline=L%28f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i%29%7D)%2Cy%5E%7B(i)%7D)%3D%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bc%7D-log%7B(f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i)%7D))%7D%2Cif%5C%2Cy%5E%7B(i)%7D%3D1%5C%5C-log%7B(1-f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i)%7D))%7D%2Cif%5C%2Cy%5E%7B(i)%7D%3D0%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>简化写法：<img src="https://math.now.sh?inline=L%28f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i%29%7D)%2Cy%5E%7B(i)%7D)%3D-y%5E%7B(i)%7Dlog%7B(f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i)%7D))%7D-(1-y%5E%7B(i)%7D)log%7B(1-f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i)%7D))%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=J%28%5Cvec%7Bw%7D%2Cb%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7B%5BL(f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i)%7D)%2Cy%5E%7B(i)%7D)%5D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>欠拟合和过拟合</h1><p>欠拟合：函数对于训练集的拟合效果不好——高偏差（high bias）</p><p>过拟合：函数对于训练集的拟合效果好，对于测试集的效果不好——高方差（high variance）</p><p>避免过拟合的方法：</p><ol><li>收集更多的训练数据</li><li>从全部的特征中挑选最相关的特征进行训练</li><li>正则化——减小某一参数对拟合函数的影响</li></ol><h2 id="正则化">正则化</h2><p>通过将损失函数加上特别大的常数与某一参数的乘积，使得这个参数在优化的过程中变得非常小</p><p>例如回归问题：</p><p><img src="https://math.now.sh?inline=J%28w%2Cb%29%3D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7Bw%2Cb%7D(x%5E%7B(i)%7D)-y%5E%7B(i)%7D)%5E2%7D%2B%5Cfrac%7B%5Clambda%7D%7B2m%7D%5Csum_%7Bj%3D1%7D%5En%7Bw_j%5E2%7D(%2B%5Cfrac%7B%5Clambda%7D%7B2m%7Db%5E2)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>由于不知道哪些特征是比较重要的，哪些特征不重要，因此加上参数平方求和的正则项，让优化算法自行选择。</p><p>对于线性回归来说：</p><p><img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bw%7D%7DJ%28w%2Cb%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i)%7D)-y%5E%7B(i)%7D)x_j%5E%7B(i)%7D%7D%2B%5Cfrac%7B%5Clambda%7D%7Bm%7Dw_j" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cfrac%7B%5Cpartial%7B%7D%7D%7B%5Cpartial%7Bb%7D%7DJ%28w%2Cb%29%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i)%7D)-y%5E%7B(i)%7D)%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>进一步推导：</p><p><img src="https://math.now.sh?inline=w_j%3Dw_j-%5Calpha%5Ccdot%5B%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7B%28f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i%29%7D)-y%5E%7B(i)%7D)x_j%5E%7B(i)%7D%7D%2B%5Cfrac%7B%5Clambda%7D%7Bm%7Dw_j%5D%3Dw_j(1-%5Calpha%5Cfrac%7B%5Clambda%7D%7Bm%7D)-%5Calpha%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5Em%7B(f_%7B%5Cvec%7Bw%7D%2Cb%7D(%5Cvec%7Bx%7D%5E%7B(i)%7D)-y%5E%7B(i)%7D)x_j%5E%7B(i)%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此正则项的加入实际上相当于将参数略微减小</p><h1>资料</h1><h2 id="第一周课件和代码">第一周课件和代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Supervised-Machine-Learning-Regression-and-Classification/Notebooks-W1.zip" title="Notebooks Week 1 for Supervised Machine Learning: Regression and Classification">Notebooks Week 1</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Supervised-Machine-Learning-Regression-and-Classification/C1_W1.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="第二周课件和代码">第二周课件和代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Supervised-Machine-Learning-Regression-and-Classification/Notebooks-W2.zip" title="Notebooks Week 2 for Supervised Machine Learning: Regression and Classification">Notebooks Week 2</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Supervised-Machine-Learning-Regression-and-Classification/C1_W2.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="第三周课件和代码">第三周课件和代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Supervised-Machine-Learning-Regression-and-Classification/Notebooks-W3.zip" title="Notebooks Week 3 for Supervised Machine Learning: Regression and Classification">Notebooks Week 3</a></p><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Supervised-Machine-Learning-Regression-and-Classification/C1_W3.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="作业代码">作业代码</h2><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Supervised-Machine-Learning-Regression-and-Classification/Exercises-W2.zip" title="Exercise 1 for Supervised Machine Learning: Regression and Classification">Exercise 1</a></p><p><a href="https://zhangzhao219.github.io/file/Coursera/Machine-Learning-Specialization/Supervised-Machine-Learning-Regression-and-Classification/Exercises-W3.zip" title="Exercise 2 for Supervised Machine Learning: Regression and Classification">Exercise 2</a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Supervised Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Previous Love</title>
    <link href="/2022/07/28/about-my-previous-love/"/>
    <url>/2022/07/28/about-my-previous-love/</url>
    
    <content type="html"><![CDATA[<p><strong>记于2022年7月28日，已于2022年9月24日正式分手，公开于2023年11月19日</strong></p><span id="more"></span><p>青岛的五天旅行结束了，251天后的初次见面，美好的时光总是短暂。</p><p>回家后心里一直不太舒服，一直在胡思乱想，想着想着有时还偷偷抹抹眼泪。父母也是真的了解我，虽然并没有表现出什么，一直在不断追问我怎么了。当然就算有明确的原因也不会说，对爸妈只能是报喜不报忧，何况我现在也不知道我为什么这样。</p><p>可能是不舍得吧，分开了251天，再次见面的时间只有短短的五天，下一次见面还不知道什么时候。</p><p>可能是由于毕业季的几乎分手吧，可能现在自己的信心没有那么足了。</p><p>可能是对自己未来的迷茫吧，本科取得了不错的成绩，研究生一切从头开始，不知该从何做起。</p><p>这一段时间，对我影响最大的就是那一次的几乎分手。女孩子真的需要陪伴，异地太久了，感情是真的会变淡的。而且之前并没有很明确的聊过未来的规划。可能随口的一句“杭州南京”，就成为了一道跨不过去的坎。</p><p>我出生在东北的一个小城，从小的梦想就是要走出去，给我自己，甚至给我的下一代创造一个更好的生活环境。高二那年清华暑校遇到全国的优秀学生，发现不同地区顶尖学生之间的差异居然也有如此之大，更加坚定了我走出去的决心。我也很庆幸在高考失利的情况下能选到一个好专业，在房价居高不下的大环境下，至少目前来看毕业后的薪资还是非常有竞争力的。</p><p>我很开心可以遇到我的女朋友，我们在一无所有的情况下愿意去尝试。我也从此有了另外的一个前进动力，从高考失利和大一的挫折中走了出来，拿下了年级排名和无数的竞赛奖项、荣誉称号，成功保研。保研的时候也没有选择华师大，想着自己应该获得更好的学历，以后赚更多的钱，才能和她一起有更好的生活。我按照我的道路一步一步在走。</p><p>然而由于我早去北京的提前异地，我们之间的沟通就少了许多。地理上的距离造成了心的距离，找到了一个很好的教师编职位后，她便产生了分手的想法。整个过程我甚至都是毫不知情的状态。虽然靠着一条时间轴挽回，但是我需要对自己做一个深刻的反思。我自认为我的爱没有变，但是异地半年多，确实很难将爱表达出来，同时也忽略了她的感受，我们之间的交流变得更少，最终导致了单方面无吵架的分手。</p><p>能有一个爱人时刻陪伴在身边，确实是一件非常美好的事情。才分开两天，五天的回忆一波一波涌上心头，真的很难受。想起她忘记带伞的时候，只能躲在小店内等待雨停，却无法等到一个送伞的我。异地恋真的难熬。然而这还不到一年的时间。最少需要三年才能奔现，要是找一份更高薪的工作，甚至需要五年的时间，我才能在合肥站稳脚跟，真正地和她在一起。“所以你就选定我了是嘛”“是的”“为什么呢”“。。。”是啊，为什么呢，我回答不上来。后来我也认真考虑了很久，我是一个纯理性思维的人，这一次我选择听从我的心。我相信我三年前的选择，不管是现在，三年后，三十年后，我还会作出同样的选择。</p><p>我是一个很坚定的人，我作出了选择，就会坚定的走下去。这几年我会尽全力维护这一段感情，改正掉我之前的错误，尽量多见面，尽量提升自己以后拿到更好的薪资，尽量多关心，多询问她的感受。三年前我还是一个懵懂无知的学生，我不知道三年后，甚至五年后我会成为什么样的人，但是我的爱是永远不变的。</p><p>如果她熬不住了，我会坦然接受。因为我知道，我才是那个最对不起她的人。长三角省会城市工作稳定，我又何德何能拴住她数年的时间，忍受着屏幕那边可有可无的关心，忍受着几个月甚至半年才有的一次短短几天的见面。</p><p>我真的希望最终我们可以幸福地走到一起。</p><p>为你，千千万万遍。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ziyaooo</tag>
      
      <tag>Love</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Travel List</title>
    <link href="/2022/07/13/travel-list/"/>
    <url>/2022/07/13/travel-list/</url>
    
    <content type="html"><![CDATA[<p>旅行物品清单</p><span id="more"></span><h1>高铁新规</h1><p><a href="https://imgtu.com/i/jqsL6K"><img src="https://s1.ax1x.com/2022/07/21/jqsL6K.md.png" alt="jqsL6K.md.png"></a></p><h1>必备物品</h1><ol><li>身份证、学生证（本科的估计也行）、手机（足够流量）</li><li>足量的口罩</li><li>一点点现金</li></ol><h1>生活用品</h1><ol><li>手纸、面巾纸等、塑料袋</li><li>洗漱包（牙具）、毛巾</li><li>水杯（可选）</li><li>雨伞（或雨衣）</li></ol><h1>药品</h1><ol><li>消炎药</li><li>腹泻药</li><li>感冒发烧药</li></ol><h1>衣物</h1><ol><li>2-3套换洗的内衣、袜子等</li><li>应季适量外衣外裤</li><li>被褥、蚊帐等（若目的地不提供）</li></ol><h1>电子产品</h1><ol><li>手机充电线（器）、充电宝、充电宝充电器</li><li>笔记本电脑（充电器）、iPad（充电器）</li><li>耳机</li><li>电蚊香（液）</li><li>剃须刀</li><li>插排（若目的地不提供）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Travel</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mathematics for Machine Learning: Linear Algebra</title>
    <link href="/2022/07/12/Coursera/Mathematics-for-Machine-Learning-Linear-Algebra/"/>
    <url>/2022/07/12/Coursera/Mathematics-for-Machine-Learning-Linear-Algebra/</url>
    
    <content type="html"><![CDATA[<p>数学在机器学习领域的应用一：线性代数</p><span id="more"></span><h1>开始学习</h1><p>总是觉得自己数学有一点差，可能是因为上大学学习的时候题目做的比较少，我的脑子又不太灵光，因此一直不能很好的理解数学相关的一些公式、定理等，平时编程的时候尽量找简单的方法绕开复杂的数学公式。假期有时间了，试一下帝国理工的线性代数课程，注重记录，注重理解。这也是第一次看没有中文字幕的全英文课。加油！</p><h1>课程简介</h1><p>In this course on Linear Algebra we look at what linear algebra is and how it relates to vectors and matrices. Then we look through what vectors and matrices are and how to work with them, including the knotty problem of eigenvalues and eigenvectors, and how to use these to solve problems. Finally  we look at how to use these to do fun things with datasets - like how to rotate images of faces and how to extract eigenvectors to look at how the Pagerank algorithm works.</p><p>Since we’re aiming at data-driven applications, we’ll be implementing some of these ideas in code, not just on pencil and paper. Towards the end of the course, you’ll write code blocks and encounter Jupyter notebooks in Python, but don’t worry, these will be quite short, focussed on the concepts, and will guide you through if you’ve not coded before.</p><p>At the end of this course you will have an intuitive understanding of vectors and matrices that will help you bridge the gap into linear algebra problems, and how to apply these concepts to machine learning.</p><h1>什么是线性代数</h1><p>Linear algebra is a mathematical system for manipulating vectors in the spaces described by vectors.</p><p>Linear algebra is linear, because it just takes input values, and multiplies them by constants, everything is linear.</p><p>Linear algebra is algebra, that is it’s a notation describing mathematical objects and a system of manipulating those notations.</p><p>How vectors are transformed by matrices is the heart of linear algebra.</p><h1>为什么我们需要线性代数？</h1><ol><li>让计算机快速求解多元方程组<br>例如：多元方程组<img src="https://math.now.sh?inline=%5Cleft%5C%7B%5Cbegin%7Barray%7D%7Bc%7D2a%2B3b%3D8%5C%5C10a%2B1b%3D13%5Cend%7Barray%7D%5Cright." style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，可以转换为<img src="https://math.now.sh?inline=%5Cleft%28%5Cbegin%7Barray%7D%7Bcc%7D2%263%5C%5C10%261%5Cend%7Barray%7D%5Cright%29%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7Da%5C%5Cb%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D8%20%5C%5C%2013%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，然后进行求解。</li><li>为数据拟合方程<br>随着神经网络和机器学习的发展，并不仅仅是拟合方程，最好还能在已有方程曲线的前提下，找到最佳的拟合参数，从而更适用于当前的数据。描述一个方程的各种参数可以使用一个向量来表示，我们希望通过某种方式，数据科学或者机器学习的方式来找到最佳的拟合参数。</li></ol><h1>向量(Vector)</h1><p><strong>在计算机科学中，向量被认为是描述一个物体的属性的集合。</strong></p><h2 id="向量的基本操作">向量的基本操作</h2><p>向量有两种操作：向量与向量之间的加法，以及向量与标量之间的乘法。</p><p>向量与向量之间的加法满足结合律(associativity)。</p><p>向量与标量之间的乘法，要将标量与向量中的每一个属性相乘</p><h2 id="向量的其他运算">向量的其他运算</h2><p>如果不以坐标系的角度去观察向量，那么一个向量由两个属性构成：<strong>向量的方向和向量的模长</strong></p><p>向量的模长指的是向量各组成成分的平方和开根号</p><p>向量的点乘指的是向量对应位置的数值相乘之和，满足交换律（commutative）</p><p>同时满足向量的加法分配律（distributive over addition），即<img src="https://math.now.sh?inline=%5Cvec%7Br%7D%5Ccdot%28%5Cvec%7Bs%7D%2B%5Cvec%7Bt%7D%29%3D%5Cvec%7Br%7D%5Ccdot%5Cvec%7Bs%7D%2B%5Cvec%7Br%7D%5Ccdot%5Cvec%7Bt%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>向量与标量相乘满足结合律和交换律，即<img src="https://math.now.sh?inline=%5Cvec%7Br%7D%5Ccdot%28a%5Ccdot%5Cvec%7Bs%7D%29%3Da%5Ccdot(%5Cvec%7Br%7D%5Ccdot%5Cvec%7Bs%7D)" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>向量模长与点乘之间的关系：向量自身的点乘与模长的平方相等，即 <img src="https://math.now.sh?inline=%5Cvec%7Br%7D%5Ccdot%5Cvec%7Br%7D%3D%7C%5Cvec%7Br%7D%7C%5E2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>向量的余弦定理：<img src="https://math.now.sh?inline=%5Ccos%7B%5Ctheta%7D%3D%5Cfrac%20%7B%5Cvec%7Br%7D%5Ccdot%5Cvec%7Bs%7D%7D%20%7B%7C%5Cvec%7Br%7D%7C%5Ccdot%7C%5Cvec%7Bs%7D%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>向量投影（projection）：</p><p><img src="https://math.now.sh?inline=%5Cvec%7Bs%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到<img src="https://math.now.sh?inline=%5Cvec%7Br%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的投影标量（scalar projection）= <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cvec%7Br%7D%5Ccdot%5Cvec%7Bs%7D%7D%20%7B%7C%5Cvec%7Br%7D%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%5Cvec%7Bs%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>到<img src="https://math.now.sh?inline=%5Cvec%7Br%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>上的投影向量（vector projection）= scalar projection *  <img src="https://math.now.sh?inline=%5Cvec%7Br%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>单位向量 = <img src="https://math.now.sh?inline=%5Cfrac%7B%5Cvec%7Br%7D%5Ccdot%5Cvec%7Bs%7D%7D%20%7B%7C%5Cvec%7Br%7D%7C%7D%5Ccdot%5Cfrac%7B%5Cvec%7Br%7D%7D%7B%7C%5Cvec%7Br%7D%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>向量投影是一个标量，但是，如果需要投影向量的方向，直接与被投影的单位向量相乘即可。</p><h2 id="向量的坐标系">向量的坐标系</h2><p>两个不共线的向量可以确定一个坐标系(coordinate system)。要描述一个向量，首先要定义一个坐标系，决定坐标系的是<strong>基向量</strong>。</p><p>基向量是<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维的向量集合，需要满足3个条件：</p><ol><li><img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维的向量彼此之间不线性相关，也就是线性独立的<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维向量。</li><li>可以扩展到整个空间。</li><li>空间是<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维的。</li></ol><p>虽然并不要求基向量正交，但是如果它们正交，会为解决数学问题带来很大的方便。</p><p>如果二维的<strong>基向量互相垂直</strong>，转换坐标系只需将向量投影到转换后的基向量，计算数值即可。</p><p>设原始坐标系<img src="https://math.now.sh?inline=%5Cvec%7Be_1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C0%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cvec%7Be_2%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D0%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，转换后的基向量<img src="https://math.now.sh?inline=%5Cvec%7Bb_1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D2%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cvec%7Bb_2%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D-2%5C%5C4%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>首先验证<img src="https://math.now.sh?inline=%5Cvec%7Bb_1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>与<img src="https://math.now.sh?inline=%5Cvec%7Bb_2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是否垂直，<img src="https://math.now.sh?inline=%5Ccos%7B%5Ctheta%7D%3D%5Cfrac%20%7B%5Cvec%7Bb_1%7D%5Ccdot%5Cvec%7Bb_2%7D%7D%20%7B%7C%5Cvec%7Bb_1%7D%7C%5Ccdot%7C%5Cvec%7Bb_2%7D%7C%7D%3D0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>然后将待转换的向量<img src="https://math.now.sh?inline=r_e%3D3%5Cvec%7Be_1%7D%2B4%5Cvec%7Be_2%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D3%5C%5C4%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，对<img src="https://math.now.sh?inline=%5Cvec%7Bb_1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的投影为<img src="https://math.now.sh?inline=%5Cfrac%7B%5Cvec%7Br_e%7D%5Ccdot%5Cvec%7Bb_1%7D%7D%7B%7C%5Cvec%7Bb_1%7D%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，这个投影除以<img src="https://math.now.sh?inline=%5Cvec%7Bb_1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的模长<img src="https://math.now.sh?inline=%5Cfrac%7B%5Cvec%7Br_e%7D%5Ccdot%5Cvec%7Bb_1%7D%7D%7B%7C%5Cvec%7Bb_1%7D%7C%7D%5Ccdot%5Cfrac%7B1%7D%7B%7C%5Cvec%7Bb_1%7D%7C%7D%3D%5Cfrac%7B3*2%2B4*1%7D%7B2%5E2%2B1%5E2%7D%3D2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即<img src="https://math.now.sh?inline=%5Cvec%7Br_e%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在<img src="https://math.now.sh?inline=%5Cvec%7Bb_1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>方向的投影为2个<img src="https://math.now.sh?inline=%7C%5Cvec%7Bb_1%7D%7C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>长度。同理，即<img src="https://math.now.sh?inline=%5Cvec%7Br_e%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>在<img src="https://math.now.sh?inline=%5Cvec%7Bb_2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>方向的投影为0.5个<img src="https://math.now.sh?inline=%7C%5Cvec%7Bb_2%7D%7C" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>长度。</p><p>从而得出<img src="https://math.now.sh?inline=%5Cvec%7Br_e%7D%3D2%5Cvec%7Bb_1%7D%2B%5Cfrac%7B1%7D%7B2%7D%5Cvec%7Bb_2%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，最终计算得<img src="https://math.now.sh?inline=r_b%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D2%5C%5C%5Cfrac%7B1%7D%7B2%7D%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p><strong>找到一个合适的坐标系，帮助我们解决数学问题，是非常重要的。</strong></p><h1>矩阵(Matrices)</h1><p>矩阵与向量相乘，相当于将向量转换到不同的坐标系。</p><p>矩阵的乘法满足结合律，但是不满足交换律.</p><p>如<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D2%263%5C%5C10%261%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C0%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D2%5C%5C10%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，相当于将<img src="https://math.now.sh?inline=%5Cvec%7Be_1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C0%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>转换到了<img src="https://math.now.sh?inline=%5Cvec%7Be_1%5E%7B'%7D%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D2%5C%5C10%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>如<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D2%263%5C%5C10%261%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D0%5C%5C1%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D3%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，相当于将<img src="https://math.now.sh?inline=%5Cvec%7Be_2%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D0%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>转换到了<img src="https://math.now.sh?inline=%5Cvec%7Be_2%5E%7B'%7D%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D3%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>通过矩阵的转换实际上可以看作不同转换向量之间的和。</p><p>如果我们对<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D3%5C%5C2%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>做这个矩阵的变换，则可以推导：</p><p><img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D2%263%5C%5C10%261%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D3%5C%5C2%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D2%263%5C%5C10%261%5Cend%7Barray%7D%5Cright%5D%5B3%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C0%5Cend%7Barray%7D%5Cright%5D%2B2%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D0%5C%5C1%5Cend%7Barray%7D%5Cright%5D%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%3D3%28%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D2%263%5C%5C10%261%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C0%5Cend%7Barray%7D%5Cright%5D%2B2%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D2%263%5C%5C10%261%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D0%5C%5C1%5Cend%7Barray%7D%5Cright%5D%29" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=%3D3%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D2%5C%5C10%5Cend%7Barray%7D%5Cright%5D%2B2%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D3%5C%5C1%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D12%5C%5C32%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>.</p><p><strong>单位矩阵(identity matrix)不对向量做任何变换</strong></p><p><img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D1%260%5C%5C0%261%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7Dx%5C%5Cy%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7Dx%5C%5Cy%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>设单位矩阵<img src="https://math.now.sh?inline=I%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D1%260%5C%5C0%261%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=A%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D2%263%5C%5C10%261%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=r%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7Da%5C%5Cb%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为待求根，<img src="https://math.now.sh?inline=s%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D8%5C%5C13%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>根据逆矩阵的定义，<img src="https://math.now.sh?inline=A%5E%7B-1%7DA%3DI" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此<img src="https://math.now.sh?inline=A%5E%7B-1%7DAr%3DA%5E%7B-1%7Ds" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，即<img src="https://math.now.sh?inline=r%3DA%5E%7B-1%7Ds" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>通过初等行变换求解逆矩阵：<img src="https://math.now.sh?inline=%5BA%2CI%5D-%5BI%2CA%5E%7B-1%7D%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>对于二维矩阵<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7Da%26b%5C%5Cc%26d%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>来说，它的逆矩阵是<img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7Bad-bc%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7Dd%26-b%5C%5C-c%26a%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=ad-bc%5Cneq0" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>二维行列式(determinant)：<img src="https://math.now.sh?inline=ad-bc" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>行列式为0的矩阵，维度不满足当前矩阵的维度，因此在矩阵操作前要<strong>首先检查行列式</strong>。</p><p>矩阵的转置：<img src="https://math.now.sh?inline=A_%7Bij%7D%5ET%3DA_%7Bji%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，正交矩阵<img src="https://math.now.sh?inline=A%5ETA%3DI" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则<img src="https://math.now.sh?inline=A%5ET%3DA%5E%7B-1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，且正交矩阵的行列式为-1或1。</p><h2 id="爱因斯坦求和约定-Einstein-summation-convention">爱因斯坦求和约定(Einstein summation convention)</h2><p>设<img src="https://math.now.sh?inline=A%3D%5Cleft%5B%5Cbegin%7Bmatrix%7Da_%7B11%7D%26a_%7B12%7D%26%5Ccdots%26%20a_%7B1n%7D%5C%5Ca_%7B21%7D%26a_%7B22%7D%26%5Ccdots%26a_%7B2n%7D%5C%5C%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5Ca_%7Bn1%7D%26a_%7Bn2%7D%26%20%5Ccdots%5C%20%26a_%7Bnn%7D%20%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=B%3D%5Cleft%5B%5Cbegin%7Bmatrix%7Db_%7B11%7D%26b_%7B12%7D%26%5Ccdots%26%20b_%7B1n%7D%5C%5Cb_%7B21%7D%26b_%7B22%7D%26%5Ccdots%26b_%7B2n%7D%5C%5C%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5Cb_%7Bn1%7D%26b_%7Bn2%7D%26%20%5Ccdots%5C%20%26b_%7Bnn%7D%20%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，则</p><p>则<img src="https://math.now.sh?inline=AB%3D%5Cleft%5B%5Cbegin%7Bmatrix%7D%28ab%29_%7B11%7D%26(ab)_%7B12%7D%26%5Ccdots%26(ab)_%7B1n%7D%5C%5C(ab)_%7B21%7D%26(ab)_%7B22%7D%26%5Ccdots%26(ab)_%7B2n%7D%5C%5C%5Cvdots%26%5Cvdots%26%5Cddots%26%5Cvdots%5C%5C(ab)_%7Bn1%7D%26(ab)_%7Bn2%7D%26%20%5Ccdots%5C%20%26(ab)_%7Bnn%7D%20%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>是由<img src="https://math.now.sh?inline=A" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中的某一行与<img src="https://math.now.sh?inline=B" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>中的某一列相乘求和后填充的矩阵。</p><p>如<img src="https://math.now.sh?inline=%28ab%29_%7B23%7D%3Da_%7B21%7Db_%7B13%7D%2Ba_%7B22%7Db_%7B23%7D%2B%5Ccdots%2Ba_%7B2n%7Db_%7Bn3%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>因此<img src="https://math.now.sh?inline=%28ab%29_%7Bik%7D%3Da_%7Bi1%7Db_%7B1k%7D%2Ba_%7Bi2%7Db_%7B2k%7D%2B%5Ccdots%2Ba_%7Bin%7Db_%7Bnk%7D%3D%5Csum_%7Bj%3D0%7D%5En%7Ba_%7Bij%7Db_%7Bjk%7D%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=a_%7Bij%7Db_%7Bjk%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>即为爱因斯坦求和约定的表示法。</p><h2 id="矩阵坐标系的转换">矩阵坐标系的转换</h2><p>设原始坐标系<img src="https://math.now.sh?inline=%5Cvec%7Be_1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C0%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cvec%7Be_2%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D0%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，现在有另外一个坐标系，<strong>坐标系在原始坐标系下基向量表示为</strong><img src="https://math.now.sh?inline=%5Cvec%7Bb_1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D3%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cvec%7Bb_2%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C0%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>如果将<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>坐标系下的向量<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1.5%5C%5C0.5%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>转换到原始坐标系中，则为<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D3%261%5C%5C1%260%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1.5%5C%5C0.5%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D5%5C%5C2%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>反之，将原始坐标系中的向量转换到<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>坐标系下，则<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcc%7D3%261%5C%5C1%260%5Cend%7Barray%7D%5Cright%5D%5E%7B-1%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D5%5C%5C2%5Cend%7Barray%7D%5Cright%5D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1.5%5C%5C0.5%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p><strong>如果基向量是正交的，可以使用投影来实现坐标系的转换：</strong></p><p>设原始坐标系<img src="https://math.now.sh?inline=%5Cvec%7Be_1%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C0%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cvec%7Be_2%7D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D0%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，现在有另外一个坐标系，<strong>坐标系在原始坐标系下基向量表示为</strong><img src="https://math.now.sh?inline=%5Cvec%7Bb_1%7D%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cvec%7Bb_2%7D%3D%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D-1%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><p>则将<img src="https://math.now.sh?inline=b" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>坐标系下的向量<img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C3%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>转换到原始坐标系中，通过投影实现：</p><p><img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C3%5Cend%7Barray%7D%5Cright%5D%5Ccdot%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C1%5Cend%7Barray%7D%5Cright%5D%3D2" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D1%5C%5C3%5Cend%7Barray%7D%5Cright%5D%5Ccdot%5Cfrac%7B1%7D%7B%5Csqrt%7B2%7D%7D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D-1%5C%5C1%5Cend%7Barray%7D%5Cright%5D%3D1" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，因此在原始坐标系下的向量为<img src="https://math.now.sh?inline=%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D2%5C%5C1%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>。</p><h2 id="施密特正交化-Gram–Schmidt-process">施密特正交化(Gram–Schmidt process)</h2><p>正交的基向量会给我们解决问题带来很多的方便，需要一种方法将基向量转换为正交的基向量。</p><p>设原始的<img src="https://math.now.sh?inline=n" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>维基向量为<img src="https://math.now.sh?inline=V%3D%5C%7Bv_1%2Cv_2%2Cv_3%2C%5Ccdots%2Cv_n%5C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p><img src="https://math.now.sh?inline=u_1%3Dv_1%2Ce_1%3D%5Cfrac%7Bu_1%7D%7B%7Cu_1%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=u_2%3Dv_2-%28v_2%5Ccdot%20e_1%29%5Cfrac%7Be_1%7D%7B%7Ce_1%7C%7D%2Ce_2%3D%5Cfrac%7Bu_2%7D%7B%7Cu_2%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p><img src="https://math.now.sh?inline=u_3%3Dv_3-%28v_3%5Ccdot%20e_2%29%5Cfrac%7Be_2%7D%7B%7Ce_2%7C%7D-(v_3%5Ccdot%20e_1)%5Cfrac%7Be_1%7D%7B%7Ce_1%7C%7D%2Ce_3%3D%5Cfrac%7Bu_3%7D%7B%7Cu_3%7C%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>特征问题(Eigenproblems)</h1><p>对特征向量的直观感受：在进行变换的时候方向仍然保持不变的向量。</p><p><img src="https://math.now.sh?inline=Ax%3D%5Clambda%20x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=x" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为特征向量，<img src="https://math.now.sh?inline=%5Clambda" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>为特征值。</p><p>求特征值，即<img src="https://math.now.sh?inline=A-%5Clambda%20I" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>的行列式为0</p><p>对角矩阵(diagonal matrix)会使矩阵的乘法变得更加容易，<img src="https://math.now.sh?inline=T%5En%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7Da%5En%260%260%5C%5C0%26b%5En%260%5C%5C0%260%26c%5En%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><p>因此可以通过特征值与特征向量的转换，将矩阵转化为对角矩阵，然后求矩阵的幂。</p><p>设特征向量<img src="https://math.now.sh?inline=C%3D%5Cleft%5B%5Cbegin%7Bmatrix%7Dx_%7B1%7D%26x_%7B2%7D%26%20x_%7B3%7D%5C%5C%5Cvdots%26%5Cvdots%26%5Cvdots%5C%5C%20%5Cend%7Bmatrix%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，特征值的对角矩阵<img src="https://math.now.sh?inline=D%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D%5Clambda_1%5En%260%260%5C%5C0%26%5Clambda_2%5En%260%5C%5C0%260%26%5Clambda_3%5En%5Cend%7Barray%7D%5Cright%5D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，</p><p>矩阵<img src="https://math.now.sh?inline=T%3DCDC%5E%7B-1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/>，<img src="https://math.now.sh?inline=T%5E2%3DCDC%5E%7B-1%7DCDC%5E%7B-1%7D%3DCD%5E2C%5E%7B-1%7D" style="transform:box-shadow:unset;border-radius:0px;display:inline-block;margin: 0;"/></p><h1>编程练习</h1><h2 id="判断一个矩阵是奇异矩阵-singular-还是非奇异矩阵">判断一个矩阵是奇异矩阵(singular)还是非奇异矩阵</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># GRADED FUNCTION</span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># Our function will go through the matrix replacing each row in order turning it into echelon form.</span><span class="hljs-comment"># If at any point it fails because it can&#x27;t put a 1 in the leading diagonal,</span><span class="hljs-comment"># we will return the value True, otherwise, we will return False.</span><span class="hljs-comment"># There is no need to edit this function.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">isSingular</span>(<span class="hljs-params">A</span>) :    B = np.array(A, dtype=np.float_) <span class="hljs-comment"># Make B as a copy of A, since we&#x27;re going to alter it&#x27;s values.</span>    <span class="hljs-keyword">try</span>:        fixRowZero(B)        fixRowOne(B)        fixRowTwo(B)        fixRowThree(B)    <span class="hljs-keyword">except</span> MatrixIsSingular:        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-comment"># This next line defines our error flag. For when things go wrong if the matrix is singular.</span><span class="hljs-comment"># There is no need to edit this line.</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MatrixIsSingular</span>(<span class="hljs-title class_ inherited__">Exception</span>): <span class="hljs-keyword">pass</span><span class="hljs-comment"># For Row Zero, all we require is the first element is equal to 1.</span><span class="hljs-comment"># We&#x27;ll divide the row by the value of A[0, 0].</span><span class="hljs-comment"># This will get us in trouble though if A[0, 0] equals 0, so first we&#x27;ll test for that,</span><span class="hljs-comment"># and if this is true, we&#x27;ll add one of the lower rows to the first one before the division.</span><span class="hljs-comment"># We&#x27;ll repeat the test going down each lower row until we can do the division.</span><span class="hljs-comment"># There is no need to edit this function.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fixRowZero</span>(<span class="hljs-params">A</span>) :    <span class="hljs-keyword">if</span> A[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> :        A[<span class="hljs-number">0</span>] = A[<span class="hljs-number">0</span>] + A[<span class="hljs-number">1</span>]    <span class="hljs-keyword">if</span> A[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> :        A[<span class="hljs-number">0</span>] = A[<span class="hljs-number">0</span>] + A[<span class="hljs-number">2</span>]    <span class="hljs-keyword">if</span> A[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> :        A[<span class="hljs-number">0</span>] = A[<span class="hljs-number">0</span>] + A[<span class="hljs-number">3</span>]    <span class="hljs-keyword">if</span> A[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> :        <span class="hljs-keyword">raise</span> MatrixIsSingular()    A[<span class="hljs-number">0</span>] = A[<span class="hljs-number">0</span>] / A[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]    <span class="hljs-keyword">return</span> A<span class="hljs-comment"># First we&#x27;ll set the sub-diagonal elements to zero, i.e. A[1,0].</span><span class="hljs-comment"># Next we want the diagonal element to be equal to one.</span><span class="hljs-comment"># We&#x27;ll divide the row by the value of A[1, 1].</span><span class="hljs-comment"># Again, we need to test if this is zero.</span><span class="hljs-comment"># If so, we&#x27;ll add a lower row and repeat setting the sub-diagonal elements to zero.</span><span class="hljs-comment"># There is no need to edit this function.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fixRowOne</span>(<span class="hljs-params">A</span>) :    A[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>] - A[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] * A[<span class="hljs-number">0</span>]    <span class="hljs-keyword">if</span> A[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> :        A[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>] + A[<span class="hljs-number">2</span>]        A[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>] - A[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] * A[<span class="hljs-number">0</span>]    <span class="hljs-keyword">if</span> A[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> :        A[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>] + A[<span class="hljs-number">3</span>]        A[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>] - A[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] * A[<span class="hljs-number">0</span>]    <span class="hljs-keyword">if</span> A[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> :        <span class="hljs-keyword">raise</span> MatrixIsSingular()    A[<span class="hljs-number">1</span>] = A[<span class="hljs-number">1</span>] / A[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]    <span class="hljs-keyword">return</span> A<span class="hljs-comment"># This is the first function that you should complete.</span><span class="hljs-comment"># Follow the instructions inside the function at each comment.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fixRowTwo</span>(<span class="hljs-params">A</span>) :    <span class="hljs-comment"># Insert code below to set the sub-diagonal elements of row two to zero (there are two of them).</span>    A[<span class="hljs-number">2</span>] = A[<span class="hljs-number">2</span>] - A[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] * A[<span class="hljs-number">0</span>]    A[<span class="hljs-number">2</span>] = A[<span class="hljs-number">2</span>] - A[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] * A[<span class="hljs-number">1</span>]    <span class="hljs-comment"># Next we&#x27;ll test that the diagonal element is not zero.</span>    <span class="hljs-keyword">if</span> A[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] == <span class="hljs-number">0</span> :        <span class="hljs-comment"># Insert code below that adds a lower row to row 2.</span>        A[<span class="hljs-number">2</span>] = A[<span class="hljs-number">2</span>] + A[<span class="hljs-number">3</span>]        <span class="hljs-comment"># Now repeat your code which sets the sub-diagonal elements to zero.</span>        A[<span class="hljs-number">2</span>] = A[<span class="hljs-number">2</span>] - A[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] * A[<span class="hljs-number">0</span>]        A[<span class="hljs-number">2</span>] = A[<span class="hljs-number">2</span>] - A[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] * A[<span class="hljs-number">1</span>]    <span class="hljs-keyword">if</span> A[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] == <span class="hljs-number">0</span> :        <span class="hljs-keyword">raise</span> MatrixIsSingular()    <span class="hljs-comment"># Finally set the diagonal element to one by dividing the whole row by that element.</span>    A[<span class="hljs-number">2</span>] = A[<span class="hljs-number">2</span>] / A[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]    <span class="hljs-keyword">return</span> A<span class="hljs-comment"># You should also complete this function</span><span class="hljs-comment"># Follow the instructions inside the function at each comment.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">fixRowThree</span>(<span class="hljs-params">A</span>) :    <span class="hljs-comment"># Insert code below to set the sub-diagonal elements of row three to zero.</span>    A[<span class="hljs-number">3</span>] = A[<span class="hljs-number">3</span>] - A[<span class="hljs-number">3</span>,<span class="hljs-number">0</span>] * A[<span class="hljs-number">0</span>]    A[<span class="hljs-number">3</span>] = A[<span class="hljs-number">3</span>] - A[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>] * A[<span class="hljs-number">1</span>]    A[<span class="hljs-number">3</span>] = A[<span class="hljs-number">3</span>] - A[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>] * A[<span class="hljs-number">2</span>]    <span class="hljs-comment"># Complete the if statement to test if the diagonal element is zero.</span>    <span class="hljs-keyword">if</span> A[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] == <span class="hljs-number">0</span>:        <span class="hljs-keyword">raise</span> MatrixIsSingular()    <span class="hljs-comment"># Transform the row to set the diagonal element to one.</span>    A[<span class="hljs-number">3</span>] = A[<span class="hljs-number">3</span>] / A[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]    <span class="hljs-keyword">return</span> A</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">A = np.array([        [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],        [<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>],        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]    ], dtype=np.float_)isSingular(A)A = np.array([        [<span class="hljs-number">0</span>, <span class="hljs-number">7</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">3</span>],        [<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>],        [<span class="hljs-number">3</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>],        [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>]    ], dtype=np.float_)isSingular(A)fixRowZero(A)fixRowOne(A)fixRowTwo(A)fixRowThree(A)</code></pre></div><h2 id="施密特正交化">施密特正交化</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># GRADED FUNCTION</span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> numpy.linalg <span class="hljs-keyword">as</span> laverySmallNumber = <span class="hljs-number">1e-14</span> <span class="hljs-comment"># That&#x27;s 1×10⁻¹⁴ = 0.00000000000001</span><span class="hljs-comment"># Our first function will perform the Gram-Schmidt procedure for 4 basis vectors.</span><span class="hljs-comment"># We&#x27;ll take this list of vectors as the columns of a matrix, A.</span><span class="hljs-comment"># We&#x27;ll then go through the vectors one at a time and set them to be orthogonal</span><span class="hljs-comment"># to all the vectors that came before it. Before normalising.</span><span class="hljs-comment"># Follow the instructions inside the function at each comment.</span><span class="hljs-comment"># You will be told where to add code to complete the function.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">gsBasis4</span>(<span class="hljs-params">A</span>) :    B = np.array(A, dtype=np.float_) <span class="hljs-comment"># Make B as a copy of A, since we&#x27;re going to alter it&#x27;s values.</span>    <span class="hljs-comment"># The zeroth column is easy, since it has no other vectors to make it normal to.</span>    <span class="hljs-comment"># All that needs to be done is to normalise it. I.e. divide by its modulus, or norm.</span>    B[:, <span class="hljs-number">0</span>] = B[:, <span class="hljs-number">0</span>] / la.norm(B[:, <span class="hljs-number">0</span>])    <span class="hljs-comment"># For the first column, we need to subtract any overlap with our new zeroth vector.</span>    B[:, <span class="hljs-number">1</span>] = B[:, <span class="hljs-number">1</span>] - B[:, <span class="hljs-number">1</span>] @ B[:, <span class="hljs-number">0</span>] * B[:, <span class="hljs-number">0</span>]    <span class="hljs-comment"># If there&#x27;s anything left after that subtraction, then B[:, 1] is linearly independant of B[:, 0]</span>    <span class="hljs-comment"># If this is the case, we can normalise it. Otherwise we&#x27;ll set that vector to zero.</span>    <span class="hljs-keyword">if</span> la.norm(B[:, <span class="hljs-number">1</span>]) &gt; verySmallNumber :        B[:, <span class="hljs-number">1</span>] = B[:, <span class="hljs-number">1</span>] / la.norm(B[:, <span class="hljs-number">1</span>])    <span class="hljs-keyword">else</span> :        B[:, <span class="hljs-number">1</span>] = np.zeros_like(B[:, <span class="hljs-number">1</span>])    <span class="hljs-comment"># Now we need to repeat the process for column 2.</span>    <span class="hljs-comment"># Insert two lines of code, the first to subtract the overlap with the zeroth vector,</span>    <span class="hljs-comment"># and the second to subtract the overlap with the first.</span>    B[:, <span class="hljs-number">2</span>] = B[:, <span class="hljs-number">2</span>] - B[:, <span class="hljs-number">2</span>] @ B[:, <span class="hljs-number">0</span>] * B[:, <span class="hljs-number">0</span>]    B[:, <span class="hljs-number">2</span>] = B[:, <span class="hljs-number">2</span>] - B[:, <span class="hljs-number">2</span>] @ B[:, <span class="hljs-number">1</span>] * B[:, <span class="hljs-number">1</span>]      <span class="hljs-comment"># Again we&#x27;ll need to normalise our new vector.</span>    <span class="hljs-comment"># Copy and adapt the normalisation fragment from above to column 2.</span>    <span class="hljs-keyword">if</span> la.norm(B[:, <span class="hljs-number">2</span>]) &gt; verySmallNumber :        B[:, <span class="hljs-number">2</span>] = B[:, <span class="hljs-number">2</span>] / la.norm(B[:, <span class="hljs-number">2</span>])    <span class="hljs-keyword">else</span> :        B[:, <span class="hljs-number">2</span>] = np.zeros_like(B[:, <span class="hljs-number">2</span>])    <span class="hljs-comment"># Finally, column three:</span>    <span class="hljs-comment"># Insert code to subtract the overlap with the first three vectors.</span>    B[:, <span class="hljs-number">3</span>] = B[:, <span class="hljs-number">3</span>] - B[:, <span class="hljs-number">3</span>] @ B[:, <span class="hljs-number">0</span>] * B[:, <span class="hljs-number">0</span>]    B[:, <span class="hljs-number">3</span>] = B[:, <span class="hljs-number">3</span>] - B[:, <span class="hljs-number">3</span>] @ B[:, <span class="hljs-number">1</span>] * B[:, <span class="hljs-number">1</span>]       B[:, <span class="hljs-number">3</span>] = B[:, <span class="hljs-number">3</span>] - B[:, <span class="hljs-number">3</span>] @ B[:, <span class="hljs-number">2</span>] * B[:, <span class="hljs-number">2</span>]      <span class="hljs-comment"># Now normalise if possible</span>    <span class="hljs-keyword">if</span> la.norm(B[:, <span class="hljs-number">3</span>]) &gt; verySmallNumber :        B[:, <span class="hljs-number">3</span>] = B[:, <span class="hljs-number">3</span>] / la.norm(B[:, <span class="hljs-number">3</span>])    <span class="hljs-keyword">else</span> :        B[:, <span class="hljs-number">3</span>] = np.zeros_like(B[:, <span class="hljs-number">3</span>])    <span class="hljs-comment"># Finally, we return the result:</span>    <span class="hljs-keyword">return</span> B<span class="hljs-comment"># The second part of this exercise will generalise the procedure.</span><span class="hljs-comment"># Previously, we could only have four vectors, and there was a lot of repeating in the code.</span><span class="hljs-comment"># We&#x27;ll use a for-loop here to iterate the process for each vector.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">gsBasis</span>(<span class="hljs-params">A</span>) :    B = np.array(A, dtype=np.float_) <span class="hljs-comment"># Make B as a copy of A, since we&#x27;re going to alter it&#x27;s values.</span>    <span class="hljs-comment"># Loop over all vectors, starting with zero, label them with i</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(B.shape[<span class="hljs-number">1</span>]) :        <span class="hljs-comment"># Inside that loop, loop over all previous vectors, j, to subtract.</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i) :            <span class="hljs-comment"># Complete the code to subtract the overlap with previous vectors.</span>            <span class="hljs-comment"># you&#x27;ll need the current vector B[:, i] and a previous vector B[:, j]</span>            B[:, i] = B[:, i] - B[:, i] @ B[:, j] * B[:, j]        <span class="hljs-comment"># Next insert code to do the normalisation test for B[:, i]</span>        <span class="hljs-keyword">if</span> la.norm(B[:, i]) &gt; verySmallNumber :            B[:, i] = B[:, i] / la.norm(B[:, i])        <span class="hljs-keyword">else</span> :                B[:, i] = np.zeros_like(B[:, i])    <span class="hljs-comment"># Finally, we return the result:</span>    <span class="hljs-keyword">return</span> B<span class="hljs-comment"># This function uses the Gram-schmidt process to calculate the dimension</span><span class="hljs-comment"># spanned by a list of vectors.</span><span class="hljs-comment"># Since each vector is normalised to one, or is zero,</span><span class="hljs-comment"># the sum of all the norms will be the dimension.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">dimensions</span>(<span class="hljs-params">A</span>) :    <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">sum</span>(la.norm(gsBasis(A), axis=<span class="hljs-number">0</span>))</code></pre></div><div class="code-wrapper"><pre><code class="hljs python">V = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],              [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>],              [<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],              [<span class="hljs-number">1</span>,-<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]], dtype=np.float_)gsBasis4(V)<span class="hljs-comment"># Once you&#x27;ve done Gram-Schmidt once,</span><span class="hljs-comment"># doing it again should give you the same result. Test this:</span>U = gsBasis4(V)gsBasis4(U)<span class="hljs-comment"># Try the general function too.</span>gsBasis(V)<span class="hljs-comment"># See what happens for non-square matrices</span>A = np.array([[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],              [<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">1</span>],              [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>],              [<span class="hljs-number">12</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]], dtype=np.float_)gsBasis(A)dimensions(A)B = np.array([[<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>],              [<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,-<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],              [<span class="hljs-number">1</span>,-<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>]], dtype=np.float_)gsBasis(B)dimensions(B)<span class="hljs-comment"># Now let&#x27;s see what happens when we have one vector that is a linear combination of the others.</span>C = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],              [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>],              [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]], dtype=np.float_)gsBasis(C)dimensions(C)</code></pre></div><h2 id="镜面投影">镜面投影</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># PACKAGE</span><span class="hljs-comment"># Run this cell first once to load the dependancies.</span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> numpy.linalg <span class="hljs-keyword">import</span> norm, inv<span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> transpose<span class="hljs-keyword">from</span> readonly.bearNecessities <span class="hljs-keyword">import</span> *<span class="hljs-comment"># GRADED FUNCTION</span><span class="hljs-comment"># You should edit this cell.</span><span class="hljs-comment"># In this function, you will return the transformation matrix T,</span><span class="hljs-comment"># having built it out of an orthonormal basis set E that you create from Bear&#x27;s Basis</span><span class="hljs-comment"># and a transformation matrix in the mirror&#x27;s coordinates TE.</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_reflection_matrix</span>(<span class="hljs-params">bearBasis</span>) : <span class="hljs-comment"># The parameter bearBasis is a 2×2 matrix that is passed to the function.</span>    <span class="hljs-comment"># Use the gsBasis function on bearBasis to get the mirror&#x27;s orthonormal basis.</span>    E = gsBasis(bearBasis)    <span class="hljs-comment"># Write a matrix in component form that performs the mirror&#x27;s reflection in the mirror&#x27;s basis.</span>    <span class="hljs-comment"># Recall, the mirror operates by negating the last component of a vector.</span>    <span class="hljs-comment"># Replace a,b,c,d with appropriate values</span>    TE = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>],                   [<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]])    <span class="hljs-comment"># Combine the matrices E and TE to produce your transformation matrix.</span>    T = E @ TE @ inv(E)    <span class="hljs-comment"># Finally, we return the result. There is no need to change this line.</span>    <span class="hljs-keyword">return</span> T<span class="hljs-comment"># First load Pyplot, a graph plotting library.</span>%matplotlib inline<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment"># This is the matrix of Bear&#x27;s basis vectors.</span><span class="hljs-comment"># (When you&#x27;ve done the exercise once, see what happns when you change Bear&#x27;s basis.)</span>bearBasis = np.array(    [[<span class="hljs-number">1</span>,   -<span class="hljs-number">1</span>],     [<span class="hljs-number">1.5</span>, <span class="hljs-number">2</span>]])<span class="hljs-comment"># This line uses your code to build a transformation matrix for us to use.</span>T = build_reflection_matrix(bearBasis)<span class="hljs-comment"># Bear is drawn as a set of polygons, the vertices of which are placed as a matrix list of column vectors.</span><span class="hljs-comment"># We have three of these non-square matrix lists: bear_white_fur, bear_black_fur, and bear_face.</span><span class="hljs-comment"># We&#x27;ll make new lists of vertices by applying the T matrix you&#x27;ve calculated.</span>reflected_bear_white_fur = T @ bear_white_furreflected_bear_black_fur = T @ bear_black_furreflected_bear_face = T @ bear_face<span class="hljs-comment"># This next line runs a code to set up the graphics environment.</span>ax = draw_mirror(bearBasis)<span class="hljs-comment"># We&#x27;ll first plot Bear, his white fur, his black fur, and his face.</span>ax.fill(bear_white_fur[<span class="hljs-number">0</span>], bear_white_fur[<span class="hljs-number">1</span>], color=bear_white, zorder=<span class="hljs-number">1</span>)ax.fill(bear_black_fur[<span class="hljs-number">0</span>], bear_black_fur[<span class="hljs-number">1</span>], color=bear_black, zorder=<span class="hljs-number">2</span>)ax.plot(bear_face[<span class="hljs-number">0</span>], bear_face[<span class="hljs-number">1</span>], color=bear_white, zorder=<span class="hljs-number">3</span>)<span class="hljs-comment"># Next we&#x27;ll plot Bear&#x27;s reflection.</span>ax.fill(reflected_bear_white_fur[<span class="hljs-number">0</span>], reflected_bear_white_fur[<span class="hljs-number">1</span>], color=bear_white, zorder=<span class="hljs-number">1</span>)ax.fill(reflected_bear_black_fur[<span class="hljs-number">0</span>], reflected_bear_black_fur[<span class="hljs-number">1</span>], color=bear_black, zorder=<span class="hljs-number">2</span>)ax.plot(reflected_bear_face[<span class="hljs-number">0</span>], reflected_bear_face[<span class="hljs-number">1</span>], color=bear_white, zorder=<span class="hljs-number">3</span>);</code></pre></div><p><a href="https://imgtu.com/i/jhnVED"><img src="https://s1.ax1x.com/2022/07/15/jhnVED.md.png" alt="jhnVED.md.png"></a></p><h2 id="PageRank">PageRank</h2><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># PACKAGE</span><span class="hljs-comment"># Here are the imports again, just in case you need them.</span><span class="hljs-comment"># There is no need to edit or submit this cell.</span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> numpy.linalg <span class="hljs-keyword">as</span> la<span class="hljs-keyword">from</span> readonly.PageRankFunctions <span class="hljs-keyword">import</span> *np.set_printoptions(suppress=<span class="hljs-literal">True</span>)<span class="hljs-comment"># GRADED FUNCTION</span><span class="hljs-comment"># Complete this function to provide the PageRank for an arbitrarily sized internet.</span><span class="hljs-comment"># I.e. the principal eigenvector of the damped system, using the power iteration method.</span><span class="hljs-comment"># (Normalisation doesn&#x27;t matter here)</span><span class="hljs-comment"># The functions inputs are the linkMatrix, and d the damping parameter - as defined in this worksheet.</span><span class="hljs-comment"># (The damping parameter, d, will be set by the function - no need to set this yourself.)</span><span class="hljs-keyword">def</span> <span class="hljs-title function_">pageRank</span>(<span class="hljs-params">linkMatrix, d</span>) :    n = linkMatrix.shape[<span class="hljs-number">0</span>]    M = d * linkMatrix + (<span class="hljs-number">1</span>-d)/n * np.ones([n, n])    r = <span class="hljs-number">100</span> * np.ones(n) / n    lastR = r    r = M @ r    i = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> la.norm(lastR - r) &gt; <span class="hljs-number">0.01</span> :        lastR = r        r = M @ r        i += <span class="hljs-number">1</span>      <span class="hljs-keyword">return</span> r</code></pre></div><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Use the following function to generate internets of different sizes.</span>generate_internet(<span class="hljs-number">5</span>)<span class="hljs-comment"># Test your PageRank method against the built in &quot;eig&quot; method.</span><span class="hljs-comment"># You should see yours is a lot faster for large internets</span>L = generate_internet(<span class="hljs-number">10</span>)pageRank(L, <span class="hljs-number">1</span>)<span class="hljs-comment"># Do note, this is calculating the eigenvalues of the link matrix, L,</span><span class="hljs-comment"># without any damping. It may give different results that your pageRank function.</span><span class="hljs-comment"># If you wish, you could modify this cell to include damping.</span><span class="hljs-comment"># (There is no credit for this though)</span>eVals, eVecs = la.eig(L) <span class="hljs-comment"># Gets the eigenvalues and vectors</span>order = np.absolute(eVals).argsort()[::-<span class="hljs-number">1</span>] <span class="hljs-comment"># Orders them by their eigenvalues</span>eVals = eVals[order]eVecs = eVecs[:,order]r = eVecs[:, <span class="hljs-number">0</span>]<span class="hljs-number">100</span> * np.real(r / np.<span class="hljs-built_in">sum</span>(r))<span class="hljs-comment"># You may wish to view the PageRank graphically.</span><span class="hljs-comment"># This code will draw a bar chart, for each (numbered) website on the generated internet,</span><span class="hljs-comment"># The height of each bar will be the score in the PageRank.</span><span class="hljs-comment"># Run this code to see the PageRank for each internet you generate.</span><span class="hljs-comment"># Hopefully you should see what you might expect</span><span class="hljs-comment"># - there are a few clusters of important websites, but most on the internet are rubbish!</span>%pylab notebookr = pageRank(generate_internet(<span class="hljs-number">100</span>), <span class="hljs-number">0.9</span>)plt.bar(arange(r.shape[<span class="hljs-number">0</span>]), r);</code></pre></div><h1>资料</h1><p>Formula Sheet: Sheet summarising all the formulae covered in this course.</p><div class="row">    <embed src="https://zhangzhao219.github.io/file/Coursera/Mathematics-for-Machine-Learning-Specialization/Mathematics-for-Machine-Learning-Linear-Algebra/Formula-Sheet.pdf" width="100%" height="550" type="application/pdf"></div><p><a href="https://zhangzhao219.github.io/file/Coursera/Mathematics-for-Machine-Learning-Specialization/Mathematics-for-Machine-Learning-Linear-Algebra/Notebooks.zip" title="Code for Mathematics for Machine Learning: Linear Algebra">Code and Notebooks</a></p>]]></content>
    
    
    <categories>
      
      <category>Study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Machine Learning</tag>
      
      <tag>Linear Algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Trip To Qingdao</title>
    <link href="/2022/07/11/trip-to-qingdao/"/>
    <url>/2022/07/11/trip-to-qingdao/</url>
    
    <content type="html"><![CDATA[<h1>青岛旅行计划</h1><span id="more"></span><h2 id="防疫政策">防疫政策</h2><p>理论上的防疫政策：低风险地区提前三天向酒店等报备，第一天和第三天两次核酸。</p><p>实际：基本只看“青岛一码通”的绿码和7天内核酸阴性报告（有的地方可能要48小时核酸阴性报告）</p><p>具体措施：</p><ol><li>在家做好核酸，时间越晚越好（当然上车前必须要出结果），带好电子版或者纸质版报告，提前申请“青岛一码通”。</li><li>Day0 从青岛北站出来应该有核酸检测的点位，如果没有就去台东北侧的“青岛市海慈医疗集团”（公众号：青岛市海慈医疗集团）做24小时核酸。</li><li>保证 Day2 和 Day3 至少分别做一次核酸，青岛出结果比较慢，要第二天才能出。</li><li>公交地铁景区基本都要看“青岛一码通”的绿码和7天内核酸阴性报告，不要下载“青岛地铁APP”（青岛地铁APP要核验山东省电子健康卡，而申请山东省电子健康卡需要“入鲁申报”，为了减少不必要的麻烦这个不做），<strong>公交可以在支付宝或者云闪付申请电子公交码，地铁直接在地铁站买票进站，景区提前预约</strong>。</li><li>要是“青岛一码通”变黄码就BBQ了，应该不会的。</li></ol><h2 id="总计划">总计划</h2><table><thead><tr><th>日期</th><th>计划</th><th>备注</th></tr></thead><tbody><tr><td>Day0</td><td>晚上到达青岛，做核酸、住酒店</td><td>可以去旁边的丽达生活超市买一些水和吃的</td></tr><tr><td>Day1上午</td><td>信号山公园、栈桥</td><td></td></tr><tr><td>Day1中午</td><td><strong>王姐烧烤</strong>午餐</td><td></td></tr><tr><td>Day1下午</td><td>小青岛公园、鲁迅公园、小鱼山公园、青岛第一海水浴场、八大关风景区</td><td></td></tr><tr><td>Day1晚上</td><td><strong>台东步行街小吃</strong>晚餐、回酒店</td><td>可以去大商场买一点点吃的和水果等</td></tr><tr><td>Day2上午</td><td>小麦岛公园</td><td></td></tr><tr><td>Day2中午</td><td><strong>船歌鱼水饺</strong>午餐</td><td></td></tr><tr><td>Day2下午</td><td>燕儿岛公园、奥帆中心、情人坝、五四广场、海天云上艺术中心</td><td>看天气，太热了就先去海天云上艺术中心</td></tr><tr><td>Day2晚上</td><td><strong>探海岛海鲜自助</strong>（探鲜岛海鲜自助餐厅）晚餐、栈桥附近的夜景、回酒店</td><td></td></tr><tr><td>Day3上午</td><td>去崂山风景区</td><td></td></tr><tr><td>Day3中午</td><td>吃一些提前买的面包等，景区内应该也有一些吃的</td><td></td></tr><tr><td>Day3下午</td><td>崂山风景区、回市区</td><td></td></tr><tr><td>Day3晚上</td><td><strong>前海沿</strong>晚餐、回酒店</td><td></td></tr><tr><td>Day4</td><td>返程</td><td></td></tr></tbody></table><p>备注：</p><ol><li>景点备选：鲁迅公园附近的青岛<strong>海底世界</strong>和海军博物馆（太热了可以去避避暑）（可能都预约不上的）</li><li>美食备选：火车站附近：无名小吃（似乎关门了，推荐油焖大虾，扇贝）和白玉餐厅（鱿鱼、茄子）；石老人海水浴场附近的马扎子烧烤；五四广场附近的开海；台东的湘西石锅鱼和大叹号韩式烤肉；双和园水饺；还可以去买活海鲜（团岛农贸市场、营口海鲜市场、埠西市场）。<strong>要 no 尝尝崂山可乐和崂山白花蛇草水</strong>。早上要吃点东西，面包或者出去买一点点早餐。</li><li>预计支出：车票1800；吃饭128+100+158+178+150+…≈800；酒店200*4≈800；门票、交通≈500。总共3900。<strong>小荷包还有4405.73，应该可以cover全部支出</strong></li><li>实际支出：车票391.5+462.5+412.5+19.5+63+339.82+15=1703.82；酒店838；门票10+298+40；</li></ol><h3 id="青岛景点总览图">青岛景点总览图</h3><p><a href="https://imgtu.com/i/jcdeWF"><img src="https://s1.ax1x.com/2022/07/11/jcdeWF.md.png" alt="jcdeWF.md.png" title="青岛景点总览图"></a></p><h3 id="酒店附近地图">酒店附近地图</h3><p><a href="https://imgtu.com/i/jqylcV"><img src="https://s1.ax1x.com/2022/07/21/jqylcV.md.png" alt="jqylcV.md.png"></a></p><h2 id="Day-1">Day 1</h2><h3 id="信号山公园">信号山公园</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.331561-36.066446" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.331561-36.066446',{center:[36.066446,120.331561],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.066446','120.331561']).addTo(mymap);marker.bindPopup("信号山公园").openPopup();</script><ul><li><p>交通方式：酒店——信号山公园，公交前往，37分钟，步行680米</p><p><a href="https://imgtu.com/i/jq66MV"><img src="https://s1.ax1x.com/2022/07/21/jq66MV.md.png" alt="jq66MV.md.png"></a></p><p><a href="https://imgtu.com/i/jqg8nf"><img src="https://s1.ax1x.com/2022/07/21/jqg8nf.md.png" alt="jqg8nf.md.png"></a></p></li><li><p>预约：已经预约好 7月24日 6:00-20:30，包括收费5元的旋转观景楼</p></li><li><p>时间：1个小时左右</p></li><li><p>简介：信号山公园位于青岛市中心，因曾在山顶建有为船只引航的信号台而得名。信号山海拔98米，山顶三幢红顶蘑菇楼尤为显眼，其中较高的一幢是旋转观景楼，在这里你可以360度俯看青岛“红瓦绿树，碧海蓝天”的景色。进入景区大门，南坡上有踏浪观景台，就在连心桥下面一点，是拍摄南边德国古堡式建筑迎宾馆的好位置。连心桥上一把把红色爱心造型的锁挂在绿色栏杆上，情侣们可以在此买一把同心锁把彼此的山盟海誓锁在信号山上，据说手拉手走过连心桥可以得到祝福，单身的话自个儿的左手拉右手一样很好！再往前，可以看看五龙潭喷泉等景点，周围四条小龙围着中间一条大龙，与信号山又叫五龙山对应，因为山周边有龙江路、龙华路、龙口路、龙山路、伏龙路五条带“龙”字的路而得此别名。最后到达山顶的旋转观景楼，登上楼上观景台观景，一幢幢掩映在绿树中红瓦黄墙的德式建筑令人惊叹。往西南看，近处有绿色钟楼屋顶的基督教堂在一片红屋顶中非常出挑。</p></li></ul><h3 id="栈桥">栈桥</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.3193-36.061736" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.3193-36.061736',{center:[36.061736,120.3193],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.061736','120.3193']).addTo(mymap);marker.bindPopup("栈桥").openPopup();</script><ul><li>交通方式：信号山公园——栈桥，步行前往，2公里路程，10分钟。<br><a href="https://imgtu.com/i/jq2aVO"><img src="https://s1.ax1x.com/2022/07/21/jq2aVO.md.png" alt="jq2aVO.md.png"></a></li><li>预约：无需预约，包括栈桥与回澜阁，一说回澜阁8:30-16:30开放</li><li>时间：预计半小时左右</li><li>简介：栈桥位于青岛中心城区的南部海滨，是一条440米长的海上长廊，从陆地延伸入海中。回澜阁里面有一块无字碑，这块石碑的来历至今众说纷纭。现在，阁内通过主题展陈的方式，全面展示青岛近现代历史、人文、民俗等独特城市风貌。栈桥两边有铁链护栏和莲花路灯，游人漫步于栈桥海滨，风平浪静时，可观看海鸥在此自由翱翔。走到桥的尽头还可远眺小青岛。岛上树影婆娑、绿荫成群，一座白灯塔亭亭玉立。涨潮时，惊涛拍打着防波堤，激起簇簇浪花，可驻足观看。退潮时，赭色岩礁和金色沙滩露出水面，可走下栈桥，漫步在海滩上赶海拾贝。</li></ul><h3 id="王姐烧烤">王姐烧烤</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.33032-36.05876" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.33032-36.05876',{center:[36.05876,120.33032],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.05876','120.33032']).addTo(mymap);marker.bindPopup("王姐烧烤").openPopup();</script><ul><li><p>交通方式：栈桥——王姐烧烤，步行前往，1.2公里路程，16分钟。</p><p><a href="https://imgtu.com/i/jqRFeK"><img src="https://s1.ax1x.com/2022/07/21/jqRFeK.md.png" alt="jqRFeK.md.png"></a></p></li><li><p>美团可以直接订座，重点菜：辣炒蛤蜊</p></li></ul><center class="half"><img src="https://s1.ax1x.com/2022/07/17/jIFSts.md.jpg" width="40%"/><img src="https://s1.ax1x.com/2022/07/17/jIFphn.md.jpg" width="40%"/></center><h3 id="小青岛公园——鲁迅公园——小鱼山公园——青岛第一海水浴场">小青岛公园——鲁迅公园——小鱼山公园——青岛第一海水浴场</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.333117-36.055007" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.333117-36.055007',{center:[36.055007,120.333117],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.055007','120.333117']).addTo(mymap);marker.bindPopup("鲁迅公园").openPopup();</script><ul><li><p>交通方式：步行，共3公里左右</p><p><a href="https://imgtu.com/i/j6slDJ"><img src="https://s1.ax1x.com/2022/07/11/j6slDJ.md.png" alt="j6slDJ.md.png" title="鲁迅公园——小鱼山公园——青岛第一海水浴场"></a></p></li><li><p>预约：小鱼山公园开放时间08:00-17:00，网上找不到预约入口</p></li><li><p>时间：2-3小时</p></li><li><p>简介：小青岛故称为“琴岛”，是青岛湾内的一座小岛，青岛这个城市的名称就来源于它。小青岛与陆地之间有长长的海堤相接，岛上矗立着德国人建于1898年的灯塔，是青岛的标志之一。小青岛面积很小，岛上绿树成荫，岛的四周礁石环绕，海水清澈、蔚蓝，岛上常能见到来垂钓的游客。坐在礁石上吹吹海风，赤脚踩踩海水，看看四周青岛湾边林立的高楼和红顶的小洋房，仿佛置身于海上花园。每当夕阳西下时景色尤其美，阳光把整个海湾都镀成了金色。小青岛的南侧有一尊姿态优美的琴女雕像，雕像周围是花坛，种植着五颜六色的鲜花。岛的较高处有当年德国人建造的灯塔，整个岛的海拔也不高，才17米，走到灯塔脚下不需要爬多少路。灯塔通体洁白，由大理石构筑，是海上过往船只进出胶州湾的重要航标。每当夜幕降临，灯塔与岛上的灯光倒映在海面上，像一匹飘动的彩绸，形成青岛的一大胜景“琴屿飘灯”，在这里拍摄夜景很不错。鲁迅公园是青岛市内一处对外开放的临海公园，海边有大片的红褐色礁石，景色很特别，常有不少新人在此拍摄婚纱照。沿着海边步道慢慢走、听听海浪拍壁之声，或是走上岩石高处的亭子远眺大海，很是惬意。公园的东部紧邻青岛海底世界，再往东走是第一海水浴场，沿途风光很美。小鱼山公园是青岛佳风景眺望点之一，一是因为它位于市中心，是青岛离海近的一座山，地理位置；二是因为它的海拔仅60米，爬山不累，登到山顶能看到“红瓦绿树，碧海蓝天”具青岛代表性的景色。</p></li></ul><h3 id="八大关风景区">八大关风景区</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.351241-36.053309" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.351241-36.053309',{center:[36.053309,120.351241],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.053309','120.351241']).addTo(mymap);marker.bindPopup("八大关风景区").openPopup();</script><ul><li><p>交通方式：步行，毗邻青岛第一海水浴场</p></li><li><p>景区图：</p><p><a href="https://imgtu.com/i/j6g5lV"><img src="https://s1.ax1x.com/2022/07/11/j6g5lV.md.png" alt="j6g5lV.md.png" title="八大关风景区"></a></p></li><li><p>预约：无需预约，内部场馆单独售票，营业时间：9：00-17：00；换票时间：9：00-15：00</p></li><li><p>时间：2小时</p></li><li><p>简介：八大关是青岛市区南部相交错的十几条马路的总称，它们大多取名于我国知名关隘的名称。这里环境清幽，春季有碧桃盛开、夏季有紫薇盛放，秋季可见银杏红枫夹道，还坐落着许多各国风格的别墅，是摄影胜地。在这里，你可以进入欧洲古堡风格的“花石楼”参观、登上楼顶遥望大海，或者外观开国元帅住过的日式洋楼“元帅楼”、流传着唯美爱情故事的丹麦建筑“公主楼”等经典别墅，让你仿佛身处欧洲的某个角落。</p></li></ul><h3 id="台东步行街">台东步行街</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.353979-36.083335" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.353979-36.083335',{center:[36.083335,120.353979],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.083335','120.353979']).addTo(mymap);marker.bindPopup("台东步行街").openPopup();</script><ul><li><p>交通方式：地铁，24分钟，步行248m</p><p><a href="https://imgtu.com/i/j6WRFH"><img src="https://s1.ax1x.com/2022/07/11/j6WRFH.md.png" alt="j6WRFH.md.png" title="八大关——台东步行街"></a></p></li><li><p>预约：无需预约</p></li><li><p>时间：晚上</p></li><li><p>简介：“朝观壁画夜赏灯，购物休闲在台东”，台东步行街是青岛有名的街区，街内有国内外知名的沃尔玛、万达广场、百信鞋业、利群集团、苏宁电器、三联家电、亚泰电器、新华书店、医保城等各类业态的企业245家。步行街两侧的21座楼6万余平方米的墙面为统一彩绘，精心绘制了色彩斑斓、造型生动的大型壁画，形成了独特的彩色画廊，这是大型的手工彩绘一条街。台东三路经过精心的景观设置，夜景迷人。这里还有男士、女士特色广场，营造出优美的购物和休闲环境，使市民在购物消费的同时，还享受着文化特色的盛宴。</p></li><li><p>美食推荐（有人排队多的肯定好吃）：</p><ul><li>一家烤猪蹄，好像是叫黄金猪蹄。</li><li>一家烤冷面，旁边一个蜜雪冰城，对面一家章鱼小丸子。烤冷面、烤粉丝、还有对面的章鱼烧都很好。</li><li>一家炸鸡腿，在一个路口上，然后附近有一个杨国福麻辣烫。</li><li>有一家面包，就是三角形的，好像是叫三脚猫。</li><li>买酱猪蹄带回去（周钦公流亭酱猪蹄）</li></ul></li></ul><center class="third"><img src="https://s1.ax1x.com/2022/07/17/jIFg4s.md.jpg" width="30%"/><img src="https://s1.ax1x.com/2022/07/17/jIF5uT.md.jpg" width="30%"/><img src="https://s1.ax1x.com/2022/07/17/jIFsHg.md.jpg" width="30%"/></center><h2 id="Day-2">Day 2</h2><h3 id="小麦岛公园">小麦岛公园</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.431045-36.054245" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.431045-36.054245',{center:[36.054245,120.431045],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.054245','120.431045']).addTo(mymap);marker.bindPopup("小麦岛公园").openPopup();</script><ul><li><p>交通方式：地铁+公交（打车）（或公交），58分钟，步行1.2公里</p><p><a href="https://imgtu.com/i/jqI21e"><img src="https://s1.ax1x.com/2022/07/21/jqI21e.md.png" alt="jqI21e.md.png"></a></p></li><li><p>预约：无需预约</p></li><li><p>时间：1-2小时</p></li><li><p>简介：小麦岛公园位于崂山区麦岛路西50米，小麦岛属环形岛屿，有大片平坦宽广的绿化草地，远处就是湛蓝的海水，可在这里眺望到遥远的海岸线，一派海滨美景，非常适宜拍照。</p></li></ul><h3 id="船歌鱼水饺">船歌鱼水饺</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.427741-36.061852" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.427741-36.061852',{center:[36.061852,120.427741],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.061852','120.427741']).addTo(mymap);marker.bindPopup("船歌鱼水饺").openPopup();</script><p>就在小麦岛公园的公交站旁边，逛后吃午餐。</p><p>重点菜：鲅鱼、墨鱼、三鲜、虾仁水饺，海菜凉粉</p><center class="half"><img src="https://s1.ax1x.com/2022/07/17/jIkCUH.md.jpg" width="40%"/><img src="https://s1.ax1x.com/2022/07/17/jIkFPA.md.jpg" width="40%"/></center><h3 id="燕儿岛公园">燕儿岛公园</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.40571-36.055267" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.40571-36.055267',{center:[36.055267,120.40571],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.055267','120.40571']).addTo(mymap);marker.bindPopup("燕儿岛公园").openPopup();</script><ul><li><p>交通方式：公交34分钟，步行883米</p><p><a href="https://imgtu.com/i/jcn8gS" title="小麦岛公园——燕儿岛公园"><img src="https://s1.ax1x.com/2022/07/11/jcn8gS.md.png" alt="jcn8gS.md.png"></a></p></li><li><p>预约：无需预约</p></li><li><p>时间：1-3小时</p></li><li><p>简介：燕儿岛山公园位于山东省青岛市南部，处在浮山湾东端，是一个突出海中的岬角。园内环境优美，集生态、景观、文化、健身、休闲等为一体，是市民休闲锻炼、观光游玩的好地方。公园里的海滨栈道是一大亮点，木栈道与阶梯相连，一边是大海，一边是峭壁，峭壁底下鲜花盛开，在这里拍照仿佛置身于美丽的垦丁，有着独特的韵味。登上阶梯高处的平台放眼望去，可以将整个大海纳入眼帘，景色十分迷人。</p></li></ul><h3 id="奥帆中心——情人坝——五四广场">奥帆中心——情人坝——五四广场</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.393844-36.055406" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.393844-36.055406',{center:[36.055406,120.393844],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.055406','120.393844']).addTo(mymap);marker.bindPopup("奥帆中心").openPopup();</script><ul><li><p>交通方式：步行，直线距离2公里左右</p><p><a href="https://imgtu.com/i/jcQYR0"><img src="https://s1.ax1x.com/2022/07/11/jcQYR0.md.png" alt="jcQYR0.md.png" title="奥帆中心——情人坝——五四广场"></a></p></li><li><p>预约：无需预约，奥帆中心其他景点待确定</p></li><li><p>时间：2-3小时</p></li><li><p>简介：青岛奥帆中心景区位于青岛市浮山湾畔，与青岛市标志性景点——<a href="https://baike.baidu.com/item/%E4%BA%94%E5%9B%9B%E5%B9%BF%E5%9C%BA/1111704">五四广场</a>近海相望，总占地面积约45公顷，是2008年北京第29届奥运会奥帆赛和第13届残奥会帆船比赛举办场地，奥帆中心景区依山面海，景色宜人，是全国唯一“国家滨海旅游休闲示范区”。青岛被誉为“帆船之都”，作为最能体现青岛城市特色和展示城市形象的景区，奥帆中心景区内不仅有飞帆渺渺的优雅，有青岛十大旧景代表燕岛秋潮，有青岛新时代景观鸥翔彩虹，更有众多惊险刺激的娱乐体验，是游客来青必看的景点。</p></li></ul><h3 id="海天云上艺术中心">海天云上艺术中心</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.369799-36.056747" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.369799-36.056747',{center:[36.056747,120.369799],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.056747','120.369799']).addTo(mymap);marker.bindPopup("青岛云上海天").openPopup();</script><ul><li><p>交通方式：公交或地铁，20分钟</p><p><a href="https://imgtu.com/i/jcQ7Wt"><img src="https://s1.ax1x.com/2022/07/11/jcQ7Wt.md.png" alt="jcQ7Wt.md.png" title="海天云上艺术中心"></a></p></li><li><p>预约：已经预约好 7月25日 9:00-20:00，80F+81F联票</p></li><li><p>时间：没查到。。。</p></li><li><p>简介：海天中心城市观光厅是山东省超高层垂直建筑之上的高空观光平台。在这里，向西可揽胜八大关老城区红瓦绿树，向东承接新城区璀璨繁华，360°俯瞰壮美海景、山景、城景，全方位感受身处&quot;天空之城&quot;的独特体验。其内部设置的透明观景区、沉浸式体验区、多媒体展示区与空中水吧等多个功能空间，将内部游览体验与外部自然景观融为一体。站在369米之上的城市观光厅，可以看尽因海而生、向海而兴的魅力青岛在时间长河中的风貌变迁与发展动线。随着观光者的漫步，不同姿态的青岛都将尽收眼底。</p></li></ul><h3 id="探海岛海鲜自助（探鲜岛海鲜自助餐厅）">探海岛海鲜自助（探鲜岛海鲜自助餐厅）</h3><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="gaodeMap-120.320334-36.062995" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"高德卫星地图":imgm,"高德卫星标注":image};var mymap=L.map('gaodeMap-120.320334-36.062995',{center:[36.062995,120.320334],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['36.062995','120.320334']).addTo(mymap);marker.bindPopup("探鲜岛海鲜自助餐厅").openPopup();</script><p>回青岛站附近吃晚餐，美团可以订座，顺便可以游览栈桥附近的夜景。</p><center class="half"><img src="https://s1.ax1x.com/2022/07/17/jIkmqS.md.jpg" width="40%"/><img src="https://s1.ax1x.com/2022/07/17/jIkM5j.md.jpg" width="40%"/></center><h2 id="Day-3">Day 3</h2><h3 id="崂山风景区">崂山风景区</h3><ul><li><p>交通方式：地铁接公交</p></li><li><p>预约：已经预约好 7月26日 6:00-12:00太清，12:01-17:30 华严和仰口</p></li><li><p>时间：一天</p></li><li><p>路线：大河东检票——第三站下车游览太清宫、太清索道——索道往返——走到垭口乘坐公交618路前往华严（或仰口）——景区游览车到仰口（或华严）——原路返回大河东（或者直接从仰口出去）</p></li><li><p><a href="https://90a40goyo.wasee.com/wt/90a40goyo?def_sid=0" title="地图">崂山风景区地图</a></p><p><a href="https://imgtu.com/i/jcaA8e"><img src="https://s1.ax1x.com/2022/07/11/jcaA8e.md.png" alt="jcaA8e.md.png"></a></p><p><a href="https://imgtu.com/i/jcUjgJ"><img src="https://s1.ax1x.com/2022/07/11/jcUjgJ.md.png" alt="jcUjgJ.md.png"></a></p></li></ul><h3 id="前海沿">前海沿</h3><p>这个位置暂定，美团可以排队</p><p><a href="https://imgtu.com/i/jIirk9"><img src="https://s1.ax1x.com/2022/07/17/jIirk9.md.png" alt="jIirk9.md.png" title="前海沿"></a></p><p>重点菜：蒜蓉粉丝虾、手锤茄子卷饼</p><center class="half"><img src="https://s1.ax1x.com/2022/07/17/jIkBGR.md.jpg" width="30%"/><img src="https://s1.ax1x.com/2022/07/17/jIkDR1.md.jpg" width="30%"/><img src="https://s1.ax1x.com/2022/07/17/jIkrxx.md.jpg" width="30%"/></center>]]></content>
    
    
    <categories>
      
      <category>Travel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ziyaooo</tag>
      
      <tag>Love</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022保研经历</title>
    <link href="/2022/07/03/postgraduate-recommendation/"/>
    <url>/2022/07/03/postgraduate-recommendation/</url>
    
    <content type="html"><![CDATA[<p>2022级保研经历</p><span id="more"></span><p>2022级推免基本告一段落，刚开始夏令营的时候其实还没有什么疫情，但是各大高校仍然基本选择了线上夏令营，因此造成了夏令营非常非常卷。我本人将比我们学校好的985基本全部报了一遍，总共报了20多个，最后入营的非常少。不幸中的万幸我以为根本不可能考虑我的中科院计算所在我没入营没联系老师的情况下仍然打电话叫我过去考试，最终拿到了offer。计算所offer确认的时间比较早，是9月10日，而经过夏令营入营惨痛的经历，我决定就不参加预推免了。</p><h2 id="本人情况">本人情况</h2><ul><li>某中流985大数据专业</li><li>rank：3/65，一等奖学金，优秀学生</li><li>竞赛：天梯赛个人二等奖，程序设计竞赛校二，CCF250分；数学建模国赛省三，亚太杯二等奖，美赛H奖；大英赛三等奖；服创国二，计算机设计大赛省二</li><li>科研经历：0论文，1国家级大创1校级大创（因为参与度不高全程夏令营都没有提及），跟本科老师做的项目（1专利1软著，论文正在写）</li><li>英语：六级540，四级560</li><li>最终去向：中科院计算所网数重点实验室学硕</li><li>参加的夏令营（均为学硕）：<br>南京大学计算机科学与技术系（笔试挂）<br>北京理工大学计算机学院（优营）<br>北京航空航天大学计算机学院（替补）<br>天津大学智能与计算学部（优营）<br>华东师范大学计算机科学与技术学院（优营）<br>华中科技大学计算机科学与技术学院（优营）<br>中山大学计算机学院（软件学院）（替补）</li><li>没有入营但是去面试的：中科院计算所</li><li>入营但是没有去面试的：东南大学计算机科学与工程学院</li><li>没有参加预推免</li></ul><h2 id="入营经历">入营经历</h2><h3 id="南京大学计算机科学与技术系（线上）">南京大学计算机科学与技术系（线上）</h3><p>南京大学今年养了一个大鱼塘，就拿我们专业来说，65人的小专业前三名都通过了南大的初审。当时接到了南大的邮件激动坏了，然而南大先搞了一波笔试。。。</p><ul><li>笔试：笔试的内容是408，27道选择题，一个小时，双机位监考。选择题有单选有多选，多选的选项超过4个。</li></ul><p>我实在是太菜了，有一半的题里面的名词都没听说过。。。所以就挂了，也没有然后了。</p><h3 id="北京理工大学计算机学院（线上）">北京理工大学计算机学院（线上）</h3><ul><li>宣讲：第一天上午是学院的宣讲，在宣讲的过程中所有的实验室都会拉一个群，下午是实验室的宣讲。不同实验室不一样，大部分也是老师宣讲，有一个实验室的老师直接让想来的在会议中作自我介绍，问问题（公开处刑）。<br>有一个印象最深的，一个中北大学的学生作了自我介绍，老师直接问“我有个顾虑：中北大学不太好，所以学生的质量可能也不太好，你来讲讲实验室录取你的理由”就特别直白。。</li><li>面试：第二天分组面试，面试分组随机，一个人10分钟左右。自我介绍要使用PPT，可以全程使用英文，也可以先中文再英文（当然是用英文啊。。。混着说多麻烦）。自我介绍完问的问题也很迷，比如“自我介绍为什么用英文”（是你们要求的好吧？？）“北理有你的学长学姐吗”等等，有一个和项目相关的，没有专业知识，基本就是在随便聊。。。</li></ul><p>面试后就结束了，几周后公布了优营名单，一共三四百入营的，优营给了不到二百个，承诺优营一定录取。</p><h3 id="北京航空航天大学计算机学院（线上）">北京航空航天大学计算机学院（线上）</h3><ul><li>宣讲：北航没有宣讲，给了一个百度网盘的链接，里面是宣讲的视频，可以自己下载看看。</li><li>机试：北航的机试可以用CCF认证成绩抵，但是CCF证书上必须标明使用的是C /C++，ALL是不能抵的（所以我考的CCF就没什么用处了）机试是完全闭卷，两个小时两道题，一个是关于结构体排序的40分，一个是关于最小生成树的60分。有一个平台提交试题，但是只验证是否能编译通过，不能返回结果和得分。</li><li>面试：机试后刷掉了一小批人，然后面试。面试20分钟，首先是英文自我介绍，然后是数学问题，专业问题，性格测试等。数学问题“请说一下积分和微分含义”，专业问题“满二叉树和完全二叉树的区别”“什么是大数据”“分布式系统主要有哪些方面的内容”“分布式与集群有什么区别”等等。当时好紧张，数学专业问题基本都没答对什么。。老师还一直在大数据的概念上给我扔问题。</li></ul><p>北航最后拿到了候补，一共500个入营的，过了机试有400左右，优营给了110多个，候补给了100个。不过整个夏令营的阶段都没有北航的同学参与，而看去年的录取名单基本都是北航的。。不知道是什么原因</p><h3 id="天津大学智能与计算学部（线上）">天津大学智能与计算学部（线上）</h3><ul><li>宣讲：学部整体宣讲+实验室宣讲，宣讲之后填志愿，根据志愿安排面试小组</li><li>面试：没有专业知识，自我介绍后随便提两个问题就结束了</li></ul><p>入营有五百左右，给了三百的优营，要自己联系老师，8月底联系不到的认为放弃优营资格。</p><h3 id="华东师范大学计算机科学与技术学院（线上）">华东师范大学计算机科学与技术学院（线上）</h3><ul><li>宣讲：上午是中目会议宣讲，宣讲过程中有签到，下午是实验室自由宣讲，要填报志愿决定面试小组</li><li>机试：华师大的在线oj平台，acm难度，4道题400分，按通过的测试点给分。总共三个小时，可以查阅纸质材料。我只做出来了第一题，剩下的都是大模拟骗分，最终得了273分。平台上可以看到大家的平均成绩，160分左右，不能看到实时排名。</li><li>面试：PPT中文自我介绍，专业知识问答，英文文献翻译，自由问答。专业知识包括“TCP与UDP的区别”“如何构造哈夫曼树”，自由问答基本都是项目相关，总体来说难度不大。<br>面试后老师打了电话询问能否确定报考华师大，我说不能确定，一个月后又打了电话，当时已经拿到计算所的offer了，就放弃了华师大，最终官网的优营名单中也没有我。入营的只有一百左右，给了五六十优营（应该是打电话后不放弃的都给了我觉得）。</li></ul><h3 id="华中科技大学计算机科学与技术学院（线上）">华中科技大学计算机科学与技术学院（线上）</h3><ul><li>宣讲：上午分实验室B站宣讲</li><li>面试：自我介绍+项目问题，没有专业知识，时间比较短</li></ul><p>入营只有200左右，大多数给了优营，但是是唯一一个没有后续的学校，没人说过优营有什么用接下来干什么。。。</p><h3 id="中山大学计算机学院（软件学院）（线上）">中山大学计算机学院（软件学院）（线上）</h3><p>吐槽吐槽！！！！中山真的是太烦人了，就算过了也真心不想去。<br>入营资格要一个一个电话确认，还没开始夏令营就开了三场会，一个面试环境检查会，一个笔试环境检查会，一个面试分组抽签会。更为奇葩的双机位要求：两个机位互相能看见，次机位看清电脑屏幕，主机位能看到脑袋+肩膀且能看到双手？？？你来教教我咋能主机位看到双手？？？我双手举起来编程吗？？？更为奇葩的机试监考，要共享屏幕到腾讯会议中。好家伙总共五百多人参加机试你找了五百多个研究生坐五百多个电脑前面开五百多个腾讯会议盯着我们？？？面试环境检查会都已经查看完了承诺书，正式面试还要再看一遍？？？程序无比繁琐，而且充斥着学校对学生的满满的不信任感！</p><ul><li>宣讲：无数宣讲，还要签到</li><li>机试：用的中山自己开发的Matrix平台，没有自动补全，三个小时10道题，根本就不是那种oj题，更像C++考试题，评测速度也慢。还有机试考察面向对象的内容不允许用Java不允许用Python奇葩不？？？没学过C++就直接踢一边了呗？</li><li>面试：中文自我介绍，英文问答一个，然后随便问，一些项目相关的知识。最后有个老师问“看你一个本科生搞了这么多竞赛，是不是基础知识掌握的不好啊”然后让我结束会议了？？？无力吐槽了</li></ul><p>五百多人给了300优营和100候补，还承诺优营一定录取，还说不搞预推免了。祝愿中山被鸽穿！</p><h3 id="中科院计算所（线下）">中科院计算所（线下）</h3><p>中科院计算所本来是没有入营的（意料之中），看QQ群里面的报名号有六千多人报名，入营名单发了400多。但是实验室秘书有一天早上打电话过来希望我能去北京参加机试面试，难得的机会就过去了。在报名后和入营名单公布之前会在QQ群里面让选意向导师，实际上就是意向实验室，才会有实验室秘书联系你，所以要多关注群消息。</p><ul><li>宣讲：B站整体宣讲，一个实验室20分钟左右，可线上可线下</li><li>机试：宣讲的下午网数实验室组织了机试。两个小时六道题，题目打印好了发给你，在自己笔记本上做，做完后学长学姐用U盘拷贝走，不会的也可以写思路。大家都在一个屋子里面做题，有几个学长学姐在巡视，完全闭卷不允许参考任何资料。</li><li>面试：安排的是一个人20分钟，但是普遍延后，我等了超出预定时间一个小时才轮到我。一个长条桌，有十多个老师在对面，英文自我介绍然后就是项目问题、性格测试和政治问题，没有专业知识，面试全程比较愉悦。</li></ul><p>面试结束当天晚上就打来了电话并发送了拟录取的邮件。一个月后在官网公布了拟录取的名单，入营的优营与没入营的优营（比如我）各占一半，总共给了200优营，承诺一定录取。其中查了一下，网数实验室面试38进12。</p><h2 id="经验总结">经验总结</h2><ol><li>机试能力相当重要，推荐<a href="https://pintia.cn/%5D">PTA平台</a>，《算法笔记》和《算法笔记上机训练指南》。我在大学期间将《算法笔记》刷了三遍，最后一遍是在天梯赛比赛前一个月与《算法笔记上机训练指南》一起刷完的，收获非常多。由于我们学院选拔ACM队只招大一的，大一当时学的不太好，我没有接触过ACM，但是大三的天梯赛我的分数也能超过一半的ACM队员。如果你是一个大一萌新，一定要尽早接触编程，最好能参加ACM集训体验一下，多练多刷题，毕竟这是互联网行业的敲门砖，硬实力的体现。</li><li>英文能力很重要，至少能清晰表达自己的含义，自我介绍要背熟，中英文的都要准备，也要准备中英文的PPT。</li><li>要多投学校，面试多了自然就不紧张了，而且该背的在面试期间也都背熟了。（如果计算所是第一个面试的我感觉我可能都紧张得说不出话来）。</li><li>夏令营入营的门槛就是学校的title和个人的rank，竞赛什么的一点用都没有，论文不知道能不能有点用。</li><li>夏令营是否要联系老师？我觉得如果你真的想去，可以联系联系，不想去的就不要联系了，免得到时候有心理负担。录取我的计算所我也是全程没有联系老师，甚至在拟录取后玩了一个月我才和研究生导师加上微信说了两句话。</li><li>避坑：明显超发offer的：天津大学智能与计算学部和中山大学计算机学院（软件学院），千万不要堵在这两个学校上，会死得很惨的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Experience</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Postgraduate</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>隐藏博客</title>
    <link href="/2022/07/03/hidden-blogs/"/>
    <url>/2022/07/03/hidden-blogs/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="139307a14703a13558b67c5229729b365c8dc6a709eb2a25903e334408344809">7a713bd9b34fdd7a2953d3ce08985b45f800743fd4c478a99ac7a00c31a82e4500231b42354050bb48949ad191a67acc2dff43465cd19317c590b8433ed096a1a5c0b6657280e0e8e62145f48bb4d4030f4fa0ebff67fdd99932dfa78c8cb5da561c03faf1d0b737269b175d6bcb8dac19c39928d142f8b38c676f32dac67220ece71ebe3a6aa0718dd82655bdfcd2ed6c1dc9b63aa025f1f52b4e18607e8c522b4c1b2b215ce515e27ba62de29ae199ff4f9e32c083c569c554eb5b6efcae5c62e99d0f108d3973622d2444eb3f8e5fb7e73b568760903cb266754b6f48d4c7a8e559d7f4fb55780c73cdd8f6796bc2dc8a5cf326b80f610879f3de741239260a9c3a096dd54e0aa9c116a8c78b4bb3fb9862ed588078a83ef5a4d1a47d7032624cb794c938b28009523fe4760b556a5bb06d5b2b195401af168229077729949a1baac566a677a07f38646c468ce8948cc34b6c148af7ee5520ad001a3f91db686e7fdea32c6ceca7e17f0cecf9ee8f204c4fa626ecfff3da8fe4e692412c9de3db9dd49f6bf8c6e1562800883d41eb8256860474548ab0c3cefbd6085b6f9d55fd641f6243bf505e76185bb1e61fd1a1135934e4ed699a63cba35b2fc9765a0b6937a56ad4c7630a4fdf89acd4b963955b0d457fcdd4702a215f2ad83f03ad57c01ae5fbabbb2ccd26c70ea3e9f03c48fff8d0b361da175d18673aa344c8ce3c83283e5d4f00c4ede3e5a9a9ef1dafc887c963faa2ae69cb0fb869434012a350aad094719521312d09736dbdc9498208dc4b5044282ad4c9be2d3118f72942365b57efea442549172b08631dda1ed15e5db85c97d82e52f268645a1c2b0b588cb24b36da68c804484076b582edf3edb56e4e8fb653cbbd3bc813a9071783f99f0385a69e15266b6cb96908f6c85c9ec8a5524aa816b3ea53745668c6d0e3fba8e3e1eded1bed4862b8c6f47c9033403ca6dea34ba2bd23b6967dc289500868b0b37f5cf8226147dba24fb29aeaaa9dcc21d8c609fa1e6957ebe61ed452f6f72b99ad76b1e90b36c68efc31a8581cc88ee8a7bbfb1d3b3352af24b682d45817ab44b1eb371d6b66451430c2347f2d400034daeee71bfbe47f53f794a387faa37bb10fdfc70891f77c67fb1858dfe849617c731a8d47dc9789b912bc66beb4fc20b84d137cee0588527a07f5fc3040ec53db1dfabab45c61c057281a49405030e0908df82a1277b51e8a75b3b8dfcf199c19f72773d81c6f1773b3db4de0f311b0782b6d03ccd3d60c1ec9a37ae17f71fe89c4e435cd3bd1503573e3229e75be2290903a6a397e45bfa595563ccdcd401baf675975afe5c641a392ac19ab448533443cb56be819a31c97c1e824b5c11796162e04554182179a3b1659e1c7ef67ad8cf41b88efe45ac951c464b52119121712db5e467993f122fc90dee8aaa126dca8f023a76c2318cdb366368c5d3da3b43359c8d3aee419ed9a7cff4d96e82f580a9ae2f00a77ef887a13bbcc29cb2d6ca11b7e5528cdaac4347b0e4b80d1897c0f7611157824907e1e79fcc59e78589b4aa1f1eb4845df7400d0200c622615172b1086598758bb7fd76c741694a5e1b745830c42c391ebec0d6ff549631eb8c0cf18e0217582ec1ccc0729a8937304809c1c04da293ac3c40e188319a065b2b3b79626da6c45a31db52245a999370ddd44aff5c22291f0e4c5a1db038fbcec6a203f81fa6a010750334bf43125d990a8051e434433f970864a534b8faf9a3c955813ab2107d8e460fcce617e1dd94f7444ae7ec98fd254347c2d6828b931f5a759ee91d24595ca19b1bd7d19867dfb080a49d4e9c8b88404fb84a204f783e4bdafbcb15bccbc20ffdfe94f4276a06eec6175e7c31c7c3bd48f81604231241e3afd8f5f7b37213adc5e58febed0a4828ccae3b65244800884532debcfcad9bde0e62d8cf4acf8382c040ba9c8cfc7684f785c42c43c040bb72e371fc7193cf7f5dd24474806c98b385ae4aa8f39e910ac17c8524a85bd29092c66cfbb1ab1294387c3b8be74166b4eb70c8bee861fad3b60698f50ca3adba6bb428c3f780f9bf074a0c58b1bd91e2502905a512fb9dfc564cf4850e0f119705a2fed91f4442328588248c3cee480268802129ae802d6d364a101aecab1dde5cb4bd38da31b55986e0aead298068559dcd718a616cf18bbecf8a1712571e97b256461b350c706e02e19d6b13a87c49985a517cac209c6a3e0b27b53745daaad7c100b9f347eb16458ca4fde003fa12413d66286ef5f172fc80002afa4c5465d6f045af30a366dfb4fa519b1fd671354784b2e2722b2644f20693eb40073e0fab11f473e183da7325257359d4b62d015083974f9eece552a4615c5e14783cd29b7552092b298c27d33dad2da4aeca5c5dc6edc40086492b702c47e60722ad92ed5f8ef25375f857a8e0b12e593c0eb63b0ac679bed6f7931a979a8068fa941862a7eca292d1ecd714f5216445bb4015f5ef80185318a82e66d4c7a56bc476fecc749035390471c17ed2858b90080ca5b16d84fd05d55fac3e38d3e29df38ee74a547332e27673ea30f5e7e12c2f5cb88cb914f79e360be45abaae6a08a6d6271b22b60d47985534fdd6a77ad2c0b6b2ca75f87328d3a48d7b805045ee4c66221f0f4022a2ac65cee08cb82170b3d1c84886649d05e63c1c52ae5234a520c946cb62060dddef71c873b046e4047d45c2ef0c8bcf17b460c4df422ed1674433030bffff5a7f44df2c62c55dec3c0be956fc8e4b2373670612e31a1e580eee82ef96bfb483c4de919302bbad51250650e426fe3b2a4a2b3c8154205698405bfcb1a7ebf9f0c18fbad27d651e93c8456d37d1396d301b72b7767a1666b392b99033febe0fb3dd41cb84e7cab713b338069c8248009399acec88a815e5ac061b59755d4399f41411f228226726ee1fc69a9f7912de4f53e1d17b9f911c77024ae06f2f99d79111371f37afc1c7b6f2c4fa5643cbfd206cd76d96b2855588a316b40a6cbe96de75afdd3e20c9bbc4ac0d5e9d33d499ea9147612bf7864fbf33114d2aa6697088238032ee4e9ac8333632ed28cf0147fd0f6b37211d919591a4abea2c594089cc0da7251dda82d9d57a84178c50c2e4aff1351710440d2439146e80b07ff74776c69ad33f9d4f74add4735dffe9ffd36973f7abf62c18e4a5b1c8bfb93fdc83b48d29e3a98d426fb5cabb82fec6a8316751a4bed77d88460e2417fbc9eca7d1582eefdc3a201701544ecfb843a03b8a2fd5d95ffc5bd0c49c7d78386b7f1cd91f4682ecac6c1f85700b5a00d973f2297f029cb2cd03831fc85d58b99cab765132e9c97fb9f6156e98d77a8200423c80b55ad4173219b7a63ec6febedfdd4d4f3827ba0aa20da661f413be82ed3c565cf7078d7da553c94c43fd7872552b2f9218d79fddeca0f8dc98ebc16d8f98f7235dfe6a8b98d25e8b946bd85150e52055a9c46ed70d43c82c1d4fb79fa004f92af161e222dc96638905fc617616392829178cd87eab7c0f031192f2f32c264e1e5f61eb67ed015b79870b2669c08074f466092a84f36d5b2d84936aa5f34a66bb50dba66f5b2b4a13eb0fcefe40bc54862e5e87118b9ef3fe3b2b2a4b5d5117765924f7e7e3c69d31706c78591a138f0125a9b058bfa3ce08831ca87f6027cdd0db85feef5ba1849fb7154711c6377f86cac8218faa69a207a38d692fb08ae8acff54fa761c50cde4e7d3d12087794604ac9d648669deda13deca185c24dacb5a7380b175001885e75776d898318cd21df5cefecdd13f5810b424a994a042c1a25ef72a5e283139c844c8b0568c1295c3be63a87a05597a52b32f8dceb9f2802c879f62493d34208d6aa5a942bdd63a423095afd0b11ad41a3fa2c9a79855e41075bb16413ebb505da79dbc9566ebafc74c008f896e09ebb10b408b9bccb841c00c6773f7260ebd08a41d90796ad12804100e179675c5c29c6604d4d5d592b7ecb3fef6b95484b84fc0bbefde2e31f737f18ff812518626e9a120c34f9f40dbd207f1271b7d5861527edd1063b55de54638155ed9fbc48c36a3528332a1a5ab1eba74d5e28c267b3e1925467c9973e2c1a9c530cac238bb5ee7ed324a808c2e4a3672967477f2515e80d6a090beb1bb187ec9eda0289b8f509abcfbcdd272646fd4baf6487f125fd84a05396ff67afab45fcd886853a5627aebcb9489e5d242c6c700910737a74704ab4a760f183f02959dc49d149c8d406edec5a5ff464b3d985dfb2c096b4cc86e4cce2bf0e896f3bc3767bfdc3f1c1c22ed8423f579dcf17d59691a013055f92fccf1aeb3d95a0b9cca162b6b20854125eecb89802a8bdbfd7fc792f3673be346c62ea3c53ad98d8189fbf9caaf6197fde0c68e3edb5208c2df5a001de4ce9ac2663b6b4be5e6b1dd8e73a681b022f35f37301b19216da0c34a4a127c652836689e187b257c00e308e1b025b3f0dc62630149d324222fa3cb1af88796613739ed49f4102b980649977bf8e6e10939d729445ed59d000bfa659c09d71c0f3d33e74df6bf3261e8ff2c8170d8d9672536072e91a689c264b9d0b576890759e6eb34b954f7bd1c7142cce0cf049681aa001d0a1befcac4743297f9a6e9a17692cbfdca9949d53f7e6fffaac0a1aa8a3f7b92c7e9f72d62ecaf3287b8c37235136192820827a3e360313af34a4a7fa9d5cf4275d91082425ca06f6d96b0294462ec8a4882cf00b20e747e6e7e122ff009ead6de8b722d94b2784b6cafeaf6c1d2870fa063ce0bb3d742f7856f56cbb65890c8a04b061a4cc6dd4e464284fb22ae232691455bcc99bb86855f1903f8f879a175d5465f6cce41a734af24d7c85e756cc86f3a4fb6e14a3ba40685d5bc7c4e7f409706845b655c00939fa3491843bfb626b44c52d363a9594661afdca6fa245daaccf79a4da85f3fa97614597731c69c0430df7adbc13492852401506bb38e0be44dd03b6942c5a04a19af4a4db95eea17b74e0401840ed6897b8dbf7788e6fd685ce2caa6950d6673f944312f8202ee1ff2b74c82ed27d5f85f020195d6a15e7d08126eda26481624ff7dc3b9e0a413ba5256d59b140dfa2038c33239005a179275bf2ee0d0eb6aa81c4c981073c107755e31b2cbeb41d90a4d93a9a5cb7e8da896350d133f9c48f03a583f0531c81a30d4c7c5965baf370c2615c9fb50126dccd1d8f71836cdddf5b60af294b570aef1d45678fd543b23f388b72099dff86657cab1c5cea8db2a056c62ca9163bb9e6effa212f7069f6135c3ad2f025aefaadfcca7e28d8ff70185debdb7d6b09513a674cf1550000baad92f53090fb9f8e19d489b502af40fa39b27ef4684523cf0d76fa5a507550c0761f32143b675353059fea7a8aad4a3b89d143ce5e2b73ddc2f72f49931c85f912ef9167b16b491caa0085dab9213d6f8438df8577a1558ccde823bac776173a60ccac6ba03941bd17764d90fb1bd706a0f27daf81fc328115279fdb3d663db5a04619731d0df1e714b7e5bca13665f4fcf8939d4e5aee4ad75c2f7debfe94607423adf34b3e039f6f7e099e5ed8ba0f2014b10a35ec42737a8e2d98101ce193de63e189f7c7fea8a7effe76aa6da01ef9ef7c5f8a65931a77437e9985885d492e9fa119da249b8779d5db99759d469a5eb45cf998c1080c4d8df8d52c6cfe75e3cd7898a511b33e35c87db10f0276b76a553bb2e4d6611b65467e0ea253645b0f59fa52abca037ff0ceaf50fd2e5f94f9e1dad4c0263aae32b2fd46afabfab2d3407a977c012426681062e9a2593120a9de94c29da09d1b94496f823e8a57a1ef8394f1bdf6d7edd19478c19b6af49eada1e9f15dc406fae92f5de034e87aa91709f179c204a1cba991555b94a73cc9bb637cd35bd632991a387d3d44b159f7ffdfb25de10e915174c01ddafe7268fc5f2128fc69b5b5489b5185aa2bd01b5b08310dba66481c12a78633ecfbcb69e4582f96fb5c01b2aebaa5b686b3d067b32e0c60dc16a5bf5a8c515235ac124cabd804b9334226453cfb338cf14ea5f2eb78a29caab38a84879f6104fd56f37d6218e42c40b11527a30fdc357d6fe0025b4b81ba610ed5eab57c044ad9c817b64a3ee1d5045c63f27b7d561ca891e44d3e4f11e3f63ac6dc4557fe322a7c5c4fc221afc32ae118c934b72d83788c69af1010ee27a3d7df89477191dc64734df357096b35f7f43d43e10744fc22a759cece7156fc8d190e9e1abc623c501b8eca8e7e2d0e042f62d607b9a444f143bd7a0afd79e60456d3e0f970026d3ac1b349ec831e1b9630920683d2028c9aca6853fa2be084ad316983cc1e3f82b48891ea782c1335a4cfbd80da5663d9149826baa157c115842f9e89582cc1c3d996b5e9681311605756766fb7ff0d5362fee9acf367771f8119ff3bc7629e6b8d89489605959375a08b05442c9be77760844b07a646deb43ccff07945aef55b8cb5d74653998f720d8fab41d9a006080c438240e19f38a165557f1e03f97e68890410eddddc491ccdb69c28f54d6c0eda27651757ed1355fd9c52bea0a35a5c1bacc50275f5bfe8ccfc10c0e0b70d63ea6c66ee403f925c952f4399d8985f1876bba02814c09529e26ec596e53b6cef16d9b6530b4c2692de5389b9b552e0e81da45e3ce8b569f9db25d380a153176b6ebc9e103a90114f30adc9b7a1560e2cb25470bc5b60d23dcb3bb7594864f00e28080e254af1f7c79b857466a68cf26788a203ca6fb5813db72856106e5be44b86677c97b5cd873f900c7ea26c55cc3dd67700ab19196b19b9ef50e475c467a7e0f20308512c1e9df6ff83a8e09d96c33fe99df8204acbdf7f588c9a90bfd45d08667844fc0373eff1a653a1269378e8581e7ca40cd90ac279ce2575b4132ba82bfc83da22c18a607965c3003208c966f3c6de1d31dbeb77261bf5fb3886d37c1ceb2878edffa319af0800ed50beb9aea48c9785f8d35b37e81d055a528b89016426fc38cadb1eba1e7953f517b6fc47498e0f02f39787b731c46234aa52fa8a35e00761e1d17079a63d431584584c7bbf42812ff2c18ea27f747ee337e0f1ee06ea5bd907554fe4592bd448a99fbf697cd77d17aa6079357e411315fd0a5929aa3efb70dbe76425702630b3f4bd665d0c4fbab70fac8aacd31ea4020c24a7d2e28aba8dbfe3c3f02b36f2a4150939dd792f68a154959d966489957ef47ac277ce98a8b4a08f4e875b99cad0b6ec34d79ab8b3542604a0ffe86fbc1013ef9e9b91267712bc695fed4a65a3a137f95af33ad146e6d7e5dc63f2ec5ec0854b5d29925905e33c48a88f3a162405638af7cb9f65f0a225b84cff5e6e5d39e16743cfd33eac62d6492a719f2daf9e7584c05bcdaaf55cbd95229d9eee643bebdb16de5316481eae19efcb946ff5ebf8ea75ac99c6b71c46911ddc111fb5b8011a45f17a40b7b96a35b26f642a03690888161d3dde91dbcdbdfab3492db69c2f9e68f3b03a135c25c37f4d6c9110cff1dae78f0ff8cb21741af36d968c93c4a0921827d6d6a324158e243e6c1b11d7f4b650f3e293b1cd220bba10f214654c7befb144fefd419b936204df31ebff8b3aec074ece6712dd6ca4efc4a23eb52403fdb116c306c924f8eff5ef43f52d406cd051c5f68f55ce19ec3a2d6fce11dbc898bdae74924981eca586e23c80b4fc91c1c8f36e6941ea244eb9130f76109c9d5a51c7048ed5961c775b63a21b4e490994f6fc1b84e8e17dd633fc65d3edea5570074ccd1a6c93e3b2587218d51ee971218420321a48a49baf479ded461161eab459e7fb0dc5b398f58cd2657e782c41c330a1dce0296abddedeedc33a7edf25c730170d8a29322868f73f529b42caf8a51699ac92a6b4bb613eb37bdd1361dfa8fd9da9e60a35b236872a20b13b818381776639e45a195a14ee89aa7e985b809302528eb3ec0b37380a768b47650b8f64e8f5b399d5fe0e55dddcd20c23649d92262643dab38b61833fa60ea4c590c8ce572428f792b78a94285d9299822213fda3c5ec519f631231a035d6f3da8f669e2287b9d4f2ab7c102581d5890c99b88d498a87737b2afeb35456910cb96475322eefc1664787db3166a0d6dda5fc383826c9f3ff7fe55e2dae11314773f7a88e0b9e4f3284a80e3c484ebd40d2fe3929fcf3d8d199ec16ca002170d4056e9ef74ad0875b7182aa88999de3f7359059fb3ab249a90c54e957a8e5c2578486b6d7b7cf8162efce1bb77ba2047637d539829d798f629492427bbd2953f837df7608055120006f06f90385a4a60d19e7dd2875aace02738e0b47120e8cbf072a70225ee646ebd7c8917c5998bceeed388abefb388d070aea59aabbcef8202300612d214a7fa4b83bb33a6c6304a93dc561ad204da217332cb4b403a6256c00b6aa04abc028af4587679d88191974dc74f10c841cf30c9e181da90257924864a031519759f6330ce6aaae95391fbd8aa1c1309a6dc899a0f23b471b6fbd1ac6bb00d88c47bddea0c7e35fcf34075be8d5b2f20e0f3ff0f712a52ef1b2578f5f9c9b5dfcd20ad06df6067332d76f50cbcdcaf8db59a8f7d51f2fe11328db0e7da9c9cd8bd097bb036359ec8dd3806fcfd4bcf41f52b085a8f1269f03587d576fb6b7c1b3c51c1b689a39437fa52082b685813989da94c9f69805b69190577b532ca7b5588c357079c78d98831fd9e0bae3895462c7893f1dcf2870e65ff2b5e01800d294bb345ce1369ed20795e53cda7e2a7e8e2b8c4de50aea8111281818c02b23ba786d421bc83029abf20bc51e0e214ce5ce1ef436cf996e38d8b3191ecfb668ef2633ca986cc69429fc7564298c9b0bca74aaf7af46fa1c6d49080824e3a7b5aa91e603bad9ca7f836b42f045b6f50be67fe8010222d4a1284d2c13a75b41bad9cb4aa3a513266ded4739232be34bbbe4d679e1ab9332013f8ab09c14fa11563fec329974ce4c072a8ca9dc984444846415059aec640ba3aab221584bfe39a1f75ee9dcf913a6bf78ba2f398249</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
