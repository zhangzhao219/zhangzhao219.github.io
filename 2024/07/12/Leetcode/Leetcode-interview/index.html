

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://s1.ax1x.com/2022/07/03/j83xmQ.png">
  <link rel="icon" href="https://s1.ax1x.com/2022/07/03/j83xmQ.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zhang Zhao">
  <meta name="keywords" content="">
  
    <meta name="description" content="Leetcode-Interview">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode-Interview">
<meta property="og:url" content="https://zhangzhao219.github.io/2024/07/12/Leetcode/Leetcode-interview/index.html">
<meta property="og:site_name" content="Zostanzo&#39;s Blog">
<meta property="og:description" content="Leetcode-Interview">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png">
<meta property="article:published_time" content="2024-07-12T16:34:25.000Z">
<meta property="article:modified_time" content="2025-05-16T02:13:21.542Z">
<meta property="article:author" content="Zhang Zhao">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">
  
  
  
  <title>Leetcode-Interview - Zostanzo&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhangzhao219.github.io","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"NeXpkMMRYHdOZW6AImFcr7NU-gzGzoHsz","app_key":"87RqX31mqiCFg6DWMRIA7K6O","server_url":"https://nexpkmmr.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Zostanzo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Leetcode-Interview</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-12 16:34" pubdate>
          2024年7月12日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          158 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Leetcode-Interview</h1>
            
            
              <div class="markdown-body">
                
                <p>Leetcode-Interview</p>
<span id="more"></span>
<h1>面试题 01</h1>
<h2 id="面试题-01-01-判定字符是否唯一">面试题 01.01. 判定字符是否唯一</h2>
<p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isUnique</span><span class="hljs-params">(string astr)</span> </span>&#123;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-literal">false</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;astr.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-type">int</span> t = astr[i] - <span class="hljs-string">&#x27;a&#x27;</span>;
            <span class="hljs-keyword">if</span>(visited[t] == <span class="hljs-literal">true</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            visited[t] = <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-01-02-判定是否互为字符重排">面试题 01.02. 判定是否互为字符重排</h2>
<p>给定两个由小写字母组成的字符串 <code>s1</code> 和 <code>s2</code>，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CheckPermutation</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();i++)&#123;
            visited[s1[i] - <span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();i++)&#123;
            visited[s2[i] - <span class="hljs-string">&#x27;a&#x27;</span>] -= <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;
            <span class="hljs-keyword">if</span>(visited[i] != <span class="hljs-number">0</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-01-03-URL化">面试题 01.03. URL化</h2>
<p>URL化。编写一种方法，将字符串中的空格全部替换为 <code>%20</code>。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用 <code>Java</code>实现的话，请使用字符数组实现，以便直接在数组上操作。）</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">string <span class="hljs-title">replaceSpaces</span><span class="hljs-params">(string S, <span class="hljs-type">int</span> length)</span> </span>&#123;
        string res = <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;
            <span class="hljs-keyword">if</span>(S[i] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;
                res += <span class="hljs-string">&quot;%20&quot;</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                res += S[i];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-01-04-回文排列">面试题 01.04. 回文排列</h2>
<p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p>
<p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p>
<p>回文串不一定是字典当中的单词。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPermutePalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;
        set&lt;<span class="hljs-type">char</span>&gt; st;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(s[i]) == <span class="hljs-number">0</span>)&#123;
                st.<span class="hljs-built_in">insert</span>(s[i]);
            &#125; <span class="hljs-keyword">else</span>&#123;
                st.<span class="hljs-built_in">erase</span>(s[i]);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> || st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-01-05-一次编辑">面试题 01.05. 一次编辑</h2>
<p>字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">oneEditAway</span><span class="hljs-params">(string first, string second)</span> </span>&#123;
        <span class="hljs-type">int</span> m = first.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = second.<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)&#123;
            dp[i][<span class="hljs-number">0</span>] = i;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)&#123;
            dp[<span class="hljs-number">0</span>][j] = j;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;
                <span class="hljs-keyword">if</span>(first[i<span class="hljs-number">-1</span>] == second[j<span class="hljs-number">-1</span>])&#123;
                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];
                &#125;<span class="hljs-keyword">else</span>&#123;
                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[m][n] == <span class="hljs-number">0</span> || dp[m][n] == <span class="hljs-number">1</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-01-06-字符串压缩">面试题 01.06. 字符串压缩</h2>
<p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串 <code>aabcccccaaa</code>会变为 <code>a2b1c5a3</code>。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">string <span class="hljs-title">compressString</span><span class="hljs-params">(string S)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> S;
        &#125;
        string res = <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;
        <span class="hljs-type">char</span> temp = S[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;S.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(S[i] == temp)&#123;
                count += <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                res += temp;
                string tempcount = <span class="hljs-string">&quot;&quot;</span>;
                <span class="hljs-keyword">while</span>(count != <span class="hljs-number">0</span>)&#123;
                    tempcount += count%<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;
                    count /= <span class="hljs-number">10</span>;
                &#125;
                <span class="hljs-built_in">reverse</span>(tempcount.<span class="hljs-built_in">begin</span>(), tempcount.<span class="hljs-built_in">end</span>());
                res += tempcount;
          
                count = <span class="hljs-number">1</span>;
                temp = S[i];
            &#125;
        &#125;
        res += temp;
        string tempcount2 = <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-keyword">while</span>(count != <span class="hljs-number">0</span>)&#123;
            tempcount2 += count%<span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>;
            count /= <span class="hljs-number">10</span>;
        &#125;
        <span class="hljs-built_in">reverse</span>(tempcount<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), tempcount<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>());
        res += tempcount2;
        <span class="hljs-keyword">if</span>(res.<span class="hljs-built_in">size</span>() &lt; S.<span class="hljs-built_in">size</span>())&#123;
            <span class="hljs-keyword">return</span> res;
        &#125;
        <span class="hljs-keyword">return</span> S;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-01-07-旋转矩阵">面试题 01.07. 旋转矩阵</h2>
<p>给你一幅由 <code>N × N</code> 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。</p>
<p>不占用额外内存空间能否做到？</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;
        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(n<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span>;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n/<span class="hljs-number">2</span>;j++)&#123;
                <span class="hljs-type">int</span> temp = matrix[i][j];
                matrix[i][j] = matrix[n-j<span class="hljs-number">-1</span>][i];
                matrix[n-j<span class="hljs-number">-1</span>][i] = matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>];
                matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>] = matrix[j][n-i<span class="hljs-number">-1</span>];
                matrix[j][n-i<span class="hljs-number">-1</span>] = temp;
            &#125;
        &#125;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-01-08-零矩阵">面试题 01.08. 零矩阵</h2>
<p>编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;
        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-type">bool</span> rowflag = <span class="hljs-literal">false</span>;
        <span class="hljs-type">bool</span> colflag = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;
                colflag = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;
                rowflag = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;
                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;
                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span> || matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;
                    matrix[i][j] = <span class="hljs-number">0</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(rowflag)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(colflag)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
            &#125;
        &#125;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-01-09-字符串轮转">面试题 01.09. 字符串轮转</h2>
<p>字符串轮转。给定两个字符串 <code>s1</code>和 <code>s2</code>，请编写代码检查 <code>s2</code>是否为 <code>s1</code>旋转而成（比如，<code>waterbottle</code>是 <code>erbottlewat</code>旋转后的字符串）。</p>
<p><strong>示例1:</strong></p>
<div class="code-wrapper"><pre><strong> 输入</strong>：s1 = "waterbottle", s2 = "erbottlewat"
<strong> 输出</strong>：True
</pre></div>
<p><strong>示例2:</strong></p>
<div class="code-wrapper"><pre><strong> 输入</strong>：s1 = "aa", s2 = "aba"
<strong> 输出</strong>：False
</pre></div>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFlipedString</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() != s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">if</span>(s1 == <span class="hljs-string">&quot;&quot;</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-type">int</span> l = s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();
        s1 = s1 + s1;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">substr</span>(i,l) == s2)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h1>面试题 02</h1>
<h2 id="面试题-02-01-移除重复节点">面试题 02.01. 移除重复节点</h2>
<p>编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">removeDuplicateNodes</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;
        ListNode* t = head;
        ListNode* p = head;
        <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> p;
        &#125;
        set&lt;<span class="hljs-type">int</span>&gt; st;
        st.<span class="hljs-built_in">insert</span>(p-&gt;val);
        <span class="hljs-keyword">while</span>(p-&gt;next != <span class="hljs-literal">NULL</span>)&#123;
            ListNode* q = p-&gt;next;
            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">count</span>(q-&gt;val) != <span class="hljs-number">0</span>)&#123;
                p-&gt;next = p-&gt;next-&gt;next;
            &#125; <span class="hljs-keyword">else</span>&#123;
                p = p-&gt;next;
                st.<span class="hljs-built_in">insert</span>(q-&gt;val);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> t;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-02-02-返回倒数第-k-个节点">面试题 02.02. 返回倒数第 k 个节点</h2>
<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthToLast</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;
        ListNode* slow = head;
        ListNode* fast = head;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;
            fast = fast-&gt;next;
        &#125;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>)&#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        &#125;
        <span class="hljs-keyword">return</span> slow-&gt;val;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-02-03-删除中间节点">面试题 02.03. 删除中间节点</h2>
<p>若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。</p>
<p>假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。</p>
<p>例如，传入节点 <code>c</code>（位于单向链表 <code>a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f</code> 中），将其删除后，剩余链表为 <code>a-&gt;b-&gt;d-&gt;e-&gt;f</code></p>
<p><strong>示例：</strong></p>
<div class="code-wrapper"><pre><strong>输入：</strong>节点 5 （位于单向链表 4->5->1->9 中）
<strong>输出：</strong>不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9
</pre></div>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;
        *node = *node-&gt;next;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-02-04-分割链表">面试题 02.04. 分割链表</h2>
<p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p>
<p>你不需要 <strong>保留</strong> 每个分区中各节点的初始相对位置。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;
        ListNode* p = head;
        ListNode* q = head;
        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">if</span>(q-&gt;val &lt; x)&#123;
                <span class="hljs-built_in">swap</span>(p-&gt;val,q-&gt;val);
                p = p-&gt;next;
            &#125;
            q = q-&gt;next;
        &#125;
        <span class="hljs-keyword">return</span> head;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-02-05-链表求和">面试题 02.05. 链表求和</h2>
<p>给定两个用链表表示的整数，每个节点包含一个数位。</p>
<p>这些数位是反向存放的，也就是个位排在链表首部。</p>
<p>编写函数对这两个整数求和，并用链表形式返回结果。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;
        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
        ListNode* l3 = dummy;
        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> || l2 != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">NULL</span>)&#123;
                temp = l2-&gt;val + cnt;
                l2 = l2-&gt;next;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">NULL</span>)&#123;
                temp = l1-&gt;val + cnt;
                l1 = l1-&gt;next;
            &#125; <span class="hljs-keyword">else</span>&#123;
                temp = l1-&gt;val + l2-&gt;val + cnt;
                l1 = l1-&gt;next;
                l2 = l2-&gt;next;
            &#125;
            <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">10</span>)&#123;
                temp = temp - <span class="hljs-number">10</span>;
                cnt = <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                cnt = <span class="hljs-number">0</span>;
            &#125;
            l3-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(temp);
            l3 = l3-&gt;next;
        &#125;
        <span class="hljs-keyword">if</span>(cnt == <span class="hljs-number">1</span>)&#123;
            l3-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);
        &#125;
        <span class="hljs-keyword">return</span> dummy-&gt;next;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-02-06-回文链表">面试题 02.06. 回文链表</h2>
<p>编写一个函数，检查输入的链表是否是回文的。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; result;
        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span>)&#123;
            result.<span class="hljs-built_in">push_back</span>(head-&gt;val);
            head = head-&gt;next;
        &#125;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> right = result.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span>(left &lt; right)&#123;
            <span class="hljs-keyword">if</span>(result[left] != result[right])&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            left++;
            right--;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-02-07-链表相交">面试题 02.07. 链表相交</h2>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" srcset="/img/loading.gif" lazyload alt=""></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong> ，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;
        ListNode* p = headA;
        ListNode* q = headB;
        <span class="hljs-keyword">while</span>(p != q)&#123;
            <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;
                p = headB;
            &#125; <span class="hljs-keyword">else</span>&#123;
                p = p-&gt;next;
            &#125;
            <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">NULL</span>)&#123;
                q = headA;
            &#125; <span class="hljs-keyword">else</span>&#123;
                q = q-&gt;next;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> p;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-02-08-环路检测">面试题 02.08. 环路检测</h2>
<p>给定一个链表，如果它是有环链表，实现一个算法返回环路的 <code>开头节点</code>。若环不存在，请返回 <code>null</code>。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。 <strong>注意：<code>pos</code> 不作为参数进行传递</strong> ，仅仅是为了标识链表的实际情况。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;
        ListNode* slow = head;
        ListNode* fast = head;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)&#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
            <span class="hljs-keyword">if</span>(slow == fast)&#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">NULL</span> || fast-&gt;next == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        fast = head;
        <span class="hljs-keyword">while</span>(slow != fast)&#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        &#125;
        <span class="hljs-keyword">return</span> slow;
    &#125;
&#125;;</code></pre></div>
<h1>面试题 03</h1>
<h2 id="面试题-03-01-三合一">面试题 03.01. 三合一</h2>
<p>三合一。描述如何只用一个数组来实现三个栈。</p>
<p>你应该实现 <code>push(stackNum, value)</code>、<code>pop(stackNum)</code>、<code>isEmpty(stackNum)</code>、<code>peek(stackNum)</code>方法。<code>stackNum</code>表示栈下标，<code>value</code>表示压入的值。</p>
<p>构造函数会传入一个 <code>stackSize</code>参数，代表每个栈的大小。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TripleInOne</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;<span class="hljs-type">int</span>&gt; stackown;
    vector&lt;<span class="hljs-type">int</span>&gt; nowtop;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">TripleInOne</span>(<span class="hljs-type">int</span> stackSize) &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;stackSize*<span class="hljs-number">3</span>;i++)&#123;
            stackown.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
        &#125;
        nowtop.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);
        nowtop.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);
        nowtop.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> stackNum, <span class="hljs-type">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(nowtop[stackNum] / <span class="hljs-number">3</span> == stackown.<span class="hljs-built_in">size</span>() / <span class="hljs-number">3</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        stackown[nowtop[stackNum]] = value;
        nowtop[stackNum] += <span class="hljs-number">3</span>;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> stackNum)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(nowtop[stackNum] == stackNum)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-type">int</span> t = stackown[nowtop[stackNum]<span class="hljs-number">-3</span>];
        nowtop[stackNum] -= <span class="hljs-number">3</span>;
        <span class="hljs-keyword">return</span> t;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">(<span class="hljs-type">int</span> stackNum)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(nowtop[stackNum] == stackNum)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-keyword">return</span> stackown[nowtop[stackNum]<span class="hljs-number">-3</span>];
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-type">int</span> stackNum)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(nowtop[stackNum] == stackNum)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Your TripleInOne object will be instantiated and called as such:</span>
<span class="hljs-comment"> * TripleInOne* obj = new TripleInOne(stackSize);</span>
<span class="hljs-comment"> * obj-&gt;push(stackNum,value);</span>
<span class="hljs-comment"> * int param_2 = obj-&gt;pop(stackNum);</span>
<span class="hljs-comment"> * int param_3 = obj-&gt;peek(stackNum);</span>
<span class="hljs-comment"> * bool param_4 = obj-&gt;isEmpty(stackNum);</span>
<span class="hljs-comment"> */</span></code></pre></div>
<h2 id="面试题-03-02-栈的最小值">面试题 03.02. 栈的最小值</h2>
<p>请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;
<span class="hljs-keyword">private</span>:
    stack&lt;<span class="hljs-type">int</span>&gt; st;
    stack&lt;<span class="hljs-type">int</span>&gt; minst;
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** initialize your data structure here. */</span>
    <span class="hljs-built_in">MinStack</span>() &#123;
        minst.<span class="hljs-built_in">push</span>(INT_MAX);
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
        st.<span class="hljs-built_in">push</span>(x);
        <span class="hljs-keyword">if</span>(x &lt; minst.<span class="hljs-built_in">top</span>())&#123;
            minst.<span class="hljs-built_in">push</span>(x);
        &#125;<span class="hljs-keyword">else</span>&#123;
            minst.<span class="hljs-built_in">push</span>(minst.<span class="hljs-built_in">top</span>());
        &#125;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        st.<span class="hljs-built_in">pop</span>();
        minst.<span class="hljs-built_in">pop</span>();
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> minst.<span class="hljs-built_in">top</span>();
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-03-03-堆盘子">面试题 03.03. 堆盘子</h2>
<p>堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构 <code>SetOfStacks</code>，模拟这种行为。<code>SetOfStacks</code>应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，<code>SetOfStacks.push()</code>和 <code>SetOfStacks.pop()</code>应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个 <code>popAt(int index)</code>方法，根据指定的子栈，执行pop操作。</p>
<p>当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，<code>pop</code>，<code>popAt</code> 应返回 -1.</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StackOfPlates</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;stack&lt;<span class="hljs-type">int</span>&gt; &gt; vt;
    <span class="hljs-type">int</span> capacity;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">StackOfPlates</span>(<span class="hljs-type">int</span> cap) &#123;
        capacity = cap;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(vt.<span class="hljs-built_in">empty</span>())&#123;
            stack&lt;<span class="hljs-type">int</span>&gt; st;
            st.<span class="hljs-built_in">push</span>(val);
            vt.<span class="hljs-built_in">push_back</span>(st);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-type">int</span> l = vt.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">if</span>(vt[l].<span class="hljs-built_in">size</span>() == capacity)&#123;
            stack&lt;<span class="hljs-type">int</span>&gt; st;
            st.<span class="hljs-built_in">push</span>(val);
            vt.<span class="hljs-built_in">push_back</span>(st);
            <span class="hljs-keyword">return</span>;
        &#125;
        vt[l].<span class="hljs-built_in">push</span>(val);
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span> || vt.<span class="hljs-built_in">empty</span>()) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-type">int</span> l = vt.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
        <span class="hljs-type">int</span> t = vt[l].<span class="hljs-built_in">top</span>();
        vt[l].<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">if</span>(vt[l].<span class="hljs-built_in">empty</span>())&#123;
            vt.<span class="hljs-built_in">pop_back</span>();
        &#125;
        <span class="hljs-keyword">return</span> t;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (capacity == <span class="hljs-number">0</span> || index &gt;= vt.<span class="hljs-built_in">size</span>())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-type">int</span> res = vt[index].<span class="hljs-built_in">top</span>();
        vt[index].<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">if</span> (vt[index].<span class="hljs-built_in">empty</span>()) &#123;
            <span class="hljs-comment">// 如果当前栈空，最后删除当前栈</span>
            vt.<span class="hljs-built_in">erase</span>(vt.<span class="hljs-built_in">begin</span>() + index);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-03-04-化栈为队">面试题 03.04. 化栈为队</h2>
<p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;
<span class="hljs-keyword">private</span>:
    stack&lt;<span class="hljs-type">int</span>&gt; st1;
    stack&lt;<span class="hljs-type">int</span>&gt; st2;
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">/** Initialize your data structure here. */</span>
    <span class="hljs-built_in">MyQueue</span>() &#123;

    &#125;
  
    <span class="hljs-comment">/** Push element x to the back of queue. */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;
            st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>());
            st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();
        &#125;
        st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(x);
    &#125;
  
    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>())&#123;
            st<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>());
            st<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();
        &#125;
        <span class="hljs-type">int</span> t = st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>();
        st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">return</span> t;
    &#125;
  
    <span class="hljs-comment">/** Get the front element. */</span>
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>())&#123;
            st<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>());
            st<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();
        &#125;
        <span class="hljs-keyword">return</span> st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>();
    &#125;
  
    <span class="hljs-comment">/** Returns whether the queue is empty. */</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &amp;&amp; st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>();
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-03-05-栈排序">面试题 03.05. 栈排序</h2>
<p>栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：<code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>isEmpty</code>。当栈为空时，<code>peek</code> 返回 -1。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortedStack</span> &#123;
<span class="hljs-keyword">private</span>:
    stack&lt;<span class="hljs-type">int</span>&gt; st1;
    stack&lt;<span class="hljs-type">int</span>&gt; st2;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">SortedStack</span>() &#123;

    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;
        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>() &amp;&amp; st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>() &gt; val)&#123;
            st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>());
            st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();
        &#125;
        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &amp;&amp; st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>() &lt; val)&#123;
            st<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>());
            st<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();
        &#125;
        st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(val);
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;
            st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>());
            st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();
        &#125;
        <span class="hljs-keyword">if</span>(st<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span>)&#123;
            st<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();
        &#125;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">while</span>(!st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;
            st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>());
            st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();
        &#125;
        <span class="hljs-keyword">if</span>(!st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-keyword">return</span> st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> st<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>() &amp;&amp; st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>();
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-03-06-动物收容所">面试题 03.06. 动物收容所</h2>
<p>动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如 <code>enqueue</code>、<code>dequeueAny</code>、<code>dequeueDog</code>和 <code>dequeueCat</code>。允许使用Java内置的LinkedList数据结构。</p>
<p><code>enqueue</code>方法有一个 <code>animal</code>参数，<code>animal[0]</code>代表动物编号，<code>animal[1]</code>代表动物种类，其中 0 代表猫，1 代表狗。</p>
<p><code>dequeue*</code>方法返回一个列表 <code>[动物编号, 动物种类]</code>，若没有可以收养的动物，则返回 <code>[-1,-1]</code>。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalShelf</span> &#123;
<span class="hljs-keyword">private</span>:
    queue&lt;<span class="hljs-type">int</span>&gt; cats, dogs;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">AnimalShelf</span>() &#123;
  
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; animal)</span> </span>&#123;
        <span class="hljs-type">int</span> id = animal[<span class="hljs-number">0</span>];
        <span class="hljs-type">int</span> type = animal[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>)&#123;
            dogs.<span class="hljs-built_in">push</span>(id);
        &#125;
        <span class="hljs-keyword">else</span>&#123;
            cats.<span class="hljs-built_in">push</span>(id);
        &#125;
    &#125;
  
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dequeueAny</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(cats.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dequeueDog</span>();
        &#125;
        <span class="hljs-keyword">if</span>(dogs.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dequeueCat</span>();
        &#125;
        <span class="hljs-keyword">if</span>(cats.<span class="hljs-built_in">front</span>() &lt; dogs.<span class="hljs-built_in">front</span>())&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dequeueCat</span>();
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dequeueDog</span>();
    &#125;
  
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dequeueDog</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(dogs.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;
        &#125;
        <span class="hljs-type">int</span> id = dogs.<span class="hljs-built_in">front</span>();
        dogs.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">return</span> &#123;id, <span class="hljs-number">1</span>&#125;;
    &#125;
  
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dequeueCat</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">if</span>(cats.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;
        &#125;
        <span class="hljs-type">int</span> id = cats.<span class="hljs-built_in">front</span>();
        cats.<span class="hljs-built_in">pop</span>();
        <span class="hljs-keyword">return</span> &#123;id, <span class="hljs-number">0</span>&#125;;
    &#125;
&#125;;</code></pre></div>
<h1>面试题 04</h1>
<h2 id="面试题-04-01-节点间通路">面试题 04.01. 节点间通路</h2>
<p>节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findWhetherExistsPath</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">g</span>(n);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;graph.<span class="hljs-built_in">size</span>();i++)&#123;
            g[graph[i][<span class="hljs-number">0</span>]].<span class="hljs-built_in">push_back</span>(graph[i][<span class="hljs-number">1</span>]);
        &#125;
        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;
        queue&lt;<span class="hljs-type">int</span>&gt; q;
        q.<span class="hljs-built_in">push</span>(start);
        vis[start] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();
            q.<span class="hljs-built_in">pop</span>();
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[cur].<span class="hljs-built_in">size</span>();i++)&#123;
                <span class="hljs-keyword">if</span>(g[cur][i] == target)&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                &#125;
                <span class="hljs-keyword">if</span>(!vis[g[cur][i]] &amp;&amp; g[cur][i] != cur)&#123;
                    q.<span class="hljs-built_in">push</span>(g[cur][i]);
                    vis[g[cur][i]] = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-02-最小高度树">面试题 04.02. 最小高度树</h2>
<p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        <span class="hljs-type">int</span> mid = nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>;
        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);
        vector&lt;<span class="hljs-type">int</span>&gt; templeft;
        vector&lt;<span class="hljs-type">int</span>&gt; tempright;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(i &lt; mid)&#123;
                templeft.<span class="hljs-built_in">push_back</span>(nums[i]);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt; mid)&#123;
                tempright.<span class="hljs-built_in">push_back</span>(nums[i]);
            &#125;
        &#125;
        root-&gt;left = <span class="hljs-built_in">sortedArrayToBST</span>(templeft);
        root-&gt;right = <span class="hljs-built_in">sortedArrayToBST</span>(tempright);
        <span class="hljs-keyword">return</span> root;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-03-特定深度节点链表">面试题 04.03. 特定深度节点链表</h2>
<p>给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 <code>D</code>，则会创建出 <code>D</code> 个链表）。返回一个包含所有深度的链表的数组。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">listOfDepth</span><span class="hljs-params">(TreeNode* tree)</span> </span>&#123;
        vector&lt;ListNode*&gt; vt;
        queue&lt;TreeNode*&gt; q;
        <span class="hljs-keyword">if</span>(tree == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> vt;
        &#125;
        q.<span class="hljs-built_in">push</span>(tree);
        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">size</span>();
            ListNode* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
            ListNode* nhead = n;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t;i++)&#123;
                TreeNode* a = q.<span class="hljs-built_in">front</span>();
                q.<span class="hljs-built_in">pop</span>();
                n-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(a-&gt;val);
                n = n-&gt;next;
                <span class="hljs-keyword">if</span>(a-&gt;left != <span class="hljs-literal">NULL</span>)&#123;
                    q.<span class="hljs-built_in">push</span>(a-&gt;left);
                &#125;
                <span class="hljs-keyword">if</span>(a-&gt;right != <span class="hljs-literal">NULL</span>)&#123;
                    q.<span class="hljs-built_in">push</span>(a-&gt;right);
                &#125;
            &#125;
            vt.<span class="hljs-built_in">push_back</span>(nhead-&gt;next);
        &#125;
        <span class="hljs-keyword">return</span> vt;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-04-检查平衡性">面试题 04.04. 检查平衡性</h2>
<p>实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">balance</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-type">int</span> left = <span class="hljs-built_in">balance</span>(root-&gt;left);
        <span class="hljs-type">int</span> right = <span class="hljs-built_in">balance</span>(root-&gt;right);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-type">int</span> left = <span class="hljs-built_in">balance</span>(root-&gt;left);
        <span class="hljs-type">int</span> right = <span class="hljs-built_in">balance</span>(root-&gt;right);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(left-right) &gt; <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isBalanced</span>(root-&gt;right);
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-05-合法二叉搜索树">面试题 04.05. 合法二叉搜索树</h2>
<p>实现一个函数，检查一棵二叉树是否为二叉搜索树。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;<span class="hljs-type">int</span>&gt; result;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">inorder</span>(root-&gt;left);
        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);
        <span class="hljs-built_in">inorder</span>(root-&gt;right);
    &#125;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-built_in">inorder</span>(root);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;result.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;
            <span class="hljs-keyword">if</span>(result[i<span class="hljs-number">+1</span>] &lt;= result[i])&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-06-后继者">面试题 04.06. 后继者</h2>
<p>设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
<p>如果指定节点没有对应的“下一个”节点，则返回 <code>null</code>。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* root, TreeNode* p)</span> </span>&#123;
        stack&lt;TreeNode*&gt; st;
        TreeNode *prev = <span class="hljs-literal">NULL</span>, *curr = root;
        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() || curr != <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">NULL</span>) &#123;
                st.<span class="hljs-built_in">emplace</span>(curr);
                curr = curr-&gt;left;
            &#125;
            curr = st.<span class="hljs-built_in">top</span>();
            st.<span class="hljs-built_in">pop</span>();
            <span class="hljs-keyword">if</span> (prev == p) &#123;
                <span class="hljs-keyword">return</span> curr;
            &#125;
            prev = curr;
            curr = curr-&gt;right;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-08-首个共同祖先">面试题 04.08. 首个共同祖先</h2>
<p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || root == p || root == q)&#123;
            <span class="hljs-keyword">return</span> root;
        &#125;
        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);
        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);
        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> root;
        &#125;
        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> right;
        &#125;
        <span class="hljs-keyword">return</span> left;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-09-二叉搜索树序列">面试题 04.09. 二叉搜索树序列</h2>
<p>从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。</p>
<p>给定一个由<strong>不同节点</strong>组成的二叉搜索树 <code>root</code>，输出所有可能生成此树的数组。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;
    vector&lt;<span class="hljs-type">int</span>&gt; tmp;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(deque&lt;TreeNode*&gt; dq)</span></span>&#123;
        <span class="hljs-keyword">if</span> (dq.<span class="hljs-built_in">empty</span>())
        &#123;
            res.<span class="hljs-built_in">push_back</span>(tmp);     <span class="hljs-comment">//得到一种合法序列</span>
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-type">int</span> size = dq.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">while</span> (size -- )            <span class="hljs-comment">//二叉树的层序遍历</span>
        &#123;
            TreeNode* node = dq.<span class="hljs-built_in">front</span>();
            dq.<span class="hljs-built_in">pop_front</span>();

            tmp.<span class="hljs-built_in">push_back</span>(node-&gt;val);

            <span class="hljs-keyword">if</span> (node-&gt;left) dq.<span class="hljs-built_in">push_back</span>(node-&gt;left);   <span class="hljs-comment">//左右子树入队</span>
            <span class="hljs-keyword">if</span> (node-&gt;right) dq.<span class="hljs-built_in">push_back</span>(node-&gt;right);

            <span class="hljs-built_in">dfs</span>(dq);

            <span class="hljs-keyword">if</span> (node-&gt;right) dq.<span class="hljs-built_in">pop_back</span>();             <span class="hljs-comment">//左右子树出队</span>
            <span class="hljs-keyword">if</span> (node-&gt;left) dq.<span class="hljs-built_in">pop_back</span>();

            dq.<span class="hljs-built_in">push_back</span>(node);
            tmp.<span class="hljs-built_in">pop_back</span>();
        &#125;
    &#125;

    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">BSTSequences</span>(TreeNode* root) &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#123;&#125;&#125;;
        deque&lt;TreeNode*&gt; dq;
        dq.<span class="hljs-built_in">push_back</span>(root);
        <span class="hljs-built_in">dfs</span>(dq);

        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-10-检查子树">面试题 04.10. 检查子树</h2>
<p>检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。</p>
<p>如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSame</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span></span>&#123;
        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">NULL</span> &amp;&amp; t2 == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">NULL</span> || t2 == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">if</span>(t1-&gt;val != t2-&gt;val)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSame</span>(t1-&gt;left, t2-&gt;left) &amp;&amp; <span class="hljs-built_in">isSame</span>(t1-&gt;right, t2-&gt;right);
    &#125;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkSubTree</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">NULL</span> &amp;&amp; t2 == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">if</span>(t1 == <span class="hljs-literal">NULL</span> || t2 == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">if</span>(t1-&gt;val == t2-&gt;val &amp;&amp; <span class="hljs-built_in">isSame</span>(t1, t2))&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">checkSubTree</span>(t1-&gt;left, t2) || <span class="hljs-built_in">checkSubTree</span>(t1-&gt;right, t2);
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-04-12-求和路径">面试题 04.12. 求和路径</h2>
<p>给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> res;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(sum == root-&gt;val)&#123;
            res += <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-built_in">DFS</span>(root-&gt;left, sum-root-&gt;val);
        <span class="hljs-built_in">DFS</span>(root-&gt;right, sum-root-&gt;val);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS1</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">DFS</span>(root, sum);
        <span class="hljs-built_in">DFS1</span>(root-&gt;left, sum);
        <span class="hljs-built_in">DFS1</span>(root-&gt;right, sum);
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;
        res = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">DFS1</span>(root, sum);
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h1>面试题 05</h1>
<h2 id="面试题-05-01-插入">面试题 05.01. 插入</h2>
<p>给定两个整型数字 <code>N</code> 与 <code>M</code>，以及表示比特位置的 <code>i</code> 与 <code>j</code>（<code>i &lt;= j</code>，且从 0 位开始计算）。</p>
<p>编写一种方法，使 <code>M</code> 对应的二进制数字插入 <code>N</code> 对应的二进制数字的第 <code>i ~ j</code> 位区域，不足之处用 <code>0</code> 补齐。具体插入过程如图所示。</p>
<ul>
<li>先将 <code>N</code>的第 <code>i ~ j</code>位全部置零；</li>
<li>再将 <code>M</code>左移 <code>i</code>位，使之对齐上一步中 <code>N</code>置零的位，直接相加即可。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertBits</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = i; k &lt;= j; ++ k)&#123;
               <span class="hljs-comment">//举例说明： (1 &lt;&lt; 3) 表示 00001000，取反后得 11110111</span>
            <span class="hljs-comment">// N &amp;= (11110111) 表示将 N 的第3位置零了</span>
            N &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; k);
        &#125;
        <span class="hljs-keyword">return</span> N + (M &lt;&lt; i);
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-05-02-二进制数转字符串">面试题 05.02. 二进制数转字符串</h2>
<p>二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字无法精确地用32位以内的二进制表示，则打印“ERROR”。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">string <span class="hljs-title">printBin</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;
        string res = <span class="hljs-string">&quot;0.&quot;</span>;
        <span class="hljs-keyword">while</span> (res.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">32</span> &amp;&amp; num != <span class="hljs-number">0</span>) &#123;
            num *= <span class="hljs-number">2</span>;
            <span class="hljs-type">int</span> digit = num;
            res.<span class="hljs-built_in">push_back</span>(digit + <span class="hljs-string">&#x27;0&#x27;</span>);
            num -= digit;
        &#125;
        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">32</span> ? res : <span class="hljs-string">&quot;ERROR&quot;</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-05-03-翻转数位">面试题 05.03. 翻转数位</h2>
<p>给定一个32位整数 <code>num</code>，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。</p>
<p>暴力思路：</p>
<ol>
<li>将32位整数转化为0序列和1序列长度的数组：例如 11011101111被转化为[0(0), 4(1), 1(0), 3(1), 1(0), 2(1)];即num(从右往左为)) 0个0, 4个1, 1个0, 3个1, 1个0, 2个1 组成。该数组为从0开始的交替序列</li>
<li>有了该序列之后，对其进行遍历，对每一个0序列如果长度为1，则length = left + right + 1 把左边和右边的1长度相加再加1。如果0序列长度大于1，则length = max(left, right) + 1 不能连接，左右1长度最大 + 1</li>
<li>遍历过程中更新最大值</li>
</ol>
<p>思路优化：</p>
<ol>
<li>遍历每一位，用previous和current记录之前1的数量和现在1的数量，遇到0就更新previous，current = 0；</li>
<li>用一个变量储存最大长度，每轮遍历进行更新:length = max(previous + current + 1, length);</li>
<li>有个问题是遇到连续的0，这样正确吗？书上的做法是再判断一位，如果 (num &amp; 2) == 0,将previous置为0;这样做好像没有必要，因为遇到第一个0时，current = 0;遇到第二个0时, previous = current = 0, current 被重新置为0，此时length = previous + current + 1，表达式仍然正确；</li>
<li>在c++中 &gt;&gt; 右移为逻辑右移，左边补符号位，如果是负数，左边补1，正数左边补0，使用 while (num &gt; 0) 时负数会死循环：可以转化为无符号数，左移时补0， while 循环正确退出；或者使用for循环，循环32次</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (~num == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">32</span>;
        <span class="hljs-type">int</span> previous = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> current = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;
            <span class="hljs-keyword">if</span> (num &amp; <span class="hljs-number">1</span>) &#123;
                current++;
            &#125; <span class="hljs-keyword">else</span> &#123;
                previous = current;
                current = <span class="hljs-number">0</span>;
            &#125;
            length = <span class="hljs-built_in">max</span>(length, previous + current + <span class="hljs-number">1</span>);
            num &gt;&gt;= <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> length;

    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-05-04-下一个数">面试题 05.04. 下一个数</h2>
<p>下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;
        <span class="hljs-type">int</span> lb  = num &amp; -num;
        <span class="hljs-type">int</span> r = lb + num;
        <span class="hljs-comment">//if(r==0)return 0; 这里是对small没有10的判断，但是也会影响large</span>
        <span class="hljs-keyword">return</span> (num ^r)/lb &gt;&gt; <span class="hljs-number">2</span> | r;
    &#125;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findClosedNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (num == INT_MAX) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;
        <span class="hljs-keyword">if</span> (num==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> &#123;<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>&#125;;
        <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">f</span>(num), ~<span class="hljs-built_in">f</span>(~num)&#125;;  <span class="hljs-comment">//large和small</span>
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-05-06-整数转换">面试题 05.06. 整数转换</h2>
<p>整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。</p>
<p>不断对 c 进行移位操作，然后检查最低有效位。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">convertInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B)</span> </span>&#123;
        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> c = A ^ B; c != <span class="hljs-number">0</span>; c = c &gt;&gt; <span class="hljs-number">1</span>)
            res += c &amp; <span class="hljs-number">1</span>; <span class="hljs-comment">// 数一数 c 中有几个 1</span>
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-05-07-配对交换">面试题 05.07. 配对交换</h2>
<p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exchangeBits</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;
        <span class="hljs-type">int</span> pre=<span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(pre&lt;=num)
        &#123;
            res|=(pre&amp;num)&lt;&lt;<span class="hljs-number">1</span>;
            res|=((pre&lt;&lt;<span class="hljs-number">1</span>)&amp;num)&gt;&gt;<span class="hljs-number">1</span>;
            pre&lt;&lt;=<span class="hljs-number">2</span>;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-05-08-绘制直线">面试题 05.08. 绘制直线</h2>
<p>已知一个由像素点组成的单色屏幕，每行均有 <code>w</code> 个像素点，所有像素点初始为 <code>0</code>，左上角位置为 <code>(0,0)</code>。</p>
<p>现将每行的像素点按照「每 <code>32</code> 个像素点」为一组存放在一个 <code>int</code> 中，再依次存入长度为 <code>length</code> 的一维数组中。</p>
<p>我们将在屏幕上绘制一条从点 <code>(x1,y)</code> 到点 <code>(x2,y)</code> 的直线（即像素点修改为 <code>1</code>），请返回绘制过后的数组。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">drawLine</span><span class="hljs-params">(<span class="hljs-type">int</span> length, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y)</span> </span>&#123;
        <span class="hljs-comment">// 注意直线的坐标</span>
        <span class="hljs-comment">// 实际上需要特殊处理的 只有直线所在的那一行</span>
        <span class="hljs-comment">// 结果数组从 像素点(0, 0)开始计算</span>
        <span class="hljs-type">int</span> per_row = w / <span class="hljs-number">32</span>;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(length, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x1; i &lt;= x2 &amp;&amp; i &lt; length * <span class="hljs-number">32</span>; i++)
            res[y * per_row + i / <span class="hljs-number">32</span>] |= (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span> - i % <span class="hljs-number">32</span>);        <span class="hljs-comment">// 从左到右，先高后低</span>

        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h1>面试题 08</h1>
<h2 id="面试题-08-01-三步问题">面试题 08.01. 三步问题</h2>
<p>三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">waysToStep</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)&#123;
            <span class="hljs-keyword">return</span> n;
        &#125;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">3</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
        &#125;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;
        dp[<span class="hljs-number">3</span>] = <span class="hljs-number">4</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">4</span>;i&lt;=n;i++)&#123;
            dp[i] = (dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>]) % <span class="hljs-number">1000000007</span> +dp[i<span class="hljs-number">-3</span>];
            dp[i] %= <span class="hljs-number">1000000007</span>;
        &#125;
        <span class="hljs-keyword">return</span> dp[n];
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-02-迷路的机器人">面试题 08.02. 迷路的机器人</h2>
<p>设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">if</span>(obstacleGrid[i][j] == <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">if</span>(i == m<span class="hljs-number">-1</span> &amp;&amp; j == n<span class="hljs-number">-1</span>)&#123;
            result.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        result.<span class="hljs-built_in">push_back</span>(&#123;i,j&#125;);
        <span class="hljs-keyword">if</span>(i<span class="hljs-number">+1</span> &lt; m &amp;&amp; <span class="hljs-built_in">DFS</span>(obstacleGrid, result, i<span class="hljs-number">+1</span>,j,m,n))&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">if</span>(j<span class="hljs-number">+1</span> &lt; n &amp;&amp; <span class="hljs-built_in">DFS</span>(obstacleGrid, result, i,j<span class="hljs-number">+1</span>,m,n))&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        result.<span class="hljs-built_in">pop_back</span>();
        obstacleGrid[i][j] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathWithObstacles</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; obstacleGrid) &#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;
        <span class="hljs-type">int</span> m = obstacleGrid.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = obstacleGrid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">DFS</span>(obstacleGrid, result, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,m,n);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-03-魔术索引">面试题 08.03. 魔术索引</h2>
<p>魔术索引。 在数组 <code>A[0...n-1]</code>中，有所谓的魔术索引，满足条件 <code>A[i] = i</code>。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMagicIndex</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;
            <span class="hljs-keyword">if</span>(i == nums[i]) <span class="hljs-keyword">return</span> i;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-04-幂集">面试题 08.04. 幂集</h2>
<p>幂集。编写一种方法，返回某集合的所有子集。集合中 <strong>不包含重复的元素</strong> 。</p>
<p>说明：解集不能包含重复的子集。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &amp;result, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start)</span></span>&#123;
        result.<span class="hljs-built_in">push_back</span>(temp);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            temp.<span class="hljs-built_in">push_back</span>(nums[i]);
            <span class="hljs-built_in">backtracking</span>(result, temp, nums, i<span class="hljs-number">+1</span>);
            temp.<span class="hljs-built_in">pop_back</span>();
        &#125;
    &#125;
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;
        vector&lt;<span class="hljs-type">int</span>&gt; temp;
        <span class="hljs-built_in">backtracking</span>(result, temp, nums, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-05-递归乘法">面试题 08.05. 递归乘法</h2>
<p>递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">(<span class="hljs-type">int</span> A, <span class="hljs-type">int</span> B)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(B)&#123;<span class="hljs-comment">//B非0才计算</span>
            <span class="hljs-comment">//从0阶(A*(B&amp;1)*2^0)开始，每次算当前阶(A*(B&amp;1)*2^n)的乘法并累加起来,算到B为0为止。</span>
            <span class="hljs-keyword">if</span>(B&amp;<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果B的最后一位是1</span>
                <span class="hljs-comment">//把B的阶放到A上去，递归算B的倒数第2位和A的乘法,然后求和+(1*A=A)。</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">multiply</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)A&lt;&lt;<span class="hljs-number">1</span>,B&gt;&gt;<span class="hljs-number">1</span>)+A;
            &#125;<span class="hljs-keyword">else</span>&#123;
                <span class="hljs-comment">//把B的阶放到A上去，递归算B的倒数第2位和A的乘法,然后求和+(0*A=0)。</span>
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">multiply</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)A&lt;&lt;<span class="hljs-number">1</span>,B&gt;&gt;<span class="hljs-number">1</span>);
            &#125;
        &#125;
        <span class="hljs-comment">// B为0结果当然是0</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-06-汉诺塔问题">面试题 08.06. 汉诺塔问题</h2>
<p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>
(1) 每次只能移动一个盘子;<br>
(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>
(3) 盘子只能叠在比它大的盘子上。</p>
<p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p>
<p>你需要原地修改栈。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hanota</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C)</span> </span>&#123;
        <span class="hljs-type">int</span> n = A.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">move</span>(n, A, B, C);
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> n, vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C)</span></span>&#123;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)&#123;
            C.<span class="hljs-built_in">push_back</span>(A.<span class="hljs-built_in">back</span>());
            A.<span class="hljs-built_in">pop_back</span>();
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-built_in">move</span>(n<span class="hljs-number">-1</span>, A, C, B);    <span class="hljs-comment">// 将A上面n-1个通过C移到B</span>
        C.<span class="hljs-built_in">push_back</span>(A.<span class="hljs-built_in">back</span>());  <span class="hljs-comment">// 将A最后一个移到C</span>
        A.<span class="hljs-built_in">pop_back</span>();          <span class="hljs-comment">// 这时，A空了</span>
        <span class="hljs-built_in">move</span>(n<span class="hljs-number">-1</span>, B, A, C);     <span class="hljs-comment">// 将B上面n-1个通过空的A移到C</span>
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-07-无重复字符串的排列组合">面试题 08.07. 无重复字符串的排列组合</h2>
<p>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;string&gt; &amp; result, string S, vector&lt;<span class="hljs-type">char</span>&gt; &amp;temp, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;visited)</span></span>&#123;
        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == S.<span class="hljs-built_in">size</span>())&#123;
            string t = <span class="hljs-string">&quot;&quot;</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;
                t += temp[i];
            &#125;
            result.<span class="hljs-built_in">push_back</span>(t);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>)&#123;
                visited[i] = <span class="hljs-literal">true</span>;
                temp.<span class="hljs-built_in">push_back</span>(S[i]);
                <span class="hljs-built_in">backtracking</span>(result, S, temp, visited);
                temp.<span class="hljs-built_in">pop_back</span>();
                visited[i] = <span class="hljs-literal">false</span>;
            &#125;

        &#125;
    &#125;
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string S)</span> </span>&#123;
        vector&lt;string&gt; result;
        vector&lt;<span class="hljs-type">char</span>&gt; temp;
        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(S.size(), <span class="hljs-literal">false</span>)</span></span>;
        <span class="hljs-built_in">backtracking</span>(result, S, temp, visited);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-08-有重复字符串的排列组合">面试题 08.08. 有重复字符串的排列组合</h2>
<p>有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;string&gt; &amp; result, string S, vector&lt;<span class="hljs-type">char</span>&gt; &amp;temp, vector&lt;<span class="hljs-type">bool</span>&gt; &amp;visited)</span></span>&#123;
        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == S.<span class="hljs-built_in">size</span>())&#123;
            string t = <span class="hljs-string">&quot;&quot;</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;
                t += temp[i];
            &#125;
            result.<span class="hljs-built_in">push_back</span>(t);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;S.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; S[i] == S[i<span class="hljs-number">-1</span>] &amp;&amp; visited[i<span class="hljs-number">-1</span>] == <span class="hljs-literal">false</span>)&#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-keyword">if</span> (visited[i] == <span class="hljs-literal">false</span>)&#123;
                visited[i] = <span class="hljs-literal">true</span>;
                temp.<span class="hljs-built_in">push_back</span>(S[i]);
                <span class="hljs-built_in">backtracking</span>(result, S, temp, visited);
                temp.<span class="hljs-built_in">pop_back</span>();
                visited[i] = <span class="hljs-literal">false</span>;
            &#125;

        &#125;
    &#125;
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">permutation</span><span class="hljs-params">(string S)</span> </span>&#123;
        <span class="hljs-built_in">sort</span>(S.<span class="hljs-built_in">begin</span>(), S.<span class="hljs-built_in">end</span>());
        vector&lt;string&gt; result;
        vector&lt;<span class="hljs-type">char</span>&gt; temp;
        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(S.size(), <span class="hljs-literal">false</span>)</span></span>;
        <span class="hljs-built_in">backtracking</span>(result, S, temp, visited);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-09-括号">面试题 08.09. 括号</h2>
<p>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。</p>
<p>说明：解集不能包含重复的子集。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;string&gt; &amp;result, vector&lt;<span class="hljs-type">char</span>&gt; &amp;temp, <span class="hljs-type">int</span> nowleft, <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == n * <span class="hljs-number">2</span>)&#123;
            <span class="hljs-keyword">if</span>(nowleft == <span class="hljs-number">0</span>)&#123;
                string t = <span class="hljs-string">&quot;&quot;</span>;
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;
                    t += temp[i];
                &#125;
                result.<span class="hljs-built_in">push_back</span>(t);
            &#125;
            <span class="hljs-keyword">return</span>;
        &#125;
        temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);
        <span class="hljs-built_in">backtracking</span>(result, temp, nowleft<span class="hljs-number">+1</span>, n);
        temp.<span class="hljs-built_in">pop_back</span>();
        <span class="hljs-keyword">if</span>(nowleft &gt; <span class="hljs-number">0</span>)&#123;
            temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);
            <span class="hljs-built_in">backtracking</span>(result, temp, nowleft<span class="hljs-number">-1</span>, n);
            temp.<span class="hljs-built_in">pop_back</span>();
        &#125;
    &#125;
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
        vector&lt;string&gt; result;
        vector&lt;<span class="hljs-type">char</span>&gt; temp;
        <span class="hljs-built_in">backtracking</span>(result, temp, <span class="hljs-number">0</span>, n);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-10-颜色填充">面试题 08.10. 颜色填充</h2>
<p>编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。</p>
<p>待填充的图像用二维数组 <code>image</code> 表示，元素为初始颜色值。初始坐标点的行坐标为 <code>sr</code> 列坐标为 <code>sc</code>。需要填充的新颜色为 <code>newColor</code> 。</p>
<p>「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。</p>
<p>请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;
        <span class="hljs-type">int</span> m = image.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = image[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));
        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q;
        q.<span class="hljs-built_in">push</span>(&#123;sr, sc&#125;);
        visited[sr][sc] = <span class="hljs-literal">true</span>;
        <span class="hljs-type">int</span> sign = image[sr][sc];
        image[sr][sc] = newColor;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; direction = &#123;
            &#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,
            &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,
            &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,
            &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,
        &#125;;
        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p = q.<span class="hljs-built_in">front</span>();
            q.<span class="hljs-built_in">pop</span>();
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;direction.<span class="hljs-built_in">size</span>();i++)&#123;
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;direction[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)&#123;
                    <span class="hljs-type">int</span> x = p.first + direction[i][<span class="hljs-number">0</span>];
                    <span class="hljs-type">int</span> y = p.second + direction[i][<span class="hljs-number">1</span>];
                    <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n &amp;&amp; image[x][y] == sign &amp;&amp; visited[x][y] == <span class="hljs-literal">false</span>)&#123;
                        q.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);
                        image[x][y] = newColor;
                        visited[x][y] = <span class="hljs-literal">true</span>;
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> image;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-11-硬币">面试题 08.11. 硬币</h2>
<p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">waysToChange</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; coins = &#123;<span class="hljs-number">25</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>&#125;;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=coins[i];j&lt;=n;j++)&#123;
                dp[j] = (dp[j] + dp[j-coins[i]]) % <span class="hljs-number">1000000007</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[n];
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-12-八皇后">面试题 08.12. 八皇后</h2>
<p>设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt; &amp;temp, <span class="hljs-type">int</span> nowindex)</span></span>&#123;
        <span class="hljs-type">int</span> m = temp.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = temp[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m<span class="hljs-number">-1</span>;i++)&#123;
            <span class="hljs-keyword">if</span>(temp[i][nowindex] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-type">int</span> x = m<span class="hljs-number">-1</span><span class="hljs-number">-1</span>;
        <span class="hljs-type">int</span> y = nowindex<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &gt;= <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">if</span>(temp[x][y] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            x--;
            y--;
        &#125;
        x = m<span class="hljs-number">-1</span><span class="hljs-number">-1</span>;
        y = nowindex<span class="hljs-number">+1</span>;
        <span class="hljs-keyword">while</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; n)&#123;
            <span class="hljs-keyword">if</span>(temp[x][y] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            x--;
            y++;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;string&gt; &gt; &amp;result, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt; &amp;temp, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> now)</span></span>&#123;
        <span class="hljs-keyword">if</span>(now == n)&#123;
            vector&lt;string&gt; t;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;
                string tempstring = <span class="hljs-string">&quot;&quot;</span>;
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;temp[i].<span class="hljs-built_in">size</span>();j++)&#123;
                    tempstring += temp[i][j];
                &#125;
                t.<span class="hljs-built_in">push_back</span>(tempstring);
            &#125;
            result.<span class="hljs-built_in">push_back</span>(t);
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
            vector&lt;<span class="hljs-type">char</span>&gt; vt;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                vt.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;.&#x27;</span>);
            &#125;
            vt[i] = <span class="hljs-string">&#x27;Q&#x27;</span>;
            temp.<span class="hljs-built_in">push_back</span>(vt);
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(temp, i))&#123;
                <span class="hljs-built_in">backtracking</span>(result, temp, n, now<span class="hljs-number">+1</span>);
            &#125;
            temp.<span class="hljs-built_in">pop_back</span>();
        &#125;
    &#125;
    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;
        vector&lt;vector&lt;string&gt; &gt; result;
        vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt; temp;
        <span class="hljs-built_in">backtracking</span>(result, temp, n, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-13-堆箱子">面试题 08.13. 堆箱子</h2>
<p>堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。</p>
<p>输入使用数组 <code>[wi, di, hi]</code>表示每个箱子。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pileBox</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; box)</span> </span>&#123;
        <span class="hljs-built_in">sort</span>(box.<span class="hljs-built_in">begin</span>(), box.<span class="hljs-built_in">end</span>());
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(box.size(), <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; box.<span class="hljs-built_in">size</span>(); ++i) &#123;
            dp[i] = box[i][<span class="hljs-number">2</span>];
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; box.<span class="hljs-built_in">size</span>(); ++i) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;
                <span class="hljs-keyword">if</span> (box[i][<span class="hljs-number">0</span>] &gt; box[j][<span class="hljs-number">0</span>] &amp;&amp; box[i][<span class="hljs-number">1</span>] &gt; box[j][<span class="hljs-number">1</span>] &amp;&amp; box[i][<span class="hljs-number">2</span>] &gt; box[j][<span class="hljs-number">2</span>])
                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + box[i][<span class="hljs-number">2</span>]);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> *<span class="hljs-built_in">max_element</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">end</span>());
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-08-14-布尔运算">面试题 08.14. 布尔运算</h2>
<p>给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 <code>0</code> (false)、<code>1</code> (true)、<code>&amp;</code> (AND)、 <code>|</code> (OR) 和 <code>^</code> (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。</p>
<ul>
<li>dp[i][j][0]代表第i个字符到第j个字符，result=0的可能性个数</li>
<li>dp[i][j][1]代表第i个字符到第j个字符，result=1的可能性个数</li>
</ul>
<p>然后枚举中间断点就行啦</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countEval</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> result)</span> </span>&#123;
        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();
        vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)));

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i+=<span class="hljs-number">2</span>)&#123;
            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) tmp = <span class="hljs-number">1</span>;
            dp[i][i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>-tmp;
            dp[i][i][<span class="hljs-number">1</span>] = tmp;
        &#125;

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> step=<span class="hljs-number">0</span>; step&lt;n; step+=<span class="hljs-number">2</span>)&#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i+step&lt;n; i+=<span class="hljs-number">2</span>)&#123;
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>; j&lt;i+step; j+=<span class="hljs-number">2</span>)&#123;
                    <span class="hljs-type">int</span> left0 = dp[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], left1 = dp[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>];
                    <span class="hljs-type">int</span> right0 = dp[j<span class="hljs-number">+1</span>][i+step][<span class="hljs-number">0</span>], right1 = dp[j<span class="hljs-number">+1</span>][i+step][<span class="hljs-number">1</span>];
                    <span class="hljs-comment">// cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i+step&lt;&lt;&quot; &quot;&lt;&lt;left0&lt;&lt;&quot; &quot;&lt;&lt;left1&lt;&lt;&quot; &quot;&lt;&lt;right0&lt;&lt;&quot; &quot;&lt;&lt;right1;</span>
                    <span class="hljs-keyword">if</span> (s[j]==<span class="hljs-string">&#x27;&amp;&#x27;</span>)&#123;
                        dp[i][i+step][<span class="hljs-number">0</span>] += left0*(right0+right1)+left1*right0;
                        dp[i][i+step][<span class="hljs-number">1</span>] += left1*right1;
                    &#125;
                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[j]==<span class="hljs-string">&#x27;|&#x27;</span>)&#123;
                        dp[i][i+step][<span class="hljs-number">0</span>] += left0*right0;
                        dp[i][i+step][<span class="hljs-number">1</span>] += left0*right1 + left1*(right0+right1);
                    &#125;
                    <span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//s[j]==&#x27;^&#x27;</span>
                        dp[i][i+step][<span class="hljs-number">0</span>] += left0*right0 + left1*right1;
                        dp[i][i+step][<span class="hljs-number">1</span>] += left0*right1 + left1*right0;
                    &#125;
                    <span class="hljs-comment">// cout&lt;&lt;&quot; dp[i][i+step][0]:&quot;&lt;&lt;dp[i][i+step][0]&lt;&lt;&quot; dp[i][i+step][1]:&quot;&lt;&lt;dp[i][i+step][1]&lt;&lt;endl;</span>
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>][result];
    &#125;
&#125;;</code></pre></div>
<h1>面试题 10</h1>
<h2 id="面试题-10-01-合并排序的数组">面试题 10.01. 合并排序的数组</h2>
<p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p>
<p>初始化 A 和 B 的元素数量分别为 <em>m</em> 和  <em>n</em> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, <span class="hljs-type">int</span> n)</span> </span>&#123;
        <span class="hljs-type">int</span> actualindex = m + n - <span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> Aindex = m - <span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> Bindex = n - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(Aindex &gt;= <span class="hljs-number">0</span> || Bindex &gt;= <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">if</span>(Aindex &lt; <span class="hljs-number">0</span>)&#123;
                A[actualindex] = B[Bindex];
                Bindex--;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Bindex &lt; <span class="hljs-number">0</span>)&#123;
                A[actualindex] = A[Aindex];
                Aindex--;
            &#125; <span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">if</span>(A[Aindex] &lt; B[Bindex])&#123;
                    A[actualindex] = B[Bindex];
                    Bindex--;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    A[actualindex] = A[Aindex];
                    Aindex--;
                &#125;
            &#125;
            actualindex--;
        &#125;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-10-02-变位词组">面试题 10.02. 变位词组</h2>
<p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;
        unordered_map&lt;string, vector&lt;string&gt; &gt; mp;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.<span class="hljs-built_in">size</span>();i++)&#123;
            string t = strs[i];
            <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">end</span>());
            mp[t].<span class="hljs-built_in">push_back</span>(strs[i]);
        &#125;
        vector&lt;vector&lt;string&gt; &gt; result;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>();it++)&#123;
            result.<span class="hljs-built_in">push_back</span>(it-&gt;second);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-10-03-搜索旋转数组">面试题 10.03. 搜索旋转数组</h2>
<p>搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> right = arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (right == <span class="hljs-number">-1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span> (left &lt; right) &#123;                                         <span class="hljs-comment">// 循环结束条件left==right</span>
            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;
            <span class="hljs-keyword">if</span> (arr[left] &lt; arr[mid]) &#123;                              <span class="hljs-comment">// 如果左值小于中值，说明左边区间升序           </span>
                <span class="hljs-keyword">if</span> (arr[left] &lt;= target &amp;&amp; target &lt;= arr[mid]) &#123;     <span class="hljs-comment">// 如果目标在左边的升序区间中，右边界移动到mid</span>
                    right = mid;                                   
                &#125; <span class="hljs-keyword">else</span> &#123;                                               <span class="hljs-comment">// 否则目标在右半边，左边界移动到mid+1</span>
                    left = mid + <span class="hljs-number">1</span>;                                
                &#125;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[left] &gt; arr[mid]) &#123;                       <span class="hljs-comment">// 如果左值大于中值，说明左边不是升序，右半边升序</span>
                <span class="hljs-keyword">if</span> (arr[left] &lt;= target || target &lt;= arr[mid]) &#123;     <span class="hljs-comment">// 如果目标在左边，右边界移动到mid</span>
                    right = mid;                                   
                &#125; <span class="hljs-keyword">else</span> &#123;                                               <span class="hljs-comment">// 否则目标在右半边，左边界移动到mid+1</span>
                    left = mid + <span class="hljs-number">1</span>;                                
                &#125;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[left] == arr[mid]) &#123;                      <span class="hljs-comment">// 如果左值等于中值，可能是已经找到了目标，也可能是遇到了重复值</span>
                <span class="hljs-keyword">if</span> (arr[left] != target) &#123;                            <span class="hljs-comment">// 如果左值不等于目标，说明还没找到，需要逐一清理重复值。</span>
                    left++;
                &#125; <span class="hljs-keyword">else</span> &#123;                                               <span class="hljs-comment">// 如果左值等于目标，说明已经找到最左边的目标值 </span>
                    right = left;                                      <span class="hljs-comment">// 将右边界移动到left，循环结束</span>
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> (arr[left] == target) ? left : <span class="hljs-number">-1</span>;                     <span class="hljs-comment">// 返回left，或者-1</span>
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-10-05-稀疏数组搜索">面试题 10.05. 稀疏数组搜索</h2>
<p>稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findString</span><span class="hljs-params">(<span class="hljs-type">char</span>** words, <span class="hljs-type">int</span> wordsSize, <span class="hljs-type">char</span>* s)</span></span>&#123;
    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = wordsSize<span class="hljs-number">-1</span>, mid;
    <span class="hljs-keyword">while</span>(left&lt;right)&#123;
        mid = (left + right) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (*words[mid] == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//如果中间为空，则由二分查找变为线性遍历</span>
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(words[left],s)) left++;<span class="hljs-comment">//从左至右扫描</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> left; 
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(words[mid],s) &gt; <span class="hljs-number">0</span>) right = mid - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(words[mid],s) &lt; <span class="hljs-number">0</span>) left = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;
    &#125;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(words[left],s) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> left;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

&#125;</code></pre></div>
<h2 id="面试题-10-09-排序矩阵查找">面试题 10.09. 排序矩阵查找</h2>
<p>给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> y = n - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">if</span>(matrix[x][y] == target)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[x][y] &gt; target)&#123;
                y--;
            &#125; <span class="hljs-keyword">else</span>&#123;
                x++;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-10-10-数字流的秩">面试题 10.10. 数字流的秩</h2>
<p>假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：</p>
<p>实现 <code>track(int x)</code> 方法，每读入一个数字都会调用该方法；</p>
<p>实现 <code>getRankOfNumber(int x)</code> 方法，返回小于或等于 x 的值的个数。</p>
<p>树状数组的模板题目</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StreamRank</span> &#123;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> a[<span class="hljs-number">50010</span>];
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">StreamRank</span>() &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">50001</span>;++i) a[i]=<span class="hljs-number">0</span>;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">track</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
        ++x;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=x;i&lt;=<span class="hljs-number">50001</span>;i+=i&amp;(-i)) a[i]++;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getRankOfNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;
        ++x;
        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=x;i;i-=i&amp;(-i)) sum+=a[i];
        <span class="hljs-keyword">return</span> sum;
    &#125;
&#125;;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Your StreamRank object will be instantiated and called as such:</span>
<span class="hljs-comment"> * StreamRank* obj = new StreamRank();</span>
<span class="hljs-comment"> * obj-&gt;track(x);</span>
<span class="hljs-comment"> * int param_2 = obj-&gt;getRankOfNumber(x);</span>
<span class="hljs-comment"> */</span></code></pre></div>
<h2 id="面试题-10-11-峰与谷">面试题 10.11. 峰与谷</h2>
<p>在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wiggleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; temp=nums;
        <span class="hljs-built_in">sort</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>());
        <span class="hljs-type">int</span> Left=<span class="hljs-number">0</span>, Right=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
        <span class="hljs-type">int</span> index=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(index &lt; nums.<span class="hljs-built_in">size</span>())&#123;
            nums[index++] = temp[Left++];
            <span class="hljs-keyword">if</span>(index &lt; nums.<span class="hljs-built_in">size</span>())&#123;
                nums[index++] = temp[Right--];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span>;
    &#125;
&#125;;</code></pre></div>
<h1>面试题 16</h1>
<h2 id="面试题-16-01-交换数字">面试题 16.01. 交换数字</h2>
<p>编写一个函数，不用临时变量，直接交换 <code>numbers = [a, b]</code>中 <code>a</code>与 <code>b</code>的值。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">swapNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers)</span> </span>&#123;
        numbers[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)numbers[<span class="hljs-number">0</span>] + (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)numbers[<span class="hljs-number">1</span>];
        numbers[<span class="hljs-number">1</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)numbers[<span class="hljs-number">0</span>] - (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)numbers[<span class="hljs-number">1</span>];
        numbers[<span class="hljs-number">0</span>] = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)numbers[<span class="hljs-number">0</span>] - (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)numbers[<span class="hljs-number">1</span>];
        <span class="hljs-keyword">return</span> numbers;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-02-单词频率">面试题 16.02. 单词频率</h2>
<p>设计一个方法，找出任意指定单词在一本书中的出现频率。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li><code>WordsFrequency(book)</code>构造函数，参数为字符串数组构成的一本书</li>
<li><code>get(word)</code>查询指定单词在书中出现的频率</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordsFrequency</span> &#123;
<span class="hljs-keyword">private</span>:
    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; mp;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">WordsFrequency</span>(vector&lt;string&gt;&amp; book) &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;book.<span class="hljs-built_in">size</span>();i++)&#123;
            mp[book[i]] += <span class="hljs-number">1</span>;
        &#125;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(string word)</span> </span>&#123;
        <span class="hljs-keyword">return</span> mp[word];
    &#125;
&#125;;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Your WordsFrequency object will be instantiated and called as such:</span>
<span class="hljs-comment"> * WordsFrequency* obj = new WordsFrequency(book);</span>
<span class="hljs-comment"> * int param_1 = obj-&gt;get(word);</span>
<span class="hljs-comment"> */</span></code></pre></div>
<h2 id="面试题-16-03-交点">面试题 16.03. 交点</h2>
<p>给定两条线段（表示为起点 <code>start = &#123;X1, Y1&#125;</code>和终点 <code>end = &#123;X2, Y2&#125;</code>），如果它们有交点，请计算其交点，没有交点则返回空值。</p>
<p>要求浮点型误差不超过 <code>10^-6</code>。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。</p>
<h2 id="面试题-16-04-井字游戏">面试题 16.04. 井字游戏</h2>
<p>设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符&quot; &quot;，“X&quot;和&quot;O&quot;组成，其中字符” &quot;代表一个空位。</p>
<p>以下是井字游戏的规则：</p>
<ul>
<li>玩家轮流将字符放入空位（&quot; &quot;）中。</li>
<li>第一个玩家总是放字符&quot;O&quot;，且第二个玩家总是放字符&quot;X&quot;。</li>
<li>&quot;X&quot;和&quot;O&quot;只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>
<li>当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。</li>
<li>当所有位置非空时，也算为游戏结束。</li>
<li>如果游戏结束，玩家不允许再放置字符。</li>
</ul>
<p>如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（“X&quot;或&quot;O”）；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(vector&lt;string&gt;&amp; board, <span class="hljs-type">char</span> word, <span class="hljs-type">int</span> N)</span></span>&#123;
        <span class="hljs-type">bool</span> flag;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;
            flag = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;
                <span class="hljs-keyword">if</span>(board[i][j] != word)&#123;
                    flag = <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span>(flag)&#123;
                <span class="hljs-keyword">return</span> flag;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;
            flag = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;
                <span class="hljs-keyword">if</span>(board[j][i] != word)&#123;
                    flag = <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span>(flag)&#123;
                <span class="hljs-keyword">return</span> flag;
            &#125;
        &#125;
        flag = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;
            <span class="hljs-keyword">if</span>(board[i][i] != word)&#123;
                flag = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(flag)&#123;
            <span class="hljs-keyword">return</span> flag;
        &#125;

        flag = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;
            <span class="hljs-keyword">if</span>(board[i][N-i<span class="hljs-number">-1</span>] != word)&#123;
                flag = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> flag;
      
    &#125;
    <span class="hljs-function">string <span class="hljs-title">tictactoe</span><span class="hljs-params">(vector&lt;string&gt;&amp; board)</span> </span>&#123;
        <span class="hljs-type">int</span> N = board.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(board, <span class="hljs-string">&#x27;X&#x27;</span>, N))&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;X&quot;</span>;
        &#125;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(board, <span class="hljs-string">&#x27;O&#x27;</span>, N))&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;O&quot;</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;N;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;N;j++)&#123;
                <span class="hljs-keyword">if</span>(board[i][j] == <span class="hljs-string">&#x27; &#x27;</span>)&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pending&quot;</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Draw&quot;</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-05-阶乘尾数">面试题 16.05. 阶乘尾数</h2>
<p>设计一个算法，算出 n 阶乘有多少个尾随零。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (n) &#123;
            n = n/<span class="hljs-number">5</span>;
            ans += n;
        &#125;
      
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-06-最小差">面试题 16.06. 最小差</h2>
<p>给定两个整数数组 <code>a</code>和 <code>b</code>，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">smallestDifference</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;
        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());
        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());
        <span class="hljs-type">int</span> na = a.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> nb = b.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;
        <span class="hljs-type">long</span> res = LONG_MAX;
        <span class="hljs-keyword">while</span> (i &lt; na &amp;&amp; j &lt; nb)
        &#123;
            <span class="hljs-keyword">if</span> (a[i] != b[j])
            &#123;
                res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">abs</span>((<span class="hljs-type">long</span>)a[i]-(<span class="hljs-type">long</span>)b[j]));
                a[i] &gt; b[j] ? ++j : ++i;
            &#125;
            <span class="hljs-keyword">else</span>
            &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            &#125;
        &#125;

        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-07-最大数值">面试题 16.07. 最大数值</h2>
<p>编写一个方法，找出两个数字 <code>a</code>和 <code>b</code>中最大的那一个。不得使用if-else或其他比较运算符。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a,b);
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-08-整数的英语表示">面试题 16.08. 整数的英语表示</h2>
<p>给定一个整数，打印该整数的英文描述。</p>
<h2 id="面试题-16-09-运算">面试题 16.09. 运算</h2>
<p>请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li><code>Operations()</code> 构造函数</li>
<li><code>minus(a, b)</code> 减法，返回 <code>a - b</code></li>
<li><code>multiply(a, b)</code> 乘法，返回 <code>a * b</code></li>
<li><code>divide(a, b)</code> 除法，返回 <code>a / b</code></li>
</ul>
<h2 id="面试题-16-10-生存人数">面试题 16.10. 生存人数</h2>
<p>给定 N 个人的出生年份和死亡年份，第 <code>i</code> 个人的出生年份为 <code>birth[i]</code>，死亡年份为 <code>death[i]</code>，实现一个方法以计算生存人数最多的年份。</p>
<p>你可以假设所有人都出生于 1900 年至 2000 年（含 1900 和 2000 ）之间。如果一个人在某一年的任意时期处于生存状态，那么他应该被纳入那一年的统计中。例如，生于 1908 年、死于 1909 年的人应当被列入 1908 年和 1909 年的计数。</p>
<p>如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAliveYear</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; birth, vector&lt;<span class="hljs-type">int</span>&gt;&amp; death)</span> </span>&#123;
        <span class="hljs-type">int</span> smallbirth = birth[<span class="hljs-number">0</span>];
        <span class="hljs-type">int</span> maxdeath = death[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;birth.<span class="hljs-built_in">size</span>();i++)&#123;
            smallbirth = <span class="hljs-built_in">min</span>(smallbirth, birth[i]);
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;death.<span class="hljs-built_in">size</span>();i++)&#123;
            maxdeath = <span class="hljs-built_in">max</span>(maxdeath, death[i]);
        &#125;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(maxdeath - smallbirth + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;birth.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=birth[i];j&lt;=death[i];j++)&#123;
                result[j-smallbirth] += <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> year = birth[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=smallbirth;i&lt;=maxdeath;i++)&#123;
            <span class="hljs-keyword">if</span> (result[i-smallbirth] &gt; res)&#123;
                year = i;
                res = result[i-smallbirth];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> year;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-11-跳水板">面试题 16.11. 跳水板</h2>
<p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为 <code>shorter</code>，长度较长的木板长度为 <code>longer</code>。你必须正好使用 <code>k</code>块木板。编写一个方法，生成跳水板所有可能的长度。</p>
<p>返回的长度需要从小到大排列。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;<span class="hljs-type">int</span>&gt; result;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">divingBoard</span><span class="hljs-params">(<span class="hljs-type">int</span> shorter, <span class="hljs-type">int</span> longer, <span class="hljs-type">int</span> k)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">return</span> vector &lt;<span class="hljs-type">int</span>&gt; ();
        &#125;

        <span class="hljs-keyword">if</span> (shorter == longer) &#123;
            <span class="hljs-keyword">return</span> vector &lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">1</span>, shorter * k);
        &#125;

        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">lengths</span>(k + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= k; ++i) &#123;
            lengths[i] = shorter * (k - i) + longer * i;
        &#125;

        <span class="hljs-keyword">return</span> lengths;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-13-平分正方形">面试题 16.13. 平分正方形</h2>
<p>给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与 x 轴平行。</p>
<p>每个正方形的数据 <code>square</code>包含3个数值，正方形的左下顶点坐标 <code>[X,Y] = [square[0],square[1]]</code>，以及正方形的边长 <code>square[2]</code>。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标 <code>[X&lt;sub&gt;1&lt;/sub&gt;,Y&lt;sub&gt;1&lt;/sub&gt;]</code>和 <code>[X&lt;sub&gt;2&lt;/sub&gt;,Y&lt;sub&gt;2&lt;/sub&gt;]</code>的返回格式为 <code>&#123;X&lt;sub&gt;1&lt;/sub&gt;,Y&lt;sub&gt;1&lt;/sub&gt;,X&lt;sub&gt;2&lt;/sub&gt;,Y&lt;sub&gt;2&lt;/sub&gt;&#125;</code>，要求若 <code>X&lt;sub&gt;1&lt;/sub&gt; != X&lt;sub&gt;2&lt;/sub&gt;</code>，需保证 <code>X&lt;sub&gt;1&lt;/sub&gt; &lt; X&lt;sub&gt;2&lt;/sub&gt;</code>，否则需保证 <code>Y&lt;sub&gt;1&lt;/sub&gt; &lt;= Y&lt;sub&gt;2&lt;/sub&gt;</code>。</p>
<p>若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。</p>
<h2 id="面试题-16-14-最佳直线">面试题 16.14. 最佳直线</h2>
<p>给定一个二维平面及平面上的 N 个点列表 <code>Points</code>，其中第 <code>i</code>个点的坐标为 <code>Points[i]=[X&lt;sub&gt;i&lt;/sub&gt;,Y&lt;sub&gt;i&lt;/sub&gt;]</code>。请找出一条直线，其通过的点的数目最多。</p>
<p>设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为 <code>S</code>，你仅需返回 <code>[S[0],S[1]]</code>作为答案，若有多条直线穿过了相同数量的点，则选择 <code>S[0]</code>值较小的直线返回，<code>S[0]</code>相同则选择 <code>S[1]</code>值较小的直线返回。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bestLine</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;
        <span class="hljs-type">int</span> n = points.<span class="hljs-built_in">size</span>();
        <span class="hljs-comment">// 保存最大的数量和对应的序号数组</span>
        <span class="hljs-type">int</span> maxCnt = <span class="hljs-number">0</span>;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)
        &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>; j &lt; n; ++j)
            &#123;
                <span class="hljs-type">int</span> cnt = <span class="hljs-number">2</span>;
                <span class="hljs-comment">// 坑： 这里计算需要用long避免乘法时候的溢出</span>
                <span class="hljs-type">long</span> x1 = points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>];
                <span class="hljs-type">long</span> y1 = points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>];
                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j + <span class="hljs-number">1</span>; k &lt; n; ++k)
                &#123;
                    <span class="hljs-type">long</span> x2 = points[i][<span class="hljs-number">0</span>] - points[k][<span class="hljs-number">0</span>];
                    <span class="hljs-type">long</span> y2 = points[i][<span class="hljs-number">1</span>] - points[k][<span class="hljs-number">1</span>];  
                    <span class="hljs-keyword">if</span> (x1*y2 == x2*y1)
                    &#123;
                        ++cnt;
                    &#125;
                &#125;
                <span class="hljs-keyword">if</span> (cnt &gt; maxCnt)
                &#123;
                    maxCnt = cnt;
                    res[<span class="hljs-number">0</span>] = i;
                    res[<span class="hljs-number">1</span>] = j;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-15-珠玑妙算">面试题 16.15. 珠玑妙算</h2>
<p>珠玑妙算游戏（the game of master mind）的玩法如下。</p>
<p>计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。</p>
<p>给定一种颜色组合 <code>solution</code>和一个猜测 <code>guess</code>，编写一个方法，返回猜中和伪猜中的次数 <code>answer</code>，其中 <code>answer[0]</code>为猜中的次数，<code>answer[1]</code>为伪猜中的次数。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">masterMind</span><span class="hljs-params">(string solution, string guess)</span> </span>&#123;
        <span class="hljs-type">int</span> first = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> second = <span class="hljs-number">0</span>;
        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;
            <span class="hljs-keyword">if</span>(solution[i] == guess[i])&#123;
                first += <span class="hljs-number">1</span>;
            &#125;
            mp[solution[i]] += <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;
            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(guess[i]) != mp.<span class="hljs-built_in">end</span>() &amp;&amp; mp[guess[i]] &gt; <span class="hljs-number">0</span>)&#123;
                mp[guess[i]] -= <span class="hljs-number">1</span>;
                second += <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt; &#123;first, second-first&#125;;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-16-部分排序">面试题 16.16. 部分排序</h2>
<p>给定一个整数数组，编写一个函数，找出索引 <code>m</code>和 <code>n</code>，只要将索引区间 <code>[m,n]</code>的元素排好序，整个数组就是有序的。注意：<code>n-m</code>尽量最小，也就是说，找出符合条件的最短序列。函数返回值为 <code>[m,n]</code>，若不存在这样的 <code>m</code>和 <code>n</code>（例如整个数组是有序的），请返回 <code>[-1,-1]</code>。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">subSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; res &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;
        <span class="hljs-type">int</span> n = array.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> res;
        &#125;
        <span class="hljs-type">int</span> currMin = INT_MAX;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; --i)&#123;
            <span class="hljs-keyword">if</span> (array[i] &gt; currMin)&#123;
                res[<span class="hljs-number">0</span>] = i;
            &#125;
            <span class="hljs-keyword">else</span>&#123;
                currMin = <span class="hljs-built_in">min</span>(currMin, array[i]);
            &#125;
        &#125;

        <span class="hljs-type">int</span> currMax = INT_MIN;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;
            <span class="hljs-keyword">if</span> (array[i] &lt; currMax)&#123;
                res[<span class="hljs-number">1</span>] = i;
            &#125;
            <span class="hljs-keyword">else</span>&#123;
                currMax = <span class="hljs-built_in">max</span>(currMax, array[i]);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-17-连续数列">面试题 16.17. 连续数列</h2>
<p>给定一个整数数组，找出总和最大的连续数列，并返回总和。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
        <span class="hljs-type">int</span> result = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>] + nums[i], nums[i]);
            result = <span class="hljs-built_in">max</span>(result, dp[i]);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-18-模式匹配">面试题 16.18. 模式匹配</h2>
<p>你有两个字符串，即 <code>pattern</code>和 <code>value</code>。 <code>pattern</code>字符串由字母 <code>&quot;a&quot;</code>和 <code>&quot;b&quot;</code>组成，用于描述字符串中的模式。例如，字符串 <code>&quot;catcatgocatgo&quot;</code>匹配模式 <code>&quot;aabab&quot;</code>（其中 <code>&quot;cat&quot;</code>是 <code>&quot;a&quot;</code>，<code>&quot;go&quot;</code>是 <code>&quot;b&quot;</code>），该字符串也匹配像 <code>&quot;a&quot;</code>、<code>&quot;ab&quot;</code>和 <code>&quot;b&quot;</code>这样的模式。但需注意 <code>&quot;a&quot;</code>和 <code>&quot;b&quot;</code>不能同时表示相同的字符串。编写一个方法判断 <code>value</code>字符串是否匹配 <code>pattern</code>字符串。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">patternMatching</span><span class="hljs-params">(string pattern, string value)</span> </span>&#123;
        <span class="hljs-type">int</span> count_a = <span class="hljs-number">0</span>, count_b = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch: pattern) &#123;
            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;
                ++count_a;
            &#125; <span class="hljs-keyword">else</span> &#123;
                ++count_b;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (count_a &lt; count_b) &#123;
            <span class="hljs-built_in">swap</span>(count_a, count_b);
            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span>&amp; ch: pattern) &#123;
                ch = (ch == <span class="hljs-string">&#x27;a&#x27;</span> ? <span class="hljs-string">&#x27;b&#x27;</span> : <span class="hljs-string">&#x27;a&#x27;</span>);
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">empty</span>()) &#123;
            <span class="hljs-keyword">return</span> count_b == <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">if</span> (pattern.<span class="hljs-built_in">empty</span>()) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len_a = <span class="hljs-number">0</span>; count_a * len_a &lt;= value.<span class="hljs-built_in">size</span>(); ++len_a) &#123;
            <span class="hljs-type">int</span> rest = value.<span class="hljs-built_in">size</span>() - count_a * len_a;
            <span class="hljs-keyword">if</span> ((count_b == <span class="hljs-number">0</span> &amp;&amp; rest == <span class="hljs-number">0</span>) || (count_b != <span class="hljs-number">0</span> &amp;&amp; rest % count_b == <span class="hljs-number">0</span>)) &#123;
                <span class="hljs-type">int</span> len_b = (count_b == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : rest / count_b);
                <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;
                <span class="hljs-type">bool</span> correct = <span class="hljs-literal">true</span>;
                string value_a, value_b;
                <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch: pattern) &#123;
                    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;
                        string sub = value.<span class="hljs-built_in">substr</span>(pos, len_a);
                        <span class="hljs-keyword">if</span> (!value_a.<span class="hljs-built_in">size</span>()) &#123;
                            value_a = <span class="hljs-built_in">move</span>(sub);
                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value_a != sub) &#123;
                            correct = <span class="hljs-literal">false</span>;
                            <span class="hljs-keyword">break</span>;
                        &#125;
                        pos += len_a;
                    &#125; <span class="hljs-keyword">else</span> &#123;
                        string sub = value.<span class="hljs-built_in">substr</span>(pos, len_b);
                        <span class="hljs-keyword">if</span> (!value_b.<span class="hljs-built_in">size</span>()) &#123;
                            value_b = <span class="hljs-built_in">move</span>(sub);
                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value_b != sub) &#123;
                            correct = <span class="hljs-literal">false</span>;
                            <span class="hljs-keyword">break</span>;
                        &#125;
                        pos += len_b;
                    &#125;
                &#125;
                <span class="hljs-keyword">if</span> (correct &amp;&amp; value_a != value_b) &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-19-水域大小">面试题 16.19. 水域大小</h2>
<p>你有一个用于表示一片土地的整数矩阵 <code>land</code>，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;<span class="hljs-type">int</span>&gt; result;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; land, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt;&amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>&#123;
        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q;
        q.<span class="hljs-built_in">push</span>(&#123;i,j&#125;);
        visited[i][j] = <span class="hljs-literal">true</span>;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; directions = &#123;
            &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;
        &#125;;
        <span class="hljs-type">int</span> tempsum = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
            pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p = q.<span class="hljs-built_in">front</span>();
            q.<span class="hljs-built_in">pop</span>();
            <span class="hljs-type">int</span> x = p.first;
            <span class="hljs-type">int</span> y = p.second;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;directions.<span class="hljs-built_in">size</span>();i++)&#123;
                <span class="hljs-type">int</span> newx = x + directions[i][<span class="hljs-number">0</span>];
                <span class="hljs-type">int</span> newy = y + directions[i][<span class="hljs-number">1</span>];
                <span class="hljs-keyword">if</span>(newx &gt;= <span class="hljs-number">0</span> &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= <span class="hljs-number">0</span> &amp;&amp; newy &lt; n &amp;&amp; visited[newx][newy] == <span class="hljs-literal">false</span> &amp;&amp; land[newx][newy] == <span class="hljs-number">0</span>)&#123;
                    visited[newx][newy] = <span class="hljs-literal">true</span>;
                    q.<span class="hljs-built_in">push</span>(&#123;newx,newy&#125;);
                    tempsum += <span class="hljs-number">1</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> tempsum;
    &#125;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pondSizes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; land)</span> </span>&#123;
        <span class="hljs-type">int</span> m = land.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = land[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt;<span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(visited[i][j] == <span class="hljs-literal">false</span> &amp;&amp; land[i][j] == <span class="hljs-number">0</span>)&#123;
                    result.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">BFS</span>(land, visited, i, j, m, n));
                &#125;
            &#125;
        &#125;
        <span class="hljs-built_in">sort</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-20-T9键盘">面试题 16.20. T9键盘</h2>
<p>在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" srcset="/img/loading.gif" lazyload alt=""></p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">getValidT9Words</span><span class="hljs-params">(string num, vector&lt;string&gt;&amp; words)</span> </span>&#123;
        vector&lt;string&gt; result;
        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; mp;
        mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;
        mp[<span class="hljs-string">&#x27;b&#x27;</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;
        mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;
        mp[<span class="hljs-string">&#x27;d&#x27;</span>] = <span class="hljs-string">&#x27;3&#x27;</span>;
        mp[<span class="hljs-string">&#x27;e&#x27;</span>] = <span class="hljs-string">&#x27;3&#x27;</span>;
        mp[<span class="hljs-string">&#x27;f&#x27;</span>] = <span class="hljs-string">&#x27;3&#x27;</span>;
        mp[<span class="hljs-string">&#x27;g&#x27;</span>] = <span class="hljs-string">&#x27;4&#x27;</span>;
        mp[<span class="hljs-string">&#x27;h&#x27;</span>] = <span class="hljs-string">&#x27;4&#x27;</span>;
        mp[<span class="hljs-string">&#x27;i&#x27;</span>] = <span class="hljs-string">&#x27;4&#x27;</span>;
        mp[<span class="hljs-string">&#x27;j&#x27;</span>] = <span class="hljs-string">&#x27;5&#x27;</span>;
        mp[<span class="hljs-string">&#x27;k&#x27;</span>] = <span class="hljs-string">&#x27;5&#x27;</span>;
        mp[<span class="hljs-string">&#x27;l&#x27;</span>] = <span class="hljs-string">&#x27;5&#x27;</span>;
        mp[<span class="hljs-string">&#x27;m&#x27;</span>] = <span class="hljs-string">&#x27;6&#x27;</span>;
        mp[<span class="hljs-string">&#x27;n&#x27;</span>] = <span class="hljs-string">&#x27;6&#x27;</span>;
        mp[<span class="hljs-string">&#x27;o&#x27;</span>] = <span class="hljs-string">&#x27;6&#x27;</span>;
        mp[<span class="hljs-string">&#x27;p&#x27;</span>] = <span class="hljs-string">&#x27;7&#x27;</span>;
        mp[<span class="hljs-string">&#x27;q&#x27;</span>] = <span class="hljs-string">&#x27;7&#x27;</span>;
        mp[<span class="hljs-string">&#x27;r&#x27;</span>] = <span class="hljs-string">&#x27;7&#x27;</span>;
        mp[<span class="hljs-string">&#x27;s&#x27;</span>] = <span class="hljs-string">&#x27;7&#x27;</span>;
        mp[<span class="hljs-string">&#x27;t&#x27;</span>] = <span class="hljs-string">&#x27;8&#x27;</span>;
        mp[<span class="hljs-string">&#x27;u&#x27;</span>] = <span class="hljs-string">&#x27;8&#x27;</span>;
        mp[<span class="hljs-string">&#x27;v&#x27;</span>] = <span class="hljs-string">&#x27;8&#x27;</span>;
        mp[<span class="hljs-string">&#x27;w&#x27;</span>] = <span class="hljs-string">&#x27;9&#x27;</span>;
        mp[<span class="hljs-string">&#x27;x&#x27;</span>] = <span class="hljs-string">&#x27;9&#x27;</span>;
        mp[<span class="hljs-string">&#x27;y&#x27;</span>] = <span class="hljs-string">&#x27;9&#x27;</span>;
        mp[<span class="hljs-string">&#x27;z&#x27;</span>] = <span class="hljs-string">&#x27;9&#x27;</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;words.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-type">int</span> numindex = <span class="hljs-number">0</span>;
            <span class="hljs-type">bool</span> judge = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;words[i].<span class="hljs-built_in">size</span>();j++)&#123;
                <span class="hljs-keyword">if</span>(mp[words[i][j]] == num[numindex])&#123;
                    numindex += <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    judge = <span class="hljs-literal">false</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span>(judge)&#123;
                result.<span class="hljs-built_in">push_back</span>(words[i]);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-21-交换和">面试题 16.21. 交换和</h2>
<p>给定两个整数数组，请交换一对数值（每个数组中取一个数值），使得两个数组所有元素的和相等。</p>
<p>返回一个数组，第一个元素是第一个数组中要交换的元素，第二个元素是第二个数组中要交换的元素。若有多个答案，返回任意一个均可。若无满足条件的数值，返回空数组。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findSwapValues</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; array1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; array2)</span> </span>&#123;
        <span class="hljs-type">int</span> sum1 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();i++)&#123;
            sum1 += array1[i];
        &#125;
        <span class="hljs-built_in">sort</span>(array<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), array<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>());
        <span class="hljs-type">int</span> sum2 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;array<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();i++)&#123;
            sum2 += array2[i];
        &#125;
        <span class="hljs-built_in">sort</span>(array<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), array<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>());
        <span class="hljs-type">int</span> maxsum;
        <span class="hljs-type">int</span> minsum;
        vector&lt;<span class="hljs-type">int</span>&gt; maxarray;
        vector&lt;<span class="hljs-type">int</span>&gt; minarray;
        <span class="hljs-keyword">if</span>(sum1 &gt; sum2)&#123;
            maxarray = array1;
            maxsum = sum1;
            minarray = array2;
            minsum = sum2;
        &#125; <span class="hljs-keyword">else</span>&#123;
            maxarray = array2;
            maxsum = sum2;
            minarray = array1;
            minsum = sum1;
        &#125;
        <span class="hljs-type">int</span> mid = maxsum - minsum;
        cout &lt;&lt; mid &lt;&lt; endl;
        <span class="hljs-keyword">if</span>(mid % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;&#125;;
        &#125;
        mid /= <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;maxarray.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;minarray.<span class="hljs-built_in">size</span>();j++)&#123;
                <span class="hljs-keyword">if</span>(maxarray[i] - minarray[j] == mid)&#123;
                    <span class="hljs-keyword">if</span>(sum1 &gt; sum2)&#123;
                        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;maxarray[i], minarray[j]&#125;; 
                    &#125; <span class="hljs-keyword">else</span>&#123;
                        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;minarray[j], maxarray[i]&#125;; 
                    &#125;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxarray[i] - minarray[j] &lt; mid)&#123;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;&#125;;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-22-兰顿蚂蚁">面试题 16.22. 兰顿蚂蚁</h2>
<p>一只蚂蚁坐在由白色和黑色方格构成的无限网格上。开始时，网格全白，蚂蚁面向右侧。每行走一步，蚂蚁执行以下操作。</p>
<p>(1) 如果在白色方格上，则翻转方格的颜色，向右(顺时针)转 90 度，并向前移动一个单位。<br>
(2) 如果在黑色方格上，则翻转方格的颜色，向左(逆时针方向)转 90 度，并向前移动一个单位。</p>
<p>编写程序来模拟蚂蚁执行的前 K 个动作，并返回最终的网格。</p>
<p>网格由数组表示，每个元素是一个字符串，代表网格中的一行，黑色方格由 <code>'X'</code> 表示，白色方格由 <code>'_'</code> 表示，蚂蚁所在的位置由 <code>'L'</code>, <code>'U'</code>, <code>'R'</code>, <code>'D'</code> 表示，分别表示蚂蚁 左、上、右、下 的朝向。只需要返回能够包含蚂蚁走过的所有方格的最小矩形。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">int</span> dir[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;&#125;; <span class="hljs-comment">// 右 下 左 上</span>
    <span class="hljs-type">short</span> hash[<span class="hljs-number">3000</span>][<span class="hljs-number">3000</span>], p = <span class="hljs-number">0</span>; <span class="hljs-comment">//hash保存地板颜色 p为当前位置指向的方向</span>
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">printKMoves</span><span class="hljs-params">(<span class="hljs-type">int</span> K)</span> </span>&#123;
        vector&lt;string&gt; res;
        <span class="hljs-built_in">memset</span>(hash, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> hash);
        <span class="hljs-type">int</span> x = <span class="hljs-number">2000</span>, y = <span class="hljs-number">2000</span>, minx = x, maxx = x, miny = y, maxy = y;
        <span class="hljs-type">char</span> pos[<span class="hljs-number">4</span>] = &#123;<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>&#125;, board[<span class="hljs-number">2</span>] = &#123;<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;X&#x27;</span>&#125;;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;K;i++) &#123;
            <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(hash[x][y]) d = <span class="hljs-number">3</span>;
            hash[x][y] ^= <span class="hljs-number">1</span>;
            p = (p + d) % <span class="hljs-number">4</span>;
            x += dir[p][<span class="hljs-number">0</span>], y += dir[p][<span class="hljs-number">1</span>];
            minx = <span class="hljs-built_in">min</span>(minx, x), maxx = <span class="hljs-built_in">max</span>(maxx, x);
            miny = <span class="hljs-built_in">min</span>(miny, y), maxy = <span class="hljs-built_in">max</span>(maxy, y);
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=minx;i&lt;=maxx;i++)&#123;
            string temp = <span class="hljs-string">&quot;&quot;</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=miny;j&lt;=maxy;j++) &#123;
                <span class="hljs-keyword">if</span>(i == x &amp;&amp; j == y) temp += pos[p];
                <span class="hljs-keyword">else</span> temp += board[hash[i][j]];
            &#125;
            res.<span class="hljs-built_in">push_back</span>(temp);
        &#125;
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-24-数对和">面试题 16.24. 数对和</h2>
<p>设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pairSums</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;
        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(target - nums[i]) != mp.<span class="hljs-built_in">end</span>() &amp;&amp; mp[target - nums[i]] != <span class="hljs-number">0</span>)&#123;
                result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;target - nums[i], nums[i]&#125;);
                mp[target - nums[i]] -= <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                mp[nums[i]] += <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="面试题-16-25-LRU-缓存">面试题 16.25. LRU 缓存</h2>
<p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p>
<p>它应该支持以下操作： 获取数据 <code>get</code> 和 写入数据 <code>put</code> 。</p>
<p>获取数据 <code>get(key)</code> - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>
写入数据 <code>put(key, value)</code> - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<h2 id="面试题-16-26-计算器">面试题 16.26. 计算器</h2>
<p>给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。</p>
<p>表达式仅包含非负整数，<code>+</code>， <code>-</code> ，<code>*</code>，<code>/</code> 四种运算符和空格 <code> </code>。 整数除法仅保留整数部分。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; stk;
        <span class="hljs-type">char</span> preSign = <span class="hljs-string">&#x27;+&#x27;</span>;
        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[i])) &#123;
                num = num * <span class="hljs-number">10</span> + <span class="hljs-built_in">int</span>(s[i] - <span class="hljs-string">&#x27;0&#x27;</span>);
            &#125;
            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span> || i == n - <span class="hljs-number">1</span>) &#123;
                <span class="hljs-keyword">switch</span> (preSign) &#123;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:
                        stk.<span class="hljs-built_in">push_back</span>(num);
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:
                        stk.<span class="hljs-built_in">push_back</span>(-num);
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:
                        stk.<span class="hljs-built_in">back</span>() *= num;
                        <span class="hljs-keyword">break</span>;
                    <span class="hljs-keyword">default</span>:
                        stk.<span class="hljs-built_in">back</span>() /= num;
                &#125;
                preSign = s[i];
                num = <span class="hljs-number">0</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">accumulate</span>(stk.<span class="hljs-built_in">begin</span>(), stk.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);
    &#125;
&#125;;</code></pre></div>
<h1>面试题 17</h1>
<h2 id="面试题-17-01-不用加号的加法">面试题 17.01. 不用加号的加法</h2>
<p>设计一个函数把两个数字相加。不得使用 + 或者其他算术运算符。</p>
<h2 id="面试题-17-04-消失的数字">面试题 17.04. 消失的数字</h2>
<p>数组 <code>nums</code>包含从 <code>0</code>到 <code>n</code>的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？</p>
<h2 id="面试题-17-05-字母与数字">面试题 17.05. 字母与数字</h2>
<p>给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。</p>
<p>返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。</p>
<h2 id="面试题-17-06-2出现的次数">面试题 17.06. 2出现的次数</h2>
<p>编写一个方法，计算从 0 到 n (含 n) 中数字 2 出现的次数。</p>
<h2 id="面试题-17-07-婴儿名字">面试题 17.07. 婴儿名字</h2>
<p>每年，政府都会公布一万个最常见的婴儿名字和它们出现的频率，也就是同名婴儿的数量。有些名字有多种拼法，例如，John 和 Jon 本质上是相同的名字，但被当成了两个名字公布出来。给定两个列表，一个是名字及对应的频率，另一个是本质相同的名字对。设计一个算法打印出每个真实名字的实际频率。注意，如果 John 和 Jon 是相同的，并且 Jon 和 Johnny 相同，则 John 与 Johnny 也相同，即它们有传递和对称性。</p>
<p>在结果列表中，选择** 字典序最小 **的名字作为真实名字。</p>
<h2 id="面试题-17-08-马戏团人塔">面试题 17.08. 马戏团人塔</h2>
<p>有个马戏团正在设计叠罗汉的表演节目，一个人要站在另一人的肩膀上。出于实际和美观的考虑，在上面的人要比下面的人矮一点且轻一点。已知马戏团每个人的身高和体重，请编写代码计算叠罗汉最多能叠几个人。</p>
<h2 id="面试题-17-09-第-k-个数">面试题 17.09. 第 k 个数</h2>
<p>有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。</p>
<h2 id="面试题-17-10-主要元素">面试题 17.10. 主要元素</h2>
<p>数组中占比超过一半的元素称之为主要元素。给你一个** 整数 **数组，找出其中的主要元素。若没有，返回 <code>-1</code> 。请设计时间复杂度为 <code>O(N)</code> 、空间复杂度为 <code>O(1)</code> 的解决方案。</p>
<h2 id="面试题-17-11-单词距离">面试题 17.11. 单词距离</h2>
<p>有个内含单词的超大文本文件，给定任意两个 <code>不同的</code>单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?</p>
<h2 id="面试题-17-12-BiNode">面试题 17.12. BiNode</h2>
<p>二叉树数据结构 <code>TreeNode</code>可用来表示单向链表（其中 <code>left</code>置空，<code>right</code>为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
<h2 id="面试题-17-13-恢复空格">面试题 17.13. 恢复空格</h2>
<p>哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子 <code>&quot;I reset the computer. It still didn’t boot!&quot;</code>已经变成了 <code>&quot;iresetthecomputeritstilldidntboot&quot;</code>。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典 <code>dictionary</code>，不过，有些词没在词典里。假设文章用 <code>sentence</code>表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。</p>
<h2 id="面试题-17-14-最小K个数">面试题 17.14. 最小K个数</h2>
<p>设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。</p>
<h2 id="面试题-17-15-最长单词">面试题 17.15. 最长单词</h2>
<p>给定一组单词 <code>words</code>，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。</p>
<h2 id="面试题-17-16-按摩师">面试题 17.16. 按摩师</h2>
<p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p>
<h2 id="面试题-17-17-多次搜索">面试题 17.17. 多次搜索</h2>
<p>给定一个较长字符串 <code>big</code>和一个包含较短字符串的数组 <code>smalls</code>，设计一个方法，根据 <code>smalls</code>中的每一个较短字符串，对 <code>big</code>进行搜索。输出 <code>smalls</code>中的字符串在 <code>big</code>里出现的所有位置 <code>positions</code>，其中 <code>positions[i]</code>为 <code>smalls[i]</code>出现的所有位置。</p>
<h2 id="面试题-17-18-最短超串">面试题 17.18. 最短超串</h2>
<p>假设你有两个数组，一个长一个短，短的元素均不相同。找到长数组中包含短数组所有的元素的最短子数组，其出现顺序无关紧要。</p>
<p>返回最短子数组的左端点和右端点，如有多个满足条件的子数组，返回左端点最小的一个。若不存在，返回空数组。</p>
<h2 id="面试题-17-19-消失的两个数字">面试题 17.19. 消失的两个数字</h2>
<p>给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？</p>
<p>以任意顺序返回这两个数字均可。</p>
<h2 id="面试题-17-20-连续中值">面试题 17.20. 连续中值</h2>
<p>随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。</p>
<p>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<ul>
<li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li>
<li>double findMedian() - 返回目前所有元素的中位数。</li>
</ul>
<h2 id="面试题-17-21-直方图的水量">面试题 17.21. 直方图的水量</h2>
<p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" srcset="/img/loading.gif" lazyload alt=""></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。</p>
<h2 id="面试题-17-22-单词转换">面试题 17.22. 单词转换</h2>
<p>给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。</p>
<p>编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。</p>
<h2 id="面试题-17-23-最大黑方阵">面试题 17.23. 最大黑方阵</h2>
<p>给定一个方阵，其中每个单元(像素)非黑即白。设计一个算法，找出 4 条边皆为黑色像素的最大子方阵。</p>
<p>返回一个数组 <code>[r, c, size]</code> ，其中 <code>r</code>, <code>c</code> 分别代表子方阵左上角的行号和列号，<code>size</code> 是子方阵的边长。若有多个满足条件的子方阵，返回 <code>r</code> 最小的，若 <code>r</code> 相同，返回 <code>c</code> 最小的子方阵。若无满足条件的子方阵，返回空数组。</p>
<h2 id="面试题-17-24-最大子矩阵">面试题 17.24. 最大子矩阵</h2>
<p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p>
<p>返回一个数组 <code>[r1, c1, r2, c2]</code>，其中 <code>r1</code>, <code>c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2</code>, <code>c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p>
<h2 id="面试题-17-25-单词矩阵">面试题 17.25. 单词矩阵</h2>
<p>给定一份单词的清单，设计一个算法，创建由字母组成的面积最大的矩形，其中每一行组成一个单词(自左向右)，每一列也组成一个单词(自上而下)。不要求这些单词在清单里连续出现，但要求所有行等长，所有列等高。</p>
<p>如果有多个面积最大的矩形，输出任意一个均可。一个单词可以重复使用。</p>
<h2 id="面试题-17-26-稀疏相似度">面试题 17.26. 稀疏相似度</h2>
<p>两个(具有不同单词的)文档的交集(intersection)中元素的个数除以并集(union)中元素的个数，就是这两个文档的相似度。例如，{1, 5, 3} 和 {1, 7, 2, 3} 的相似度是 0.4，其中，交集的元素有 2 个，并集的元素有 5 个。给定一系列的长篇文档，每个文档元素各不相同，并与一个 ID 相关联。它们的相似度非常“稀疏”，也就是说任选 2 个文档，相似度都很接近 0。请设计一个算法返回每对文档的 ID 及其相似度。只需输出相似度大于 0 的组合。请忽略空文档。为简单起见，可以假定每个文档由一个含有不同整数的数组表示。</p>
<p>输入为一个二维数组 <code>docs</code>，<code>docs[i]</code> 表示 id 为 <code>i</code> 的文档。返回一个数组，其中每个元素是一个字符串，代表每对相似度大于 0 的文档，其格式为 <code>&#123;id1&#125;,&#123;id2&#125;: &#123;similarity&#125;</code>，其中 <code>id1</code> 为两个文档中较小的 id，<code>similarity</code> 为相似度，精确到小数点后 4 位。以任意顺序返回数组均可。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Study/" class="category-chain-item">Study</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Algorithm/" class="print-no-link">#Algorithm</a>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/Leetcode/" class="print-no-link">#Leetcode</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Leetcode-Interview</div>
      <div>https://zhangzhao219.github.io/2024/07/12/Leetcode/Leetcode-interview/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zhang Zhao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月12日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"zhangzhao219/zhangzhao219.github.io","repo-id":"R_kgDOHmJY6g","category":"Announcements","category-id":"DIC_kwDOHmJY6s4CSBmw","theme-light":"light","theme-dark":"dark","mapping":"url","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
