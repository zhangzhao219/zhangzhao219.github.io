

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="https://s1.ax1x.com/2022/07/03/j83xmQ.png">
  <link rel="icon" href="https://s1.ax1x.com/2022/07/03/j83xmQ.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zhang Zhao">
  <meta name="keywords" content="">
  
    <meta name="description" content="Leetcode-Hot 100">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode-Hot 100">
<meta property="og:url" content="https://zhangzhao219.github.io/2024/06/01/Leetcode/Leetcode-hot100/index.html">
<meta property="og:site_name" content="Zostanzo&#39;s Blog">
<meta property="og:description" content="Leetcode-Hot 100">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-06-01T17:01:25.000Z">
<meta property="article:modified_time" content="2026-02-19T03:55:54.195Z">
<meta property="article:author" content="Zhang Zhao">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Leetcode-Hot 100 - Zostanzo&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhangzhao219.github.io","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"NeXpkMMRYHdOZW6AImFcr7NU-gzGzoHsz","app_key":"87RqX31mqiCFg6DWMRIA7K6O","server_url":"https://nexpkmmr.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Zostanzo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Leetcode-Hot 100</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-01 17:01" pubdate>
          2024年6月1日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          157 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Leetcode-Hot 100</h1>
            
            
              <div class="markdown-body">
                
                <p>Leetcode-Hot 100</p>
<span id="more"></span>
<h1>哈希</h1>
<h2 id="1-两数之和">1. 两数之和</h2>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 **和为目标值 **<em><code>target</code></em>  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;
        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(target - nums[i]) != mp.<span class="hljs-built_in">end</span>())&#123;
                result[<span class="hljs-number">0</span>] = mp[target - nums[i]];
                result[<span class="hljs-number">1</span>] = i;
                <span class="hljs-keyword">break</span>;
            &#125;
            mp[nums[i]] = i;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="49-字母异位词分组">49. 字母异位词分组</h2>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;
        vector&lt;vector&lt;string&gt; &gt; result;
        unordered_map&lt;string, vector&lt;string&gt; &gt; mp;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strs.<span class="hljs-built_in">size</span>();i++)&#123;
            string t = strs[i];
            <span class="hljs-built_in">sort</span>(t.<span class="hljs-built_in">begin</span>(),t.<span class="hljs-built_in">end</span>());
            mp[t].<span class="hljs-built_in">push_back</span>(strs[i]);
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>();it != mp.<span class="hljs-built_in">end</span>();it++)&#123;
            result.<span class="hljs-built_in">push_back</span>(it-&gt;second);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="128-最长连续序列">128. 最长连续序列</h2>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; mp;
        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            mp[nums[i]] = <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-type">int</span> maxcount = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-type">int</span> tempcount = <span class="hljs-number">0</span>;
            <span class="hljs-type">int</span> num = nums[i];
            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">find</span>(num<span class="hljs-number">-1</span>) != mp.<span class="hljs-built_in">end</span>())&#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-keyword">while</span>(mp.<span class="hljs-built_in">find</span>(num) != mp.<span class="hljs-built_in">end</span>())&#123;
                num += <span class="hljs-number">1</span>;
                tempcount += <span class="hljs-number">1</span>;
            &#125;
            maxcount = <span class="hljs-built_in">max</span>(maxcount, tempcount);
        &#125;
        <span class="hljs-keyword">return</span> maxcount;
    &#125;
&#125;;</code></pre></div>
<h1>双指针</h1>
<h2 id="283-移动零">283. 移动零</h2>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right=<span class="hljs-number">0</span>; right &lt; nums.<span class="hljs-built_in">size</span>(); right++)&#123;
            <span class="hljs-keyword">if</span>(nums[right] != <span class="hljs-number">0</span>)&#123;
                nums[left] = nums[right];
                left += <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">while</span>(left &lt; nums.<span class="hljs-built_in">size</span>())&#123;
            nums[left] = <span class="hljs-number">0</span>;
            left += <span class="hljs-number">1</span>;
        &#125;
    &#125;
&#125;;</code></pre></div>
<h2 id="11-盛最多水的容器">11. 盛最多水的容器</h2>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong> 你不能倾斜容器。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;
        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> right = height.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span>(left &lt; right)&#123;
            result = <span class="hljs-built_in">max</span>(result, (right - left) * <span class="hljs-built_in">min</span>(height[left], height[right]));
            cout &lt;&lt; left &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; right &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;
            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;
                left += <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                right -= <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="15-三数之和">15. 三数之和</h2>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong> 答案中不可以包含重复的三元组。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;
        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;start += <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">if</span>(start &gt; <span class="hljs-number">0</span> &amp;&amp; nums[start] == nums[start - <span class="hljs-number">1</span>])&#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-type">int</span> left = start + <span class="hljs-number">1</span>;
            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span>(left &lt; right)&#123;
                <span class="hljs-type">int</span> res = nums[start] + nums[left] + nums[right];
                <span class="hljs-keyword">if</span>(res == <span class="hljs-number">0</span>)&#123;
                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt; &#123;nums[start], nums[left], nums[right]&#125;);
                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right<span class="hljs-number">-1</span>])&#123;
                        right -= <span class="hljs-number">1</span>;
                    &#125;
                    <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])&#123;
                        left += <span class="hljs-number">1</span>;
                    &#125;
                    left += <span class="hljs-number">1</span>;
                    right -= <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>)&#123;
                    left += <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    right -= <span class="hljs-number">1</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="42-接雨水">42. 接雨水</h2>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;
        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> leftMax = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> rightMax = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> right = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(left &lt; right)&#123;
            leftMax = <span class="hljs-built_in">max</span>(leftMax, height[left]);
            rightMax = <span class="hljs-built_in">max</span>(rightMax, height[right]);
            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;
                result += leftMax - height[left];
                left += <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                result += rightMax - height[right];
                right -= <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h1>滑动窗口</h1>
<h2 id="3-无重复字符的最长子串">3. 无重复字符的最长子串</h2>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;
        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;
        unordered_set&lt;<span class="hljs-type">char</span>&gt; st;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;left &lt; n;left++)&#123;
            <span class="hljs-keyword">while</span>(right &lt; n &amp;&amp; !st.<span class="hljs-built_in">count</span>(s[right]))&#123;
                st.<span class="hljs-built_in">insert</span>(s[right]);
                right++;
            &#125;
            result = <span class="hljs-built_in">max</span>(result, right - left);
            st.<span class="hljs-built_in">erase</span>(s[left]);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="438-找到字符串中所有字母异位词">438. 找到字符串中所有字母异位词</h2>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 **异位词 **的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>**异位词 **指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">schar</span><span class="hljs-params">(<span class="hljs-number">26</span>, <span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p.<span class="hljs-built_in">size</span>();i++)&#123;
            schar[p[i]-<span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;
        &#125;
        vector&lt;<span class="hljs-type">int</span>&gt; result;
        <span class="hljs-keyword">if</span>(p.<span class="hljs-built_in">size</span>() &gt; s.<span class="hljs-built_in">size</span>())&#123;
            <span class="hljs-keyword">return</span> result;
        &#125;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;right &lt; s.<span class="hljs-built_in">size</span>();right++)&#123;
            schar[s[right]-<span class="hljs-string">&#x27;a&#x27;</span>] -= <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span> (right &lt; p.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>)&#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)&#123;
                <span class="hljs-keyword">if</span>(schar[i] != <span class="hljs-number">0</span>)&#123;
                    flag = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;
                result.<span class="hljs-built_in">push_back</span>(left);
            &#125;
            schar[s[left]-<span class="hljs-string">&#x27;a&#x27;</span>] += <span class="hljs-number">1</span>;
            left += <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h1>子串</h1>
<h2 id="560-和为-K-的子数组">560. 和为 K 的子数组</h2>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回  该数组中和为 <code>k</code> 的子数组的个数。</p>
<p>子数组是数组中元素的连续非空序列。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
            pre[i] = nums[i<span class="hljs-number">-1</span>] + pre[i<span class="hljs-number">-1</span>];
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)&#123;
            cout &lt;&lt; pre[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
        &#125;
        cout &lt;&lt; endl;
        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;
        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; i++)&#123;
            <span class="hljs-keyword">if</span> (cnt.<span class="hljs-built_in">contains</span>(pre[i] - k))&#123;
                result += cnt[pre[i] - k];
            &#125;
            cnt[pre[i]] += <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="239-滑动窗口最大值">239. 滑动窗口最大值</h2>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回  *滑动窗口中的最大值 * 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;
        deque&lt;<span class="hljs-type">int</span>&gt; st;
        vector&lt;<span class="hljs-type">int</span>&gt; result;
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
            <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">front</span>() &lt;= i-k)&#123;
                st.<span class="hljs-built_in">pop_front</span>();
            &#125;
            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[st.<span class="hljs-built_in">back</span>()] &lt; nums[i])&#123;
                st.<span class="hljs-built_in">pop_back</span>();
            &#125;
            st.<span class="hljs-built_in">push_back</span>(i);
            <span class="hljs-keyword">if</span>(i &gt;= k<span class="hljs-number">-1</span>)&#123;
                result.<span class="hljs-built_in">push_back</span>(nums[st.<span class="hljs-built_in">front</span>()]);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="76-最小覆盖子串">76. 最小覆盖子串</h2>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li>
<li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; map_window, map_base;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : map_base) &#123; <span class="hljs-comment">// 遍历字符串t的哈希表！！不要遍历错了！！</span>
            <span class="hljs-comment">// 只要出现窗口内的某字符数量&lt;字符串t的同一字符数量，则说明“窗口字符串”未覆盖“字符串t”</span>
            <span class="hljs-keyword">if</span> (map_window[it.first] &lt; it.second) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;
        <span class="hljs-comment">// 初始化固定“字符串t”的字符频率哈希表</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : t) &#123;
            map_base[c]++;
        &#125;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> current_min_length = INT_MAX; <span class="hljs-comment">// 因为后续下相当于取min，所以这里取MAX</span>
        <span class="hljs-type">int</span> res_start_index = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>; right &lt; s.<span class="hljs-built_in">size</span>(); right++) &#123;
            map_window[s[right]]++; <span class="hljs-comment">// 更新“当前窗口字符串”的哈希表（right右移，添加字符）</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">check</span>()) &#123; <span class="hljs-comment">// 如果覆盖</span>
                <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">1</span> &lt; current_min_length) &#123; <span class="hljs-comment">// 窗口大小 &lt; 当前覆盖子串最小长度</span>
                    current_min_length = right - left + <span class="hljs-number">1</span>; <span class="hljs-comment">// 更新当前覆盖子串的最小长度</span>
                    res_start_index = left; <span class="hljs-comment">// 记录该覆盖子串的起始索引。最后直接通过起始索引+最小长度来求结果，避免这里重复的拷贝复制</span>
                &#125;
                map_window[s[left]]--; <span class="hljs-comment">// 更新“当前窗口字符串”的哈希表（left右移，删除字符）</span>
                left++;
            &#125;
        &#125;
        <span class="hljs-comment">// 别漏了无结果的情况，返回空串</span>
        <span class="hljs-keyword">return</span> res_start_index == <span class="hljs-number">-1</span> ? <span class="hljs-string">&quot;&quot;</span> : s.<span class="hljs-built_in">substr</span>(res_start_index, current_min_length);
    &#125;
&#125;;</code></pre></div>
<h1>普通数组</h1>
<h2 id="53-最大子数组和">53. 最大子数组和</h2>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>**子数组 **是数组中的一个连续部分。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> result = nums[<span class="hljs-number">0</span>];
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;
            dp[i] = <span class="hljs-built_in">max</span>(nums[i], nums[i] + dp[i<span class="hljs-number">-1</span>]);
            result = <span class="hljs-built_in">max</span>(result, dp[i]);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="56-合并区间">56. 合并区间</h2>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [start&lt;sub&gt;i&lt;/sub&gt;, end&lt;sub&gt;i&lt;/sub&gt;]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, vector&lt;<span class="hljs-type">int</span>&gt; &amp;b)</span></span>&#123;
        <span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])&#123;
            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];
        &#125;
        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];
    &#125;
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;
        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);
        <span class="hljs-type">bool</span> now = <span class="hljs-literal">false</span>;
        <span class="hljs-type">int</span> start = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];
        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;intervals.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &gt; end)&#123;
                result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;start, end&#125;);
                start = intervals[i][<span class="hljs-number">0</span>];
                end = intervals[i][<span class="hljs-number">1</span>];
            &#125; <span class="hljs-keyword">else</span>&#123;
                start = <span class="hljs-built_in">min</span>(start, intervals[i][<span class="hljs-number">0</span>]);
                end = <span class="hljs-built_in">max</span>(end, intervals[i][<span class="hljs-number">1</span>]);
            &#125;
        &#125;
        result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;start, end&#125;);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="189-轮转数组">189. 轮转数组</h2>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp; nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;
        <span class="hljs-keyword">while</span>(start &lt; end)&#123;
            <span class="hljs-type">int</span> temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start += <span class="hljs-number">1</span>;
            end -= <span class="hljs-number">1</span>;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;
        k = k % nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-built_in">reverse</span>(nums,<span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);
        <span class="hljs-built_in">reverse</span>(nums,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>);
        <span class="hljs-built_in">reverse</span>(nums,k,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);
    &#125;
&#125;;</code></pre></div>
<h2 id="238-除自身以外数组的乘积">238. 除自身以外数组的乘积</h2>
<p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在  <strong>32 位</strong> 整数范围内。</p>
<p>请  <strong>不要使用除法，</strong> 且在 <code>O(&lt;em&gt;n&lt;/em&gt;)</code> 时间复杂度内完成此题。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(nums.size()<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">back</span><span class="hljs-params">(nums.size()<span class="hljs-number">+1</span>,<span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            pre[i<span class="hljs-number">+1</span>] = nums[i] * pre[i];
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=nums.<span class="hljs-built_in">size</span>();i&gt;<span class="hljs-number">0</span>;i--)&#123;
            back[i<span class="hljs-number">-1</span>] = nums[i<span class="hljs-number">-1</span>] * back[i];
        &#125;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>;i++)&#123;
            cout &lt;&lt; pre[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; back[i] &lt;&lt; endl;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            result[i] = pre[i] * back[i<span class="hljs-number">+1</span>];
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="41-缺失的第一个正数">41. 缺失的第一个正数</h2>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
            <span class="hljs-keyword">if</span>(nums[i] &lt;= <span class="hljs-number">0</span>)&#123;
                nums[i] = n + <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
            <span class="hljs-type">int</span> num = <span class="hljs-built_in">abs</span>(nums[i]);
            <span class="hljs-keyword">if</span>(num &lt;= n)&#123;
                nums[num<span class="hljs-number">-1</span>] = -<span class="hljs-built_in">abs</span>(nums[num<span class="hljs-number">-1</span>]);
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
            <span class="hljs-keyword">if</span>(nums[i] &gt; <span class="hljs-number">0</span>)&#123;
                <span class="hljs-keyword">return</span> i<span class="hljs-number">+1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> n<span class="hljs-number">+1</span>;
    &#125;
&#125;;</code></pre></div>
<h1>矩阵</h1>
<h2 id="73-矩阵置零">73. 矩阵置零</h2>
<p>给定一个 <code>&lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt;</code> 的矩阵，如果一个元素为0 ，则将其所在行和列的所有元素都设为0 。请使用 <a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a> 算法</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;
        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-type">bool</span> firstrow = <span class="hljs-literal">false</span>;
        <span class="hljs-type">bool</span> firstcol = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)&#123;
                firstcol = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;
                firstrow = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>)&#123;
                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;
                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> || matrix[<span class="hljs-number">0</span>][j] == <span class="hljs-number">0</span>)&#123;
                    matrix[i][j] = <span class="hljs-number">0</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(firstcol == <span class="hljs-literal">true</span>)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(firstrow == <span class="hljs-literal">true</span>)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;
            &#125;
        &#125;
    &#125;
&#125;;</code></pre></div>
<h2 id="54-螺旋矩阵">54. 螺旋矩阵</h2>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; result;
        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">visit</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; directions&#123;
            &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;
        &#125;;
        <span class="hljs-type">int</span> xIndex = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> yIndex = <span class="hljs-number">0</span>;
        result.<span class="hljs-built_in">push_back</span>(matrix[xIndex][yIndex]);
        visit[xIndex][yIndex] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">while</span>(result.<span class="hljs-built_in">size</span>() != m*n)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;directions.<span class="hljs-built_in">size</span>();i++)&#123;
                <span class="hljs-keyword">while</span>(xIndex + directions[i][<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; xIndex + directions[i][<span class="hljs-number">0</span>] &lt; m &amp;&amp; yIndex + directions[i][<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; yIndex + directions[i][<span class="hljs-number">1</span>] &lt; n &amp;&amp; visit[xIndex + directions[i][<span class="hljs-number">0</span>]][yIndex + directions[i][<span class="hljs-number">1</span>]] == <span class="hljs-literal">false</span>)&#123;
                    xIndex = xIndex + directions[i][<span class="hljs-number">0</span>];
                    yIndex = yIndex + directions[i][<span class="hljs-number">1</span>];
                    result.<span class="hljs-built_in">push_back</span>(matrix[xIndex][yIndex]);
                    visit[xIndex][yIndex] = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="48-旋转图像">48. 旋转图像</h2>
<p>给定一个  *n * × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要 **使用另一个矩阵来旋转图像。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;
        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(n<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span>;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n/<span class="hljs-number">2</span>;j++)&#123;
                <span class="hljs-type">int</span> temp = matrix[n-j<span class="hljs-number">-1</span>][i];
                matrix[n-j<span class="hljs-number">-1</span>][i] = matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>];
                matrix[n-i<span class="hljs-number">-1</span>][n-j<span class="hljs-number">-1</span>] = matrix[j][n-i<span class="hljs-number">-1</span>];
                matrix[j][n-i<span class="hljs-number">-1</span>] = matrix[i][j];
                matrix[i][j] = temp;
            &#125;
        &#125;
    &#125;
&#125;;</code></pre></div>
<h2 id="240-搜索二维矩阵-II">240. 搜索二维矩阵 II</h2>
<p>编写一个高效的算法来搜索 <code>&lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt;</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> y = n<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span>(x &lt; m &amp;&amp; y &gt;= <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">if</span> (matrix[x][y] == target)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
            <span class="hljs-keyword">if</span>(target &lt; matrix[x][y])&#123;
                y -= <span class="hljs-number">1</span>;
            &#125;
            <span class="hljs-keyword">else</span>&#123;
                x += <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h1>链表</h1>
<h2 id="160-相交链表">160. 相交链表</h2>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;
        ListNode* p = headA;
        ListNode* q = headB;
        <span class="hljs-keyword">while</span>(p != q)&#123;
            <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;
                p = headB;
            &#125; <span class="hljs-keyword">else</span>&#123;
                p = p-&gt;next;
            &#125;
            <span class="hljs-keyword">if</span>(q == <span class="hljs-literal">NULL</span>)&#123;
                q = headA;
            &#125; <span class="hljs-keyword">else</span>&#123;
                q = q-&gt;next;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> p;
    &#125;
&#125;;</code></pre></div>
<h2 id="206-反转链表">206. 反转链表</h2>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;
        ListNode* pre = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span>)&#123;
            ListNode* q = head-&gt;next;
            head-&gt;next = pre;
            pre = head;
            head = q;
        &#125;
        <span class="hljs-keyword">return</span> pre;
    &#125;
&#125;;</code></pre></div>
<h2 id="234-回文链表">234. 回文链表</h2>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;
        ListNode* pre = <span class="hljs-literal">NULL</span>;
        ListNode* slow = head;
        ListNode* fast = head;
        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">if</span>(fast-&gt;next == <span class="hljs-literal">NULL</span>)&#123;
                fast = fast-&gt;next;
                flag = <span class="hljs-literal">true</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                fast = fast-&gt;next-&gt;next;
            &#125;
            ListNode* q = slow-&gt;next;
            slow-&gt;next = pre;
            pre = slow;
            slow = q;
            <span class="hljs-keyword">if</span>(flag)&#123;
                pre = pre-&gt;next;
            &#125;

        &#125;
        <span class="hljs-keyword">while</span>(pre != <span class="hljs-literal">NULL</span> &amp;&amp; slow != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">if</span>(pre-&gt;val != slow-&gt;val)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            pre = pre-&gt;next;
            slow = slow-&gt;next;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    &#125;
&#125;;</code></pre></div>
<h2 id="141-环形链表">141. 环形链表</h2>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 **注意：<code>pos</code> 不作为参数进行传递 ** 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        ListNode* slow = head;
        ListNode* fast = head-&gt;next;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)&#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
            <span class="hljs-keyword">if</span>(slow == fast)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125; 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="142-环形链表-II">142. 环形链表 II</h2>
<p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（ <strong>索引从 0 开始</strong> ）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。 <strong>注意：<code>pos</code> 不作为参数进行传递</strong> ，仅仅是为了标识链表的实际情况。</p>
<p>**不允许修改 **链表。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        ListNode* slow = head;
        ListNode* fast = head;
        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)&#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
            <span class="hljs-keyword">if</span>(slow == fast)&#123;
                flag = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        fast = head;
        <span class="hljs-keyword">while</span>(slow != fast)&#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        &#125;
        <span class="hljs-keyword">return</span> slow;
    &#125;
&#125;;</code></pre></div>
<h2 id="21-合并两个有序链表">21. 合并两个有序链表</h2>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;
        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
        ListNode* head = dummy;
        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">NULL</span> &amp;&amp; list2 != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">if</span>(list1-&gt;val &lt; list2-&gt;val)&#123;
                dummy-&gt;next = list1;
                list1 = list1-&gt;next;
                dummy = dummy-&gt;next;
            &#125; <span class="hljs-keyword">else</span>&#123;
                dummy-&gt;next = list2;
                list2 = list2-&gt;next;
                dummy = dummy-&gt;next;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(list1 != <span class="hljs-literal">NULL</span>)&#123;
            dummy-&gt;next = list1;
        &#125; <span class="hljs-keyword">else</span>&#123;
            dummy-&gt;next = list2;
        &#125;
        <span class="hljs-keyword">return</span> head-&gt;next;
    &#125;
&#125;;</code></pre></div>
<h2 id="2-两数相加">2. 两数相加</h2>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;
        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
        ListNode* l3 = dummy;
        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-literal">NULL</span> || l2 != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">if</span>(l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>)&#123;
                sum = l1-&gt;val + l2-&gt;val + cur;
                l1 = l1-&gt;next;
                l2 = l2-&gt;next;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l1 != <span class="hljs-literal">NULL</span>)&#123;
                sum = l1-&gt;val + cur;
                l1 = l1-&gt;next;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 != <span class="hljs-literal">NULL</span>)&#123;
                sum = l2-&gt;val + cur;
                l2 = l2-&gt;next;
            &#125;
            <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">10</span>)&#123;
                sum -= <span class="hljs-number">10</span>;
                cur = <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                cur = <span class="hljs-number">0</span>;
            &#125;
            l3-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum);
            l3 = l3-&gt;next;
        &#125;
        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">1</span>)&#123;
            l3-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);
        &#125;
        <span class="hljs-keyword">return</span> dummy-&gt;next;
    &#125;
&#125;;</code></pre></div>
<h2 id="19-删除链表的倒数第-N-个结点">19. 删除链表的倒数第 N 个结点</h2>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;
        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
        dummy-&gt;next = head;
        ListNode* pre = dummy;;
        ListNode* slow = head;
        ListNode* fast = head;
        <span class="hljs-keyword">while</span>(n--)&#123;
            fast = fast-&gt;next;
        &#125;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span>)&#123;
            pre = slow;
            slow = slow-&gt;next;
            fast = fast-&gt;next;
        &#125;
        pre-&gt;next = pre-&gt;next-&gt;next;
        <span class="hljs-keyword">return</span> dummy-&gt;next;
    &#125;
&#125;;</code></pre></div>
<h2 id="24-两两交换链表中的节点">24. 两两交换链表中的节点</h2>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;
        ListNode* pre = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span>)&#123;
            ListNode* q = head-&gt;next;
            head-&gt;next = pre;
            pre = head;
            head = q;
        &#125;
        <span class="hljs-keyword">return</span> pre;
    &#125;
    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;
        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
        ListNode* realhead = dummy;
        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span> &amp;&amp; head-&gt;next != <span class="hljs-literal">NULL</span>)&#123;
            ListNode* q = head-&gt;next-&gt;next;
            head-&gt;next-&gt;next = <span class="hljs-literal">NULL</span>;
            dummy-&gt;next = <span class="hljs-built_in">reverseList</span>(head);
            dummy = dummy-&gt;next-&gt;next;
            head = q;
        &#125;
        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">NULL</span>)&#123;
            dummy-&gt;next = head;
        &#125;
        <span class="hljs-keyword">return</span> realhead-&gt;next;
    &#125;
&#125;;</code></pre></div>
<h2 id="25-K-个一组翻转链表">25. K 个一组翻转链表</h2>
<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span></span>&#123;
        ListNode* pre = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">while</span>(head != <span class="hljs-literal">NULL</span>)&#123;
            ListNode* q = head-&gt;next;
            head-&gt;next = pre;
            pre = head;
            head = q;
        &#125;
        <span class="hljs-keyword">return</span> pre;
    &#125;
    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;
        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
        ListNode* realhead = dummy;
  
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
            <span class="hljs-type">bool</span> sign = <span class="hljs-literal">false</span>;
            ListNode* p = head;
            ListNode* pre = <span class="hljs-literal">NULL</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;
                <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span>)&#123;
                    sign = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">break</span>;
                &#125;
                pre = p;
                p = p-&gt;next;
            &#125;
            <span class="hljs-keyword">if</span>(sign)&#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            pre-&gt;next = <span class="hljs-literal">NULL</span>;
            dummy-&gt;next = <span class="hljs-built_in">reverseList</span>(head);
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;
                dummy = dummy-&gt;next;
            &#125;
            head = p;
        &#125;
        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">NULL</span>)&#123;
            dummy-&gt;next = head;
        &#125;
        <span class="hljs-keyword">return</span> realhead-&gt;next;
    &#125;
&#125;;</code></pre></div>
<h2 id="138-随机链表的复制">138. 随机链表的复制</h2>
<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的  <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin" title="https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin">深拷贝</a></strong> 。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。 **复制链表中的指针都不应指向原链表中的节点 ** 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。</li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        Node* cur = head;
        unordered_map&lt;Node*, Node*&gt; map;
        <span class="hljs-comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span>
        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span>) &#123;
            map[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);
            cur = cur-&gt;next;
        &#125;
        cur = head;
        <span class="hljs-comment">// 4. 构建新链表的 next 和 random 指向</span>
        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">NULL</span>) &#123;
            map[cur]-&gt;next = map[cur-&gt;next];
            map[cur]-&gt;random = map[cur-&gt;random];
            cur = cur-&gt;next;
        &#125;
        <span class="hljs-comment">// 5. 返回新链表的头节点</span>
        <span class="hljs-keyword">return</span> map[head];
    &#125;
&#125;;</code></pre></div>
<h2 id="148-排序链表">148. 排序链表</h2>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">mergesort</span><span class="hljs-params">(ListNode* head)</span></span>&#123;
        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> head;
        &#125;
        ListNode* slow = head;
        ListNode* fast = head-&gt;next;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>)&#123;
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        &#125;
  
        ListNode* right = <span class="hljs-built_in">mergesort</span>(slow-&gt;next);
        <span class="hljs-keyword">if</span>(slow != <span class="hljs-literal">NULL</span>)&#123;
            slow-&gt;next = <span class="hljs-literal">NULL</span>;
        &#125;
        ListNode* left = <span class="hljs-built_in">mergesort</span>(head);
        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
        ListNode* p = dummy;
        <span class="hljs-keyword">while</span>(left != <span class="hljs-literal">NULL</span> || right != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span>)&#123;
                p-&gt;next = right;
                right = right-&gt;next;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">NULL</span>)&#123;
                p-&gt;next = left;
                left = left-&gt;next;
            &#125; <span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">if</span>(left-&gt;val &lt; right-&gt;val)&#123;
                    p-&gt;next = left;
                    left = left-&gt;next;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    p-&gt;next = right;
                    right = right-&gt;next;
                &#125;
            &#125;
            p = p-&gt;next;
        &#125;
        <span class="hljs-keyword">return</span> dummy-&gt;next;
    &#125;
    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergesort</span>(head);
    &#125;
&#125;;</code></pre></div>
<h2 id="23-合并-K-个升序链表">23. 合并 K 个升序链表</h2>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;
        <span class="hljs-keyword">if</span>(start == end)&#123;
            <span class="hljs-keyword">return</span> lists[start];
        &#125;
        <span class="hljs-type">int</span> mid = (end - start) / <span class="hljs-number">2</span> + start;
        ListNode* left = <span class="hljs-built_in">merge</span>(lists, start, mid);
        ListNode* right = <span class="hljs-built_in">merge</span>(lists, mid<span class="hljs-number">+1</span>, end);
        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);
        ListNode* p = dummy;
        <span class="hljs-keyword">while</span>(left != <span class="hljs-literal">NULL</span> || right != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span>)&#123;
                dummy-&gt;next = right;
                right = right-&gt;next;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">NULL</span>)&#123;
                dummy-&gt;next = left;
                left = left-&gt;next;
            &#125; <span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">if</span>(left-&gt;val &lt; right -&gt; val)&#123;
                    dummy-&gt;next = left;
                    left = left-&gt;next;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    dummy-&gt;next = right;
                    right = right-&gt;next;
                &#125;
            &#125;
            dummy = dummy-&gt;next;
        &#125;
        <span class="hljs-keyword">return</span> p-&gt;next;
    &#125;
    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);
    &#125;
&#125;;</code></pre></div>
<h2 id="146-LRU-缓存">146. LRU 缓存</h2>
<p>请你设计并实现一个满足  <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU" title="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DLinkedNode</span> &#123;
    <span class="hljs-type">int</span> key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    <span class="hljs-built_in">DLinkedNode</span>(): <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">value</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;
    <span class="hljs-built_in">DLinkedNode</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">value</span>(_value), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;
&#125;;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;
<span class="hljs-keyword">private</span>:
    unordered_map&lt;<span class="hljs-type">int</span>, DLinkedNode*&gt; cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    <span class="hljs-type">int</span> size;
    <span class="hljs-type">int</span> capacity;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> _capacity): <span class="hljs-built_in">capacity</span>(_capacity), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">// 使用伪头部和伪尾部节点</span>
        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();
        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();
        head-&gt;next = tail;
        tail-&gt;prev = head;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span>
        DLinkedNode* node = cache[key];
        <span class="hljs-built_in">moveToHead</span>(node);
        <span class="hljs-keyword">return</span> node-&gt;value;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (!cache.<span class="hljs-built_in">count</span>(key)) &#123;
            <span class="hljs-comment">// 如果 key 不存在，创建一个新的节点</span>
            DLinkedNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>(key, value);
            <span class="hljs-comment">// 添加进哈希表</span>
            cache[key] = node;
            <span class="hljs-comment">// 添加至双向链表的头部</span>
            <span class="hljs-built_in">addToHead</span>(node);
            ++size;
            <span class="hljs-keyword">if</span> (size &gt; capacity) &#123;
                <span class="hljs-comment">// 如果超出容量，删除双向链表的尾部节点</span>
                DLinkedNode* removed = <span class="hljs-built_in">removeTail</span>();
                <span class="hljs-comment">// 删除哈希表中对应的项</span>
                cache.<span class="hljs-built_in">erase</span>(removed-&gt;key);
                <span class="hljs-comment">// 防止内存泄漏</span>
                <span class="hljs-keyword">delete</span> removed;
                --size;
            &#125;
        &#125;
        <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span>
            DLinkedNode* node = cache[key];
            node-&gt;value = value;
            <span class="hljs-built_in">moveToHead</span>(node);
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addToHead</span><span class="hljs-params">(DLinkedNode* node)</span> </span>&#123;
        node-&gt;prev = head;
        node-&gt;next = head-&gt;next;
        head-&gt;next-&gt;prev = node;
        head-&gt;next = node;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode* node)</span> </span>&#123;
        node-&gt;prev-&gt;next = node-&gt;next;
        node-&gt;next-&gt;prev = node-&gt;prev;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveToHead</span><span class="hljs-params">(DLinkedNode* node)</span> </span>&#123;
        <span class="hljs-built_in">removeNode</span>(node);
        <span class="hljs-built_in">addToHead</span>(node);
    &#125;

    <span class="hljs-function">DLinkedNode* <span class="hljs-title">removeTail</span><span class="hljs-params">()</span> </span>&#123;
        DLinkedNode* node = tail-&gt;prev;
        <span class="hljs-built_in">removeNode</span>(node);
        <span class="hljs-keyword">return</span> node;
    &#125;
&#125;;</code></pre></div>
<h1>二叉树</h1>
<h2 id="94-二叉树的中序遍历">94. 二叉树的中序遍历</h2>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp; result)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">inorder</span>(root-&gt;left, result);
        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);
        <span class="hljs-built_in">inorder</span>(root-&gt;right, result);
    &#125;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; result;
        <span class="hljs-built_in">inorder</span>(root, result);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="104-二叉树的最大深度">104. 二叉树的最大深度</h2>
<p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">int</span> max_depth = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            max_depth = <span class="hljs-built_in">max</span>(max_depth, depth);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">DFS</span>(root-&gt;left, depth<span class="hljs-number">+1</span>);
        <span class="hljs-built_in">DFS</span>(root-&gt;right, depth<span class="hljs-number">+1</span>);
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-built_in">DFS</span>(root,<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> max_depth;
    &#125;
&#125;;</code></pre></div>
<h2 id="226-翻转二叉树">226. 翻转二叉树</h2>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);
        <span class="hljs-built_in">invertTree</span>(root-&gt;left);
        <span class="hljs-built_in">invertTree</span>(root-&gt;right);
        <span class="hljs-keyword">return</span> root;
    &#125;
&#125;;</code></pre></div>
<h2 id="101-对称二叉树">101. 对称二叉树</h2>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">issame</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span>&#123;
        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(right == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125; <span class="hljs-keyword">else</span>&#123;
            <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">issame</span>(left-&gt;right, right-&gt;left) &amp;&amp; <span class="hljs-built_in">issame</span>(right-&gt;right, left-&gt;left);
    &#125;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">issame</span>(root-&gt;left, root-&gt;right);
    &#125;
&#125;;</code></pre></div>
<h2 id="543-二叉树的直径">543. 二叉树的直径</h2>
<p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>
<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>
<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">int</span> maxlength = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> nowlength)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-type">int</span> leftlength = <span class="hljs-built_in">DFS</span>(root-&gt;left, nowlength<span class="hljs-number">+1</span>);
        <span class="hljs-type">int</span> rightlength = <span class="hljs-built_in">DFS</span>(root-&gt;right, nowlength<span class="hljs-number">+1</span>);
        maxlength = <span class="hljs-built_in">max</span>(maxlength, leftlength + rightlength + <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftlength, rightlength) + <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-built_in">DFS</span>(root,<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> maxlength<span class="hljs-number">-1</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="102-二叉树的层序遍历">102. 二叉树的层序遍历</h2>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> result;
        &#125;
        queue&lt;TreeNode* &gt; q;
        q.<span class="hljs-built_in">push</span>(root);
        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-type">int</span> s = q.<span class="hljs-built_in">size</span>();
            vector&lt;<span class="hljs-type">int</span>&gt; temp;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s;i++)&#123;
                TreeNode* t = q.<span class="hljs-built_in">front</span>();
                q.<span class="hljs-built_in">pop</span>();
                temp.<span class="hljs-built_in">push_back</span>(t-&gt;val);
                <span class="hljs-keyword">if</span>(t-&gt;left != <span class="hljs-literal">NULL</span>)&#123;
                    q.<span class="hljs-built_in">push</span>(t-&gt;left);
                &#125;
                <span class="hljs-keyword">if</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)&#123;
                    q.<span class="hljs-built_in">push</span>(t-&gt;right);
                &#125;
            &#125;
            result.<span class="hljs-built_in">push_back</span>(temp);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="108-将有序数组转换为二叉搜索树">108. 将有序数组转换为二叉搜索树</h2>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> end = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;
        vector&lt;<span class="hljs-type">int</span>&gt; numsleft;
        vector&lt;<span class="hljs-type">int</span>&gt; numsright;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;end;i++)&#123;
            <span class="hljs-keyword">if</span>(i &lt; mid)&#123;
                numsleft.<span class="hljs-built_in">push_back</span>(nums[i]);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt; mid)&#123;
                numsright.<span class="hljs-built_in">push_back</span>(nums[i]);
            &#125;
        &#125;
        TreeNode* left = <span class="hljs-built_in">sortedArrayToBST</span>(numsleft);
        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);
        TreeNode* right = <span class="hljs-built_in">sortedArrayToBST</span>(numsright);
        root-&gt;left = left;
        root-&gt;right = right;
        <span class="hljs-keyword">return</span> root;
  
    &#125;
&#125;;</code></pre></div>
<h2 id="98-验证二叉搜索树">98. 验证二叉搜索树</h2>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含** 小于 **当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    vector&lt;<span class="hljs-type">int</span>&gt; result;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">inorder</span>(root-&gt;left);
        result.<span class="hljs-built_in">push_back</span>(root-&gt;val);
        <span class="hljs-built_in">inorder</span>(root-&gt;right);
    &#125;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-built_in">inorder</span>(root);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;result.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)&#123;
            <span class="hljs-keyword">if</span>(result[i] &lt; result[i<span class="hljs-number">+1</span>])&#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="230-二叉搜索树中第K小的元素">230. 二叉搜索树中第K小的元素</h2>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode* root,<span class="hljs-type">int</span> k)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">inorder</span>(root-&gt;left, k);
        num += <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(num == k)&#123;
            result = root-&gt;val;
        &#125;
        <span class="hljs-built_in">inorder</span>(root-&gt;right, k);
    &#125;
   
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;
        <span class="hljs-built_in">inorder</span>(root, k);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="199-二叉树的右视图">199. 二叉树的右视图</h2>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; result;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> result;
        &#125;
        queue&lt;TreeNode*&gt; q;
        q.<span class="hljs-built_in">push</span>(root);
        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
            <span class="hljs-type">int</span> s = q.<span class="hljs-built_in">size</span>();
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s;i++)&#123;
                TreeNode* t = q.<span class="hljs-built_in">front</span>();
                q.<span class="hljs-built_in">pop</span>();
                <span class="hljs-keyword">if</span>(t-&gt;left != <span class="hljs-literal">NULL</span>)&#123;
                    q.<span class="hljs-built_in">push</span>(t-&gt;left);
                &#125;
                <span class="hljs-keyword">if</span>(t-&gt;right != <span class="hljs-literal">NULL</span>)&#123;
                    q.<span class="hljs-built_in">push</span>(t-&gt;right);
                &#125;
                <span class="hljs-keyword">if</span>(i == s<span class="hljs-number">-1</span>)&#123;
                    result.<span class="hljs-built_in">push_back</span>(t-&gt;val);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="114-二叉树展开为链表">114. 二叉树展开为链表</h2>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" title="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-built_in">flatten</span>(root-&gt;left);
        <span class="hljs-built_in">flatten</span>(root-&gt;right);
        <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-keyword">auto</span> pre = root-&gt;left;
            <span class="hljs-keyword">while</span> (pre-&gt;right != <span class="hljs-literal">NULL</span>)&#123;
                pre = pre-&gt;right;
            &#125;
            pre-&gt;right = root-&gt;right;
            root-&gt;right = root-&gt;left;
            root-&gt;left = <span class="hljs-literal">NULL</span>;
        &#125;
        root = root-&gt;right;
        <span class="hljs-keyword">return</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="105-从前序与中序遍历序列构造二叉树">105. 从前序与中序遍历序列构造二叉树</h2>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的 <strong>先序遍历</strong> ， <code>inorder</code> 是同一棵树的 <strong>中序遍历</strong> ，请构造二叉树并返回其根节点。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        &#125;
        <span class="hljs-type">int</span> val = preorder[<span class="hljs-number">0</span>];
        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);
        <span class="hljs-type">int</span> k;
        vector&lt;<span class="hljs-type">int</span>&gt; leftpreorder, leftinorder, rightpreorder, rightinorder;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(inorder[i] == val)&#123;
                k = i;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;preorder.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(i &lt;= k)&#123;
                leftpreorder.<span class="hljs-built_in">push_back</span>(preorder[i]);
            &#125; <span class="hljs-keyword">else</span>&#123;
                rightpreorder.<span class="hljs-built_in">push_back</span>(preorder[i]);
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;inorder.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(i &lt; k)&#123;
                leftinorder.<span class="hljs-built_in">push_back</span>(inorder[i]);
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; k)&#123;
                rightinorder.<span class="hljs-built_in">push_back</span>(inorder[i]);
            &#125;
        &#125;
        root-&gt;left = <span class="hljs-built_in">buildTree</span>(leftpreorder, leftinorder);
        root-&gt;right = <span class="hljs-built_in">buildTree</span>(rightpreorder, rightinorder);
        <span class="hljs-keyword">return</span> root;
    &#125;
&#125;;</code></pre></div>
<h2 id="437-路径总和-III">437. 路径总和 III</h2>
<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DFS</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">long</span> <span class="hljs-type">long</span> targetSum)</span></span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(root-&gt;val == targetSum)&#123;
            res += <span class="hljs-number">1</span>;
        &#125;
        res += <span class="hljs-built_in">DFS</span>(root-&gt;left, targetSum - root-&gt;val);
        res += <span class="hljs-built_in">DFS</span>(root-&gt;right, targetSum - root-&gt;val);
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-type">int</span> nownum = <span class="hljs-built_in">DFS</span>(root, (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)targetSum);
        nownum += <span class="hljs-built_in">pathSum</span>(root-&gt;left, targetSum);
        nownum += <span class="hljs-built_in">pathSum</span>(root-&gt;right, targetSum);
        <span class="hljs-keyword">return</span> nownum;
    &#125;
&#125;;</code></pre></div>
<h2 id="236-二叉树的最近公共祖先">236. 二叉树的最近公共祖先</h2>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" title="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ <strong>一个节点也可以是它自己的祖先</strong> ）。”</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> root;
        &#125;
        <span class="hljs-keyword">if</span>(root == p || root == q)&#123;
            <span class="hljs-keyword">return</span> root;
        &#125;
        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);
        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);
        <span class="hljs-keyword">if</span>(left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> root;
        &#125;
        <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> right;
        &#125;
        <span class="hljs-keyword">return</span> left;
    &#125;
&#125;;</code></pre></div>
<h2 id="124-二叉树中的最大路径和">124. 二叉树中的最大路径和</h2>
<p>二叉树中的** 路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径** 至少包含一个 **节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> maxSum  = INT_MIN;
<span class="hljs-keyword">public</span>:
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxGain</span><span class="hljs-params">(TreeNode* node)</span></span>&#123;
        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">NULL</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-type">int</span> leftGain  = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(node-&gt;left), <span class="hljs-number">0</span>);
        <span class="hljs-type">int</span> rightresult = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxGain</span>(node-&gt;right), <span class="hljs-number">0</span>);
        <span class="hljs-type">int</span> priceNewpath = node-&gt;val + leftGain  + rightresult;

        <span class="hljs-comment">// 更新答案</span>
        maxSum  = <span class="hljs-built_in">max</span>(maxSum , priceNewpath);
        <span class="hljs-keyword">return</span> node-&gt;val + <span class="hljs-built_in">max</span>(leftGain, rightresult);
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;
        <span class="hljs-built_in">maxGain</span>(root);
        <span class="hljs-keyword">return</span> maxSum ;
    &#125;
&#125;;</code></pre></div>
<h1>图论</h1>
<h2 id="200-岛屿数量">200. 岛屿数量</h2>
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; &amp; visited, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n || visited[i][j] == <span class="hljs-literal">true</span> || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        visited[i][j] = <span class="hljs-literal">true</span>;
        <span class="hljs-built_in">DFS</span>(grid, visited, i<span class="hljs-number">-1</span>, j, m, n);
        <span class="hljs-built_in">DFS</span>(grid, visited, i<span class="hljs-number">+1</span>, j, m, n);
        <span class="hljs-built_in">DFS</span>(grid, visited, i, j<span class="hljs-number">-1</span>, m, n);
        <span class="hljs-built_in">DFS</span>(grid, visited, i, j<span class="hljs-number">+1</span>, m, n);
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;
        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(visited[i][j] == <span class="hljs-literal">false</span> &amp;&amp; grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;
                    <span class="hljs-built_in">DFS</span>(grid, visited, i, j, m, n);
                    sum += <span class="hljs-number">1</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> sum;

    &#125;
&#125;;</code></pre></div>
<h2 id="994-腐烂的橘子">994. 腐烂的橘子</h2>
<p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>
<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;
        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));
        <span class="hljs-type">int</span> minpath = <span class="hljs-number">0</span>;
        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; q;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">2</span>)&#123;
                    visited[i][j] = <span class="hljs-literal">true</span>;
                    q.<span class="hljs-built_in">push</span>(&#123;i,j&#125;);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;
            minpath += <span class="hljs-number">1</span>;
            <span class="hljs-type">int</span> s = q.<span class="hljs-built_in">size</span>();
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s;i++)&#123;
                pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; p = q.<span class="hljs-built_in">front</span>();
                q.<span class="hljs-built_in">pop</span>();
                <span class="hljs-type">int</span> pi = p.first;
                <span class="hljs-type">int</span> pj = p.second;
                <span class="hljs-keyword">if</span>(pi<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; visited[pi<span class="hljs-number">-1</span>][pj] == <span class="hljs-literal">false</span> &amp;&amp; grid[pi<span class="hljs-number">-1</span>][pj] == <span class="hljs-number">1</span>)&#123;
                    visited[pi<span class="hljs-number">-1</span>][pj] = <span class="hljs-literal">true</span>;
                    grid[pi<span class="hljs-number">-1</span>][pj] = <span class="hljs-number">2</span>;
                    q.<span class="hljs-built_in">push</span>(&#123;pi<span class="hljs-number">-1</span>,pj&#125;);
                &#125;
                <span class="hljs-keyword">if</span>(pj<span class="hljs-number">-1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; visited[pi][pj<span class="hljs-number">-1</span>] == <span class="hljs-literal">false</span> &amp;&amp; grid[pi][pj<span class="hljs-number">-1</span>] == <span class="hljs-number">1</span>)&#123;
                    visited[pi][pj<span class="hljs-number">-1</span>] = <span class="hljs-literal">true</span>;
                    grid[pi][pj<span class="hljs-number">-1</span>] = <span class="hljs-number">2</span>;
                    q.<span class="hljs-built_in">push</span>(&#123;pi,pj<span class="hljs-number">-1</span>&#125;);
                &#125;
                <span class="hljs-keyword">if</span>(pi<span class="hljs-number">+1</span> &lt; m &amp;&amp; visited[pi<span class="hljs-number">+1</span>][pj] == <span class="hljs-literal">false</span> &amp;&amp; grid[pi<span class="hljs-number">+1</span>][pj] == <span class="hljs-number">1</span>)&#123;
                    visited[pi<span class="hljs-number">+1</span>][pj] = <span class="hljs-literal">true</span>;
                    grid[pi<span class="hljs-number">+1</span>][pj] = <span class="hljs-number">2</span>;
                    q.<span class="hljs-built_in">push</span>(&#123;pi<span class="hljs-number">+1</span>,pj&#125;);
                &#125;
                <span class="hljs-keyword">if</span>(pj<span class="hljs-number">+1</span> &lt; n &amp;&amp; visited[pi][pj<span class="hljs-number">+1</span>] == <span class="hljs-literal">false</span> &amp;&amp; grid[pi][pj<span class="hljs-number">+1</span>] == <span class="hljs-number">1</span>)&#123;
                    visited[pi][pj<span class="hljs-number">+1</span>] = <span class="hljs-literal">true</span>;
                    grid[pi][pj<span class="hljs-number">+1</span>] = <span class="hljs-number">2</span>;
                    q.<span class="hljs-built_in">push</span>(&#123;pi,pj<span class="hljs-number">+1</span>&#125;);
                &#125;
            &#125;
        &#125;

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(minpath == <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        &#125;
        <span class="hljs-keyword">return</span> minpath<span class="hljs-number">-1</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="207-课程表">207. 课程表</h2>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [a&lt;sub&gt;i&lt;/sub&gt;, b&lt;sub&gt;i&lt;/sub&gt;]</code> ，表示如果要学习课程 <code>a&lt;sub&gt;i&lt;/sub&gt;</code> 则 <strong>必须</strong> 先学习课程  <code>b&lt;sub&gt;i&lt;/sub&gt;</code> ~ ~ 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">table</span>(numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">judge</span><span class="hljs-params">(numCourses,<span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(numCourses,<span class="hljs-literal">false</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prerequisites.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-type">int</span> pre = prerequisites[i][<span class="hljs-number">1</span>];
            <span class="hljs-type">int</span> post = prerequisites[i][<span class="hljs-number">0</span>];
            table[pre].<span class="hljs-built_in">push_back</span>(post);
            judge[post] += <span class="hljs-number">1</span>;
        &#125;
  
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;
            <span class="hljs-type">bool</span> modify = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++)&#123;
                <span class="hljs-keyword">if</span>(visit[i] == <span class="hljs-literal">false</span> &amp;&amp; judge[i] == <span class="hljs-number">0</span>)&#123;
                    modify = <span class="hljs-literal">true</span>;
                    visit[i] = <span class="hljs-literal">true</span>;
                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;table[i].<span class="hljs-built_in">size</span>();j++)&#123;
                        judge[table[i][j]] -= <span class="hljs-number">1</span>;
                    &#125;
                &#125;
            &#125;
            <span class="hljs-keyword">if</span>(modify == <span class="hljs-literal">false</span>)&#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numCourses;i++)&#123;
            <span class="hljs-keyword">if</span>(judge[i] != <span class="hljs-number">0</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="208-实现-Trie-前缀树">208. 实现 Trie (前缀树)</h2>
<p><strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin" title="https://baike.baidu.com/item/字典树/9825209?fr=aladdin">Trie</a></strong> （发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">bool</span> isEnd;
    Trie* next[<span class="hljs-number">26</span>];
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Trie</span>() &#123;
        isEnd = <span class="hljs-literal">false</span>;
        <span class="hljs-built_in">memset</span>(next, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(next));
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;
        Trie* node = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word) &#123;
            <span class="hljs-keyword">if</span> (node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">NULL</span>) &#123;
                node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();
            &#125;
            node = node-&gt;next[c-<span class="hljs-string">&#x27;a&#x27;</span>];
        &#125;
        node-&gt;isEnd = <span class="hljs-literal">true</span>;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;
        Trie* node = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : word) &#123;
            node = node-&gt;next[c - <span class="hljs-string">&#x27;a&#x27;</span>];
            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> node-&gt;isEnd;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;
        Trie* node = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : prefix) &#123;
            node = node-&gt;next[c - <span class="hljs-string">&#x27;a&#x27;</span>];
            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;;</code></pre></div>
<h1>回溯</h1>
<h2 id="46-全排列">46. 全排列</h2>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt;&amp; visited, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp)</span></span>&#123;
        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == nums.<span class="hljs-built_in">size</span>())&#123;
            result.<span class="hljs-built_in">push_back</span>(temp);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(visited[i] == <span class="hljs-literal">true</span>)&#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            visited[i] = <span class="hljs-literal">true</span>;
            temp.<span class="hljs-built_in">push_back</span>(nums[i]);
            <span class="hljs-built_in">backtracking</span>(nums, visited, temp);
            temp.<span class="hljs-built_in">pop_back</span>();
            visited[i] = <span class="hljs-literal">false</span>;
        &#125;
    &#125;
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;
        vector&lt;<span class="hljs-type">int</span>&gt; temp;
        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(nums.size(), <span class="hljs-literal">false</span>)</span></span>;
        <span class="hljs-built_in">backtracking</span>(nums, visited, temp);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="78-子集">78. 子集</h2>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">int</span>&gt;&amp; temp, <span class="hljs-type">int</span> start)</span></span>&#123;
        result.<span class="hljs-built_in">push_back</span>(temp);
        <span class="hljs-keyword">if</span>(start &gt;= nums.<span class="hljs-built_in">size</span>())&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            temp.<span class="hljs-built_in">push_back</span>(nums[i]);
            <span class="hljs-built_in">backtracking</span>(nums, temp, i<span class="hljs-number">+1</span>);
            temp.<span class="hljs-built_in">pop_back</span>();
        &#125;
    &#125;
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;
        vector&lt;<span class="hljs-type">int</span>&gt; temp;
        <span class="hljs-built_in">backtracking</span>(nums, temp, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="17-电话号码的字母组合">17. 电话号码的字母组合</h2>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;string&gt; result;
    vector&lt;<span class="hljs-type">char</span>&gt; temp;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string digits, map&lt;<span class="hljs-type">char</span>, vector&lt;<span class="hljs-type">char</span>&gt; &gt; &amp;mp, <span class="hljs-type">int</span> start)</span></span>&#123;
        <span class="hljs-keyword">if</span>(start == digits.<span class="hljs-built_in">size</span>())&#123;
            string t = <span class="hljs-string">&quot;&quot;</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;
                t += temp[i];
            &#125;
            result.<span class="hljs-built_in">push_back</span>(t);
            <span class="hljs-keyword">return</span>;
        &#125;
        vector&lt;<span class="hljs-type">char</span>&gt; now = mp[digits[start]];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;now.<span class="hljs-built_in">size</span>();i++)&#123;
            temp.<span class="hljs-built_in">push_back</span>(now[i]);
            <span class="hljs-built_in">backtracking</span>(digits, mp, start<span class="hljs-number">+1</span>);
            temp.<span class="hljs-built_in">pop_back</span>();
        &#125;
    &#125;
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(digits == <span class="hljs-string">&quot;&quot;</span>)&#123;
            <span class="hljs-keyword">return</span> result;
        &#125;
        map&lt;<span class="hljs-type">char</span>, vector&lt;<span class="hljs-type">char</span>&gt; &gt; mp;
        mp[<span class="hljs-string">&#x27;2&#x27;</span>] = vector&lt;<span class="hljs-type">char</span>&gt;&#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;
        mp[<span class="hljs-string">&#x27;3&#x27;</span>] = vector&lt;<span class="hljs-type">char</span>&gt;&#123;<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>&#125;;
        mp[<span class="hljs-string">&#x27;4&#x27;</span>] = vector&lt;<span class="hljs-type">char</span>&gt;&#123;<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>&#125;;
        mp[<span class="hljs-string">&#x27;5&#x27;</span>] = vector&lt;<span class="hljs-type">char</span>&gt;&#123;<span class="hljs-string">&#x27;j&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>&#125;;
        mp[<span class="hljs-string">&#x27;6&#x27;</span>] = vector&lt;<span class="hljs-type">char</span>&gt;&#123;<span class="hljs-string">&#x27;m&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125;;
        mp[<span class="hljs-string">&#x27;7&#x27;</span>] = vector&lt;<span class="hljs-type">char</span>&gt;&#123;<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;q&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>&#125;;
        mp[<span class="hljs-string">&#x27;8&#x27;</span>] = vector&lt;<span class="hljs-type">char</span>&gt;&#123;<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>&#125;;
        mp[<span class="hljs-string">&#x27;9&#x27;</span>] = vector&lt;<span class="hljs-type">char</span>&gt;&#123;<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>&#125;;
        <span class="hljs-built_in">backtracking</span>(digits, mp, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="39-组合总和">39. 组合总和</h2>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;
    vector&lt;<span class="hljs-type">int</span>&gt; temp;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> nowsum, <span class="hljs-type">int</span> start)</span></span>&#123;
        <span class="hljs-keyword">if</span>(nowsum &gt; target)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(nowsum == target)&#123;
            result.<span class="hljs-built_in">push_back</span>(temp);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start;i&lt;candidates.<span class="hljs-built_in">size</span>();i++)&#123;
            temp.<span class="hljs-built_in">push_back</span>(candidates[i]);
            <span class="hljs-built_in">backtracking</span>(candidates, target, nowsum+candidates[i], i);
            temp.<span class="hljs-built_in">pop_back</span>();
        &#125;
    &#125;
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;
        <span class="hljs-built_in">backtracking</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="22-括号生成">22. 括号生成</h2>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的 **括号组合。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;string&gt; result;
    vector&lt;<span class="hljs-type">char</span>&gt; temp;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> left)</span></span>&#123;
        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span> * n &amp;&amp; left == <span class="hljs-number">0</span>)&#123;
            string res = <span class="hljs-string">&quot;&quot;</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temp.<span class="hljs-built_in">size</span>();i++)&#123;
                res += temp[i];
            &#125;
            result.<span class="hljs-built_in">push_back</span>(res);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>*n)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(left &gt; n)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span>)&#123;
            temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);
            <span class="hljs-built_in">backtracking</span>(n, <span class="hljs-number">1</span>);
            temp.<span class="hljs-built_in">pop_back</span>();
        &#125; <span class="hljs-keyword">else</span>&#123;
            temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;(&#x27;</span>);
            <span class="hljs-built_in">backtracking</span>(n, left<span class="hljs-number">+1</span>);
            temp.<span class="hljs-built_in">pop_back</span>();
            temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;)&#x27;</span>);
            <span class="hljs-built_in">backtracking</span>(n, left<span class="hljs-number">-1</span>);
            temp.<span class="hljs-built_in">pop_back</span>();
        &#125;
    &#125;
    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
        <span class="hljs-built_in">backtracking</span>(n,<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="79-单词搜索">79. 单词搜索</h2>
<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">bool</span> sign = <span class="hljs-literal">false</span>;
    string temp = <span class="hljs-string">&quot;&quot;</span>;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; &amp;visited, string word, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> now)</span></span>&#123;
        <span class="hljs-keyword">if</span>(temp == word)&#123;
            sign = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(now &gt;= word.<span class="hljs-built_in">size</span>())&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt;= m || j &lt; <span class="hljs-number">0</span> || j &gt;= n)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(visited[i][j] == <span class="hljs-literal">true</span>)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">if</span>(board[i][j] != word[now])&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        visited[i][j] = <span class="hljs-literal">true</span>;
        string t = temp;
        temp += board[i][j];
        <span class="hljs-built_in">backtracking</span>(board, visited, word, i<span class="hljs-number">+1</span>, j, m, n, now<span class="hljs-number">+1</span>);
        <span class="hljs-built_in">backtracking</span>(board, visited, word, i<span class="hljs-number">-1</span>, j, m, n, now<span class="hljs-number">+1</span>);
        <span class="hljs-built_in">backtracking</span>(board, visited, word, i, j<span class="hljs-number">+1</span>, m, n, now<span class="hljs-number">+1</span>);
        <span class="hljs-built_in">backtracking</span>(board, visited, word, i, j<span class="hljs-number">-1</span>, m, n, now<span class="hljs-number">+1</span>);
        temp = t;
        visited[i][j] = <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;
        <span class="hljs-type">int</span> m = board.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt; &gt; <span class="hljs-built_in">visited</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n,<span class="hljs-literal">false</span>));
                temp = <span class="hljs-string">&quot;&quot;</span>;
                <span class="hljs-built_in">backtracking</span>(board, visited, word, i, j, m, n, <span class="hljs-number">0</span>);
                <span class="hljs-keyword">if</span>(sign == <span class="hljs-literal">true</span>)&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="131-分割回文串">131. 分割回文串</h2>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;vector&lt;string&gt;&gt; result;
    vector&lt;string&gt; temp;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string t)</span></span>&#123;
        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> end = t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(start &lt; end)&#123;
            <span class="hljs-keyword">if</span>(t[start] != t[end])&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            start += <span class="hljs-number">1</span>;
            end -= <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> start)</span></span>&#123;
        <span class="hljs-keyword">if</span>(start == s.<span class="hljs-built_in">size</span>())&#123;
            result.<span class="hljs-built_in">push_back</span>(temp);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=s.<span class="hljs-built_in">size</span>()-start;i++)&#123;
            string t = s.<span class="hljs-built_in">substr</span>(start,i);
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(t))&#123;
                temp.<span class="hljs-built_in">push_back</span>(t);
                <span class="hljs-built_in">backtracking</span>(s,start+i);
                temp.<span class="hljs-built_in">pop_back</span>();
            &#125;
        &#125;
    &#125;
    vector&lt;vector&lt;string&gt; &gt; <span class="hljs-built_in">partition</span>(string s) &#123;
        <span class="hljs-built_in">backtracking</span>(s,<span class="hljs-number">0</span>);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="51-N-皇后">51. N 皇后</h2>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">private</span>:
    vector&lt;vector&lt;string&gt;&gt; result;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt; &amp;board, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;p&lt;i;p++)&#123;
            <span class="hljs-keyword">if</span>(board[p][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
        &#125;
        <span class="hljs-type">int</span> l = i<span class="hljs-number">-1</span>;
        <span class="hljs-type">int</span> r = j<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &gt;= <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">if</span>(board[l][r] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            l--;
            r--;
        &#125;
        l = i<span class="hljs-number">-1</span>;
        r = j<span class="hljs-number">+1</span>;
        <span class="hljs-keyword">while</span>(l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; n)&#123;
            <span class="hljs-keyword">if</span>(board[l][r] == <span class="hljs-string">&#x27;Q&#x27;</span>)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            &#125;
            l--;
            r++;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtracking</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt; &amp;board, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> n)</span></span>&#123;
        <span class="hljs-keyword">if</span>(start == n)&#123;
            vector&lt;string&gt; vt;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
                string temp = <span class="hljs-string">&quot;&quot;</span>;
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                    temp += board[i][j];
                &#125;
                vt.<span class="hljs-built_in">push_back</span>(temp);
            &#125;
            result.<span class="hljs-built_in">push_back</span>(vt);
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
            board[start][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(board,start,i,n))&#123;
                <span class="hljs-built_in">backtracking</span>(board,start<span class="hljs-number">+1</span>,n);
            &#125;
            board[start][i] = <span class="hljs-string">&#x27;.&#x27;</span>;
        &#125;
    &#125;
    vector&lt;vector&lt;string&gt; &gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;
        vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt; <span class="hljs-built_in">board</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">char</span>&gt;(n, <span class="hljs-string">&#x27;.&#x27;</span>));
        <span class="hljs-built_in">backtracking</span>(board,<span class="hljs-number">0</span>,n);
        <span class="hljs-keyword">return</span> result; 
    &#125;
&#125;;</code></pre></div>
<h1>二分查找</h1>
<h2 id="35-搜索插入位置">35. 搜索插入位置</h2>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;
            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;
            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;
                <span class="hljs-keyword">return</span> mid;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &lt; target)&#123;
                left = mid + <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                right = mid - <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> left;
    &#125;
&#125;;</code></pre></div>
<h2 id="74-搜索二维矩阵">74. 搜索二维矩阵</h2>
<p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-type">int</span> m = matrix.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(i &lt;= m<span class="hljs-number">-1</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>)&#123;
            <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &lt; target)&#123;
                i += <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                j -= <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置">34. 在排序数组中查找元素的第一个和最后一个位置</h2>
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowerbound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> leftBorder = <span class="hljs-number">-2</span>;
        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;
            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;
            <span class="hljs-keyword">if</span>(nums[mid] &gt;= target)&#123;
                right = mid - <span class="hljs-number">1</span>;
                leftBorder = right;
            &#125; <span class="hljs-keyword">else</span>&#123;
                left = mid + <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> leftBorder;
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">upperbound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> rightBorder = <span class="hljs-number">-2</span>;
        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;
            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;
            <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;
                right = mid - <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                left = mid + <span class="hljs-number">1</span>;
                rightBorder = left;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> rightBorder;
    &#125;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-type">int</span> leftBorder = <span class="hljs-built_in">lowerbound</span>(nums, target);
        <span class="hljs-type">int</span> rightBorder = <span class="hljs-built_in">upperbound</span>(nums,target);
        <span class="hljs-keyword">if</span> (leftBorder == <span class="hljs-number">-2</span> || rightBorder == <span class="hljs-number">-2</span>)&#123;
            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>&#125;;
        &#125;
        <span class="hljs-keyword">if</span> (rightBorder - leftBorder &gt; <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;leftBorder + <span class="hljs-number">1</span>, rightBorder - <span class="hljs-number">1</span>&#125;;
        &#125;
        <span class="hljs-keyword">return</span> vector&lt;<span class="hljs-type">int</span>&gt;&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;
    &#125;
&#125;;</code></pre></div>
<h2 id="33-搜索旋转排序数组">33. 搜索旋转排序数组</h2>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了  <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;
            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;
            <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;
                <span class="hljs-keyword">return</span> mid;
            &#125;
            <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= nums[mid])&#123;
                <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= target &amp;&amp; target &lt;= nums[mid])&#123;
                    right = mid - <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    left = mid + <span class="hljs-number">1</span>;
                &#125;
            &#125; <span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">if</span>(nums[mid] &lt;= target &amp;&amp; target &lt;= nums[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>])&#123;
                    left = mid + <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    right = mid - <span class="hljs-number">1</span>;
                &#125;
            &#125;

        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="153-寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</h2>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(left &lt; right)&#123;
            <span class="hljs-type">int</span> mid = (right - left) / <span class="hljs-number">2</span> + left;
            <span class="hljs-keyword">if</span>(nums[right] &gt; nums[mid])&#123;
                right = mid;
            &#125; <span class="hljs-keyword">else</span>&#123;
                left = mid + <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> nums[left];
    &#125;
&#125;;</code></pre></div>
<h2 id="4-寻找两个正序数组的中位数">4. 寻找两个正序数组的中位数</h2>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;
        <span class="hljs-type">int</span> m = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();
        <span class="hljs-type">bool</span> next;
        <span class="hljs-type">int</span> sign = (m + n) / <span class="hljs-number">2</span>; 
        <span class="hljs-keyword">if</span>((m + n) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;
            next = <span class="hljs-literal">false</span>;
        &#125; <span class="hljs-keyword">else</span>&#123;
            sign -= <span class="hljs-number">1</span>;
            next = <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-type">int</span> res1 = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> res2 = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> globalindex = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> nums1index = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> nums2index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(globalindex &lt;= sign)&#123;
            <span class="hljs-keyword">if</span>(nums1index &lt; m &amp;&amp; nums2index &lt; n)&#123;
                <span class="hljs-keyword">if</span>(nums1[nums1index] &lt; nums2[nums2index])&#123;
                    res1 = nums1[nums1index];
                    nums1index += <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    res1 = nums2[nums2index];
                    nums2index += <span class="hljs-number">1</span>;
                &#125;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1index &lt; m)&#123;
                res1 = nums1[nums1index];
                nums1index += <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                res1 = nums2[nums2index];
                nums2index += <span class="hljs-number">1</span>;
            &#125;
            globalindex += <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-keyword">if</span>(next == <span class="hljs-literal">false</span>)&#123;
            <span class="hljs-keyword">return</span> res1;
        &#125;
        <span class="hljs-keyword">if</span>(nums1index &lt; m &amp;&amp; nums2index &lt; n)&#123;
            <span class="hljs-keyword">if</span>(nums1[nums1index] &lt; nums2[nums2index])&#123;
                res2 = nums1[nums1index];
            &#125; <span class="hljs-keyword">else</span>&#123;
                res2 = nums2[nums2index];
            &#125;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1index &lt; m)&#123;
            res2 = nums1[nums1index];
        &#125; <span class="hljs-keyword">else</span> &#123;
            res2 = nums2[nums2index];
        &#125;
        <span class="hljs-keyword">return</span> ((<span class="hljs-type">double</span>)res1 + (<span class="hljs-type">double</span>)res2) / <span class="hljs-number">2.0</span>;
    &#125;
&#125;;</code></pre></div>
<h1>栈</h1>
<h2 id="20-有效的括号">20. 有效的括号</h2>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;
        stack&lt;<span class="hljs-type">char</span>&gt; st;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span> || s[i] == <span class="hljs-string">&#x27;[&#x27;</span> || s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;
                st.<span class="hljs-built_in">push</span>(s[i]);
            &#125; <span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                &#125;
                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;
                    <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;(&#x27;</span>)&#123;
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    &#125; <span class="hljs-keyword">else</span>&#123;
                        st.<span class="hljs-built_in">pop</span>();
                    &#125;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;
                    <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;[&#x27;</span>)&#123;
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    &#125; <span class="hljs-keyword">else</span>&#123;
                        st.<span class="hljs-built_in">pop</span>();
                    &#125;
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;
                    <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;&#123;&#x27;</span>)&#123;
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                    &#125; <span class="hljs-keyword">else</span>&#123;
                        st.<span class="hljs-built_in">pop</span>();
                    &#125;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="155-最小栈">155. 最小栈</h2>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;
<span class="hljs-keyword">private</span>:
    stack&lt;<span class="hljs-type">int</span>&gt; st1;
    stack&lt;<span class="hljs-type">int</span>&gt; st2;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">MinStack</span>() &#123;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;
        st<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(val);
        <span class="hljs-keyword">if</span>(st<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>() || val &lt; st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>())&#123;
            st<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(val);
        &#125; <span class="hljs-keyword">else</span>&#123;
            st<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>());
        &#125;
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;
        st<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();
        st<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();
    &#125;   
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> st<span class="hljs-number">1.</span><span class="hljs-built_in">top</span>();
    &#125;
  
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> st<span class="hljs-number">2.</span><span class="hljs-built_in">top</span>();
    &#125;
&#125;;</code></pre></div>
<h2 id="394-字符串解码">394. 字符串解码</h2>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;
        stack&lt;<span class="hljs-type">char</span>&gt; st;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;]&#x27;</span>)&#123;
                vector&lt;<span class="hljs-type">char</span>&gt; tempchar;
                vector&lt;<span class="hljs-type">int</span>&gt; tempnum;
                <span class="hljs-keyword">while</span>(st.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;[&#x27;</span>)&#123;
                    tempchar.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>());
                    st.<span class="hljs-built_in">pop</span>();
                &#125;
                st.<span class="hljs-built_in">pop</span>();
                <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; st.<span class="hljs-built_in">top</span>() &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;
                    tempnum.<span class="hljs-built_in">push_back</span>(st.<span class="hljs-built_in">top</span>() - <span class="hljs-string">&#x27;0&#x27;</span>);
                    st.<span class="hljs-built_in">pop</span>();
                &#125;
                <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=tempnum.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">0</span>;j--)&#123;
                    num = num * <span class="hljs-number">10</span> + tempnum[j];
                &#125;
                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;num;j++)&#123;
                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=tempchar.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;k&gt;=<span class="hljs-number">0</span>;k--)&#123;
                        st.<span class="hljs-built_in">push</span>(tempchar[k]);
                    &#125;
                &#125;
            &#125;<span class="hljs-keyword">else</span>&#123;
                st.<span class="hljs-built_in">push</span>(s[i]);
            &#125;
        &#125;
        string res;
        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;
            res += st.<span class="hljs-built_in">top</span>();
            st.<span class="hljs-built_in">pop</span>();
        &#125;
        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">return</span> res;
    &#125;
&#125;;</code></pre></div>
<h2 id="739-每日温度">739. 每日温度</h2>
<p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;
        <span class="hljs-type">int</span> n = temperatures.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;
        stack&lt;<span class="hljs-type">int</span>&gt; st;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;temperatures.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[st.<span class="hljs-built_in">top</span>()] &lt; temperatures[i])&#123;
                result[st.<span class="hljs-built_in">top</span>()] = i - st.<span class="hljs-built_in">top</span>();
                st.<span class="hljs-built_in">pop</span>();
            &#125;
            st.<span class="hljs-built_in">push</span>(i);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="84-柱状图中最大的矩形">84. 柱状图中最大的矩形</h2>
<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; heights)</span> </span>&#123;
        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> n = heights.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];
        &#125;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minLeftIndex</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minRightIndex</span><span class="hljs-params">(n,<span class="hljs-number">0</span>)</span></span>;
        minLeftIndex[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;
            <span class="hljs-type">int</span> t = i - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (t &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[t] &gt;= heights[i])&#123;
                t = minLeftIndex[t];
            &#125;
            minLeftIndex[i] = t;
        &#125;
        minRightIndex[n<span class="hljs-number">-1</span>] = n;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;
            <span class="hljs-type">int</span> t = i + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (t &lt; n &amp;&amp; heights[t] &gt;= heights[i])&#123;
                t = minRightIndex[t];
            &#125;
            minRightIndex[i] = t;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
            result = <span class="hljs-built_in">max</span>(result, heights[i] * (minRightIndex[i] - minLeftIndex[i] - <span class="hljs-number">1</span>));
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h1>堆</h1>
<h2 id="215-数组中的第K个最大元素">215.数组中的第K个最大元素</h2>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>&lt;strong&gt;k&lt;/strong&gt;</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span></span>&#123;
        <span class="hljs-keyword">if</span>(i &gt;= j)&#123;
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-type">int</span> start = i;
        <span class="hljs-type">int</span> end = j;
        <span class="hljs-type">int</span> x = nums[start];
        <span class="hljs-keyword">while</span>(start &lt; end)&#123;
            <span class="hljs-keyword">while</span>(start &lt; end &amp;&amp; nums[end] &lt; x)&#123;
                end--;
            &#125;
            nums[start] = nums[end];
            <span class="hljs-keyword">while</span>(start &lt; end &amp;&amp; nums[start] &gt;= x)&#123;
                start++;
            &#125;
            nums[end] = nums[start];
        &#125;
        nums[start] = x;
        <span class="hljs-keyword">if</span>(k<span class="hljs-number">-1</span> == start)&#123;
            <span class="hljs-keyword">return</span>;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k<span class="hljs-number">-1</span> &lt; start)&#123;
            <span class="hljs-built_in">quicksort</span>(nums, i, start<span class="hljs-number">-1</span>,k);
        &#125; <span class="hljs-keyword">else</span>&#123;
            <span class="hljs-built_in">quicksort</span>(nums,start<span class="hljs-number">+1</span>,j,k);
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;
        <span class="hljs-built_in">quicksort</span>(nums,<span class="hljs-number">0</span>,nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,k);
        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>];
    &#125;
&#125;;</code></pre></div>
<h2 id="347-前-K-个高频元素">347. 前 K 个高频元素</h2>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;
        <span class="hljs-keyword">return</span> a &gt; b;
    &#125;
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;
        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            mp[nums[i]] += <span class="hljs-number">1</span>;
        &#125;
        vector&lt;<span class="hljs-type">int</span>&gt; temp;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>();it++)&#123;
            temp.<span class="hljs-built_in">push_back</span>(it-&gt;second);
        &#125;
        <span class="hljs-built_in">sort</span>(temp.<span class="hljs-built_in">begin</span>(), temp.<span class="hljs-built_in">end</span>(), cmp);
        <span class="hljs-type">int</span> sign = temp[k<span class="hljs-number">-1</span>];
        vector&lt;<span class="hljs-type">int</span>&gt; result;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mp.<span class="hljs-built_in">begin</span>(); it != mp.<span class="hljs-built_in">end</span>();it++)&#123;
            <span class="hljs-keyword">if</span>(it-&gt;second &gt;= sign)&#123;
                result.<span class="hljs-built_in">push_back</span>(it-&gt;first);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="295-数据流的中位数">295. 数据流的中位数</h2>
<p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<ul>
<li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li>
<li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li>
</ul>
<p>实现 MedianFinder 类:</p>
<ul>
<li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li>
<li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li>
<li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10&lt;sup&gt;-5&lt;/sup&gt;</code> 以内的答案将被接受。</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;
<span class="hljs-keyword">public</span>:
    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; A; <span class="hljs-comment">// 小顶堆，保存较大的一半</span>
    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; B; <span class="hljs-comment">// 大顶堆，保存较小的一半</span>

    <span class="hljs-built_in">MedianFinder</span>() &#123;

    &#125;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>()) &#123;
            A.<span class="hljs-built_in">push</span>(num);
            B.<span class="hljs-built_in">push</span>(A.<span class="hljs-built_in">top</span>());
            A.<span class="hljs-built_in">pop</span>();
        &#125; <span class="hljs-keyword">else</span> &#123;
            B.<span class="hljs-built_in">push</span>(num);
            A.<span class="hljs-built_in">push</span>(B.<span class="hljs-built_in">top</span>());
            B.<span class="hljs-built_in">pop</span>();
        &#125;

    &#125;
  
    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>() != B.<span class="hljs-built_in">size</span>() ? A.<span class="hljs-built_in">top</span>() : (A.<span class="hljs-built_in">top</span>() + B.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;
    &#125;
&#125;;</code></pre></div>
<h1>贪心算法</h1>
<h2 id="121-买卖股票的最佳时机">121. 买卖股票的最佳时机</h2>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;
        <span class="hljs-type">int</span> minprice = INT_MAX, maxprofit = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++)&#123;
            maxprofit = <span class="hljs-built_in">max</span>(maxprofit, prices[i] - minprice);
            minprice = <span class="hljs-built_in">min</span>(prices[i], minprice);
        &#125;
        <span class="hljs-keyword">return</span> maxprofit;
    &#125;
&#125;;</code></pre></div>
<h2 id="55-跳跃游戏">55. 跳跃游戏</h2>
<p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span> (i &lt;= result)&#123;
                result = <span class="hljs-built_in">max</span>(result, i + nums[i]);
                <span class="hljs-keyword">if</span>(result &gt;= n - <span class="hljs-number">1</span>)&#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="45-跳跃游戏-II">45. 跳跃游戏 II</h2>
<p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code></li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> result = n<span class="hljs-number">+1</span>;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,n<span class="hljs-number">+1</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;
                <span class="hljs-keyword">if</span>(j + nums[j] &gt;= i)&#123;
                    dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[n<span class="hljs-number">-1</span>];
    &#125;
&#125;;</code></pre></div>
<h2 id="763-划分字母区间">763. 划分字母区间</h2>
<p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;
        vector&lt;<span class="hljs-type">int</span>&gt; result;
        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">alphabet</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;
            alphabet[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;
        &#125;
        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> end = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;
            end = <span class="hljs-built_in">max</span>(end, alphabet[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);
            <span class="hljs-keyword">if</span>(i == end)&#123;
                result.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);
                start = end + <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h1>动态规划</h1>
<h2 id="70-爬楼梯">70. 爬楼梯</h2>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)&#123;
            <span class="hljs-keyword">return</span> n;
        &#125;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;
        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
        dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;
            dp[i] = dp[i<span class="hljs-number">-1</span>] + dp[i<span class="hljs-number">-2</span>];
        &#125;
        <span class="hljs-keyword">return</span> dp[n];
    &#125;
&#125;;</code></pre></div>
<h2 id="118-杨辉三角">118. 杨辉三角</h2>
<p>给定一个非负整数  <em><code>numRows</code>，</em> 生成「杨辉三角」的前 *<code>numRows</code> *行。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=numRows;i++)&#123;
            vector&lt;<span class="hljs-type">int</span>&gt; temp;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;
                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || j == i<span class="hljs-number">-1</span>)&#123;
                    temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);
                &#125; <span class="hljs-keyword">else</span>&#123;
                    vector&lt;<span class="hljs-type">int</span>&gt; last = result[result.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];
                    temp.<span class="hljs-built_in">push_back</span>(last[j<span class="hljs-number">-1</span>] + last[j]);
                &#125;
            &#125;
            result.<span class="hljs-built_in">push_back</span>(temp);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="198-打家劫舍">198. 打家劫舍</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统， <strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 ** 不触动警报装置的情况下 ** ，一夜之内能够偷窃到的最高金额。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
        &#125;
        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
        &#125;
        dp[<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];
        dp[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>]);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)&#123;
            dp[i] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-2</span>] + nums[i<span class="hljs-number">-1</span>]);
        &#125;
        <span class="hljs-keyword">return</span> dp[n];
    &#125;
&#125;;</code></pre></div>
<h2 id="279-完全平方数">279. 完全平方数</h2>
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,n<span class="hljs-number">+1</span>)</span></span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
            <span class="hljs-keyword">if</span>(i*i &lt; n)&#123;
                dp[i*i] = <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i*i == n)&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
            &#125; <span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&gt;=<span class="hljs-number">1</span>;j--)&#123;
                dp[i] = <span class="hljs-built_in">min</span>(dp[i], dp[i-j]+ dp[j]);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[n];
    &#125;
&#125;;</code></pre></div>
<h2 id="322-零钱兑换">322. 零钱兑换</h2>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(amount<span class="hljs-number">+1</span>,amount<span class="hljs-number">+1</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;coins.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=amount;j++)&#123;
                <span class="hljs-keyword">if</span>(j &gt;= coins[i])&#123;
                    dp[j] = <span class="hljs-built_in">min</span>(dp[j], dp[j-coins[i]] + <span class="hljs-number">1</span>);
                &#125;
  
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[amount] == amount<span class="hljs-number">+1</span> ? <span class="hljs-number">-1</span>:dp[amount];
    &#125;
&#125;;</code></pre></div>
<h2 id="139-单词拆分">139. 单词拆分</h2>
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p><strong>注意：</strong> 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;
        <span class="hljs-function">unordered_set&lt;string&gt; <span class="hljs-title">wordSet</span><span class="hljs-params">(wordDict.begin(), wordDict.end())</span></span>;
        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(s.size()<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;
                string word = s.<span class="hljs-built_in">substr</span>(j,i-j);
                <span class="hljs-keyword">if</span>(wordSet.<span class="hljs-built_in">find</span>(word) != wordSet.<span class="hljs-built_in">end</span>() &amp;&amp; dp[j] == <span class="hljs-literal">true</span>)&#123;
                    dp[i] = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[s.<span class="hljs-built_in">size</span>()] == <span class="hljs-literal">true</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="300-最长递增子序列">300. 最长递增子序列</h2>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p>**子序列 **是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n,<span class="hljs-number">1</span>)</span></span>;
        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;
                <span class="hljs-keyword">if</span>(nums[j] &lt; nums[i])&#123;
                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);
                &#125;
            &#125;
            result = <span class="hljs-built_in">max</span>(result, dp[i]);
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="152-乘积最大子数组">152. 乘积最大子数组</h2>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">double</span> maxF = nums[<span class="hljs-number">0</span>], minF = nums[<span class="hljs-number">0</span>], ans = nums[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;
            <span class="hljs-type">double</span> mx = maxF, mn = minF;
            maxF = <span class="hljs-built_in">max</span>(mx * nums[i], <span class="hljs-built_in">max</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(nums[i]), mn * nums[i]));
            minF = <span class="hljs-built_in">min</span>(mn * nums[i], <span class="hljs-built_in">min</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(nums[i]), mx * nums[i]));
            ans = <span class="hljs-built_in">max</span>(maxF, ans);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(ans);
    &#125;
&#125;;</code></pre></div>
<h2 id="416-分割等和子集">416. 分割等和子集</h2>
<p>给你一个 **只包含正整数 **的 **非空 **数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums)&#123;
            sum += num;
        &#125;
        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
        sum /= <span class="hljs-number">2</span>;
        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum<span class="hljs-number">+1</span>,<span class="hljs-literal">false</span>)</span></span>;
        dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=sum;j&gt;=nums[i];j--)&#123;
                dp[j] = dp[j] || dp[j-nums[i]];
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[sum];
    &#125;
&#125;;</code></pre></div>
<h2 id="32-最长有效括号（-）">32. 最长有效括号（*）</h2>
<p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;
        stack&lt;<span class="hljs-type">int</span>&gt; st;
        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++)&#123;
            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;
                st.<span class="hljs-built_in">push</span>(i);
            &#125; <span class="hljs-keyword">else</span>&#123;
                <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">empty</span>())&#123;
                    st.<span class="hljs-built_in">pop</span>();
                    <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>()) &#123;
                        ans = <span class="hljs-built_in">max</span>(ans, i - start + <span class="hljs-number">1</span>);
                    &#125;
                    <span class="hljs-keyword">else</span> &#123;
                        ans = <span class="hljs-built_in">max</span>(ans, i - st.<span class="hljs-built_in">top</span>());
                    &#125;

                &#125; <span class="hljs-keyword">else</span>&#123;
                    start = i + <span class="hljs-number">1</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> ans;
    &#125;
&#125;;</code></pre></div>
<h1>多维动态规划</h1>
<h2 id="62-不同路径">62. 不同路径</h2>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;
                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span> &amp;&amp; j == <span class="hljs-number">1</span>)&#123;
                    dp[i][j] = <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j<span class="hljs-number">-1</span>];
                &#125;
  
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[m][n];
    &#125;
&#125;;</code></pre></div>
<h2 id="64-最小路径和">64. 最小路径和</h2>
<p>给定一个包含非负整数的 <code>&lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt;</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p><strong>说明：</strong> 每次只能向下或者向右移动一步。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;
        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;
                <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>)&#123;
                    dp[i][j] = grid[i][j];
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)&#123;
                    dp[i][j] = grid[i][j] + dp[i][j<span class="hljs-number">-1</span>];
                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>)&#123;
                    dp[i][j] = grid[i][j] + dp[i<span class="hljs-number">-1</span>][j];
                &#125; <span class="hljs-keyword">else</span>&#123;
                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j];
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>];
    &#125;
&#125;;</code></pre></div>
<h2 id="5-最长回文子串">5. 最长回文子串</h2>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;
        string result = <span class="hljs-string">&quot;&quot;</span>;
        <span class="hljs-type">int</span> longresult = <span class="hljs-number">1</span>;
        result += s[<span class="hljs-number">0</span>];
        <span class="hljs-type">int</span> l = s.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;l<span class="hljs-number">-1</span>;i++)&#123;
            <span class="hljs-type">int</span> start = i;
            <span class="hljs-type">int</span> end = i + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span>(start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; l &amp;&amp; s[start] == s[end])&#123;
                start--;
                end++;
            &#125;
            start++;
            end--;
            <span class="hljs-keyword">if</span>(end-start<span class="hljs-number">+1</span> &gt; longresult)&#123;
                longresult = end-start<span class="hljs-number">+1</span>;
                result = s.<span class="hljs-built_in">substr</span>(start,longresult);
            &#125;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;l<span class="hljs-number">-1</span>;i++)&#123;
            <span class="hljs-type">int</span> start = i - <span class="hljs-number">1</span>;
            <span class="hljs-type">int</span> end = i + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span>(start &gt;= <span class="hljs-number">0</span> &amp;&amp; end &lt; l &amp;&amp; s[start] == s[end])&#123;
                start--;
                end++;
            &#125;
            start++;
            end--;
            <span class="hljs-keyword">if</span>(end-start<span class="hljs-number">+1</span> &gt; longresult)&#123;
                longresult = end-start<span class="hljs-number">+1</span>;
                result = s.<span class="hljs-built_in">substr</span>(start,longresult);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;;</code></pre></div>
<h2 id="1143-最长公共子序列">1143. 最长公共子序列</h2>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;
        <span class="hljs-type">int</span> m = text<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> n = text<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(m<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;
                <span class="hljs-keyword">if</span>(text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>])&#123;
                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;
                &#125; <span class="hljs-keyword">else</span>&#123;
                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[m][n];
    &#125;
&#125;;</code></pre></div>
<h2 id="72-编辑距离">72. 编辑距离</h2>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em>  。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;
        <span class="hljs-type">int</span> s1 = word<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> s2 = word<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();
        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">dp</span>(s1<span class="hljs-number">+1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(s2<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=s1;i++)&#123;
            dp[i][<span class="hljs-number">0</span>] = i;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=s2;j++)&#123;
            dp[<span class="hljs-number">0</span>][j] = j;
        &#125;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=s1;i++)&#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=s2;j++)&#123;
                <span class="hljs-keyword">if</span>(word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>])&#123;
                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];
                &#125; <span class="hljs-keyword">else</span>&#123;
                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], <span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])) + <span class="hljs-number">1</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> dp[s1][s2];
    &#125;
&#125;;</code></pre></div>
<h1>技巧（*）</h1>
<h2 id="136-只出现一次的数字">136. 只出现一次的数字</h2>
<p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;
        <span class="hljs-keyword">return</span> ret;
    &#125;
&#125;;</code></pre></div>
<h2 id="169-多数元素">169. 多数元素</h2>
<p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, votes = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums)&#123;
            <span class="hljs-keyword">if</span> (votes == <span class="hljs-number">0</span>) x = num;
            votes += num == x ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
        &#125;
        <span class="hljs-keyword">return</span> x;
    &#125;
&#125;;</code></pre></div>
<h2 id="75-颜色分类">75. 颜色分类</h2>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;right &lt; nums.<span class="hljs-built_in">size</span>();right++)&#123;
            <span class="hljs-keyword">if</span>(nums[right] == <span class="hljs-number">0</span>)&#123;
                <span class="hljs-built_in">swap</span>(nums[left], nums[right]);
                left += <span class="hljs-number">1</span>;
            &#125;
        &#125;
        left = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;right &gt;= <span class="hljs-number">0</span>; right--)&#123;
            <span class="hljs-keyword">if</span>(nums[right] == <span class="hljs-number">2</span>)&#123;
                <span class="hljs-built_in">swap</span>(nums[left], nums[right]);
                left -= <span class="hljs-number">1</span>;
            &#125;
        &#125;
    &#125;
&#125;;</code></pre></div>
<h2 id="31-下一个排列">31. 下一个排列</h2>
<p>整数数组的一个 <strong>排列</strong>  就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" title="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地 </a>**修改，只允许使用额外常数空间。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();
        <span class="hljs-type">int</span> sign = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;
            <span class="hljs-keyword">if</span>(nums[i<span class="hljs-number">-1</span>] &lt; nums[i])&#123;
                sign = i<span class="hljs-number">-1</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">-1</span>)&#123;
            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());
            <span class="hljs-keyword">return</span>;
        &#125;
        <span class="hljs-type">int</span> sign2 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;
            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[sign])&#123;
                sign2 = i;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-built_in">swap</span>(nums[sign], nums[sign2]);
        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>()+sign<span class="hljs-number">+1</span>,nums.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">return</span>;
    &#125;
&#125;;</code></pre></div>
<h2 id="287-寻找重复数">287. 寻找重复数</h2>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>
<div class="code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;
        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;
            fast = nums[nums[fast]];
            slow = nums[slow];
            <span class="hljs-keyword">if</span>(fast == slow)
                <span class="hljs-keyword">break</span>;
        &#125;
        <span class="hljs-type">int</span> finder = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;
            finder = nums[finder];
            slow = nums[slow];
            <span class="hljs-keyword">if</span>(slow == finder)
                <span class="hljs-keyword">break</span>;  
        &#125;
        <span class="hljs-keyword">return</span> slow;
    &#125;
&#125;;</code></pre></div>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Study/" class="category-chain-item">Study</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Algorithm/" class="print-no-link">#Algorithm</a>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
        <a href="/tags/Leetcode/" class="print-no-link">#Leetcode</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Leetcode-Hot 100</div>
      <div>https://zhangzhao219.github.io/2024/06/01/Leetcode/Leetcode-hot100/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zhang Zhao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年6月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
  
  
    <article id="comments" lazyload>
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"zhangzhao219/zhangzhao219.github.io","repo-id":"R_kgDOHmJY6g","category":"Announcements","category-id":"DIC_kwDOHmJY6s4CSBmw","theme-light":"light","theme-dark":"dark","mapping":"url","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
